/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@easepick/bundle/dist/index.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/@easepick/bundle/dist/index.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AmpPlugin": () => (/* binding */ d),
/* harmony export */   "DateTime": () => (/* binding */ t),
/* harmony export */   "KbdPlugin": () => (/* binding */ h),
/* harmony export */   "LockPlugin": () => (/* binding */ a),
/* harmony export */   "PresetPlugin": () => (/* binding */ r),
/* harmony export */   "RangePlugin": () => (/* binding */ c),
/* harmony export */   "TimePlugin": () => (/* binding */ l),
/* harmony export */   "create": () => (/* binding */ n),
/* harmony export */   "easepick": () => (/* binding */ s)
/* harmony export */ });
class t extends Date{static parseDateTime(e,i="YYYY-MM-DD",n="en-US"){if(!e)return new Date((new Date).setHours(0,0,0,0));if(e instanceof t)return e.toJSDate();if(e instanceof Date)return e;if(/^-?\d{10,}$/.test(String(e)))return new Date(Number(e));if("string"==typeof e){const s=[];let o=null;for(;null!=(o=t.regex.exec(i));)"\\"!==o[1]&&s.push(o);if(s.length){const i={year:null,month:null,shortMonth:null,longMonth:null,day:null,hour:0,minute:0,second:0,ampm:null,value:""};s[0].index>0&&(i.value+=".*?");for(const[e,o]of Object.entries(s)){const s=Number(e),{group:a,pattern:r}=t.formatPatterns(o[0],n);i[a]=s+1,i.value+=r,i.value+=".*?"}const o=new RegExp(`^${i.value}$`);if(o.test(e)){const s=o.exec(e),a=Number(s[i.year]);let r=null;i.month?r=Number(s[i.month])-1:i.shortMonth?r=t.shortMonths(n).indexOf(s[i.shortMonth]):i.longMonth&&(r=t.longMonths(n).indexOf(s[i.longMonth]));const c=Number(s[i.day])||1,l=Number(s[i.hour]);let h=Number.isNaN(l)?0:l;const d=Number(s[i.minute]),p=Number.isNaN(d)?0:d,u=Number(s[i.second]),g=Number.isNaN(u)?0:u,m=s[i.ampm];return m&&"PM"===m&&(h+=12,24===h&&(h=0)),new Date(a,r,c,h,p,g,0)}}}return new Date((new Date).setHours(0,0,0,0))}static regex=/(\\)?(Y{2,4}|M{1,4}|D{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|A|a)/g;static MONTH_JS=[0,1,2,3,4,5,6,7,8,9,10,11];static shortMonths(e){return t.MONTH_JS.map((t=>new Date(2019,t).toLocaleString(e,{month:"short"})))}static longMonths(e){return t.MONTH_JS.map((t=>new Date(2019,t).toLocaleString(e,{month:"long"})))}static formatPatterns(e,i){switch(e){case"YY":case"YYYY":return{group:"year",pattern:`(\\d{${e.length}})`};case"M":return{group:"month",pattern:"(\\d{1,2})"};case"MM":return{group:"month",pattern:"(\\d{2})"};case"MMM":return{group:"shortMonth",pattern:`(${t.shortMonths(i).join("|")})`};case"MMMM":return{group:"longMonth",pattern:`(${t.longMonths(i).join("|")})`};case"D":return{group:"day",pattern:"(\\d{1,2})"};case"DD":return{group:"day",pattern:"(\\d{2})"};case"h":case"H":return{group:"hour",pattern:"(\\d{1,2})"};case"hh":case"HH":return{group:"hour",pattern:"(\\d{2})"};case"m":return{group:"minute",pattern:"(\\d{1,2})"};case"mm":return{group:"minute",pattern:"(\\d{2})"};case"s":return{group:"second",pattern:"(\\d{1,2})"};case"ss":return{group:"second",pattern:"(\\d{2})"};case"a":case"A":return{group:"ampm",pattern:"(AM|PM|am|pm)"}}}lang;constructor(e=null,i="YYYY-MM-DD",n="en-US"){super(t.parseDateTime(e,i,n)),this.lang=n}getWeek(t){const e=new Date(this.midnight_ts(this)),i=(this.getDay()+(7-t))%7;e.setDate(e.getDate()-i);const n=e.getTime();return e.setMonth(0,1),e.getDay()!==t&&e.setMonth(0,1+(4-e.getDay()+7)%7),1+Math.ceil((n-e.getTime())/6048e5)}clone(){return new t(this)}toJSDate(){return new Date(this)}inArray(t,e="[]"){return t.some((t=>t instanceof Array?this.isBetween(t[0],t[1],e):this.isSame(t,"day")))}isBetween(t,e,i="()"){switch(i){default:case"()":return this.midnight_ts(this)>this.midnight_ts(t)&&this.midnight_ts(this)<this.midnight_ts(e);case"[)":return this.midnight_ts(this)>=this.midnight_ts(t)&&this.midnight_ts(this)<this.midnight_ts(e);case"(]":return this.midnight_ts(this)>this.midnight_ts(t)&&this.midnight_ts(this)<=this.midnight_ts(e);case"[]":return this.midnight_ts()>=this.midnight_ts(t)&&this.midnight_ts()<=this.midnight_ts(e)}}isBefore(t,e="days"){switch(e){case"day":case"days":return new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()>new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime();case"month":case"months":return new Date(t.getFullYear(),t.getMonth(),1).getTime()>new Date(this.getFullYear(),this.getMonth(),1).getTime();case"year":case"years":return t.getFullYear()>this.getFullYear()}throw new Error("isBefore: Invalid unit!")}isSameOrBefore(t,e="days"){switch(e){case"day":case"days":return new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()>=new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime();case"month":case"months":return new Date(t.getFullYear(),t.getMonth(),1).getTime()>=new Date(this.getFullYear(),this.getMonth(),1).getTime()}throw new Error("isSameOrBefore: Invalid unit!")}isAfter(t,e="days"){switch(e){case"day":case"days":return new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime()>new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime();case"month":case"months":return new Date(this.getFullYear(),this.getMonth(),1).getTime()>new Date(t.getFullYear(),t.getMonth(),1).getTime();case"year":case"years":return this.getFullYear()>t.getFullYear()}throw new Error("isAfter: Invalid unit!")}isSameOrAfter(t,e="days"){switch(e){case"day":case"days":return new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime()>=new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime();case"month":case"months":return new Date(this.getFullYear(),this.getMonth(),1).getTime()>=new Date(t.getFullYear(),t.getMonth(),1).getTime()}throw new Error("isSameOrAfter: Invalid unit!")}isSame(t,e="days"){switch(e){case"day":case"days":return new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime()===new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime();case"month":case"months":return new Date(this.getFullYear(),this.getMonth(),1).getTime()===new Date(t.getFullYear(),t.getMonth(),1).getTime()}throw new Error("isSame: Invalid unit!")}add(t,e="days"){switch(e){case"day":case"days":this.setDate(this.getDate()+t);break;case"month":case"months":this.setMonth(this.getMonth()+t)}return this}subtract(t,e="days"){switch(e){case"day":case"days":this.setDate(this.getDate()-t);break;case"month":case"months":this.setMonth(this.getMonth()-t)}return this}diff(t,e="days"){switch(e){default:case"day":case"days":return Math.round((this.midnight_ts()-this.midnight_ts(t))/864e5);case"month":case"months":let e=12*(t.getFullYear()-this.getFullYear());return e-=t.getMonth(),e+=this.getMonth(),e}}format(e,i="en-US"){let n="";const s=[];let o=null;for(;null!=(o=t.regex.exec(e));)"\\"!==o[1]&&s.push(o);if(s.length){s[0].index>0&&(n+=e.substring(0,s[0].index));for(const[t,o]of Object.entries(s)){const a=Number(t);n+=this.formatTokens(o[0],i),s[a+1]&&(n+=e.substring(o.index+o[0].length,s[a+1].index)),a===s.length-1&&(n+=e.substring(o.index+o[0].length))}}return n.replace(/\\/g,"")}midnight_ts(t){return t?new Date(t.getFullYear(),t.getMonth(),t.getDate(),0,0,0,0).getTime():new Date(this.getFullYear(),this.getMonth(),this.getDate(),0,0,0,0).getTime()}formatTokens(e,i){switch(e){case"YY":return String(this.getFullYear()).slice(-2);case"YYYY":return String(this.getFullYear());case"M":return String(this.getMonth()+1);case"MM":return`0${this.getMonth()+1}`.slice(-2);case"MMM":return t.shortMonths(i)[this.getMonth()];case"MMMM":return t.longMonths(i)[this.getMonth()];case"D":return String(this.getDate());case"DD":return`0${this.getDate()}`.slice(-2);case"H":return String(this.getHours());case"HH":return`0${this.getHours()}`.slice(-2);case"h":return String(this.getHours()%12||12);case"hh":return`0${this.getHours()%12||12}`.slice(-2);case"m":return String(this.getMinutes());case"mm":return`0${this.getMinutes()}`.slice(-2);case"s":return String(this.getSeconds());case"ss":return`0${this.getSeconds()}`.slice(-2);case"a":return this.getHours()<12||24===this.getHours()?"am":"pm";case"A":return this.getHours()<12||24===this.getHours()?"AM":"PM";default:return""}}}class e{picker;constructor(t){this.picker=t}render(e,i){e||(e=new t),e.setDate(1),e.setHours(0,0,0,0),"function"==typeof this[`get${i}View`]&&this[`get${i}View`](e)}getContainerView(t){this.picker.ui.container.innerHTML="",this.picker.options.header&&this.picker.trigger("render",{date:t.clone(),view:"Header"}),this.picker.trigger("render",{date:t.clone(),view:"Main"}),this.picker.options.autoApply||this.picker.trigger("render",{date:t.clone(),view:"Footer"})}getHeaderView(t){const e=document.createElement("header");this.picker.options.header instanceof HTMLElement&&e.appendChild(this.picker.options.header),"string"==typeof this.picker.options.header&&(e.innerHTML=this.picker.options.header),this.picker.ui.container.appendChild(e),this.picker.trigger("view",{target:e,date:t.clone(),view:"Header"})}getMainView(t){const e=document.createElement("main");this.picker.ui.container.appendChild(e);const i=document.createElement("div");i.className=`calendars grid-${this.picker.options.grid}`;for(let e=0;e<this.picker.options.calendars;e++){const n=document.createElement("div");n.className="calendar",i.appendChild(n);const s=this.getCalendarHeaderView(t.clone());n.appendChild(s),this.picker.trigger("view",{date:t.clone(),view:"CalendarHeader",index:e,target:s});const o=this.getCalendarDayNamesView();n.appendChild(o),this.picker.trigger("view",{date:t.clone(),view:"CalendarDayNames",index:e,target:o});const a=this.getCalendarDaysView(t.clone());n.appendChild(a),this.picker.trigger("view",{date:t.clone(),view:"CalendarDays",index:e,target:a});const r=this.getCalendarFooterView(this.picker.options.lang,t.clone());n.appendChild(r),this.picker.trigger("view",{date:t.clone(),view:"CalendarFooter",index:e,target:r}),this.picker.trigger("view",{date:t.clone(),view:"CalendarItem",index:e,target:n}),t.add(1,"month")}e.appendChild(i),this.picker.trigger("view",{date:t.clone(),view:"Calendars",target:i}),this.picker.trigger("view",{date:t.clone(),view:"Main",target:e})}getFooterView(t){const e=document.createElement("footer"),i=document.createElement("div");i.className="footer-buttons";const n=document.createElement("button");n.className="cancel-button unit",n.innerHTML=this.picker.options.locale.cancel,i.appendChild(n);const s=document.createElement("button");s.className="apply-button unit",s.innerHTML=this.picker.options.locale.apply,s.disabled=!0,i.appendChild(s),e.appendChild(i),this.picker.ui.container.appendChild(e),this.picker.trigger("view",{date:t,target:e,view:"Footer"})}getCalendarHeaderView(t){const e=document.createElement("div");e.className="header";const i=document.createElement("div");i.className="month-name",i.innerHTML=`<span>${t.toLocaleString(this.picker.options.lang,{month:"long"})}</span> ${t.format("YYYY")}`,e.appendChild(i);const n=document.createElement("button");n.className="previous-button unit",n.innerHTML=this.picker.options.locale.previousMonth,e.appendChild(n);const s=document.createElement("button");return s.className="next-button unit",s.innerHTML=this.picker.options.locale.nextMonth,e.appendChild(s),e}getCalendarDayNamesView(){const t=document.createElement("div");t.className="daynames-row";for(let e=1;e<=7;e++){const i=3+this.picker.options.firstDay+e,n=document.createElement("div");n.className="dayname",n.innerHTML=new Date(1970,0,i,12,0,0,0).toLocaleString(this.picker.options.lang,{weekday:"short"}),n.title=new Date(1970,0,i,12,0,0,0).toLocaleString(this.picker.options.lang,{weekday:"long"}),t.appendChild(n),this.picker.trigger("view",{dayIdx:i,view:"CalendarDayName",target:n})}return t}getCalendarDaysView(t){const e=document.createElement("div");e.className="days-grid";const i=this.calcOffsetDays(t,this.picker.options.firstDay),n=32-new Date(t.getFullYear(),t.getMonth(),32).getDate();for(let t=0;t<i;t++){const t=document.createElement("div");t.className="offset",e.appendChild(t)}for(let i=1;i<=n;i++){t.setDate(i);const n=this.getCalendarDayView(t);e.appendChild(n),this.picker.trigger("view",{date:t,view:"CalendarDay",target:n})}return e}getCalendarDayView(e){const i=this.picker.options.date?new t(this.picker.options.date):null,n=new t,s=document.createElement("div");return s.className="day unit",s.innerHTML=e.format("D"),s.dataset.time=String(e.getTime()),e.isSame(n,"day")&&s.classList.add("today"),[0,6].includes(e.getDay())&&s.classList.add("weekend"),this.picker.datePicked.length?this.picker.datePicked[0].isSame(e,"day")&&s.classList.add("selected"):i&&e.isSame(i,"day")&&s.classList.add("selected"),this.picker.trigger("view",{date:e,view:"CalendarDay",target:s}),s}getCalendarFooterView(t,e){const i=document.createElement("div");return i.className="footer",i}calcOffsetDays(t,e){let i=t.getDay()-e;return i<0&&(i+=7),i}}class i{picker;instances={};constructor(t){this.picker=t}initialize(){const t=[];this.picker.options.plugins.forEach((e=>{"function"==typeof e?t.push(new e):"string"==typeof e&&"undefined"!=typeof easepick&&Object.prototype.hasOwnProperty.call(easepick,e)?t.push(new easepick[e]):console.warn(`easepick: ${e} not found.`)})),t.sort(((t,e)=>t.priority>e.priority?-1:t.priority<e.priority||t.dependencies.length>e.dependencies.length?1:t.dependencies.length<e.dependencies.length?-1:0)),t.forEach((t=>{t.attach(this.picker),this.instances[t.getName()]=t}))}getInstance(t){return this.instances[t]}addInstance(t){if(Object.prototype.hasOwnProperty.call(this.instances,t))console.warn(`easepick: ${t} already added.`);else{if("undefined"!=typeof easepick&&Object.prototype.hasOwnProperty.call(easepick,t)){const e=new easepick[t];return e.attach(this.picker),this.instances[e.getName()]=e,e}if("undefined"!==this.getPluginFn(t)){const e=new(this.getPluginFn(t));return e.attach(this.picker),this.instances[e.getName()]=e,e}console.warn(`easepick: ${t} not found.`)}return null}removeInstance(t){return t in this.instances&&this.instances[t].detach(),delete this.instances[t]}reloadInstance(t){return this.removeInstance(t),this.addInstance(t)}getPluginFn(t){return[...this.picker.options.plugins].filter((e=>"function"==typeof e&&(new e).getName()===t)).shift()}}class n{Calendar=new e(this);PluginManager=new i(this);calendars=[];datePicked=[];cssLoaded=0;binds={hidePicker:this.hidePicker.bind(this),show:this.show.bind(this)};options={doc:document,css:[],element:null,firstDay:1,grid:1,calendars:1,lang:"en-US",date:null,format:"YYYY-MM-DD",readonly:!0,autoApply:!0,header:!1,inline:!1,scrollToDate:!0,locale:{nextMonth:'<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M2.748 16L0 13.333 5.333 8 0 2.667 2.748 0l7.919 8z" fill-rule="nonzero"/></svg>',previousMonth:'<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M7.919 0l2.748 2.667L5.333 8l5.334 5.333L7.919 16 0 8z" fill-rule="nonzero"/></svg>',cancel:"Cancel",apply:"Apply"},documentClick:this.binds.hidePicker,plugins:[]};ui={container:null,shadowRoot:null,wrapper:null};version="1.2.1";constructor(t){const e={...this.options.locale,...t.locale};this.options={...this.options,...t},this.options.locale=e,this.handleOptions(),this.ui.wrapper=document.createElement("span"),this.ui.wrapper.style.display="none",this.ui.wrapper.style.position="absolute",this.ui.wrapper.style.pointerEvents="none",this.ui.wrapper.className="easepick-wrapper",this.ui.wrapper.attachShadow({mode:"open"}),this.ui.shadowRoot=this.ui.wrapper.shadowRoot,this.ui.container=document.createElement("div"),this.ui.container.className="container",this.options.zIndex&&(this.ui.container.style.zIndex=String(this.options.zIndex)),this.options.inline&&(this.ui.wrapper.style.position="relative",this.ui.container.classList.add("inline")),this.ui.shadowRoot.appendChild(this.ui.container),this.options.element.after(this.ui.wrapper),this.handleCSS(),this.options.element.addEventListener("click",this.binds.show),this.on("view",this.onView.bind(this)),this.on("render",this.onRender.bind(this)),this.PluginManager.initialize(),this.parseValues(),"function"==typeof this.options.setup&&this.options.setup(this),this.on("click",this.onClick.bind(this));const i=this.options.scrollToDate?this.getDate():null;this.renderAll(i)}on(t,e,i={}){this.ui.container.addEventListener(t,e,i)}off(t,e,i={}){this.ui.container.removeEventListener(t,e,i)}trigger(t,e={}){return this.ui.container.dispatchEvent(new CustomEvent(t,{detail:e}))}destroy(){this.options.element.removeEventListener("click",this.binds.show),"function"==typeof this.options.documentClick&&document.removeEventListener("click",this.options.documentClick,!0),Object.keys(this.PluginManager.instances).forEach((t=>{this.PluginManager.removeInstance(t)})),this.ui.wrapper.remove()}onRender(t){const{view:e,date:i}=t.detail;this.Calendar.render(i,e)}onView(t){const{view:e,target:i}=t.detail;"Footer"===e&&this.datePicked.length&&(i.querySelector(".apply-button").disabled=!1)}onClickHeaderButton(t){this.isCalendarHeaderButton(t)&&(t.classList.contains("next-button")?this.calendars[0].add(1,"month"):this.calendars[0].subtract(1,"month"),this.renderAll(this.calendars[0]))}onClickCalendarDay(e){if(this.isCalendarDay(e)){const i=new t(e.dataset.time);this.options.autoApply?(this.setDate(i),this.trigger("select",{date:this.getDate()}),this.hide()):(this.datePicked[0]=i,this.trigger("preselect",{date:this.getDate()}),this.renderAll())}}onClickApplyButton(t){if(this.isApplyButton(t)){if(this.datePicked[0]instanceof Date){const t=this.datePicked[0].clone();this.setDate(t)}this.hide(),this.trigger("select",{date:this.getDate()})}}onClickCancelButton(t){this.isCancelButton(t)&&this.hide()}onClick(t){const e=t.target;if(e instanceof HTMLElement){const t=e.closest(".unit");if(!(t instanceof HTMLElement))return;this.onClickHeaderButton(t),this.onClickCalendarDay(t),this.onClickApplyButton(t),this.onClickCancelButton(t)}}isShown(){return this.ui.container.classList.contains("inline")||this.ui.container.classList.contains("show")}show(t){if(this.isShown())return;const e=t&&"target"in t?t.target:this.options.element,{top:i,left:n}=this.adjustPosition(e);this.ui.container.style.top=`${i}px`,this.ui.container.style.left=`${n}px`,this.ui.container.classList.add("show"),this.trigger("show",{target:e})}hide(){this.ui.container.classList.remove("show"),this.datePicked.length=0,this.renderAll(),this.trigger("hide")}setDate(e){const i=new t(e,this.options.format);this.options.date=i.clone(),this.updateValues(),this.calendars.length&&this.renderAll()}getDate(){return this.options.date instanceof t?this.options.date.clone():null}parseValues(){this.options.date?this.setDate(this.options.date):this.options.element instanceof HTMLInputElement&&this.options.element.value.length&&this.setDate(this.options.element.value),this.options.date instanceof Date||(this.options.date=null)}updateValues(){const t=this.getDate(),e=t instanceof Date?t.format(this.options.format,this.options.lang):"",i=this.options.element;i instanceof HTMLInputElement?i.value=e:i instanceof HTMLElement&&(i.innerText=e)}hidePicker(t){let e=t.target,i=null;e.shadowRoot&&(e=t.composedPath()[0],i=e.getRootNode().host),this.isShown()&&i!==this.ui.wrapper&&e!==this.options.element&&this.hide()}renderAll(t){this.trigger("render",{view:"Container",date:(t||this.calendars[0]).clone()})}isCalendarHeaderButton(t){return["previous-button","next-button"].some((e=>t.classList.contains(e)))}isCalendarDay(t){return t.classList.contains("day")}isApplyButton(t){return t.classList.contains("apply-button")}isCancelButton(t){return t.classList.contains("cancel-button")}gotoDate(e){const i=new t(e,this.options.format);i.setDate(1),this.calendars[0]=i.clone(),this.renderAll()}clear(){this.options.date=null,this.datePicked.length=0,this.updateValues(),this.renderAll(),this.trigger("clear")}handleOptions(){this.options.element instanceof HTMLElement||(this.options.element=this.options.doc.querySelector(this.options.element)),"function"==typeof this.options.documentClick&&document.addEventListener("click",this.options.documentClick,!0),this.options.element instanceof HTMLInputElement&&(this.options.element.readOnly=this.options.readonly),this.options.date?this.calendars[0]=new t(this.options.date,this.options.format):this.calendars[0]=new t}handleCSS(){if(Array.isArray(this.options.css))this.options.css.forEach((t=>{const e=document.createElement("link");e.href=t,e.rel="stylesheet";const i=()=>{this.cssLoaded++,this.cssLoaded===this.options.css.length&&(this.ui.wrapper.style.display="")};e.addEventListener("load",i),e.addEventListener("error",i),this.ui.shadowRoot.append(e)}));else if("string"==typeof this.options.css){const t=document.createElement("style"),e=document.createTextNode(this.options.css);t.appendChild(e),this.ui.shadowRoot.append(t),this.ui.wrapper.style.display=""}else"function"==typeof this.options.css&&(this.options.css.call(this,this),this.ui.wrapper.style.display="")}adjustPosition(t){const e=t.getBoundingClientRect(),i=this.ui.wrapper.getBoundingClientRect();this.ui.container.classList.add("calc");const n=this.ui.container.getBoundingClientRect();this.ui.container.classList.remove("calc");let s=e.bottom-i.bottom,o=e.left-i.left;return"undefined"!=typeof window&&(window.innerHeight<s+n.height&&s-n.height>=0&&(s=e.top-i.top-n.height),window.innerWidth<o+n.width&&e.right-n.width>=0&&(o=e.right-i.right-n.width)),{left:o,top:s}}}var s=Object.freeze({__proto__:null,Core:n,create:n});class o{picker;options;priority=0;dependencies=[];attach(t){const e=this.getName(),i={...this.options};this.options={...this.options,...t.options[e]||{}};for(const n of Object.keys(i))if(null!==i[n]&&"object"==typeof i[n]&&Object.keys(i[n]).length&&e in t.options&&n in t.options[e]){const s={...t.options[e][n]};null!==s&&"object"==typeof s&&Object.keys(s).length&&Object.keys(s).every((t=>Object.keys(i[n]).includes(t)))&&(this.options[n]={...i[n],...s})}if(this.picker=t,this.dependenciesNotFound()){const t=this.dependencies.filter((t=>!this.pluginsAsStringArray().includes(t)));return void console.warn(`${this.getName()}: required dependencies (${t.join(", ")}).`)}const n=this.camelCaseToKebab(this.getName());this.picker.ui.container.classList.add(n),this.onAttach()}detach(){const t=this.camelCaseToKebab(this.getName());this.picker.ui.container.classList.remove(t),"function"==typeof this.onDetach&&this.onDetach()}dependenciesNotFound(){return this.dependencies.length&&!this.dependencies.every((t=>this.pluginsAsStringArray().includes(t)))}pluginsAsStringArray(){return this.picker.options.plugins.map((t=>"function"==typeof t?(new t).getName():t))}camelCaseToKebab(t){return t.replace(/([a-zA-Z])(?=[A-Z])/g,"$1-").toLowerCase()}}class a extends o{priority=1;binds={onView:this.onView.bind(this)};options={minDate:null,maxDate:null,minDays:null,maxDays:null,selectForward:null,selectBackward:null,presets:!0,inseparable:!1,filter:null};getName(){return"LockPlugin"}onAttach(){if(this.options.minDate&&(this.options.minDate=new t(this.options.minDate,this.picker.options.format,this.picker.options.lang)),this.options.maxDate&&(this.options.maxDate=new t(this.options.maxDate,this.picker.options.format,this.picker.options.lang),this.options.maxDate instanceof t&&this.picker.options.calendars>1&&this.picker.calendars[0].isSame(this.options.maxDate,"month"))){const t=this.picker.calendars[0].clone().subtract(1,"month");this.picker.gotoDate(t)}if((this.options.minDays||this.options.maxDays||this.options.selectForward||this.options.selectBackward)&&!this.picker.options.plugins.includes("RangePlugin")){const t=["minDays","maxDays","selectForward","selectBackward"];console.warn(`${this.getName()}: options ${t.join(", ")} required RangePlugin.`)}this.picker.on("view",this.binds.onView)}onDetach(){this.picker.off("view",this.binds.onView)}onView(e){const{view:i,target:n,date:s}=e.detail;if("CalendarHeader"===i&&(this.options.minDate instanceof t&&s.isSameOrBefore(this.options.minDate,"month")&&n.classList.add("no-previous-month"),this.options.maxDate instanceof t&&s.isSameOrAfter(this.options.maxDate,"month")&&n.classList.add("no-next-month")),"CalendarDay"===i){const t=this.picker.datePicked.length?this.picker.datePicked[0]:null;if(this.testFilter(s))return void n.classList.add("locked");if(this.options.inseparable){if(this.options.minDays){const t=s.clone().subtract(this.options.minDays-1,"day"),e=s.clone().add(this.options.minDays-1,"day");let i=!1,o=!1;for(;t.isBefore(s,"day");){if(this.testFilter(t)){i=!0;break}t.add(1,"day")}for(;e.isAfter(s,"day");){if(this.testFilter(e)){o=!0;break}e.subtract(1,"day")}i&&o&&n.classList.add("not-available")}this.rangeIsNotAvailable(s,t)&&n.classList.add("not-available")}this.dateIsNotAvailable(s,t)&&n.classList.add("not-available")}if(this.options.presets&&"PresetPluginButton"===i){const e=new t(Number(n.dataset.start)),i=new t(Number(n.dataset.end)),s=i.diff(e,"day"),o=this.options.minDays&&s<this.options.minDays,a=this.options.maxDays&&s>this.options.maxDays;(o||a||this.lockMinDate(e)||this.lockMaxDate(e)||this.lockMinDate(i)||this.lockMaxDate(i)||this.rangeIsNotAvailable(e,i))&&n.setAttribute("disabled","disabled")}}dateIsNotAvailable(t,e){return this.lockMinDate(t)||this.lockMaxDate(t)||this.lockMinDays(t,e)||this.lockMaxDays(t,e)||this.lockSelectForward(t)||this.lockSelectBackward(t)}rangeIsNotAvailable(t,e){if(!t||!e)return!1;const i=(t.isSameOrBefore(e,"day")?t:e).clone(),n=(e.isSameOrAfter(t,"day")?e:t).clone();for(;i.isSameOrBefore(n,"day");){if(this.testFilter(i))return!0;i.add(1,"day")}return!1}lockMinDate(e){return this.options.minDate instanceof t&&e.isBefore(this.options.minDate,"day")}lockMaxDate(e){return this.options.maxDate instanceof t&&e.isAfter(this.options.maxDate,"day")}lockMinDays(t,e){if(this.options.minDays&&e){const i=e.clone().subtract(this.options.minDays-1,"day"),n=e.clone().add(this.options.minDays-1,"day");return t.isBetween(i,n)}return!1}lockMaxDays(t,e){if(this.options.maxDays&&e){const i=e.clone().subtract(this.options.maxDays,"day"),n=e.clone().add(this.options.maxDays,"day");return!t.isBetween(i,n)}return!1}lockSelectForward(t){if(1===this.picker.datePicked.length&&this.options.selectForward){const e=this.picker.datePicked[0].clone();return t.isBefore(e,"day")}return!1}lockSelectBackward(t){if(1===this.picker.datePicked.length&&this.options.selectBackward){const e=this.picker.datePicked[0].clone();return t.isAfter(e,"day")}return!1}testFilter(t){return"function"==typeof this.options.filter&&this.options.filter(t,this.picker.datePicked)}}class r extends o{dependencies=["RangePlugin"];binds={onView:this.onView.bind(this),onClick:this.onClick.bind(this)};options={customLabels:["Today","Yesterday","Last 7 Days","Last 30 Days","This Month","Last Month"],customPreset:{},position:"left"};getName(){return"PresetPlugin"}onAttach(){if(!Object.keys(this.options.customPreset).length){const e=new t,i=()=>{const i=e.clone();i.setDate(1);const n=new Date(e.getFullYear(),e.getMonth()+1,0);return[new t(i),new t(n)]},n=()=>{const i=e.clone();i.setMonth(i.getMonth()-1),i.setDate(1);const n=new Date(e.getFullYear(),e.getMonth(),0);return[new t(i),new t(n)]},s=[[e.clone(),e.clone()],[e.clone().subtract(1,"day"),e.clone().subtract(1,"day")],[e.clone().subtract(6,"day"),e.clone()],[e.clone().subtract(29,"day"),e.clone()],i(),n()];Object.values(this.options.customLabels).forEach(((t,e)=>{this.options.customPreset[t]=s[e]}))}this.picker.on("view",this.binds.onView),this.picker.on("click",this.binds.onClick)}onDetach(){this.picker.off("view",this.binds.onView),this.picker.off("click",this.binds.onClick)}onView(t){const{view:e,target:i}=t.detail;if("Main"===e){const t=document.createElement("div");t.className="preset-plugin-container",Object.keys(this.options.customPreset).forEach((e=>{if(Object.prototype.hasOwnProperty.call(this.options.customPreset,e)){const i=this.options.customPreset[e],n=document.createElement("button");n.className="preset-button unit",n.innerHTML=e,n.dataset.start=i[0].getTime(),n.dataset.end=i[1].getTime(),t.appendChild(n),this.picker.trigger("view",{view:"PresetPluginButton",target:n})}})),i.appendChild(t),i.classList.add(`preset-${this.options.position}`),this.picker.trigger("view",{view:"PresetPluginContainer",target:t})}}onClick(e){const i=e.target;if(i instanceof HTMLElement){const e=i.closest(".unit");if(!(e instanceof HTMLElement))return;if(this.isPresetButton(e)){const i=new t(Number(e.dataset.start)),n=new t(Number(e.dataset.end));this.picker.options.autoApply?(this.picker.setDateRange(i,n),this.picker.trigger("select",{start:this.picker.getStartDate(),end:this.picker.getEndDate()}),this.picker.hide()):(this.picker.datePicked=[i,n],this.picker.renderAll())}}}isPresetButton(t){return t.classList.contains("preset-button")}}class c extends o{tooltipElement;triggerElement;binds={setStartDate:this.setStartDate.bind(this),setEndDate:this.setEndDate.bind(this),setDateRange:this.setDateRange.bind(this),getStartDate:this.getStartDate.bind(this),getEndDate:this.getEndDate.bind(this),onView:this.onView.bind(this),onShow:this.onShow.bind(this),onMouseEnter:this.onMouseEnter.bind(this),onMouseLeave:this.onMouseLeave.bind(this),onClickCalendarDay:this.onClickCalendarDay.bind(this),onClickApplyButton:this.onClickApplyButton.bind(this),parseValues:this.parseValues.bind(this),updateValues:this.updateValues.bind(this),clear:this.clear.bind(this)};options={elementEnd:null,startDate:null,endDate:null,repick:!1,strict:!0,delimiter:" - ",tooltip:!0,tooltipNumber:t=>t,locale:{zero:"",one:"day",two:"",few:"",many:"",other:"days"},documentClick:this.hidePicker.bind(this)};getName(){return"RangePlugin"}onAttach(){this.binds._setStartDate=this.picker.setStartDate,this.binds._setEndDate=this.picker.setEndDate,this.binds._setDateRange=this.picker.setDateRange,this.binds._getStartDate=this.picker.getStartDate,this.binds._getEndDate=this.picker.getEndDate,this.binds._parseValues=this.picker.parseValues,this.binds._updateValues=this.picker.updateValues,this.binds._clear=this.picker.clear,this.binds._onClickCalendarDay=this.picker.onClickCalendarDay,this.binds._onClickApplyButton=this.picker.onClickApplyButton,Object.defineProperties(this.picker,{setStartDate:{configurable:!0,value:this.binds.setStartDate},setEndDate:{configurable:!0,value:this.binds.setEndDate},setDateRange:{configurable:!0,value:this.binds.setDateRange},getStartDate:{configurable:!0,value:this.binds.getStartDate},getEndDate:{configurable:!0,value:this.binds.getEndDate},parseValues:{configurable:!0,value:this.binds.parseValues},updateValues:{configurable:!0,value:this.binds.updateValues},clear:{configurable:!0,value:this.binds.clear},onClickCalendarDay:{configurable:!0,value:this.binds.onClickCalendarDay},onClickApplyButton:{configurable:!0,value:this.binds.onClickApplyButton}}),this.options.elementEnd&&(this.options.elementEnd instanceof HTMLElement||(this.options.elementEnd=this.picker.options.doc.querySelector(this.options.elementEnd)),this.options.elementEnd instanceof HTMLInputElement&&(this.options.elementEnd.readOnly=this.picker.options.readonly),"function"==typeof this.picker.options.documentClick&&(document.removeEventListener("click",this.picker.options.documentClick,!0),"function"==typeof this.options.documentClick&&document.addEventListener("click",this.options.documentClick,!0)),this.options.elementEnd.addEventListener("click",this.picker.show.bind(this.picker))),this.options.repick=this.options.repick&&this.options.elementEnd instanceof HTMLElement,this.picker.options.date=null,this.picker.on("view",this.binds.onView),this.picker.on("show",this.binds.onShow),this.picker.on("mouseenter",this.binds.onMouseEnter,!0),this.picker.on("mouseleave",this.binds.onMouseLeave,!0),this.checkIntlPluralLocales()}onDetach(){Object.defineProperties(this.picker,{setStartDate:{configurable:!0,value:this.binds._setStartDate},setEndDate:{configurable:!0,value:this.binds._setEndDate},setDateRange:{configurable:!0,value:this.binds._setDateRange},getStartDate:{configurable:!0,value:this.binds._getStartDate},getEndDate:{configurable:!0,value:this.binds._getEndDate},parseValues:{configurable:!0,value:this.binds._parseValues},updateValues:{configurable:!0,value:this.binds._updateValues},clear:{configurable:!0,value:this.binds._clear},onClickCalendarDay:{configurable:!0,value:this.binds._onClickCalendarDay},onClickApplyButton:{configurable:!0,value:this.binds._onClickApplyButton}}),this.picker.off("view",this.binds.onView),this.picker.off("show",this.binds.onShow),this.picker.off("mouseenter",this.binds.onMouseEnter,!0),this.picker.off("mouseleave",this.binds.onMouseLeave,!0)}parseValues(){if(this.options.startDate||this.options.endDate)this.options.strict?this.options.startDate&&this.options.endDate?this.setDateRange(this.options.startDate,this.options.endDate):(this.options.startDate=null,this.options.endDate=null):(this.options.startDate&&this.setStartDate(this.options.startDate),this.options.endDate&&this.setEndDate(this.options.endDate));else if(this.options.elementEnd)this.options.strict?this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length&&this.options.elementEnd instanceof HTMLInputElement&&this.options.elementEnd.value.length&&this.setDateRange(this.picker.options.element.value,this.options.elementEnd.value):(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length&&this.setStartDate(this.picker.options.element.value),this.options.elementEnd instanceof HTMLInputElement&&this.options.elementEnd.value.length&&this.setEndDate(this.options.elementEnd.value));else if(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length){const[t,e]=this.picker.options.element.value.split(this.options.delimiter);this.options.strict?t&&e&&this.setDateRange(t,e):(t&&this.setStartDate(t),e&&this.setEndDate(e))}}updateValues(){const t=this.picker.options.element,e=this.options.elementEnd,i=this.picker.getStartDate(),n=this.picker.getEndDate(),s=i instanceof Date?i.format(this.picker.options.format,this.picker.options.lang):"",o=n instanceof Date?n.format(this.picker.options.format,this.picker.options.lang):"";if(e)t instanceof HTMLInputElement?t.value=s:t instanceof HTMLElement&&(t.innerText=s),e instanceof HTMLInputElement?e.value=o:e instanceof HTMLElement&&(e.innerText=o);else{const e=`${s}${s||o?this.options.delimiter:""}${o}`;t instanceof HTMLInputElement?t.value=e:t instanceof HTMLElement&&(t.innerText=e)}}clear(){this.options.startDate=null,this.options.endDate=null,this.picker.datePicked.length=0,this.updateValues(),this.picker.renderAll(),this.picker.trigger("clear")}onShow(t){const{target:e}=t.detail;this.triggerElement=e,this.picker.options.scrollToDate&&this.getStartDate()instanceof Date&&this.picker.gotoDate(this.getStartDate()),this.initializeRepick()}onView(e){const{view:i,target:n}=e.detail;if("Main"===i&&(this.tooltipElement=document.createElement("span"),this.tooltipElement.className="range-plugin-tooltip",n.appendChild(this.tooltipElement)),"CalendarDay"===i){const e=new t(n.dataset.time),i=this.picker.datePicked,s=i.length?this.picker.datePicked[0]:this.getStartDate(),o=i.length?this.picker.datePicked[1]:this.getEndDate();s&&s.isSame(e,"day")&&n.classList.add("start"),s&&o&&(o.isSame(e,"day")&&n.classList.add("end"),e.isBetween(s,o)&&n.classList.add("in-range"))}if("Footer"===i){const t=1===this.picker.datePicked.length&&!this.options.strict||2===this.picker.datePicked.length;n.querySelector(".apply-button").disabled=!t}}hidePicker(t){let e=t.target,i=null;e.shadowRoot&&(e=t.composedPath()[0],i=e.getRootNode().host),this.picker.isShown()&&i!==this.picker.ui.wrapper&&e!==this.picker.options.element&&e!==this.options.elementEnd&&this.picker.hide()}setStartDate(e){const i=new t(e,this.picker.options.format);this.options.startDate=i?i.clone():null,this.updateValues(),this.picker.renderAll()}setEndDate(e){const i=new t(e,this.picker.options.format);this.options.endDate=i?i.clone():null,this.updateValues(),this.picker.renderAll()}setDateRange(e,i){const n=new t(e,this.picker.options.format),s=new t(i,this.picker.options.format);this.options.startDate=n?n.clone():null,this.options.endDate=s?s.clone():null,this.updateValues(),this.picker.renderAll()}getStartDate(){return this.options.startDate instanceof Date?this.options.startDate.clone():null}getEndDate(){return this.options.endDate instanceof Date?this.options.endDate.clone():null}onMouseEnter(e){const i=e.target;if(i instanceof HTMLElement){this.isContainer(i)&&this.initializeRepick();const e=i.closest(".unit");if(!(e instanceof HTMLElement))return;if(this.picker.isCalendarDay(e)){if(1!==this.picker.datePicked.length)return;let i=this.picker.datePicked[0].clone(),n=new t(e.dataset.time),s=!1;if(i.isAfter(n,"day")){const t=i.clone();i=n.clone(),n=t.clone(),s=!0}if([...this.picker.ui.container.querySelectorAll(".day")].forEach((o=>{const a=new t(o.dataset.time),r=this.picker.Calendar.getCalendarDayView(a);a.isBetween(i,n)&&r.classList.add("in-range"),a.isSame(this.picker.datePicked[0],"day")&&(r.classList.add("start"),r.classList.toggle("flipped",s)),o===e&&(r.classList.add("end"),r.classList.toggle("flipped",s)),o.className=r.className})),this.options.tooltip){const t=this.options.tooltipNumber(n.diff(i,"day")+1);if(t>0){const i=new Intl.PluralRules(this.picker.options.lang).select(t),n=`${t} ${this.options.locale[i]}`;this.showTooltip(e,n)}else this.hideTooltip()}}}}onMouseLeave(t){if(this.isContainer(t.target)&&this.options.repick){const t=this.getStartDate(),e=this.getEndDate();t&&e&&(this.picker.datePicked.length=0,this.picker.renderAll())}}onClickCalendarDay(e){if(this.picker.isCalendarDay(e)){2===this.picker.datePicked.length&&(this.picker.datePicked.length=0);const i=new t(e.dataset.time);if(this.picker.datePicked[this.picker.datePicked.length]=i,2===this.picker.datePicked.length&&this.picker.datePicked[0].isAfter(this.picker.datePicked[1])){const t=this.picker.datePicked[1].clone();this.picker.datePicked[1]=this.picker.datePicked[0].clone(),this.picker.datePicked[0]=t.clone()}1!==this.picker.datePicked.length&&this.picker.options.autoApply||this.picker.trigger("preselect",{start:this.picker.datePicked[0]instanceof Date?this.picker.datePicked[0].clone():null,end:this.picker.datePicked[1]instanceof Date?this.picker.datePicked[1].clone():null}),1===this.picker.datePicked.length&&(!this.options.strict&&this.picker.options.autoApply&&(this.picker.options.element===this.triggerElement&&this.setStartDate(this.picker.datePicked[0]),this.options.elementEnd===this.triggerElement&&this.setEndDate(this.picker.datePicked[0]),this.picker.trigger("select",{start:this.picker.getStartDate(),end:this.picker.getEndDate()})),this.picker.renderAll()),2===this.picker.datePicked.length&&(this.picker.options.autoApply?(this.setDateRange(this.picker.datePicked[0],this.picker.datePicked[1]),this.picker.trigger("select",{start:this.picker.getStartDate(),end:this.picker.getEndDate()}),this.picker.hide()):(this.hideTooltip(),this.picker.renderAll()))}}onClickApplyButton(t){this.picker.isApplyButton(t)&&(1!==this.picker.datePicked.length||this.options.strict||(this.picker.options.element===this.triggerElement&&(this.options.endDate=null,this.setStartDate(this.picker.datePicked[0])),this.options.elementEnd===this.triggerElement&&(this.options.startDate=null,this.setEndDate(this.picker.datePicked[0]))),2===this.picker.datePicked.length&&this.setDateRange(this.picker.datePicked[0],this.picker.datePicked[1]),this.picker.trigger("select",{start:this.picker.getStartDate(),end:this.picker.getEndDate()}),this.picker.hide())}showTooltip(t,e){this.tooltipElement.style.visibility="visible",this.tooltipElement.innerHTML=e;const i=this.picker.ui.container.getBoundingClientRect(),n=this.tooltipElement.getBoundingClientRect(),s=t.getBoundingClientRect();let o=s.top,a=s.left;o-=i.top,a-=i.left,o-=n.height,a-=n.width/2,a+=s.width/2,this.tooltipElement.style.top=`${o}px`,this.tooltipElement.style.left=`${a}px`}hideTooltip(){this.tooltipElement.style.visibility="hidden"}checkIntlPluralLocales(){if(!this.options.tooltip)return;const t=[...new Set([new Intl.PluralRules(this.picker.options.lang).select(0),new Intl.PluralRules(this.picker.options.lang).select(1),new Intl.PluralRules(this.picker.options.lang).select(2),new Intl.PluralRules(this.picker.options.lang).select(6),new Intl.PluralRules(this.picker.options.lang).select(18)])],e=Object.keys(this.options.locale);t.every((t=>e.includes(t)))||console.warn(`${this.getName()}: provide locales (${t.join(", ")}) for correct tooltip text.`)}initializeRepick(){if(!this.options.repick)return;const t=this.getStartDate(),e=this.getEndDate();e&&this.triggerElement===this.picker.options.element&&(this.picker.datePicked[0]=e),t&&this.triggerElement===this.options.elementEnd&&(this.picker.datePicked[0]=t)}isContainer(t){return t===this.picker.ui.container}}class l extends o{options={native:!1,seconds:!1,stepHours:1,stepMinutes:5,stepSeconds:5,format12:!1};rangePlugin;timePicked={input:null,start:null,end:null};timePrePicked={input:null,start:null,end:null};binds={getDate:this.getDate.bind(this),getStartDate:this.getStartDate.bind(this),getEndDate:this.getEndDate.bind(this),onView:this.onView.bind(this),onInput:this.onInput.bind(this),onChange:this.onChange.bind(this),onClick:this.onClick.bind(this),setTime:this.setTime.bind(this),setStartTime:this.setStartTime.bind(this),setEndTime:this.setEndTime.bind(this)};getName(){return"TimePlugin"}onAttach(){this.binds._getDate=this.picker.getDate,this.binds._getStartDate=this.picker.getStartDate,this.binds._getEndDate=this.picker.getEndDate,Object.defineProperties(this.picker,{getDate:{configurable:!0,value:this.binds.getDate},getStartDate:{configurable:!0,value:this.binds.getStartDate},getEndDate:{configurable:!0,value:this.binds.getEndDate},setTime:{configurable:!0,value:this.binds.setTime},setStartTime:{configurable:!0,value:this.binds.setStartTime},setEndTime:{configurable:!0,value:this.binds.setEndTime}}),this.rangePlugin=this.picker.PluginManager.getInstance("RangePlugin"),this.parseValues(),this.picker.on("view",this.binds.onView),this.picker.on("input",this.binds.onInput),this.picker.on("change",this.binds.onChange),this.picker.on("click",this.binds.onClick)}onDetach(){delete this.picker.setTime,delete this.picker.setStartTime,delete this.picker.setEndTime,Object.defineProperties(this.picker,{getDate:{configurable:!0,value:this.binds._getDate},getStartDate:{configurable:!0,value:this.binds._getStartDate},getEndDate:{configurable:!0,value:this.binds._getEndDate}}),this.picker.off("view",this.binds.onView),this.picker.off("input",this.binds.onInput),this.picker.off("change",this.binds.onChange),this.picker.off("click",this.binds.onClick)}onView(t){const{view:e,target:i}=t.detail;if("Main"===e){this.rangePlugin=this.picker.PluginManager.getInstance("RangePlugin");const t=document.createElement("div");if(t.className="time-plugin-container",this.rangePlugin){const e=this.getStartInput();t.appendChild(e),this.picker.trigger("view",{view:"TimePluginInput",target:e});const i=this.getEndInput();t.appendChild(i),this.picker.trigger("view",{view:"TimePluginInput",target:i})}else{const e=this.getSingleInput();t.appendChild(e),this.picker.trigger("view",{view:"TimePluginInput",target:e})}i.appendChild(t),this.picker.trigger("view",{view:"TimePluginContainer",target:t})}}onInput(e){const i=e.target;if(i instanceof HTMLInputElement&&i.classList.contains("time-plugin-input")){const e=this.timePicked[i.name]||new t,[n,s]=i.value.split(":");e.setHours(Number(n)||0,Number(s)||0,0,0),this.picker.options.autoApply?(this.timePicked[i.name]=e,this.picker.updateValues()):this.timePrePicked[i.name]=e}}onChange(e){const i=e.target;if(i instanceof HTMLSelectElement&&i.classList.contains("time-plugin-custom-input")){const e=/(\w+)\[(\w+)\]/,[,n,s]=i.name.match(e),o=Number(i.value);let a=new t;switch(!this.picker.options.autoApply&&this.timePrePicked[n]instanceof Date?a=this.timePrePicked[n].clone():this.timePicked[n]instanceof Date&&(a=this.timePicked[n].clone()),s){case"HH":if(this.options.format12){const t=i.closest(".time-plugin-custom-block").querySelector(`select[name="${n}[period]"]`).value,e=this.handleFormat12(t,a,o);a.setHours(e.getHours(),e.getMinutes(),e.getSeconds(),0)}else a.setHours(o,a.getMinutes(),a.getSeconds(),0);break;case"mm":a.setHours(a.getHours(),o,a.getSeconds(),0);break;case"ss":a.setHours(a.getHours(),a.getMinutes(),o,0);break;case"period":if(this.options.format12){const t=i.closest(".time-plugin-custom-block").querySelector(`select[name="${n}[HH]"]`).value,e=this.handleFormat12(i.value,a,Number(t));a.setHours(e.getHours(),e.getMinutes(),e.getSeconds(),0)}}if(this.picker.options.autoApply)this.timePicked[n]=a,this.picker.updateValues();else{this.timePrePicked[n]=a;const t=this.picker.ui.container.querySelector(".apply-button");if(this.rangePlugin){const e=this.rangePlugin.options,i=this.picker.datePicked,n=e.strict&&2===i.length||!e.strict&&i.length>0||!i.length&&e.strict&&e.startDate instanceof Date&&e.endDate instanceof Date||!i.length&&!e.strict&&(e.startDate instanceof Date||e.endDate instanceof Date);t.disabled=!n}else this.picker.datePicked.length&&(t.disabled=!1)}}}onClick(t){const e=t.target;if(e instanceof HTMLElement){const t=e.closest(".unit");if(!(t instanceof HTMLElement))return;this.picker.isApplyButton(t)&&(Object.keys(this.timePicked).forEach((t=>{this.timePrePicked[t]instanceof Date&&(this.timePicked[t]=this.timePrePicked[t].clone())})),this.picker.updateValues(),this.timePrePicked={input:null,start:null,end:null}),this.picker.isCancelButton(t)&&(this.timePrePicked={input:null,start:null,end:null},this.picker.renderAll())}}setTime(t){const e=this.handleTimeString(t);this.timePicked.input=e.clone(),this.picker.renderAll(),this.picker.updateValues()}setStartTime(t){const e=this.handleTimeString(t);this.timePicked.start=e.clone(),this.picker.renderAll(),this.picker.updateValues()}setEndTime(t){const e=this.handleTimeString(t);this.timePicked.end=e.clone(),this.picker.renderAll(),this.picker.updateValues()}handleTimeString(e){const i=new t,[n,s,o]=e.split(":").map((t=>Number(t))),a=n&&!Number.isNaN(n)?n:0,r=s&&!Number.isNaN(s)?s:0,c=o&&!Number.isNaN(o)?o:0;return i.setHours(a,r,c,0),i}getDate(){if(this.picker.options.date instanceof Date){const e=new t(this.picker.options.date,this.picker.options.format);if(this.timePicked.input instanceof Date){const t=this.timePicked.input;e.setHours(t.getHours(),t.getMinutes(),t.getSeconds(),0)}return e}return null}getStartDate(){if(this.rangePlugin.options.startDate instanceof Date){const e=new t(this.rangePlugin.options.startDate,this.picker.options.format);if(this.timePicked.start instanceof Date){const t=this.timePicked.start;e.setHours(t.getHours(),t.getMinutes(),t.getSeconds(),0)}return e}return null}getEndDate(){if(this.rangePlugin.options.endDate instanceof Date){const e=new t(this.rangePlugin.options.endDate,this.picker.options.format);if(this.timePicked.end instanceof Date){const t=this.timePicked.end;e.setHours(t.getHours(),t.getMinutes(),t.getSeconds(),0)}return e}return null}getSingleInput(){return this.options.native?this.getNativeInput("input"):this.getCustomInput("input")}getStartInput(){return this.options.native?this.getNativeInput("start"):this.getCustomInput("start")}getEndInput(){return this.options.native?this.getNativeInput("end"):this.getCustomInput("end")}getNativeInput(t){const e=document.createElement("input");e.type="time",e.name=t,e.className="time-plugin-input unit";const i=this.timePicked[t];if(i){const t=`0${i.getHours()}`.slice(-2),n=`0${i.getMinutes()}`.slice(-2);e.value=`${t}:${n}`}return e}getCustomInput(t){const e=document.createElement("div");e.className="time-plugin-custom-block";const i=document.createElement("select");i.className="time-plugin-custom-input unit",i.name=`${t}[HH]`;const n=this.options.format12?1:0,s=this.options.format12?13:24;let o=null;!this.picker.options.autoApply&&this.timePrePicked[t]instanceof Date?o=this.timePrePicked[t].clone():this.timePicked[t]instanceof Date&&(o=this.timePicked[t].clone());for(let t=n;t<s;t+=this.options.stepHours){const e=document.createElement("option");e.value=String(t),e.text=String(t),o&&(this.options.format12?(o.getHours()%12?o.getHours()%12:12)===t&&(e.selected=!0):o.getHours()===t&&(e.selected=!0)),i.appendChild(e)}e.appendChild(i);const a=document.createElement("select");a.className="time-plugin-custom-input unit",a.name=`${t}[mm]`;for(let t=0;t<60;t+=this.options.stepMinutes){const e=document.createElement("option");e.value=`0${String(t)}`.slice(-2),e.text=`0${String(t)}`.slice(-2),o&&o.getMinutes()===t&&(e.selected=!0),a.appendChild(e)}if(e.appendChild(a),this.options.seconds){const i=document.createElement("select");i.className="time-plugin-custom-input unit",i.name=`${t}[ss]`;const n=60;for(let t=0;t<n;t+=this.options.stepSeconds){const e=document.createElement("option");e.value=`0${String(t)}`.slice(-2),e.text=`0${String(t)}`.slice(-2),o&&o.getSeconds()===t&&(e.selected=!0),i.appendChild(e)}e.appendChild(i)}if(this.options.format12){const i=document.createElement("select");i.className="time-plugin-custom-input unit",i.name=`${t}[period]`,["AM","PM"].forEach((t=>{const e=document.createElement("option");e.value=t,e.text=t,o&&"PM"===t&&o.getHours()>=12&&(e.selected=!0),i.appendChild(e)})),e.appendChild(i)}return e}handleFormat12(t,e,i){const n=e.clone();switch(t){case"AM":12===i?n.setHours(0,n.getMinutes(),n.getSeconds(),0):n.setHours(i,n.getMinutes(),n.getSeconds(),0);break;case"PM":12!==i?n.setHours(i+12,n.getMinutes(),n.getSeconds(),0):n.setHours(i,n.getMinutes(),n.getSeconds(),0)}return n}parseValues(){if(this.rangePlugin){if(this.rangePlugin.options.strict){if(this.rangePlugin.options.startDate&&this.rangePlugin.options.endDate){const e=new t(this.rangePlugin.options.startDate,this.picker.options.format),i=new t(this.rangePlugin.options.endDate,this.picker.options.format);this.timePicked.start=e.clone(),this.timePicked.end=i.clone()}}else{if(this.rangePlugin.options.startDate){const e=new t(this.rangePlugin.options.startDate,this.picker.options.format);this.timePicked.start=e.clone()}if(this.rangePlugin.options.endDate){const e=new t(this.rangePlugin.options.endDate,this.picker.options.format);this.timePicked.end=e.clone()}}if(this.rangePlugin.options.elementEnd)if(this.rangePlugin.options.strict){if(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length&&this.rangePlugin.options.elementEnd instanceof HTMLInputElement&&this.rangePlugin.options.elementEnd.value.length){const e=new t(this.picker.options.element.value,this.picker.options.format),i=new t(this.rangePlugin.options.elementEnd.value,this.picker.options.format);this.timePicked.start=e.clone(),this.timePicked.end=i.clone()}}else{if(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length){const e=new t(this.picker.options.element.value,this.picker.options.format);this.timePicked.start=e.clone()}if(this.rangePlugin.options.elementEnd instanceof HTMLInputElement&&this.rangePlugin.options.elementEnd.value.length){const e=new t(this.rangePlugin.options.elementEnd.value,this.picker.options.format);this.timePicked.start=e.clone()}}else if(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length){const[e,i]=this.picker.options.element.value.split(this.rangePlugin.options.delimiter);if(this.rangePlugin.options.strict){if(e&&i){const n=new t(e,this.picker.options.format),s=new t(i,this.picker.options.format);this.timePicked.start=n.clone(),this.timePicked.end=s.clone()}}else{if(e){const i=new t(e,this.picker.options.format);this.timePicked.start=i.clone()}if(i){const e=new t(i,this.picker.options.format);this.timePicked.start=e.clone()}}}}else{if(this.picker.options.date){const e=new t(this.picker.options.date,this.picker.options.format);this.timePicked.input=e.clone()}if(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length){const e=new t(this.picker.options.element.value,this.picker.options.format);this.timePicked.input=e.clone()}}}}class h extends o{docElement=null;rangePlugin;binds={onView:this.onView.bind(this),onKeydown:this.onKeydown.bind(this)};options={unitIndex:1,dayIndex:2};getName(){return"KbdPlugin"}onAttach(){const t=this.picker.options.element,e=t.getBoundingClientRect();if(this.docElement=document.createElement("span"),this.docElement.style.position="absolute",this.docElement.style.top=`${t.offsetTop}px`,this.docElement.style.left=t.offsetLeft+e.width-25+"px",this.docElement.attachShadow({mode:"open"}),this.options.html)this.docElement.shadowRoot.innerHTML=this.options.html;else{const t=`\n      <style>\n      button {\n        border: none;\n        background: transparent;\n        font-size: ${window.getComputedStyle(this.picker.options.element).fontSize};\n      }\n      </style>\n\n      <button>&#128197;</button>\n      `;this.docElement.shadowRoot.innerHTML=t}const i=this.docElement.shadowRoot.querySelector("button");i&&(i.addEventListener("click",(t=>{t.preventDefault(),this.picker.show({target:this.picker.options.element})}),{capture:!0}),i.addEventListener("keydown",(t=>{"Escape"===t.code&&this.picker.hide()}),{capture:!0})),this.picker.options.element.after(this.docElement),this.picker.on("view",this.binds.onView),this.picker.on("keydown",this.binds.onKeydown)}onDetach(){this.docElement&&this.docElement.isConnected&&this.docElement.remove(),this.picker.off("view",this.binds.onView),this.picker.off("keydown",this.binds.onKeydown)}onView(t){const{view:e,target:i}=t.detail;i&&"querySelector"in i&&("CalendarDay"!==e||["locked","not-available"].some((t=>i.classList.contains(t)))?[...i.querySelectorAll(".unit:not(.day)")].forEach((t=>t.tabIndex=this.options.unitIndex)):i.tabIndex=this.options.dayIndex)}onKeydown(t){switch(this.onMouseEnter(t),t.code){case"ArrowUp":case"ArrowDown":this.verticalMove(t);break;case"ArrowLeft":case"ArrowRight":this.horizontalMove(t);break;case"Enter":case"Space":this.handleEnter(t);break;case"Escape":this.picker.hide()}}findAllowableDaySibling(t,e,i){const n=Array.from(t.querySelectorAll(`.day[tabindex="${this.options.dayIndex}"]`)),s=n.indexOf(e);return n.filter(((t,e)=>i(e,s)&&t.tabIndex===this.options.dayIndex))[0]}changeMonth(t){const e={ArrowLeft:"previous",ArrowRight:"next"},i=this.picker.ui.container.querySelector(`.${e[t.code]}-button[tabindex="${this.options.unitIndex}"]`);i&&!i.parentElement.classList.contains(`no-${e[t.code]}-month`)&&(i.dispatchEvent(new Event("click",{bubbles:!0})),setTimeout((()=>{let e=null;switch(t.code){case"ArrowLeft":const t=this.picker.ui.container.querySelectorAll(`.day[tabindex="${this.options.dayIndex}"]`);e=t[t.length-1];break;case"ArrowRight":e=this.picker.ui.container.querySelector(`.day[tabindex="${this.options.dayIndex}"]`)}e&&e.focus()})))}verticalMove(t){const e=t.target;if(e.classList.contains("day")){t.preventDefault();const i=this.findAllowableDaySibling(this.picker.ui.container,e,((e,i)=>e===("ArrowUp"===t.code?i-7:i+7)));i&&i.focus()}}horizontalMove(t){const e=t.target;if(e.classList.contains("day")){t.preventDefault();const i=this.findAllowableDaySibling(this.picker.ui.container,e,((e,i)=>e===("ArrowLeft"===t.code?i-1:i+1)));i?i.focus():this.changeMonth(t)}}handleEnter(t){const e=t.target;e.classList.contains("day")&&(t.preventDefault(),e.dispatchEvent(new Event("click",{bubbles:!0})),setTimeout((()=>{if(this.rangePlugin=this.picker.PluginManager.getInstance("RangePlugin"),this.rangePlugin||!this.picker.options.autoApply){const t=this.picker.ui.container.querySelector(".day.selected");t&&setTimeout((()=>{t.focus()}))}})))}onMouseEnter(t){t.target.classList.contains("day")&&setTimeout((()=>{const t=this.picker.ui.shadowRoot.activeElement;t&&t.dispatchEvent(new Event("mouseenter",{bubbles:!0}))}))}}class d extends o{rangePlugin;lockPlugin;priority=10;binds={onView:this.onView.bind(this),onColorScheme:this.onColorScheme.bind(this)};options={dropdown:{months:!1,years:!1,minYear:1950,maxYear:null},darkMode:!0,locale:{resetButton:'<svg xmlns="http://www.w3.org/2000/svg" height="24" width="24"><path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/></svg>'}};matchMedia;getName(){return"AmpPlugin"}onAttach(){this.options.darkMode&&window&&"matchMedia"in window&&(this.matchMedia=window.matchMedia("(prefers-color-scheme: dark)"),this.matchMedia.matches&&(this.picker.ui.container.dataset.theme="dark"),this.matchMedia.addEventListener("change",this.binds.onColorScheme)),this.options.weekNumbers&&this.picker.ui.container.classList.add("week-numbers"),this.picker.on("view",this.binds.onView)}onDetach(){this.options.darkMode&&window&&"matchMedia"in window&&this.matchMedia.removeEventListener("change",this.binds.onColorScheme),this.picker.ui.container.removeAttribute("data-theme"),this.picker.ui.container.classList.remove("week-numbers"),this.picker.off("view",this.binds.onView)}onView(t){this.lockPlugin=this.picker.PluginManager.getInstance("LockPlugin"),this.rangePlugin=this.picker.PluginManager.getInstance("RangePlugin"),this.handleDropdown(t),this.handleResetButton(t),this.handleWeekNumbers(t)}onColorScheme(t){const e=t.matches?"dark":"light";this.picker.ui.container.dataset.theme=e}handleDropdown(e){const{view:i,target:n,date:s,index:o}=e.detail;if("CalendarHeader"===i){const e=n.querySelector(".month-name");if(this.options.dropdown.months){e.childNodes[0].remove();const i=document.createElement("select");i.className="month-name--select month-name--dropdown";for(let e=0;e<12;e+=1){const n=document.createElement("option"),o=new t(new Date(s.getFullYear(),e,2,0,0,0)),a=new t(new Date(s.getFullYear(),e,1,0,0,0));n.value=String(e),n.text=o.toLocaleString(this.picker.options.lang,{month:"long"}),this.lockPlugin&&(n.disabled=this.lockPlugin.options.minDate&&a.isBefore(new t(this.lockPlugin.options.minDate),"month")||this.lockPlugin.options.maxDate&&a.isAfter(new t(this.lockPlugin.options.maxDate),"month")),n.selected=a.getMonth()===s.getMonth(),i.appendChild(n)}i.addEventListener("change",(t=>{const e=t.target;this.picker.calendars[0].setDate(1),this.picker.calendars[0].setMonth(Number(e.value)),this.picker.renderAll()})),e.prepend(i)}if(this.options.dropdown.years){e.childNodes[1].remove();const i=document.createElement("select");i.className="month-name--select";const n=this.options.dropdown.minYear,o=this.options.dropdown.maxYear?this.options.dropdown.maxYear:(new Date).getFullYear();if(s.getFullYear()>o){const t=document.createElement("option");t.value=String(s.getFullYear()),t.text=String(s.getFullYear()),t.selected=!0,t.disabled=!0,i.appendChild(t)}for(let e=o;e>=n;e-=1){const n=document.createElement("option"),o=new t(new Date(e,0,1,0,0,0));n.value=String(e),n.text=String(e),this.lockPlugin&&(n.disabled=this.lockPlugin.options.minDate&&o.isBefore(new t(this.lockPlugin.options.minDate),"year")||this.lockPlugin.options.maxDate&&o.isAfter(new t(this.lockPlugin.options.maxDate),"year")),n.selected=s.getFullYear()===e,i.appendChild(n)}if(s.getFullYear()<n){const t=document.createElement("option");t.value=String(s.getFullYear()),t.text=String(s.getFullYear()),t.selected=!0,t.disabled=!0,i.appendChild(t)}if("asc"===this.options.dropdown.years){const t=Array.prototype.slice.call(i.childNodes).reverse();i.innerHTML="",t.forEach((t=>{t.innerHTML=t.value,i.appendChild(t)}))}i.addEventListener("change",(t=>{const e=t.target;this.picker.calendars[0].setFullYear(Number(e.value)),this.picker.renderAll()})),e.appendChild(i)}}}handleResetButton(t){const{view:e,target:i}=t.detail;if("CalendarHeader"===e&&this.options.resetButton){const t=document.createElement("button");t.className="reset-button unit",t.innerHTML=this.options.locale.resetButton,t.addEventListener("click",(t=>{t.preventDefault();let e=!0;"function"==typeof this.options.resetButton&&(e=this.options.resetButton.call(this)),e&&this.picker.clear()})),i.appendChild(t)}}handleWeekNumbers(e){if(this.options.weekNumbers){const{view:i,target:n}=e.detail;if("CalendarDayNames"===i){const t=document.createElement("div");t.className="wnum-header",t.innerHTML="Wk",n.prepend(t)}"CalendarDays"===i&&[...n.children].forEach(((e,i)=>{if(0===i||i%7==0){let i;if(e.classList.contains("day"))i=new t(e.dataset.time);else{const e=n.querySelector(".day");i=new t(e.dataset.time)}let s=i.getWeek(this.picker.options.firstDay);53===s&&0===i.getMonth()&&(s="53/1");const o=document.createElement("div");o.className="wnum-item",o.innerHTML=String(s),n.insertBefore(o,e)}}))}}}


/***/ }),

/***/ "./node_modules/@popperjs/core/lib/createPopper.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/createPopper.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "popperGenerator": () => (/* binding */ popperGenerator)
/* harmony export */ });
/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/debounce.js */ "./node_modules/@popperjs/core/lib/utils/debounce.js");
/* harmony import */ var _utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/validateModifiers.js */ "./node_modules/@popperjs/core/lib/utils/validateModifiers.js");
/* harmony import */ var _utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/uniqueBy.js */ "./node_modules/@popperjs/core/lib/utils/uniqueBy.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/mergeByName.js */ "./node_modules/@popperjs/core/lib/utils/mergeByName.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");














var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference.contextElement) : [],
          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (true) {
          var modifiers = (0,_utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_4__["default"])([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          (0,_utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_5__["default"])(modifiers);

          if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.options.placement) === _enums_js__WEBPACK_IMPORTED_MODULE_7__.auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = (0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__["default"])(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_9__["default"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__["default"])(popper), state.options.strategy === 'fixed'),
          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_11__["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ contains)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBoundingClientRect)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    scaleX = element.offsetWidth > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !(0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__["default"])() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getClippingRect)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getViewportRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");
/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");
/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");















function getInnerBoundingClientRect(element, strategy) {
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_1__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element, strategy)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__["default"])((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__["default"])(element) : element;

  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_11__["default"])(clippingParent, clipperElement) && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_12__["default"])(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.top, accRect.top);
    accRect.right = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.right, accRect.right);
    accRect.bottom = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.bottom, accRect.bottom);
    accRect.left = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getCompositeRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getNodeScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");









function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.width) / element.offsetWidth || 1;
  var scaleY = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);
  var offsetParentIsScaled = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent);
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(documentElement)) {
      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__["default"])(offsetParent);
    }

    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {
      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__["default"])(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getComputedStyle)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getComputedStyle(element) {
  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentElement)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return (((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentRect)
/* harmony export */ });
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");




 // Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  var y = -winScroll.scrollTop;

  if ((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(body || html).direction === 'rtl') {
    x += (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getHTMLElementScroll)
/* harmony export */ });
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLayoutRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
 // Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeName)
/* harmony export */ });
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeScroll)
/* harmony export */ });
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");




function getNodeScroll(node) {
  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node)) {
    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node);
  } else {
    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);
  }
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOffsetParent)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isTableElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");








function getTrueOffsetParent(element) {
  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__["default"])());
  var isIE = /Trident/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__["default"])());

  if (isIE && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = (0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(currentNode)) {
    currentNode = currentNode.host;
  }

  while ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(currentNode)) < 0) {
    var css = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(offsetParent) && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'html' || (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getParentNode)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");



function getParentNode(element) {
  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) // fallback

  );
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getScrollParent)
/* harmony export */ });
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) {
    return node;
  }

  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getViewportRect)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getViewportRect(element, strategy) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = (0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element),
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindow)
/* harmony export */ });
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScroll)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getWindowScroll(node) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScrollBarX)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isElement": () => (/* binding */ isElement),
/* harmony export */   "isHTMLElement": () => (/* binding */ isHTMLElement),
/* harmony export */   "isShadowRoot": () => (/* binding */ isShadowRoot)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");


function isElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isLayoutViewport)
/* harmony export */ });
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__["default"])());
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isScrollParent)
/* harmony export */ });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isTableElement)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) >= 0;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ listScrollParents)
/* harmony export */ });
/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");




/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(target)));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "afterMain": () => (/* binding */ afterMain),
/* harmony export */   "afterRead": () => (/* binding */ afterRead),
/* harmony export */   "afterWrite": () => (/* binding */ afterWrite),
/* harmony export */   "auto": () => (/* binding */ auto),
/* harmony export */   "basePlacements": () => (/* binding */ basePlacements),
/* harmony export */   "beforeMain": () => (/* binding */ beforeMain),
/* harmony export */   "beforeRead": () => (/* binding */ beforeRead),
/* harmony export */   "beforeWrite": () => (/* binding */ beforeWrite),
/* harmony export */   "bottom": () => (/* binding */ bottom),
/* harmony export */   "clippingParents": () => (/* binding */ clippingParents),
/* harmony export */   "end": () => (/* binding */ end),
/* harmony export */   "left": () => (/* binding */ left),
/* harmony export */   "main": () => (/* binding */ main),
/* harmony export */   "modifierPhases": () => (/* binding */ modifierPhases),
/* harmony export */   "placements": () => (/* binding */ placements),
/* harmony export */   "popper": () => (/* binding */ popper),
/* harmony export */   "read": () => (/* binding */ read),
/* harmony export */   "reference": () => (/* binding */ reference),
/* harmony export */   "right": () => (/* binding */ right),
/* harmony export */   "start": () => (/* binding */ start),
/* harmony export */   "top": () => (/* binding */ top),
/* harmony export */   "variationPlacements": () => (/* binding */ variationPlacements),
/* harmony export */   "viewport": () => (/* binding */ viewport),
/* harmony export */   "write": () => (/* binding */ write)
/* harmony export */ });
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");









 // eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_2__.basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(state.placement);
  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(basePlacement);
  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_2__.left, _enums_js__WEBPACK_IMPORTED_MODULE_2__.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.top : _enums_js__WEBPACK_IMPORTED_MODULE_2__.left;
  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_2__.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_7__.within)(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (true) {
    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_8__.isHTMLElement)(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "mapToStyles": () => (/* binding */ mapToStyles)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");







 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
      y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(x * dpr) / dpr || 0,
    y: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.left;
  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;
  var win = window;

  if (adaptive) {
    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper)) {
      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(popper);

      if ((0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.right) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper)) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if (true) {
    var transitionProperty = (0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.placement),
    variation: (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto) {
    return [];
  }

  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement);
  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);

    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.start;
    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.top, _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.right : _enums_js__WEBPACK_IMPORTED_MODULE_1__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    }

    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyStyles": () => (/* reexport safe */ _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "arrow": () => (/* reexport safe */ _arrow_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "computeStyles": () => (/* reexport safe */ _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "eventListeners": () => (/* reexport safe */ _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "flip": () => (/* reexport safe */ _flip_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "hide": () => (/* reexport safe */ _hide_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "offset": () => (/* reexport safe */ _offset_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "popperOffsets": () => (/* reexport safe */ _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "preventOverflow": () => (/* reexport safe */ _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"])
/* harmony export */ });
/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");










/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "distanceAndSkiddingToXY": () => (/* binding */ distanceAndSkiddingToXY)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");

 // eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");












function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);
  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement);
  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;
    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.min)(min, tetherMin) : min, offset, tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.max)(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;

    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper-lite.js":
/*!********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper-lite.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "defaultModifiers": () => (/* binding */ defaultModifiers),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "popperGenerator": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");





var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyStyles": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.applyStyles),
/* harmony export */   "arrow": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.arrow),
/* harmony export */   "computeStyles": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.computeStyles),
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "createPopperLite": () => (/* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__.createPopper),
/* harmony export */   "defaultModifiers": () => (/* binding */ defaultModifiers),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "eventListeners": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.eventListeners),
/* harmony export */   "flip": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.flip),
/* harmony export */   "hide": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.hide),
/* harmony export */   "offset": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.offset),
/* harmony export */   "popperGenerator": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator),
/* harmony export */   "popperOffsets": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.popperOffsets),
/* harmony export */   "preventOverflow": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.preventOverflow)
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");
/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");
/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");










var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeAutoPlacement)
/* harmony export */ });
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");




function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements : _options$allowedAutoP;
  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);
  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements.filter(function (placement) {
    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === variation;
  }) : _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;

    if (true) {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeOffsets)
/* harmony export */ });
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;
  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ detectOverflow)
/* harmony export */ });
/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");
/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements));
  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.elements.reference);
  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ expandToHashMap)
/* harmony export */ });
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/format.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/format.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ format)
/* harmony export */ });
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAltAxis)
/* harmony export */ });
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBasePlacement)
/* harmony export */ });

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getFreshSideObject)
/* harmony export */ });
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMainAxisFromPlacement)
/* harmony export */ });
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositePlacement)
/* harmony export */ });
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositeVariationPlacement)
/* harmony export */ });
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVariation)
/* harmony export */ });
function getVariation(placement) {
  return placement.split('-')[1];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/math.js":
/*!*******************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/math.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "round": () => (/* binding */ round)
/* harmony export */ });
var max = Math.max;
var min = Math.min;
var round = Math.round;

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeByName)
/* harmony export */ });
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergePaddingObject)
/* harmony export */ });
/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");

function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(), paddingObject);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ orderModifiers)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rectToClientRect)
/* harmony export */ });
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/uniqueBy.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/uniqueBy.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ uniqueBy)
/* harmony export */ });
function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/userAgent.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/userAgent.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUAString)
/* harmony export */ });
function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/validateModifiers.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/validateModifiers.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ validateModifiers)
/* harmony export */ });
/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format.js */ "./node_modules/@popperjs/core/lib/utils/format.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");


var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
    .filter(function (value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

          break;

        case 'phase':
          if (_enums_js__WEBPACK_IMPORTED_MODULE_1__.modifierPhases.indexOf(modifier.phase) < 0) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + _enums_js__WEBPACK_IMPORTED_MODULE_1__.modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (modifier.effect != null && typeof modifier.effect !== 'function') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "within": () => (/* binding */ within),
/* harmony export */   "withinMaxClamp": () => (/* binding */ withinMaxClamp)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");

function within(min, value, max) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(min, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/Datepicker.js":
/*!***********************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/Datepicker.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Datepicker)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/date.js */ "./node_modules/flowbite-datepicker/js/lib/date.js");
/* harmony import */ var _lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/date-format.js */ "./node_modules/flowbite-datepicker/js/lib/date-format.js");
/* harmony import */ var _lib_event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/event.js */ "./node_modules/flowbite-datepicker/js/lib/event.js");
/* harmony import */ var _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./i18n/base-locales.js */ "./node_modules/flowbite-datepicker/js/i18n/base-locales.js");
/* harmony import */ var _options_defaultOptions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./options/defaultOptions.js */ "./node_modules/flowbite-datepicker/js/options/defaultOptions.js");
/* harmony import */ var _options_processOptions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./options/processOptions.js */ "./node_modules/flowbite-datepicker/js/options/processOptions.js");
/* harmony import */ var _picker_Picker_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./picker/Picker.js */ "./node_modules/flowbite-datepicker/js/picker/Picker.js");
/* harmony import */ var _events_functions_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./events/functions.js */ "./node_modules/flowbite-datepicker/js/events/functions.js");
/* harmony import */ var _events_inputFieldListeners_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./events/inputFieldListeners.js */ "./node_modules/flowbite-datepicker/js/events/inputFieldListeners.js");
/* harmony import */ var _events_otherListeners_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./events/otherListeners.js */ "./node_modules/flowbite-datepicker/js/events/otherListeners.js");












function stringifyDates(dates, config) {
  return dates
    .map(dt => (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.formatDate)(dt, config.format, config.locale))
    .join(config.dateDelimiter);
}

// parse input dates and create an array of time values for selection
// returns undefined if there are no valid dates in inputDates
// when origDates (current selection) is passed, the function works to mix
// the input dates into the current selection
function processInputDates(datepicker, inputDates, clear = false) {
  const {config, dates: origDates, rangepicker} = datepicker;
  if (inputDates.length === 0) {
    // empty input is considered valid unless origiDates is passed
    return clear ? [] : undefined;
  }

  const rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];
  let newDates = inputDates.reduce((dates, dt) => {
    let date = (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(dt, config.format, config.locale);
    if (date === undefined) {
      return dates;
    }
    if (config.pickLevel > 0) {
      // adjust to 1st of the month/Jan 1st of the year
      // or to the last day of the monh/Dec 31st of the year if the datepicker
      // is the range-end picker of a rangepicker
      const dt = new Date(date);
      if (config.pickLevel === 1) {
        date = rangeEnd
          ? dt.setMonth(dt.getMonth() + 1, 0)
          : dt.setDate(1);
      } else {
        date = rangeEnd
          ? dt.setFullYear(dt.getFullYear() + 1, 0, 0)
          : dt.setMonth(0, 1);
      }
    }
    if (
      (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInRange)(date, config.minDate, config.maxDate)
      && !dates.includes(date)
      && !config.datesDisabled.includes(date)
      && !config.daysOfWeekDisabled.includes(new Date(date).getDay())
    ) {
      dates.push(date);
    }
    return dates;
  }, []);
  if (newDates.length === 0) {
    return;
  }
  if (config.multidate && !clear) {
    // get the synmetric difference between origDates and newDates
    newDates = newDates.reduce((dates, date) => {
      if (!origDates.includes(date)) {
        dates.push(date);
      }
      return dates;
    }, origDates.filter(date => !newDates.includes(date)));
  }
  // do length check always because user can input multiple dates regardless of the mode
  return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates
    ? newDates.slice(config.maxNumberOfDates * -1)
    : newDates;
}

// refresh the UI elements
// modes: 1: input only, 2, picker only, 3 both
function refreshUI(datepicker, mode = 3, quickRender = true) {
  const {config, picker, inputField} = datepicker;
  if (mode & 2) {
    const newView = picker.active ? config.pickLevel : config.startView;
    picker.update().changeView(newView).render(quickRender);
  }
  if (mode & 1 && inputField) {
    inputField.value = stringifyDates(datepicker.dates, config);
  }
}

function setDate(datepicker, inputDates, options) {
  let {clear, render, autohide} = options;
  if (render === undefined) {
    render = true;
  }
  if (!render) {
    autohide = false;
  } else if (autohide === undefined) {
    autohide = datepicker.config.autohide;
  }

  const newDates = processInputDates(datepicker, inputDates, clear);
  if (!newDates) {
    return;
  }
  if (newDates.toString() !== datepicker.dates.toString()) {
    datepicker.dates = newDates;
    refreshUI(datepicker, render ? 3 : 1);
    (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_8__.triggerDatepickerEvent)(datepicker, 'changeDate');
  } else {
    refreshUI(datepicker, 1);
  }
  if (autohide) {
    datepicker.hide();
  }
}

/**
 * Class representing a date picker
 */
class Datepicker {
  /**
   * Create a date picker
   * @param  {Element} element - element to bind a date picker
   * @param  {Object} [options] - config options
   * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the
   * date picker belongs to. Use this only when creating date picker as a part
   * of date range picker
   */
  constructor(element, options = {}, rangepicker = undefined) {
    element.datepicker = this;
    this.element = element;

    // set up config
    const config = this.config = Object.assign({
      buttonClass: (options.buttonClass && String(options.buttonClass)) || 'button',
      container: document.body,
      defaultViewDate: (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.today)(),
      maxDate: undefined,
      minDate: undefined,
    }, (0,_options_processOptions_js__WEBPACK_IMPORTED_MODULE_6__["default"])(_options_defaultOptions_js__WEBPACK_IMPORTED_MODULE_5__["default"], this));
    this._options = options;
    Object.assign(config, (0,_options_processOptions_js__WEBPACK_IMPORTED_MODULE_6__["default"])(options, this));

    // configure by type
    const inline = this.inline = element.tagName !== 'INPUT';
    let inputField;
    let initialDates;

    if (inline) {
      config.container = element;
      initialDates = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.stringToArray)(element.dataset.date, config.dateDelimiter);
      delete element.dataset.date;
    } else {
      const container = options.container ? document.querySelector(options.container) : null;
      if (container) {
        config.container = container;
      }
      inputField = this.inputField = element;
      inputField.classList.add('datepicker-input');
      initialDates = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.stringToArray)(inputField.value, config.dateDelimiter);
    }
    if (rangepicker) {
      // check validiry
      const index = rangepicker.inputs.indexOf(inputField);
      const datepickers = rangepicker.datepickers;
      if (index < 0 || index > 1 || !Array.isArray(datepickers)) {
        throw Error('Invalid rangepicker object.');
      }
      // attach itaelf to the rangepicker here so that processInputDates() can
      // determine if this is the range-end picker of the rangepicker while
      // setting inital values when pickLevel > 0
      datepickers[index] = this;
      // add getter for rangepicker
      Object.defineProperty(this, 'rangepicker', {
        get() {
          return rangepicker;
        },
      });
    }

    // set initial dates
    this.dates = [];
    // process initial value
    const inputDateValues = processInputDates(this, initialDates);
    if (inputDateValues && inputDateValues.length > 0) {
      this.dates = inputDateValues;
    }
    if (inputField) {
      inputField.value = stringifyDates(this.dates, config);
    }

    const picker = this.picker = new _picker_Picker_js__WEBPACK_IMPORTED_MODULE_7__["default"](this);

    if (inline) {
      this.show();
    } else {
      // set up event listeners in other modes
      const onMousedownDocument = _events_otherListeners_js__WEBPACK_IMPORTED_MODULE_10__.onClickOutside.bind(null, this);
      const listeners = [
        [inputField, 'keydown', _events_inputFieldListeners_js__WEBPACK_IMPORTED_MODULE_9__.onKeydown.bind(null, this)],
        [inputField, 'focus', _events_inputFieldListeners_js__WEBPACK_IMPORTED_MODULE_9__.onFocus.bind(null, this)],
        [inputField, 'mousedown', _events_inputFieldListeners_js__WEBPACK_IMPORTED_MODULE_9__.onMousedown.bind(null, this)],
        [inputField, 'click', _events_inputFieldListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickInput.bind(null, this)],
        [inputField, 'paste', _events_inputFieldListeners_js__WEBPACK_IMPORTED_MODULE_9__.onPaste.bind(null, this)],
        [document, 'mousedown', onMousedownDocument],
        [document, 'touchstart', onMousedownDocument],
        [window, 'resize', picker.place.bind(picker)]
      ];
      (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_3__.registerListeners)(this, listeners);
    }
  }

  /**
   * Format Date object or time value in given format and language
   * @param  {Date|Number} date - date or time value to format
   * @param  {String|Object} format - format string or object that contains
   * toDisplay() custom formatter, whose signature is
   * - args:
   *   - date: {Date} - Date instance of the date passed to the method
   *   - format: {Object} - the format object passed to the method
   *   - locale: {Object} - locale for the language specified by `lang`
   * - return:
   *     {String} formatted date
   * @param  {String} [lang=en] - language code for the locale to use
   * @return {String} formatted date
   */
  static formatDate(date, format, lang) {
    return (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.formatDate)(date, format, lang && _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_4__.locales[lang] || _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_4__.locales.en);
  }

  /**
   * Parse date string
   * @param  {String|Date|Number} dateStr - date string, Date object or time
   * value to parse
   * @param  {String|Object} format - format string or object that contains
   * toValue() custom parser, whose signature is
   * - args:
   *   - dateStr: {String|Date|Number} - the dateStr passed to the method
   *   - format: {Object} - the format object passed to the method
   *   - locale: {Object} - locale for the language specified by `lang`
   * - return:
   *     {Date|Number} parsed date or its time value
   * @param  {String} [lang=en] - language code for the locale to use
   * @return {Number} time value of parsed date
   */
  static parseDate(dateStr, format, lang) {
    return (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(dateStr, format, lang && _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_4__.locales[lang] || _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_4__.locales.en);
  }

  /**
   * @type {Object} - Installed locales in `[languageCode]: localeObject` format
   * en`:_English (US)_ is pre-installed.
   */
  static get locales() {
    return _i18n_base_locales_js__WEBPACK_IMPORTED_MODULE_4__.locales;
  }

  /**
   * @type {Boolean} - Whether the picker element is shown. `true` whne shown
   */
  get active() {
    return !!(this.picker && this.picker.active);
  }

  /**
   * @type {HTMLDivElement} - DOM object of picker element
   */
  get pickerElement() {
    return this.picker ? this.picker.element : undefined;
  }

  /**
   * Set new values to the config options
   * @param {Object} options - config options to update
   */
  setOptions(options) {
    const picker = this.picker;
    const newOptions = (0,_options_processOptions_js__WEBPACK_IMPORTED_MODULE_6__["default"])(options, this);
    Object.assign(this._options, options);
    Object.assign(this.config, newOptions);
    picker.setOptions(newOptions);

    refreshUI(this, 3);
  }

  /**
   * Show the picker element
   */
  show() {
    if (this.inputField) {
      if (this.inputField.disabled) {
        return;
      }
      if (this.inputField !== document.activeElement) {
        this._showing = true;
        this.inputField.focus();
        delete this._showing;
      }
    }
    this.picker.show();
  }

  /**
   * Hide the picker element
   * Not available on inline picker
   */
  hide() {
    if (this.inline) {
      return;
    }
    this.picker.hide();
    this.picker.update().changeView(this.config.startView).render();
  }

  /**
   * Destroy the Datepicker instance
   * @return {Detepicker} - the instance destroyed
   */
  destroy() {
    this.hide();
    (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_3__.unregisterListeners)(this);
    this.picker.detach();
    if (!this.inline) {
      this.inputField.classList.remove('datepicker-input');
    }
    delete this.element.datepicker;
    return this;
  }

  /**
   * Get the selected date(s)
   *
   * The method returns a Date object of selected date by default, and returns
   * an array of selected dates in multidate mode. If format string is passed,
   * it returns date string(s) formatted in given format.
   *
   * @param  {String} [format] - Format string to stringify the date(s)
   * @return {Date|String|Date[]|String[]} - selected date(s), or if none is
   * selected, empty array in multidate mode and untitled in sigledate mode
   */
  getDate(format = undefined) {
    const callback = format
      ? date => (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.formatDate)(date, format, this.config.locale)
      : date => new Date(date);

    if (this.config.multidate) {
      return this.dates.map(callback);
    }
    if (this.dates.length > 0) {
      return callback(this.dates[0]);
    }
  }

  /**
   * Set selected date(s)
   *
   * In multidate mode, you can pass multiple dates as a series of arguments
   * or an array. (Since each date is parsed individually, the type of the
   * dates doesn't have to be the same.)
   * The given dates are used to toggle the select status of each date. The
   * number of selected dates is kept from exceeding the length set to
   * maxNumberOfDates.
   *
   * With clear: true option, the method can be used to clear the selection
   * and to replace the selection instead of toggling in multidate mode.
   * If the option is passed with no date arguments or an empty dates array,
   * it works as "clear" (clear the selection then set nothing), and if the
   * option is passed with new dates to select, it works as "replace" (clear
   * the selection then set the given dates)
   *
   * When render: false option is used, the method omits re-rendering the
   * picker element. In this case, you need to call refresh() method later in
   * order for the picker element to reflect the changes. The input field is
   * refreshed always regardless of this option.
   *
   * When invalid (unparsable, repeated, disabled or out-of-range) dates are
   * passed, the method ignores them and applies only valid ones. In the case
   * that all the given dates are invalid, which is distinguished from passing
   * no dates, the method considers it as an error and leaves the selection
   * untouched.
   *
   * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date
   * objects, time values or mix of those for new selection
   * @param {Object} [options] - function options
   * - clear: {boolean} - Whether to clear the existing selection
   *     defualt: false
   * - render: {boolean} - Whether to re-render the picker element
   *     default: true
   * - autohide: {boolean} - Whether to hide the picker element after re-render
   *     Ignored when used with render: false
   *     default: config.autohide
   */
  setDate(...args) {
    const dates = [...args];
    const opts = {};
    const lastArg = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.lastItemOf)(args);
    if (
      typeof lastArg === 'object'
      && !Array.isArray(lastArg)
      && !(lastArg instanceof Date)
      && lastArg
    ) {
      Object.assign(opts, dates.pop());
    }

    const inputDates = Array.isArray(dates[0]) ? dates[0] : dates;
    setDate(this, inputDates, opts);
  }

  /**
   * Update the selected date(s) with input field's value
   * Not available on inline picker
   *
   * The input field will be refreshed with properly formatted date string.
   *
   * @param  {Object} [options] - function options
   * - autohide: {boolean} - whether to hide the picker element after refresh
   *     default: false
   */
  update(options = undefined) {
    if (this.inline) {
      return;
    }

    const opts = {clear: true, autohide: !!(options && options.autohide)};
    const inputDates = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.stringToArray)(this.inputField.value, this.config.dateDelimiter);
    setDate(this, inputDates, opts);
  }

  /**
   * Refresh the picker element and the associated input field
   * @param {String} [target] - target item when refreshing one item only
   * 'picker' or 'input'
   * @param {Boolean} [forceRender] - whether to re-render the picker element
   * regardless of its state instead of optimized refresh
   */
  refresh(target = undefined, forceRender = false) {
    if (target && typeof target !== 'string') {
      forceRender = target;
      target = undefined;
    }

    let mode;
    if (target === 'picker') {
      mode = 2;
    } else if (target === 'input') {
      mode = 1;
    } else {
      mode = 3;
    }
    refreshUI(this, mode, !forceRender);
  }

  /**
   * Enter edit mode
   * Not available on inline picker or when the picker element is hidden
   */
  enterEditMode() {
    if (this.inline || !this.picker.active || this.editMode) {
      return;
    }
    this.editMode = true;
    this.inputField.classList.add('in-edit', 'border-blue-700');
  }

  /**
   * Exit from edit mode
   * Not available on inline picker
   * @param  {Object} [options] - function options
   * - update: {boolean} - whether to call update() after exiting
   *     If false, input field is revert to the existing selection
   *     default: false
   */
  exitEditMode(options = undefined) {
    if (this.inline || !this.editMode) {
      return;
    }
    const opts = Object.assign({update: false}, options);
    delete this.editMode;
    this.inputField.classList.remove('in-edit', 'border-blue-700');
    if (opts.update) {
      this.update(opts);
    }
  }
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/events/functions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/events/functions.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "goToPrevOrNext": () => (/* binding */ goToPrevOrNext),
/* harmony export */   "switchView": () => (/* binding */ switchView),
/* harmony export */   "triggerDatepickerEvent": () => (/* binding */ triggerDatepickerEvent),
/* harmony export */   "unfocus": () => (/* binding */ unfocus)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/date.js */ "./node_modules/flowbite-datepicker/js/lib/date.js");



function triggerDatepickerEvent(datepicker, type) {
  const detail = {
    date: datepicker.getDate(),
    viewDate: new Date(datepicker.picker.viewDate),
    viewId: datepicker.picker.currentView.id,
    datepicker,
  };
  datepicker.element.dispatchEvent(new CustomEvent(type, {detail}));
}

// direction: -1 (to previous), 1 (to next)
function goToPrevOrNext(datepicker, direction) {
  const {minDate, maxDate} = datepicker.config;
  const {currentView, viewDate} = datepicker.picker;
  let newViewDate;
  switch (currentView.id) {
    case 0:
      newViewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addMonths)(viewDate, direction);
      break;
    case 1:
      newViewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addYears)(viewDate, direction);
      break;
    default:
      newViewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addYears)(viewDate, direction * currentView.navStep);
  }
  newViewDate = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.limitToRange)(newViewDate, minDate, maxDate);
  datepicker.picker.changeFocus(newViewDate).render();
}

function switchView(datepicker) {
  const viewId = datepicker.picker.currentView.id;
  if (viewId === datepicker.config.maxView) {
    return;
  }
  datepicker.picker.changeView(viewId + 1).render();
}

function unfocus(datepicker) {
  if (datepicker.config.updateOnBlur) {
    datepicker.update({autohide: true});
  } else {
    datepicker.refresh('input');
    datepicker.hide();
  }
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/events/inputFieldListeners.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/events/inputFieldListeners.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "onClickInput": () => (/* binding */ onClickInput),
/* harmony export */   "onFocus": () => (/* binding */ onFocus),
/* harmony export */   "onKeydown": () => (/* binding */ onKeydown),
/* harmony export */   "onMousedown": () => (/* binding */ onMousedown),
/* harmony export */   "onPaste": () => (/* binding */ onPaste)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/date.js */ "./node_modules/flowbite-datepicker/js/lib/date.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions.js */ "./node_modules/flowbite-datepicker/js/events/functions.js");




// Find the closest date that doesn't meet the condition for unavailable date
// Returns undefined if no available date is found
// addFn: function to calculate the next date
//   - args: time value, amount
// increase: amount to pass to addFn
// testFn: function to test the unavailablity of the date
//   - args: time value; retun: true if unavailable
function findNextAvailableOne(date, addFn, increase, testFn, min, max) {
  if (!(0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInRange)(date, min, max)) {
    return;
  }
  if (testFn(date)) {
    const newDate = addFn(date, increase);
    return findNextAvailableOne(newDate, addFn, increase, testFn, min, max);
  }
  return date;
}

// direction: -1 (left/up), 1 (right/down)
// vertical: true for up/down, false for left/right
function moveByArrowKey(datepicker, ev, direction, vertical) {
  const picker = datepicker.picker;
  const currentView = picker.currentView;
  const step = currentView.step || 1;
  let viewDate = picker.viewDate;
  let addFn;
  let testFn;
  switch (currentView.id) {
    case 0:
      if (vertical) {
        viewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addDays)(viewDate, direction * 7);
      } else if (ev.ctrlKey || ev.metaKey) {
        viewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addYears)(viewDate, direction);
      } else {
        viewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addDays)(viewDate, direction);
      }
      addFn = _lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addDays;
      testFn = (date) => currentView.disabled.includes(date);
      break;
    case 1:
      viewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addMonths)(viewDate, vertical ? direction * 4 : direction);
      addFn = _lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addMonths;
      testFn = (date) => {
        const dt = new Date(date);
        const {year, disabled} = currentView;
        return dt.getFullYear() === year && disabled.includes(dt.getMonth());
      };
      break;
    default:
      viewDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addYears)(viewDate, direction * (vertical ? 4 : 1) * step);
      addFn = _lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addYears;
      testFn = date => currentView.disabled.includes((0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(date, step));
  }
  viewDate = findNextAvailableOne(
    viewDate,
    addFn,
    direction < 0 ? -step : step,
    testFn,
    currentView.minDate,
    currentView.maxDate
  );
  if (viewDate !== undefined) {
    picker.changeFocus(viewDate).render();
  }
}

function onKeydown(datepicker, ev) {
  if (ev.key === 'Tab') {
    (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.unfocus)(datepicker);
    return;
  }

  const picker = datepicker.picker;
  const {id, isMinView} = picker.currentView;
  if (!picker.active) {
    switch (ev.key) {
      case 'ArrowDown':
      case 'Escape':
        picker.show();
        break;
      case 'Enter':
        datepicker.update();
        break;
      default:
        return;
    }
  } else if (datepicker.editMode) {
    switch (ev.key) {
      case 'Escape':
        picker.hide();
        break;
      case 'Enter':
        datepicker.exitEditMode({update: true, autohide: datepicker.config.autohide});
        break;
      default:
        return;
    }
  } else {
    switch (ev.key) {
      case 'Escape':
        picker.hide();
        break;
      case 'ArrowLeft':
        if (ev.ctrlKey || ev.metaKey) {
          (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.goToPrevOrNext)(datepicker, -1);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, -1, false);
        }
        break;
      case 'ArrowRight':
        if (ev.ctrlKey || ev.metaKey) {
          (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.goToPrevOrNext)(datepicker, 1);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, 1, false);
        }
        break;
      case 'ArrowUp':
        if (ev.ctrlKey || ev.metaKey) {
          (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.switchView)(datepicker);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, -1, true);
        }
        break;
      case 'ArrowDown':
        if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
          datepicker.enterEditMode();
          return;
        }
        moveByArrowKey(datepicker, ev, 1, true);
        break;
      case 'Enter':
        if (isMinView) {
          datepicker.setDate(picker.viewDate);
        } else {
          picker.changeView(id - 1).render();
        }
        break;
      case 'Backspace':
      case 'Delete':
        datepicker.enterEditMode();
        return;
      default:
        if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {
          datepicker.enterEditMode();
        }
        return;
    }
  }
  ev.preventDefault();
  ev.stopPropagation();
}

function onFocus(datepicker) {
  if (datepicker.config.showOnFocus && !datepicker._showing) {
    datepicker.show();
  }
}

// for the prevention for entering edit mode while getting focus on click
function onMousedown(datepicker, ev) {
  const el = ev.target;
  if (datepicker.picker.active || datepicker.config.showOnClick) {
    el._active = el === document.activeElement;
    el._clicking = setTimeout(() => {
      delete el._active;
      delete el._clicking;
    }, 2000);
  }
}

function onClickInput(datepicker, ev) {
  const el = ev.target;
  if (!el._clicking) {
    return;
  }
  clearTimeout(el._clicking);
  delete el._clicking;

  if (el._active) {
    datepicker.enterEditMode();
  }
  delete el._active;

  if (datepicker.config.showOnClick) {
    datepicker.show();
  }
}

function onPaste(datepicker, ev) {
  if (ev.clipboardData.types.includes('text/plain')) {
    datepicker.enterEditMode();
  }
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/events/otherListeners.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/events/otherListeners.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "onClickOutside": () => (/* binding */ onClickOutside)
/* harmony export */ });
/* harmony import */ var _lib_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/event.js */ "./node_modules/flowbite-datepicker/js/lib/event.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions.js */ "./node_modules/flowbite-datepicker/js/events/functions.js");



// for the `document` to delegate the events from outside the picker/input field
function onClickOutside(datepicker, ev) {
  const element = datepicker.element;
  if (element !== document.activeElement) {
    return;
  }
  const pickerElem = datepicker.picker.element;
  if ((0,_lib_event_js__WEBPACK_IMPORTED_MODULE_0__.findElementInEventPath)(ev, el => el === element || el === pickerElem)) {
    return;
  }
  (0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.unfocus)(datepicker);
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/events/pickerListeners.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/events/pickerListeners.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "onClickClearBtn": () => (/* binding */ onClickClearBtn),
/* harmony export */   "onClickNextBtn": () => (/* binding */ onClickNextBtn),
/* harmony export */   "onClickPicker": () => (/* binding */ onClickPicker),
/* harmony export */   "onClickPrevBtn": () => (/* binding */ onClickPrevBtn),
/* harmony export */   "onClickTodayBtn": () => (/* binding */ onClickTodayBtn),
/* harmony export */   "onClickView": () => (/* binding */ onClickView),
/* harmony export */   "onClickViewSwitch": () => (/* binding */ onClickViewSwitch)
/* harmony export */ });
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/date.js */ "./node_modules/flowbite-datepicker/js/lib/date.js");
/* harmony import */ var _lib_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/event.js */ "./node_modules/flowbite-datepicker/js/lib/event.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions.js */ "./node_modules/flowbite-datepicker/js/events/functions.js");




function goToSelectedMonthOrYear(datepicker, selection) {
  const picker = datepicker.picker;
  const viewDate = new Date(picker.viewDate);
  const viewId = picker.currentView.id;
  const newDate = viewId === 1
    ? (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.addMonths)(viewDate, selection - viewDate.getMonth())
    : (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.addYears)(viewDate, selection - viewDate.getFullYear());

  picker.changeFocus(newDate).changeView(viewId - 1).render();
}

function onClickTodayBtn(datepicker) {
  const picker = datepicker.picker;
  const currentDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_0__.today)();
  if (datepicker.config.todayBtnMode === 1) {
    if (datepicker.config.autohide) {
      datepicker.setDate(currentDate);
      return;
    }
    datepicker.setDate(currentDate, {render: false});
    picker.update();
  }
  if (picker.viewDate !== currentDate) {
    picker.changeFocus(currentDate);
  }
  picker.changeView(0).render();
}

function onClickClearBtn(datepicker) {
  datepicker.setDate({clear: true});
}

function onClickViewSwitch(datepicker) {
  (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.switchView)(datepicker);
}

function onClickPrevBtn(datepicker) {
  (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.goToPrevOrNext)(datepicker, -1);
}

function onClickNextBtn(datepicker) {
  (0,_functions_js__WEBPACK_IMPORTED_MODULE_2__.goToPrevOrNext)(datepicker, 1);
}

// For the picker's main block to delegete the events from `datepicker-cell`s
function onClickView(datepicker, ev) {
  const target = (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_1__.findElementInEventPath)(ev, '.datepicker-cell');
  if (!target || target.classList.contains('disabled')) {
    return;
  }

  const {id, isMinView} = datepicker.picker.currentView;
  if (isMinView) {
    datepicker.setDate(Number(target.dataset.date));
  } else if (id === 1) {
    goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));
  } else {
    goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));
  }
}

function onClickPicker(datepicker) {
  if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) {
    datepicker.inputField.focus();
  }
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/i18n/base-locales.js":
/*!******************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/i18n/base-locales.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "locales": () => (/* binding */ locales)
/* harmony export */ });
// default locales
const locales = {
  en: {
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    today: "Today",
    clear: "Clear",
    titleFormat: "MM y"
  }
};


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/lib/date-format.js":
/*!****************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/lib/date-format.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "formatDate": () => (/* binding */ formatDate),
/* harmony export */   "parseDate": () => (/* binding */ parseDate),
/* harmony export */   "reFormatTokens": () => (/* binding */ reFormatTokens),
/* harmony export */   "reNonDateParts": () => (/* binding */ reNonDateParts)
/* harmony export */ });
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./date.js */ "./node_modules/flowbite-datepicker/js/lib/date.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");



// pattern for format parts
const reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
// pattern for non date parts
const reNonDateParts = /[\s!-/:-@[-`{-~]+/;
// cache for persed formats
let knownFormats = {};
// parse funtions for date parts
const parseFns = {
  y(date, year) {
    return new Date(date).setFullYear(parseInt(year, 10));
  },
  m(date, month, locale) {
    const newDate = new Date(date);
    let monthIndex = parseInt(month, 10) - 1;

    if (isNaN(monthIndex)) {
      if (!month) {
        return NaN;
      }

      const monthName = month.toLowerCase();
      const compareNames = name => name.toLowerCase().startsWith(monthName);
      // compare with both short and full names because some locales have periods
      // in the short names (not equal to the first X letters of the full names)
      monthIndex = locale.monthsShort.findIndex(compareNames);
      if (monthIndex < 0) {
        monthIndex = locale.months.findIndex(compareNames);
      }
      if (monthIndex < 0) {
        return NaN;
      }
    }

    newDate.setMonth(monthIndex);
    return newDate.getMonth() !== normalizeMonth(monthIndex)
      ? newDate.setDate(0)
      : newDate.getTime();
  },
  d(date, day) {
    return new Date(date).setDate(parseInt(day, 10));
  },
};
// format functions for date parts
const formatFns = {
  d(date) {
    return date.getDate();
  },
  dd(date) {
    return padZero(date.getDate(), 2);
  },
  D(date, locale) {
    return locale.daysShort[date.getDay()];
  },
  DD(date, locale) {
    return locale.days[date.getDay()];
  },
  m(date) {
    return date.getMonth() + 1;
  },
  mm(date) {
    return padZero(date.getMonth() + 1, 2);
  },
  M(date, locale) {
    return locale.monthsShort[date.getMonth()];
  },
  MM(date, locale) {
    return locale.months[date.getMonth()];
  },
  y(date) {
    return date.getFullYear();
  },
  yy(date) {
    return padZero(date.getFullYear(), 2).slice(-2);
  },
  yyyy(date) {
    return padZero(date.getFullYear(), 4);
  },
};

// get month index in normal range (0 - 11) from any number
function normalizeMonth(monthIndex) {
  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);
}

function padZero(num, length) {
  return num.toString().padStart(length, '0');
}

function parseFormatString(format) {
  if (typeof format !== 'string') {
    throw new Error("Invalid date format.");
  }
  if (format in knownFormats) {
    return knownFormats[format];
  }

  // sprit the format string into parts and seprators
  const separators = format.split(reFormatTokens);
  const parts = format.match(new RegExp(reFormatTokens, 'g'));
  if (separators.length === 0 || !parts) {
    throw new Error("Invalid date format.");
  }

  // collect format functions used in the format
  const partFormatters = parts.map(token => formatFns[token]);

  // collect parse function keys used in the format
  // iterate over parseFns' keys in order to keep the order of the keys.
  const partParserKeys = Object.keys(parseFns).reduce((keys, key) => {
    const token = parts.find(part => part[0] !== 'D' && part[0].toLowerCase() === key);
    if (token) {
      keys.push(key);
    }
    return keys;
  }, []);

  return knownFormats[format] = {
    parser(dateStr, locale) {
      const dateParts = dateStr.split(reNonDateParts).reduce((dtParts, part, index) => {
        if (part.length > 0 && parts[index]) {
          const token = parts[index][0];
          if (token === 'M') {
            dtParts.m = part;
          } else if (token !== 'D') {
            dtParts[token] = part;
          }
        }
        return dtParts;
      }, {});

      // iterate over partParserkeys so that the parsing is made in the oder
      // of year, month and day to prevent the day parser from correcting last
      // day of month wrongly
      return partParserKeys.reduce((origDate, key) => {
        const newDate = parseFns[key](origDate, dateParts[key], locale);
        // ingnore the part failed to parse
        return isNaN(newDate) ? origDate : newDate;
      }, (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.today)());
    },
    formatter(date, locale) {
      let dateStr = partFormatters.reduce((str, fn, index) => {
        return str += `${separators[index]}${fn(date, locale)}`;
      }, '');
      // separators' length is always parts' length + 1,
      return dateStr += (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.lastItemOf)(separators);
    },
  };
}

function parseDate(dateStr, format, locale) {
  if (dateStr instanceof Date || typeof dateStr === 'number') {
    const date = (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.stripTime)(dateStr);
    return isNaN(date) ? undefined : date;
  }
  if (!dateStr) {
    return undefined;
  }
  if (dateStr === 'today') {
    return (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.today)();
  }

  if (format && format.toValue) {
    const date = format.toValue(dateStr, format, locale);
    return isNaN(date) ? undefined : (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.stripTime)(date);
  }

  return parseFormatString(format).parser(dateStr, locale);
}

function formatDate(date, format, locale) {
  if (isNaN(date) || (!date && date !== 0)) {
    return '';
  }

  const dateObj = typeof date === 'number' ? new Date(date) : date;

  if (format.toDisplay) {
    return format.toDisplay(dateObj, format, locale);
  }

  return parseFormatString(format).formatter(dateObj, locale);
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/lib/date.js":
/*!*********************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/lib/date.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addDays": () => (/* binding */ addDays),
/* harmony export */   "addMonths": () => (/* binding */ addMonths),
/* harmony export */   "addWeeks": () => (/* binding */ addWeeks),
/* harmony export */   "addYears": () => (/* binding */ addYears),
/* harmony export */   "dateValue": () => (/* binding */ dateValue),
/* harmony export */   "dayOfTheWeekOf": () => (/* binding */ dayOfTheWeekOf),
/* harmony export */   "getWeek": () => (/* binding */ getWeek),
/* harmony export */   "startOfYearPeriod": () => (/* binding */ startOfYearPeriod),
/* harmony export */   "stripTime": () => (/* binding */ stripTime),
/* harmony export */   "today": () => (/* binding */ today)
/* harmony export */ });
function stripTime(timeValue) {
  return new Date(timeValue).setHours(0, 0, 0, 0);
}

function today() {
  return new Date().setHours(0, 0, 0, 0);
}

// Get the time value of the start of given date or year, month and day
function dateValue(...args) {
  switch (args.length) {
    case 0:
      return today();
    case 1:
      return stripTime(args[0]);
  }

  // use setFullYear() to keep 2-digit year from being mapped to 1900-1999
  const newDate = new Date(0);
  newDate.setFullYear(...args);
  return newDate.setHours(0, 0, 0, 0);
}

function addDays(date, amount) {
  const newDate = new Date(date);
  return newDate.setDate(newDate.getDate() + amount);
}

function addWeeks(date, amount) {
  return addDays(date, amount * 7);
}

function addMonths(date, amount) {
  // If the day of the date is not in the new month, the last day of the new
  // month will be returned. e.g. Jan 31 + 1 month  Feb 28 (not Mar 03)
  const newDate = new Date(date);
  const monthsToSet = newDate.getMonth() + amount;
  let expectedMonth = monthsToSet % 12;
  if (expectedMonth < 0) {
    expectedMonth += 12;
  }

  const time = newDate.setMonth(monthsToSet);
  return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;
}

function addYears(date, amount) {
  // If the date is Feb 29 and the new year is not a leap year, Feb 28 of the
  // new year will be returned.
  const newDate = new Date(date);
  const expectedMonth = newDate.getMonth();
  const time = newDate.setFullYear(newDate.getFullYear() + amount);
  return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;
}

// Calculate the distance bettwen 2 days of the week
function dayDiff(day, from) {
  return (day - from + 7) % 7;
}

// Get the date of the specified day of the week of given base date
function dayOfTheWeekOf(baseDate, dayOfWeek, weekStart = 0) {
  const baseDay = new Date(baseDate).getDay();
  return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));
}

// Get the ISO week of a date
function getWeek(date) {
  // start of ISO week is Monday
  const thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);
  // 1st week == the week where the 4th of January is in
  const firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);
  return Math.round((thuOfTheWeek - firstThu) / 604800000) + 1;
}

// Get the start year of the period of years that includes given date
// years: length of the year period
function startOfYearPeriod(date, years) {
  /* @see https://en.wikipedia.org/wiki/Year_zero#ISO_8601 */
  const year = new Date(date).getFullYear();
  return Math.floor(year / years) * years;
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/lib/dom.js":
/*!********************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/lib/dom.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "emptyChildNodes": () => (/* binding */ emptyChildNodes),
/* harmony export */   "hideElement": () => (/* binding */ hideElement),
/* harmony export */   "isVisible": () => (/* binding */ isVisible),
/* harmony export */   "parseHTML": () => (/* binding */ parseHTML),
/* harmony export */   "replaceChildNodes": () => (/* binding */ replaceChildNodes),
/* harmony export */   "showElement": () => (/* binding */ showElement)
/* harmony export */ });
const range = document.createRange();

function parseHTML(html) {
  return range.createContextualFragment(html);
}

// equivalent to jQuery's :visble
function isVisible(el) {
  return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
}

function hideElement(el) {
  if (el.style.display === 'none') {
    return;
  }
  // back up the existing display setting in data-style-display
  if (el.style.display) {
    el.dataset.styleDisplay = el.style.display;
  }
  el.style.display = 'none';
}

function showElement(el) {
  if (el.style.display !== 'none') {
    return;
  }
  if (el.dataset.styleDisplay) {
    // restore backed-up dispay property
    el.style.display = el.dataset.styleDisplay;
    delete el.dataset.styleDisplay;
  } else {
    el.style.display = '';
  }
}

function emptyChildNodes(el) {
  if (el.firstChild) {
    el.removeChild(el.firstChild);
    emptyChildNodes(el);
  }
}

function replaceChildNodes(el, newChildNodes) {
  emptyChildNodes(el);
  if (newChildNodes instanceof DocumentFragment) {
    el.appendChild(newChildNodes);
  } else if (typeof newChildNodes === 'string') {
    el.appendChild(parseHTML(newChildNodes));
  } else if (typeof newChildNodes.forEach === 'function') {
    newChildNodes.forEach((node) => {
      el.appendChild(node);
    });
  }
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/lib/event.js":
/*!**********************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/lib/event.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "findElementInEventPath": () => (/* binding */ findElementInEventPath),
/* harmony export */   "registerListeners": () => (/* binding */ registerListeners),
/* harmony export */   "unregisterListeners": () => (/* binding */ unregisterListeners)
/* harmony export */ });
const listenerRegistry = new WeakMap();
const {addEventListener, removeEventListener} = EventTarget.prototype;

// Register event listeners to a key object
// listeners: array of listener definitions;
//   - each definition must be a flat array of event target and the arguments
//     used to call addEventListener() on the target
function registerListeners(keyObj, listeners) {
  let registered = listenerRegistry.get(keyObj);
  if (!registered) {
    registered = [];
    listenerRegistry.set(keyObj, registered);
  }
  listeners.forEach((listener) => {
    addEventListener.call(...listener);
    registered.push(listener);
  });
}

function unregisterListeners(keyObj) {
  let listeners = listenerRegistry.get(keyObj);
  if (!listeners) {
    return;
  }
  listeners.forEach((listener) => {
    removeEventListener.call(...listener);
  });
  listenerRegistry.delete(keyObj);
}

// Event.composedPath() polyfill for Edge
// based on https://gist.github.com/kleinfreund/e9787d73776c0e3750dcfcdc89f100ec
if (!Event.prototype.composedPath) {
  const getComposedPath = (node, path = []) => {
    path.push(node);

    let parent;
    if (node.parentNode) {
      parent = node.parentNode;
    } else if (node.host) { // ShadowRoot
      parent = node.host;
    } else if (node.defaultView) {  // Document
      parent = node.defaultView;
    }
    return parent ? getComposedPath(parent, path) : path;
  };

  Event.prototype.composedPath = function () {
    return getComposedPath(this.target);
  };
}

function findFromPath(path, criteria, currentTarget, index = 0) {
  const el = path[index];
  if (criteria(el)) {
    return el;
  } else if (el === currentTarget || !el.parentElement) {
    // stop when reaching currentTarget or <html>
    return;
  }
  return findFromPath(path, criteria, currentTarget, index + 1);
}

// Search for the actual target of a delegated event
function findElementInEventPath(ev, selector) {
  const criteria = typeof selector === 'function' ? selector : el => el.matches(selector);
  return findFromPath(ev.composedPath(), criteria, ev.currentTarget);
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/lib/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/lib/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTagRepeat": () => (/* binding */ createTagRepeat),
/* harmony export */   "hasProperty": () => (/* binding */ hasProperty),
/* harmony export */   "isInRange": () => (/* binding */ isInRange),
/* harmony export */   "lastItemOf": () => (/* binding */ lastItemOf),
/* harmony export */   "limitToRange": () => (/* binding */ limitToRange),
/* harmony export */   "optimizeTemplateHTML": () => (/* binding */ optimizeTemplateHTML),
/* harmony export */   "pushUnique": () => (/* binding */ pushUnique),
/* harmony export */   "stringToArray": () => (/* binding */ stringToArray)
/* harmony export */ });
function hasProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function lastItemOf(arr) {
  return arr[arr.length - 1];
}

// push only the items not included in the array
function pushUnique(arr, ...items) {
  items.forEach((item) => {
    if (arr.includes(item)) {
      return;
    }
    arr.push(item);
  });
  return arr;
}

function stringToArray(str, separator) {
  // convert empty string to an empty array
  return str ? str.split(separator) : [];
}

function isInRange(testVal, min, max) {
  const minOK = min === undefined || testVal >= min;
  const maxOK = max === undefined || testVal <= max;
  return minOK && maxOK;
}

function limitToRange(val, min, max) {
  if (val < min) {
    return min;
  }
  if (val > max) {
    return max;
  }
  return val;
}

function createTagRepeat(tagName, repeat, attributes = {}, index = 0, html = '') {
  const openTagSrc = Object.keys(attributes).reduce((src, attr) => {
    let val = attributes[attr];
    if (typeof val === 'function') {
      val = val(index);
    }
    return `${src} ${attr}="${val}"`;
  }, tagName);
  html += `<${openTagSrc}></${tagName}>`;

  const next = index + 1;
  return next < repeat
    ? createTagRepeat(tagName, repeat, attributes, next, html)
    : html;
}

// Remove the spacing surrounding tags for HTML parser not to create text nodes
// before/after elements
function optimizeTemplateHTML(html) {
  return html.replace(/>\s+/g, '>').replace(/\s+</, '<');
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/options/defaultOptions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/options/defaultOptions.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// config options updatable by setOptions() and their default values
const defaultOptions = {
  autohide: false,
  beforeShowDay: null,
  beforeShowDecade: null,
  beforeShowMonth: null,
  beforeShowYear: null,
  calendarWeeks: false,
  clearBtn: false,
  dateDelimiter: ',',
  datesDisabled: [],
  daysOfWeekDisabled: [],
  daysOfWeekHighlighted: [],
  defaultViewDate: undefined, // placeholder, defaults to today() by the program
  disableTouchKeyboard: false,
  format: 'mm/dd/yyyy',
  language: 'en',
  maxDate: null,
  maxNumberOfDates: 1,
  maxView: 3,
  minDate: null,
  nextArrow: '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M12.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>',
  orientation: 'auto',
  pickLevel: 0,
  prevArrow: '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd"></path></svg>',
  showDaysOfWeek: true,
  showOnClick: true,
  showOnFocus: true,
  startView: 0,
  title: '',
  todayBtn: false,
  todayBtnMode: 0,
  todayHighlight: false,
  updateOnBlur: true,
  weekStart: 0,
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaultOptions);


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/options/processOptions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/options/processOptions.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ processOptions)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/date.js */ "./node_modules/flowbite-datepicker/js/lib/date.js");
/* harmony import */ var _lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/date-format.js */ "./node_modules/flowbite-datepicker/js/lib/date-format.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/dom.js */ "./node_modules/flowbite-datepicker/js/lib/dom.js");
/* harmony import */ var _defaultOptions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaultOptions.js */ "./node_modules/flowbite-datepicker/js/options/defaultOptions.js");






const {
  language: defaultLang,
  format: defaultFormat,
  weekStart: defaultWeekStart,
} = _defaultOptions_js__WEBPACK_IMPORTED_MODULE_4__["default"];

// Reducer function to filter out invalid day-of-week from the input
function sanitizeDOW(dow, day) {
  return dow.length < 6 && day >= 0 && day < 7
    ? (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(dow, day)
    : dow;
}

function calcEndOfWeek(startOfWeek) {
  return (startOfWeek + 6) % 7;
}

// validate input date. if invalid, fallback to the original value
function validateDate(value, format, locale, origValue) {
  const date = (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(value, format, locale);
  return date !== undefined ? date : origValue;
}

// Validate viewId. if invalid, fallback to the original value
function validateViewId(value, origValue, max = 3) {
  const viewId = parseInt(value, 10);
  return viewId >= 0 && viewId <= max ? viewId : origValue;
}

// Create Datepicker configuration to set
function processOptions(options, datepicker) {
  const inOpts = Object.assign({}, options);
  const config = {};
  const locales = datepicker.constructor.locales;
  let {
    format,
    language,
    locale,
    maxDate,
    maxView,
    minDate,
    pickLevel,
    startView,
    weekStart,
  } = datepicker.config || {};

  if (inOpts.language) {
    let lang;
    if (inOpts.language !== language) {
      if (locales[inOpts.language]) {
        lang = inOpts.language;
      } else {
        // Check if langauge + region tag can fallback to the one without
        // region (e.g. fr-CA  fr)
        lang = inOpts.language.split('-')[0];
        if (locales[lang] === undefined) {
          lang = false;
        }
      }
    }
    delete inOpts.language;
    if (lang) {
      language = config.language = lang;

      // update locale as well when updating language
      const origLocale = locale || locales[defaultLang];
      // use default language's properties for the fallback
      locale = Object.assign({
        format: defaultFormat,
        weekStart: defaultWeekStart
      }, locales[defaultLang]);
      if (language !== defaultLang) {
        Object.assign(locale, locales[language]);
      }
      config.locale = locale;
      // if format and/or weekStart are the same as old locale's defaults,
      // update them to new locale's defaults
      if (format === origLocale.format) {
        format = config.format = locale.format;
      }
      if (weekStart === origLocale.weekStart) {
        weekStart = config.weekStart = locale.weekStart;
        config.weekEnd = calcEndOfWeek(locale.weekStart);
      }
    }
  }

  if (inOpts.format) {
    const hasToDisplay = typeof inOpts.format.toDisplay === 'function';
    const hasToValue = typeof inOpts.format.toValue === 'function';
    const validFormatString = _lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.reFormatTokens.test(inOpts.format);
    if ((hasToDisplay && hasToValue) || validFormatString) {
      format = config.format = inOpts.format;
    }
    delete inOpts.format;
  }

  //*** dates ***//
  // while min and maxDate for "no limit" in the options are better to be null
  // (especially when updating), the ones in the config have to be undefined
  // because null is treated as 0 (= unix epoch) when comparing with time value
  let minDt = minDate;
  let maxDt = maxDate;
  if (inOpts.minDate !== undefined) {
    minDt = inOpts.minDate === null
      ? (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(0, 0, 1)  // set 0000-01-01 to prevent negative values for year
      : validateDate(inOpts.minDate, format, locale, minDt);
    delete inOpts.minDate;
  }
  if (inOpts.maxDate !== undefined) {
    maxDt = inOpts.maxDate === null
      ? undefined
      : validateDate(inOpts.maxDate, format, locale, maxDt);
    delete inOpts.maxDate;
  }
  if (maxDt < minDt) {
    minDate = config.minDate = maxDt;
    maxDate = config.maxDate = minDt;
  } else {
    if (minDate !== minDt) {
      minDate = config.minDate = minDt;
    }
    if (maxDate !== maxDt) {
      maxDate = config.maxDate = maxDt;
    }
  }

  if (inOpts.datesDisabled) {
    config.datesDisabled = inOpts.datesDisabled.reduce((dates, dt) => {
      const date = (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(dt, format, locale);
      return date !== undefined ? (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(dates, date) : dates;
    }, []);
    delete inOpts.datesDisabled;
  }
  if (inOpts.defaultViewDate !== undefined) {
    const viewDate = (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.parseDate)(inOpts.defaultViewDate, format, locale);
    if (viewDate !== undefined) {
      config.defaultViewDate = viewDate;
    }
    delete inOpts.defaultViewDate;
  }

  //*** days of week ***//
  if (inOpts.weekStart !== undefined) {
    const wkStart = Number(inOpts.weekStart) % 7;
    if (!isNaN(wkStart)) {
      weekStart = config.weekStart = wkStart;
      config.weekEnd = calcEndOfWeek(wkStart);
    }
    delete inOpts.weekStart;
  }
  if (inOpts.daysOfWeekDisabled) {
    config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekDisabled;
  }
  if (inOpts.daysOfWeekHighlighted) {
    config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekHighlighted;
  }

  //*** multi date ***//
  if (inOpts.maxNumberOfDates !== undefined) {
    const maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);
    if (maxNumberOfDates >= 0) {
      config.maxNumberOfDates = maxNumberOfDates;
      config.multidate = maxNumberOfDates !== 1;
    }
    delete inOpts.maxNumberOfDates;
  }
  if (inOpts.dateDelimiter) {
    config.dateDelimiter = String(inOpts.dateDelimiter);
    delete inOpts.dateDelimiter;
  }

  //*** pick level & view ***//
  let newPickLevel = pickLevel;
  if (inOpts.pickLevel !== undefined) {
    newPickLevel = validateViewId(inOpts.pickLevel, 2);
    delete inOpts.pickLevel;
  }
  if (newPickLevel !== pickLevel) {
    pickLevel = config.pickLevel = newPickLevel;
  }

  let newMaxView = maxView;
  if (inOpts.maxView !== undefined) {
    newMaxView = validateViewId(inOpts.maxView, maxView);
    delete inOpts.maxView;
  }
  // ensure max view >= pick level
  newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;
  if (newMaxView !== maxView) {
    maxView = config.maxView = newMaxView;
  }

  let newStartView = startView;
  if (inOpts.startView !== undefined) {
    newStartView = validateViewId(inOpts.startView, newStartView);
    delete inOpts.startView;
  }
  // ensure pick level <= start view <= max view
  if (newStartView < pickLevel) {
    newStartView = pickLevel;
  } else if (newStartView > maxView) {
    newStartView = maxView;
  }
  if (newStartView !== startView) {
    config.startView = newStartView;
  }

  //*** template ***//
  if (inOpts.prevArrow) {
    const prevArrow = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_3__.parseHTML)(inOpts.prevArrow);
    if (prevArrow.childNodes.length > 0) {
      config.prevArrow = prevArrow.childNodes;
    }
    delete inOpts.prevArrow;
  }
  if (inOpts.nextArrow) {
    const nextArrow = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_3__.parseHTML)(inOpts.nextArrow);
    if (nextArrow.childNodes.length > 0) {
      config.nextArrow = nextArrow.childNodes;
    }
    delete inOpts.nextArrow;
  }

  //*** misc ***//
  if (inOpts.disableTouchKeyboard !== undefined) {
    config.disableTouchKeyboard = 'ontouchstart' in document && !!inOpts.disableTouchKeyboard;
    delete inOpts.disableTouchKeyboard;
  }
  if (inOpts.orientation) {
    const orientation = inOpts.orientation.toLowerCase().split(/\s+/g);
    config.orientation = {
      x: orientation.find(x => (x === 'left' || x === 'right')) || 'auto',
      y: orientation.find(y => (y === 'top' || y === 'bottom')) || 'auto',
    };
    delete inOpts.orientation;
  }
  if (inOpts.todayBtnMode !== undefined) {
    switch(inOpts.todayBtnMode) {
      case 0:
      case 1:
        config.todayBtnMode = inOpts.todayBtnMode;
    }
    delete inOpts.todayBtnMode;
  }

  //*** copy the rest ***//
  Object.keys(inOpts).forEach((key) => {
    if (inOpts[key] !== undefined && (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(_defaultOptions_js__WEBPACK_IMPORTED_MODULE_4__["default"], key)) {
      config[key] = inOpts[key];
    }
  });

  return config;
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/picker/Picker.js":
/*!**************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/picker/Picker.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Picker)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/date.js */ "./node_modules/flowbite-datepicker/js/lib/date.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/dom.js */ "./node_modules/flowbite-datepicker/js/lib/dom.js");
/* harmony import */ var _lib_event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/event.js */ "./node_modules/flowbite-datepicker/js/lib/event.js");
/* harmony import */ var _templates_pickerTemplate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./templates/pickerTemplate.js */ "./node_modules/flowbite-datepicker/js/picker/templates/pickerTemplate.js");
/* harmony import */ var _views_DaysView_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./views/DaysView.js */ "./node_modules/flowbite-datepicker/js/picker/views/DaysView.js");
/* harmony import */ var _views_MonthsView_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./views/MonthsView.js */ "./node_modules/flowbite-datepicker/js/picker/views/MonthsView.js");
/* harmony import */ var _views_YearsView_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./views/YearsView.js */ "./node_modules/flowbite-datepicker/js/picker/views/YearsView.js");
/* harmony import */ var _events_functions_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/functions.js */ "./node_modules/flowbite-datepicker/js/events/functions.js");
/* harmony import */ var _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../events/pickerListeners.js */ "./node_modules/flowbite-datepicker/js/events/pickerListeners.js");











function processPickerOptions(picker, options) {
  if (options.title !== undefined) {
    if (options.title) {
      picker.controls.title.textContent = options.title;
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.showElement)(picker.controls.title);
    } else {
      picker.controls.title.textContent = '';
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.hideElement)(picker.controls.title);
    }
  }
  if (options.prevArrow) {
    const prevBtn = picker.controls.prevBtn;
    (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.emptyChildNodes)(prevBtn);
    options.prevArrow.forEach((node) => {
      prevBtn.appendChild(node.cloneNode(true));
    });
  }
  if (options.nextArrow) {
    const nextBtn = picker.controls.nextBtn;
    (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.emptyChildNodes)(nextBtn);
    options.nextArrow.forEach((node) => {
      nextBtn.appendChild(node.cloneNode(true));
    });
  }
  if (options.locale) {
    picker.controls.todayBtn.textContent = options.locale.today;
    picker.controls.clearBtn.textContent = options.locale.clear;
  }
  if (options.todayBtn !== undefined) {
    if (options.todayBtn) {
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.showElement)(picker.controls.todayBtn);
    } else {
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.hideElement)(picker.controls.todayBtn);
    }
  }
  if ((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(options, 'minDate') || (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(options, 'maxDate')) {
    const {minDate, maxDate} = picker.datepicker.config;
    picker.controls.todayBtn.disabled = !(0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInRange)((0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.today)(), minDate, maxDate);
  }
  if (options.clearBtn !== undefined) {
    if (options.clearBtn) {
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.showElement)(picker.controls.clearBtn);
    } else {
      (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.hideElement)(picker.controls.clearBtn);
    }
  }
}

// Compute view date to reset, which will be...
// - the last item of the selected dates or defaultViewDate if no selection
// - limitted to minDate or maxDate if it exceeds the range
function computeResetViewDate(datepicker) {
  const {dates, config} = datepicker;
  const viewDate = dates.length > 0 ? (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.lastItemOf)(dates) : config.defaultViewDate;
  return (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.limitToRange)(viewDate, config.minDate, config.maxDate);
}

// Change current view's view date
function setViewDate(picker, newDate) {
  const oldViewDate = new Date(picker.viewDate);
  const newViewDate = new Date(newDate);
  const {id, year, first, last} = picker.currentView;
  const viewYear = newViewDate.getFullYear();

  picker.viewDate = newDate;
  if (viewYear !== oldViewDate.getFullYear()) {
    (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_8__.triggerDatepickerEvent)(picker.datepicker, 'changeYear');
  }
  if (newViewDate.getMonth() !== oldViewDate.getMonth()) {
    (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_8__.triggerDatepickerEvent)(picker.datepicker, 'changeMonth');
  }

  // return whether the new date is in different period on time from the one
  // displayed in the current view
  // when true, the view needs to be re-rendered on the next UI refresh.
  switch (id) {
    case 0:
      return newDate < first || newDate > last;
    case 1:
      return viewYear !== year;
    default:
      return viewYear < first || viewYear > last;
  }
}

function getTextDirection(el) {
  return window.getComputedStyle(el).direction;
}

// Class representing the picker UI
class Picker {
  constructor(datepicker) {
    this.datepicker = datepicker;

    const template = _templates_pickerTemplate_js__WEBPACK_IMPORTED_MODULE_4__["default"].replace(/%buttonClass%/g, datepicker.config.buttonClass);
    const element = this.element = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.parseHTML)(template).firstChild;
    const [header, main, footer] = element.firstChild.children;
    const title = header.firstElementChild;
    const [prevBtn, viewSwitch, nextBtn] = header.lastElementChild.children;
    const [todayBtn, clearBtn] = footer.firstChild.children;
    const controls = {
      title,
      prevBtn,
      viewSwitch,
      nextBtn,
      todayBtn,
      clearBtn,
    };
    this.main = main;
    this.controls = controls;

    const elementClass = datepicker.inline ? 'inline' : 'dropdown';
    element.classList.add(`datepicker-${elementClass}`);
    elementClass === 'dropdown' ? element.classList.add('dropdown', 'absolute', 'top-0', 'left-0', 'z-50', 'pt-2') : null;

    processPickerOptions(this, datepicker.config);
    this.viewDate = computeResetViewDate(datepicker);

    // set up event listeners
    (0,_lib_event_js__WEBPACK_IMPORTED_MODULE_3__.registerListeners)(datepicker, [
      [element, 'click', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickPicker.bind(null, datepicker), {capture: true}],
      [main, 'click', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickView.bind(null, datepicker)],
      [controls.viewSwitch, 'click', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickViewSwitch.bind(null, datepicker)],
      [controls.prevBtn, 'click', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickPrevBtn.bind(null, datepicker)],
      [controls.nextBtn, 'click', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickNextBtn.bind(null, datepicker)],
      [controls.todayBtn, 'click', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickTodayBtn.bind(null, datepicker)],
      [controls.clearBtn, 'click', _events_pickerListeners_js__WEBPACK_IMPORTED_MODULE_9__.onClickClearBtn.bind(null, datepicker)],
    ]);

    // set up views
    this.views = [
      new _views_DaysView_js__WEBPACK_IMPORTED_MODULE_5__["default"](this),
      new _views_MonthsView_js__WEBPACK_IMPORTED_MODULE_6__["default"](this),
      new _views_YearsView_js__WEBPACK_IMPORTED_MODULE_7__["default"](this, {id: 2, name: 'years', cellClass: 'year', step: 1}),
      new _views_YearsView_js__WEBPACK_IMPORTED_MODULE_7__["default"](this, {id: 3, name: 'decades', cellClass: 'decade', step: 10}),
    ];
    this.currentView = this.views[datepicker.config.startView];

    this.currentView.render();
    this.main.appendChild(this.currentView.element);
    datepicker.config.container.appendChild(this.element);
  }

  setOptions(options) {
    processPickerOptions(this, options);
    this.views.forEach((view) => {
      view.init(options, false);
    });
    this.currentView.render();
  }

  detach() {
    this.datepicker.config.container.removeChild(this.element);
  }

  show() {
    if (this.active) {
      return;
    }
    this.element.classList.add('active', 'block');
    this.element.classList.remove('hidden');
    this.active = true;

    const datepicker = this.datepicker;
    if (!datepicker.inline) {
      // ensure picker's direction matches input's
      const inputDirection = getTextDirection(datepicker.inputField);
      if (inputDirection !== getTextDirection(datepicker.config.container)) {
        this.element.dir = inputDirection;
      } else if (this.element.dir) {
        this.element.removeAttribute('dir');
      }

      this.place();
      if (datepicker.config.disableTouchKeyboard) {
        datepicker.inputField.blur();
      }
    }
    (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_8__.triggerDatepickerEvent)(datepicker, 'show');
  }

  hide() {
    if (!this.active) {
      return;
    }
    this.datepicker.exitEditMode();
    this.element.classList.remove('active', 'block');
    this.element.classList.add('active', 'block', 'hidden');
    this.active = false;
    (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_8__.triggerDatepickerEvent)(this.datepicker, 'hide');
  }

  place() {
    const {classList, style} = this.element;
    const {config, inputField} = this.datepicker;
    const container = config.container;
    const {
      width: calendarWidth,
      height: calendarHeight,
    } = this.element.getBoundingClientRect();
    const {
      left: containerLeft,
      top: containerTop,
      width: containerWidth,
    } = container.getBoundingClientRect();
    const {
      left: inputLeft,
      top: inputTop,
      width: inputWidth,
      height: inputHeight
    } = inputField.getBoundingClientRect();
    let {x: orientX, y: orientY} = config.orientation;
    let scrollTop;
    let left;
    let top;

    if (container === document.body) {
      scrollTop = window.scrollY;
      left = inputLeft + window.scrollX;
      top = inputTop + scrollTop;
    } else {
      scrollTop = container.scrollTop;
      left = inputLeft - containerLeft;
      top = inputTop - containerTop + scrollTop;
    }

    if (orientX === 'auto') {
      if (left < 0) {
        // align to the left and move into visible area if input's left edge < window's
        orientX = 'left';
        left = 10;
      } else if (left + calendarWidth > containerWidth) {
        // align to the right if canlendar's right edge > container's
        orientX = 'right';
      } else {
        orientX = getTextDirection(inputField) === 'rtl' ? 'right' : 'left';
      }
    }
    if (orientX === 'right') {
      left -= calendarWidth - inputWidth;
    }

    if (orientY === 'auto') {
      orientY = top - calendarHeight < scrollTop ? 'bottom' : 'top';
    }
    if (orientY === 'top') {
      top -= calendarHeight;
    } else {
      top += inputHeight;
    }

    classList.remove(
      'datepicker-orient-top',
      'datepicker-orient-bottom',
      'datepicker-orient-right',
      'datepicker-orient-left'
    );
    classList.add(`datepicker-orient-${orientY}`, `datepicker-orient-${orientX}`);

    style.top = top ? `${top}px` : top;
    style.left = left ? `${left}px` : left;
  }

  setViewSwitchLabel(labelText) {
    this.controls.viewSwitch.textContent = labelText;
  }

  setPrevBtnDisabled(disabled) {
    this.controls.prevBtn.disabled = disabled;
  }

  setNextBtnDisabled(disabled) {
    this.controls.nextBtn.disabled = disabled;
  }

  changeView(viewId) {
    const oldView = this.currentView;
    const newView =  this.views[viewId];
    if (newView.id !== oldView.id) {
      this.currentView = newView;
      this._renderMethod = 'render';
      (0,_events_functions_js__WEBPACK_IMPORTED_MODULE_8__.triggerDatepickerEvent)(this.datepicker, 'changeView');
      this.main.replaceChild(newView.element, oldView.element);
    }
    return this;
  }

  // Change the focused date (view date)
  changeFocus(newViewDate) {
    this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refreshFocus';
    this.views.forEach((view) => {
      view.updateFocus();
    });
    return this;
  }

  // Apply the change of the selected dates
  update() {
    const newViewDate = computeResetViewDate(this.datepicker);
    this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refresh';
    this.views.forEach((view) => {
      view.updateFocus();
      view.updateSelection();
    });
    return this;
  }

  // Refresh the picker UI
  render(quickRender = true) {
    const renderMethod = (quickRender && this._renderMethod) || 'render';
    delete this._renderMethod;

    this.currentView[renderMethod]();
  }
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/picker/templates/calendarWeeksTemplate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/picker/templates/calendarWeeksTemplate.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");


const calendarWeeksTemplate = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.optimizeTemplateHTML)(`<div class="calendar-weeks">
  <div class="days-of-week flex"><span class="dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"></span></div>
  <div class="weeks">${(0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createTagRepeat)('span', 6, {class: 'week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm'})}</div>
</div>`);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (calendarWeeksTemplate);


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/picker/templates/daysTemplate.js":
/*!******************************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/picker/templates/daysTemplate.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");


const daysTemplate = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.optimizeTemplateHTML)(`<div class="days">
  <div class="days-of-week grid grid-cols-7 mb-1">${(0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createTagRepeat)('span', 7, {class: 'dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm'})}</div>
  <div class="datepicker-grid w-64 grid grid-cols-7">${(0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createTagRepeat)('span', 42 , {class: 'block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400'})}</div>
</div>`);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (daysTemplate);


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/picker/templates/pickerTemplate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/picker/templates/pickerTemplate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");


const pickerTemplate = (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.optimizeTemplateHTML)(`<div class="datepicker hidden">
  <div class="datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4">
    <div class="datepicker-header">
      <div class="datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold"></div>
      <div class="datepicker-controls flex justify-between mb-2">
        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn"></button>
        <button type="button" class="text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch"></button>
        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn"></button>
      </div>
    </div>
    <div class="datepicker-main p-1"></div>
    <div class="datepicker-footer">
      <div class="datepicker-controls flex space-x-2 mt-2">
        <button type="button" class="%buttonClass% today-btn text-white bg-blue-700 dark:bg-blue-600 hover:bg-blue-800 dark:hover:bg-blue-700 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>
        <button type="button" class="%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>
      </div>
    </div>
  </div>
</div>`);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pickerTemplate);


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/picker/views/DaysView.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/picker/views/DaysView.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DaysView)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/date.js */ "./node_modules/flowbite-datepicker/js/lib/date.js");
/* harmony import */ var _lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/date-format.js */ "./node_modules/flowbite-datepicker/js/lib/date-format.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/dom.js */ "./node_modules/flowbite-datepicker/js/lib/dom.js");
/* harmony import */ var _templates_daysTemplate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../templates/daysTemplate.js */ "./node_modules/flowbite-datepicker/js/picker/templates/daysTemplate.js");
/* harmony import */ var _templates_calendarWeeksTemplate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../templates/calendarWeeksTemplate.js */ "./node_modules/flowbite-datepicker/js/picker/templates/calendarWeeksTemplate.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./View.js */ "./node_modules/flowbite-datepicker/js/picker/views/View.js");








class DaysView extends _View_js__WEBPACK_IMPORTED_MODULE_6__["default"] {
  constructor(picker) {
    super(picker, {
      id: 0,
      name: 'days',
      cellClass: 'day',
    });
  }

  init(options, onConstruction = true) {
    if (onConstruction) {
      const inner = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_3__.parseHTML)(_templates_daysTemplate_js__WEBPACK_IMPORTED_MODULE_4__["default"]).firstChild;
      this.dow = inner.firstChild;
      this.grid = inner.lastChild;
      this.element.appendChild(inner);
    }
    super.init(options);
  }

  setOptions(options) {
    let updateDOW;

    if ((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(options, 'minDate')) {
      this.minDate = options.minDate;
    }
    if ((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(options, 'maxDate')) {
      this.maxDate = options.maxDate;
    }
    if (options.datesDisabled) {
      this.datesDisabled = options.datesDisabled;
    }
    if (options.daysOfWeekDisabled) {
      this.daysOfWeekDisabled = options.daysOfWeekDisabled;
      updateDOW = true;
    }
    if (options.daysOfWeekHighlighted) {
      this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;
    }
    if (options.todayHighlight !== undefined) {
      this.todayHighlight = options.todayHighlight;
    }
    if (options.weekStart !== undefined) {
      this.weekStart = options.weekStart;
      this.weekEnd = options.weekEnd;
      updateDOW = true;
    }
    if (options.locale) {
      const locale = this.locale = options.locale;
      this.dayNames = locale.daysMin;
      this.switchLabelFormat = locale.titleFormat;
      updateDOW = true;
    }
    if (options.beforeShowDay !== undefined) {
      this.beforeShow = typeof options.beforeShowDay === 'function'
        ? options.beforeShowDay
        : undefined;
    }

    if (options.calendarWeeks !== undefined) {
      if (options.calendarWeeks && !this.calendarWeeks) {
        const weeksElem = (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_3__.parseHTML)(_templates_calendarWeeksTemplate_js__WEBPACK_IMPORTED_MODULE_5__["default"]).firstChild;
        this.calendarWeeks = {
          element: weeksElem,
          dow: weeksElem.firstChild,
          weeks: weeksElem.lastChild,
        };
        this.element.insertBefore(weeksElem, this.element.firstChild);
      } else if (this.calendarWeeks && !options.calendarWeeks) {
        this.element.removeChild(this.calendarWeeks.element);
        this.calendarWeeks = null;
      }
    }
    if (options.showDaysOfWeek !== undefined) {
      if (options.showDaysOfWeek) {
        (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_3__.showElement)(this.dow);
        if (this.calendarWeeks) {
          (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_3__.showElement)(this.calendarWeeks.dow);
        }
      } else {
        (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_3__.hideElement)(this.dow);
        if (this.calendarWeeks) {
          (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_3__.hideElement)(this.calendarWeeks.dow);
        }
      }
    }

    // update days-of-week when locale, daysOfweekDisabled or weekStart is changed
    if (updateDOW) {
      Array.from(this.dow.children).forEach((el, index) => {
        const dow = (this.weekStart + index) % 7;
        el.textContent = this.dayNames[dow];
        el.className = this.daysOfWeekDisabled.includes(dow) ? 'dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed' : 'dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400';
      });
    }
  }

  // Apply update on the focused date to view's settings
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    const viewYear = viewDate.getFullYear();
    const viewMonth = viewDate.getMonth();
    const firstOfMonth = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(viewYear, viewMonth, 1);
    const start = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dayOfTheWeekOf)(firstOfMonth, this.weekStart, this.weekStart);

    this.first = firstOfMonth;
    this.last = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(viewYear, viewMonth + 1, 0);
    this.start = start;
    this.focused = this.picker.viewDate;
  }

  // Apply update on the selected dates to view's settings
  updateSelection() {
    const {dates, rangepicker} = this.picker.datepicker;
    this.selected = dates;
    if (rangepicker) {
      this.range = rangepicker.dates;
    }
  }

   // Update the entire view UI
  render() {
    // update today marker on ever render
    this.today = this.todayHighlight ? (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.today)() : undefined;
    // refresh disabled dates on every render in order to clear the ones added
    // by beforeShow hook at previous render
    this.disabled = [...this.datesDisabled];

    const switchLabel = (0,_lib_date_format_js__WEBPACK_IMPORTED_MODULE_2__.formatDate)(this.focused, this.switchLabelFormat, this.locale);
    this.picker.setViewSwitchLabel(switchLabel);
    this.picker.setPrevBtnDisabled(this.first <= this.minDate);
    this.picker.setNextBtnDisabled(this.last >= this.maxDate);

    if (this.calendarWeeks) {
      // start of the UTC week (Monday) of the 1st of the month
      const startOfWeek = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dayOfTheWeekOf)(this.first, 1, 1);
      Array.from(this.calendarWeeks.weeks.children).forEach((el, index) => {
        el.textContent = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.getWeek)((0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addWeeks)(startOfWeek, index));
      });
    }
    Array.from(this.grid.children).forEach((el, index) => {
      const classList = el.classList;
      const current = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.addDays)(this.start, index);
      const date = new Date(current);
      const day = date.getDay();

      el.className = `datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ${this.cellClass}`;
      el.dataset.date = current;
      el.textContent = date.getDate();

      if (current < this.first) {
        classList.add('prev', 'text-gray-500', 'dark:text-white');
      } else if (current > this.last) {
        classList.add('next', 'text-gray-500', 'dark:text-white');
      }
      if (this.today === current) {
        classList.add('today', 'bg-gray-100', 'dark:bg-gray-600');
      }
      if (current < this.minDate || current > this.maxDate || this.disabled.includes(current)) {
        classList.add('disabled', 'cursor-not-allowed');
      }
      if (this.daysOfWeekDisabled.includes(day)) {
        classList.add('disabled', 'cursor-not-allowed');
        (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(this.disabled, current);
      }
      if (this.daysOfWeekHighlighted.includes(day)) {
        classList.add('highlighted');
      }
      if (this.range) {
        const [rangeStart, rangeEnd] = this.range;
        if (current > rangeStart && current < rangeEnd) {
          classList.add('range', 'bg-gray-200', 'dark:bg-gray-600');
          classList.remove('rounded-lg', 'rounded-l-lg', 'rounded-r-lg')
        }
        if (current === rangeStart) {
          classList.add('range-start', 'bg-gray-100', 'dark:bg-gray-600', 'rounded-l-lg');
          classList.remove('rounded-lg', 'rounded-r-lg');
        }
        if (current === rangeEnd) {
          classList.add('range-end', 'bg-gray-100', 'dark:bg-gray-600', 'rounded-r-lg');
          classList.remove('rounded-lg', 'rounded-l-lg');
        }
      }
      if (this.selected.includes(current)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'text-gray-500', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600', 'dark:bg-gray-600', 'bg-gray-100', 'bg-gray-200');
      }
      if (current === this.focused) {
        classList.add('focused');
      }

      if (this.beforeShow) {
        this.performBeforeHook(el, current, current);
      }
    });
  }

  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const [rangeStart, rangeEnd] = this.range || [];
    this.grid
      .querySelectorAll('.range, .range-start, .range-end, .selected, .focused')
      .forEach((el) => {
        el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white', 'focused');
        el.classList.add('text-gray-900', 'rounded-lg', 'dark:text-white');
      });
    Array.from(this.grid.children).forEach((el) => {
      const current = Number(el.dataset.date);
      const classList = el.classList;
      classList.remove('bg-gray-200', 'dark:bg-gray-600', 'rounded-l-lg', 'rounded-r-lg')
      if (current > rangeStart && current < rangeEnd) {
        classList.add('range', 'bg-gray-200', 'dark:bg-gray-600');
        classList.remove('rounded-lg');
      }
      if (current === rangeStart) {
        classList.add('range-start', 'bg-gray-200', 'dark:bg-gray-600', 'rounded-l-lg');
        classList.remove('rounded-lg', 'rounded-r-lg');
      }
      if (current === rangeEnd) {
        classList.add('range-end', 'bg-gray-200', 'dark:bg-gray-600', 'rounded-r-lg');
        classList.remove('rounded-lg', 'rounded-l-lg');
      }
      if (this.selected.includes(current)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600', 'bg-gray-100', 'bg-gray-200', 'dark:bg-gray-600');
      }
      if (current === this.focused) {
        classList.add('focused');
      }
    });
  }

  // Update the view UI by applying the change of focused item
  refreshFocus() {
    const index = Math.round((this.focused - this.start) / 86400000);
    this.grid.querySelectorAll('.focused').forEach((el) => {
      el.classList.remove('focused');
    });
    this.grid.children[index].classList.add('focused');
  }
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/picker/views/MonthsView.js":
/*!************************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/picker/views/MonthsView.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MonthsView)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/date.js */ "./node_modules/flowbite-datepicker/js/lib/date.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/dom.js */ "./node_modules/flowbite-datepicker/js/lib/dom.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./View.js */ "./node_modules/flowbite-datepicker/js/picker/views/View.js");





function computeMonthRange(range, thisYear) {
  if (!range || !range[0] || !range[1]) {
    return;
  }

  const [[startY, startM], [endY, endM]] = range;
  if (startY > thisYear || endY < thisYear) {
    return;
  }
  return [
    startY === thisYear ? startM : -1,
    endY === thisYear ? endM : 12,
  ];
}

class MonthsView extends _View_js__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor(picker) {
    super(picker, {
      id: 1,
      name: 'months',
      cellClass: 'month',
    });
  }

  init(options, onConstruction = true) {
    if (onConstruction) {
      this.grid = this.element;
      this.element.classList.add('months', 'datepicker-grid', 'w-64', 'grid', 'grid-cols-4');
      this.grid.appendChild((0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.parseHTML)((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createTagRepeat)('span', 12, {'data-month': ix => ix})));
    }
    super.init(options);
  }

  setOptions(options) {
    if (options.locale) {
      this.monthNames = options.locale.monthsShort;
    }
    if ((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(options, 'minDate')) {
      if (options.minDate === undefined) {
        this.minYear = this.minMonth = this.minDate = undefined;
      } else {
        const minDateObj = new Date(options.minDate);
        this.minYear = minDateObj.getFullYear();
        this.minMonth = minDateObj.getMonth();
        this.minDate = minDateObj.setDate(1);
      }
    }
    if ((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(options, 'maxDate')) {
      if (options.maxDate === undefined) {
        this.maxYear = this.maxMonth = this.maxDate = undefined;
      } else {
        const maxDateObj = new Date(options.maxDate);
        this.maxYear = maxDateObj.getFullYear();
        this.maxMonth = maxDateObj.getMonth();
        this.maxDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(this.maxYear, this.maxMonth + 1, 0);
      }
    }
    if (options.beforeShowMonth !== undefined) {
      this.beforeShow = typeof options.beforeShowMonth === 'function'
        ? options.beforeShowMonth
        : undefined;
    }
  }

  // Update view's settings to reflect the viewDate set on the picker
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    this.year = viewDate.getFullYear();
    this.focused = viewDate.getMonth();
  }

  // Update view's settings to reflect the selected dates
  updateSelection() {
    const {dates, rangepicker} = this.picker.datepicker;
    this.selected = dates.reduce((selected, timeValue) => {
      const date = new Date(timeValue);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (selected[year] === undefined) {
        selected[year] = [month];
      } else {
        (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(selected[year], month);
      }
      return selected;
    }, {});
    if (rangepicker && rangepicker.dates) {
      this.range = rangepicker.dates.map(timeValue => {
        const date = new Date(timeValue);
        return isNaN(date) ? undefined : [date.getFullYear(), date.getMonth()];
      });
    }
  }

  // Update the entire view UI
  render() {
    // refresh disabled months on every render in order to clear the ones added
    // by beforeShow hook at previous render
    this.disabled = [];

    this.picker.setViewSwitchLabel(this.year);
    this.picker.setPrevBtnDisabled(this.year <= this.minYear);
    this.picker.setNextBtnDisabled(this.year >= this.maxYear);

    const selected = this.selected[this.year] || [];
    const yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;
    const isMinYear = this.year === this.minYear;
    const isMaxYear = this.year === this.maxYear;
    const range = computeMonthRange(this.range, this.year);

    Array.from(this.grid.children).forEach((el, index) => {
      const classList = el.classList;
      const date = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(this.year, index, 1);

      el.className = `datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ${this.cellClass}`;
      if (this.isMinView) {
        el.dataset.date = date;
      }
      // reset text on every render to clear the custom content set
      // by beforeShow hook at previous render
      el.textContent = this.monthNames[index];

      if (
        yrOutOfRange
        || isMinYear && index < this.minMonth
        || isMaxYear && index > this.maxMonth
      ) {
        classList.add('disabled');
      }
      if (range) {
        const [rangeStart, rangeEnd] = range;
        if (index > rangeStart && index < rangeEnd) {
          classList.add('range');
        }
        if (index === rangeStart) {
          classList.add('range-start');
        }
        if (index === rangeEnd) {
          classList.add('range-end');
        }
      }
      if (selected.includes(index)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');
      }
      if (index === this.focused) {
        classList.add('focused');
      }

      if (this.beforeShow) {
        this.performBeforeHook(el, index, date);
      }
    });
  }

  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const selected = this.selected[this.year] || [];
    const [rangeStart, rangeEnd] = computeMonthRange(this.range, this.year) || [];
    this.grid
      .querySelectorAll('.range, .range-start, .range-end, .selected, .focused')
      .forEach((el) => {
        el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'dark:bg-blue-600', 'dark:text-white', 'text-white', 'focused');
        el.classList.add('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');
      });
    Array.from(this.grid.children).forEach((el, index) => {
      const classList = el.classList;
      if (index > rangeStart && index < rangeEnd) {
        classList.add('range');
      }
      if (index === rangeStart) {
        classList.add('range-start');
      }
      if (index === rangeEnd) {
        classList.add('range-end');
      }
      if (selected.includes(index)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');
      }
      if (index === this.focused) {
        classList.add('focused');
      }
    });
  }

  // Update the view UI by applying the change of focused item
  refreshFocus() {
    this.grid.querySelectorAll('.focused').forEach((el) => {
      el.classList.remove('focused');
    });
    this.grid.children[this.focused].classList.add('focused');
  }
}

/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/picker/views/View.js":
/*!******************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/picker/views/View.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ View)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/dom.js */ "./node_modules/flowbite-datepicker/js/lib/dom.js");



// Base class of the view classes
class View {
  constructor(picker, config) {
    Object.assign(this, config, {
      picker,
      element: (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_1__.parseHTML)(`<div class="datepicker-view flex"></div>`).firstChild,
      selected: [],
    });
    this.init(this.picker.datepicker.config);
  }

  init(options) {
    if (options.pickLevel !== undefined) {
      this.isMinView = this.id === options.pickLevel;
    }
    this.setOptions(options);
    this.updateFocus();
    this.updateSelection();
  }

  // Execute beforeShow() callback and apply the result to the element
  // args:
  // - current - current value on the iteration on view rendering
  // - timeValue - time value of the date to pass to beforeShow()
  performBeforeHook(el, current, timeValue) {
    let result = this.beforeShow(new Date(timeValue));
    switch (typeof result) {
      case 'boolean':
        result = {enabled: result};
        break;
      case 'string':
        result = {classes: result};
    }

    if (result) {
      if (result.enabled === false) {
        el.classList.add('disabled');
        (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(this.disabled, current);
      }
      if (result.classes) {
        const extraClasses = result.classes.split(/\s+/);
        el.classList.add(...extraClasses);
        if (extraClasses.includes('disabled')) {
          (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(this.disabled, current);
        }
      }
      if (result.content) {
        (0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_1__.replaceChildNodes)(el, result.content);
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/flowbite-datepicker/js/picker/views/YearsView.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flowbite-datepicker/js/picker/views/YearsView.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ YearsView)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils.js */ "./node_modules/flowbite-datepicker/js/lib/utils.js");
/* harmony import */ var _lib_date_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/date.js */ "./node_modules/flowbite-datepicker/js/lib/date.js");
/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/dom.js */ "./node_modules/flowbite-datepicker/js/lib/dom.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./View.js */ "./node_modules/flowbite-datepicker/js/picker/views/View.js");





function toTitleCase(word) {
  return [...word].reduce((str, ch, ix) => str += ix ? ch : ch.toUpperCase(), '');
}

// Class representing the years and decades view elements
class YearsView extends _View_js__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor(picker, config) {
    super(picker, config);
  }

  init(options, onConstruction = true) {
    if (onConstruction) {
      this.navStep = this.step * 10;
      this.beforeShowOption = `beforeShow${toTitleCase(this.cellClass)}`;
      this.grid = this.element;
      this.element.classList.add(this.name, 'datepicker-grid', 'w-64', 'grid', 'grid-cols-4');
      this.grid.appendChild((0,_lib_dom_js__WEBPACK_IMPORTED_MODULE_2__.parseHTML)((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.createTagRepeat)('span', 12)));
    }
    super.init(options);
  }

  setOptions(options) {
    if ((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(options, 'minDate')) {
      if (options.minDate === undefined) {
        this.minYear = this.minDate = undefined;
      } else {
        this.minYear = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(options.minDate, this.step);
        this.minDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(this.minYear, 0, 1);
      }
    }
    if ((0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(options, 'maxDate')) {
      if (options.maxDate === undefined) {
        this.maxYear = this.maxDate = undefined;
      } else {
        this.maxYear = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(options.maxDate, this.step);
        this.maxDate = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(this.maxYear, 11, 31);
      }
    }
    if (options[this.beforeShowOption] !== undefined) {
      const beforeShow = options[this.beforeShowOption];
      this.beforeShow = typeof beforeShow === 'function' ? beforeShow : undefined;
    }
  }

  // Update view's settings to reflect the viewDate set on the picker
  updateFocus() {
    const viewDate = new Date(this.picker.viewDate);
    const first = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(viewDate, this.navStep);
    const last = first + 9 * this.step;

    this.first = first;
    this.last = last;
    this.start = first - this.step;
    this.focused = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(viewDate, this.step);
  }

  // Update view's settings to reflect the selected dates
  updateSelection() {
    const {dates, rangepicker} = this.picker.datepicker;
    this.selected = dates.reduce((years, timeValue) => {
      return (0,_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__.pushUnique)(years, (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(timeValue, this.step));
    }, []);
    if (rangepicker && rangepicker.dates) {
      this.range = rangepicker.dates.map(timeValue => {
        if (timeValue !== undefined) {
          return (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.startOfYearPeriod)(timeValue, this.step);
        }
      });
    }
  }

  // Update the entire view UI
  render() {
    // refresh disabled years on every render in order to clear the ones added
    // by beforeShow hook at previous render
    this.disabled = [];

    this.picker.setViewSwitchLabel(`${this.first}-${this.last}`);
    this.picker.setPrevBtnDisabled(this.first <= this.minYear);
    this.picker.setNextBtnDisabled(this.last >= this.maxYear);

    Array.from(this.grid.children).forEach((el, index) => {
      const classList = el.classList;
      const current = this.start + (index * this.step);
      const date = (0,_lib_date_js__WEBPACK_IMPORTED_MODULE_1__.dateValue)(current, 0, 1);

      el.className = `datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ${this.cellClass}`;
      if (this.isMinView) {
        el.dataset.date = date;
      }
      el.textContent = el.dataset.year = current;

      if (index === 0) {
        classList.add('prev');
      } else if (index === 11) {
        classList.add('next');
      }
      if (current < this.minYear || current > this.maxYear) {
        classList.add('disabled');
      }
      if (this.range) {
        const [rangeStart, rangeEnd] = this.range;
        if (current > rangeStart && current < rangeEnd) {
          classList.add('range');
        }
        if (current === rangeStart) {
          classList.add('range-start');
        }
        if (current === rangeEnd) {
          classList.add('range-end');
        }
      }
      if (this.selected.includes(current)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');
      }
      if (current === this.focused) {
        classList.add('focused');
      }

      if (this.beforeShow) {
        this.performBeforeHook(el, current, date);
      }
    });
  }

  // Update the view UI by applying the changes of selected and focused items
  refresh() {
    const [rangeStart, rangeEnd] = this.range || [];
    this.grid
      .querySelectorAll('.range, .range-start, .range-end, .selected, .focused')
      .forEach((el) => {
        el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white', 'focused');
      });
    Array.from(this.grid.children).forEach((el) => {
      const current = Number(el.textContent);
      const classList = el.classList;
      if (current > rangeStart && current < rangeEnd) {
        classList.add('range');
      }
      if (current === rangeStart) {
        classList.add('range-start');
      }
      if (current === rangeEnd) {
        classList.add('range-end');
      }
      if (this.selected.includes(current)) {
        classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');
        classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');
      }
      if (current === this.focused) {
        classList.add('focused');
      }
    });
  }

  // Update the view UI by applying the change of focused item
  refreshFocus() {
    const index = Math.round((this.focused - this.start) / this.step);
    this.grid.querySelectorAll('.focused').forEach((el) => {
      el.classList.remove('focused');
    });
    this.grid.children[index].classList.add('focused');
  }
}


/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/accordion/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/accordion/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initAccordions": () => (/* binding */ initAccordions)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    alwaysOpen: false,
    activeClasses: 'bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white',
    inactiveClasses: 'text-gray-500 dark:text-gray-400',
    onOpen: function () { },
    onClose: function () { },
    onToggle: function () { },
};
var Accordion = /** @class */ (function () {
    function Accordion(items, options) {
        if (items === void 0) { items = []; }
        if (options === void 0) { options = Default; }
        this._items = items;
        this._options = __assign(__assign({}, Default), options);
        this._init();
    }
    Accordion.prototype._init = function () {
        var _this = this;
        if (this._items.length) {
            // show accordion item based on click
            this._items.map(function (item) {
                if (item.active) {
                    _this.open(item.id);
                }
                item.triggerEl.addEventListener('click', function () {
                    _this.toggle(item.id);
                });
            });
        }
    };
    Accordion.prototype.getItem = function (id) {
        return this._items.filter(function (item) { return item.id === id; })[0];
    };
    Accordion.prototype.open = function (id) {
        var _a, _b;
        var _this = this;
        var item = this.getItem(id);
        // don't hide other accordions if always open
        if (!this._options.alwaysOpen) {
            this._items.map(function (i) {
                var _a, _b;
                if (i !== item) {
                    (_a = i.triggerEl.classList).remove.apply(_a, _this._options.activeClasses.split(' '));
                    (_b = i.triggerEl.classList).add.apply(_b, _this._options.inactiveClasses.split(' '));
                    i.targetEl.classList.add('hidden');
                    i.triggerEl.setAttribute('aria-expanded', 'false');
                    i.active = false;
                    // rotate icon if set
                    if (i.iconEl) {
                        i.iconEl.classList.remove('rotate-180');
                    }
                }
            });
        }
        // show active item
        (_a = item.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(' '));
        (_b = item.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(' '));
        item.triggerEl.setAttribute('aria-expanded', 'true');
        item.targetEl.classList.remove('hidden');
        item.active = true;
        // rotate icon if set
        if (item.iconEl) {
            item.iconEl.classList.add('rotate-180');
        }
        // callback function
        this._options.onOpen(this, item);
    };
    Accordion.prototype.toggle = function (id) {
        var item = this.getItem(id);
        if (item.active) {
            this.close(id);
        }
        else {
            this.open(id);
        }
        // callback function
        this._options.onToggle(this, item);
    };
    Accordion.prototype.close = function (id) {
        var _a, _b;
        var item = this.getItem(id);
        (_a = item.triggerEl.classList).remove.apply(_a, this._options.activeClasses.split(' '));
        (_b = item.triggerEl.classList).add.apply(_b, this._options.inactiveClasses.split(' '));
        item.targetEl.classList.add('hidden');
        item.triggerEl.setAttribute('aria-expanded', 'false');
        item.active = false;
        // rotate icon if set
        if (item.iconEl) {
            item.iconEl.classList.remove('rotate-180');
        }
        // callback function
        this._options.onClose(this, item);
    };
    return Accordion;
}());
if (typeof window !== 'undefined') {
    window.Accordion = Accordion;
}
function initAccordions() {
    document.querySelectorAll('[data-accordion]').forEach(function ($accordionEl) {
        var alwaysOpen = $accordionEl.getAttribute('data-accordion');
        var activeClasses = $accordionEl.getAttribute('data-active-classes');
        var inactiveClasses = $accordionEl.getAttribute('data-inactive-classes');
        var items = [];
        $accordionEl
            .querySelectorAll('[data-accordion-target]')
            .forEach(function ($triggerEl) {
            var item = {
                id: $triggerEl.getAttribute('data-accordion-target'),
                triggerEl: $triggerEl,
                targetEl: document.querySelector($triggerEl.getAttribute('data-accordion-target')),
                iconEl: $triggerEl.querySelector('[data-accordion-icon]'),
                active: $triggerEl.getAttribute('aria-expanded') === 'true'
                    ? true
                    : false,
            };
            items.push(item);
        });
        new Accordion(items, {
            alwaysOpen: alwaysOpen === 'open' ? true : false,
            activeClasses: activeClasses
                ? activeClasses
                : Default.activeClasses,
            inactiveClasses: inactiveClasses
                ? inactiveClasses
                : Default.inactiveClasses,
        });
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Accordion);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/accordion/interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/accordion/interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/accordion/types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/accordion/types.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/carousel/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/carousel/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initCarousels": () => (/* binding */ initCarousels)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    defaultPosition: 0,
    indicators: {
        items: [],
        activeClasses: 'bg-white dark:bg-gray-800',
        inactiveClasses: 'bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800',
    },
    interval: 3000,
    onNext: function () { },
    onPrev: function () { },
    onChange: function () { },
};
var Carousel = /** @class */ (function () {
    function Carousel(items, options) {
        if (items === void 0) { items = []; }
        if (options === void 0) { options = Default; }
        this._items = items;
        this._options = __assign(__assign(__assign({}, Default), options), { indicators: __assign(__assign({}, Default.indicators), options.indicators) });
        this._activeItem = this.getItem(this._options.defaultPosition);
        this._indicators = this._options.indicators.items;
        this._intervalDuration = this._options.interval;
        this._intervalInstance = null;
        this._init();
    }
    /**
     * initialize carousel and items based on active one
     */
    Carousel.prototype._init = function () {
        var _this = this;
        this._items.map(function (item) {
            item.el.classList.add('absolute', 'inset-0', 'transition-transform', 'transform');
        });
        // if no active item is set then first position is default
        if (this._getActiveItem()) {
            this.slideTo(this._getActiveItem().position);
        }
        else {
            this.slideTo(0);
        }
        this._indicators.map(function (indicator, position) {
            indicator.el.addEventListener('click', function () {
                _this.slideTo(position);
            });
        });
    };
    Carousel.prototype.getItem = function (position) {
        return this._items[position];
    };
    /**
     * Slide to the element based on id
     * @param {*} position
     */
    Carousel.prototype.slideTo = function (position) {
        var nextItem = this._items[position];
        var rotationItems = {
            left: nextItem.position === 0
                ? this._items[this._items.length - 1]
                : this._items[nextItem.position - 1],
            middle: nextItem,
            right: nextItem.position === this._items.length - 1
                ? this._items[0]
                : this._items[nextItem.position + 1],
        };
        this._rotate(rotationItems);
        this._setActiveItem(nextItem);
        if (this._intervalInstance) {
            this.pause();
            this.cycle();
        }
        this._options.onChange(this);
    };
    /**
     * Based on the currently active item it will go to the next position
     */
    Carousel.prototype.next = function () {
        var activeItem = this._getActiveItem();
        var nextItem = null;
        // check if last item
        if (activeItem.position === this._items.length - 1) {
            nextItem = this._items[0];
        }
        else {
            nextItem = this._items[activeItem.position + 1];
        }
        this.slideTo(nextItem.position);
        // callback function
        this._options.onNext(this);
    };
    /**
     * Based on the currently active item it will go to the previous position
     */
    Carousel.prototype.prev = function () {
        var activeItem = this._getActiveItem();
        var prevItem = null;
        // check if first item
        if (activeItem.position === 0) {
            prevItem = this._items[this._items.length - 1];
        }
        else {
            prevItem = this._items[activeItem.position - 1];
        }
        this.slideTo(prevItem.position);
        // callback function
        this._options.onPrev(this);
    };
    /**
     * This method applies the transform classes based on the left, middle, and right rotation carousel items
     * @param {*} rotationItems
     */
    Carousel.prototype._rotate = function (rotationItems) {
        // reset
        this._items.map(function (item) {
            item.el.classList.add('hidden');
        });
        // left item (previously active)
        rotationItems.left.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-20');
        rotationItems.left.el.classList.add('-translate-x-full', 'z-10');
        // currently active item
        rotationItems.middle.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-10');
        rotationItems.middle.el.classList.add('translate-x-0', 'z-20');
        // right item (upcoming active)
        rotationItems.right.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-20');
        rotationItems.right.el.classList.add('translate-x-full', 'z-10');
    };
    /**
     * Set an interval to cycle through the carousel items
     */
    Carousel.prototype.cycle = function () {
        var _this = this;
        if (typeof window !== 'undefined') {
            this._intervalInstance = window.setInterval(function () {
                _this.next();
            }, this._intervalDuration);
        }
    };
    /**
     * Clears the cycling interval
     */
    Carousel.prototype.pause = function () {
        clearInterval(this._intervalInstance);
    };
    /**
     * Get the currently active item
     */
    Carousel.prototype._getActiveItem = function () {
        return this._activeItem;
    };
    /**
     * Set the currently active item and data attribute
     * @param {*} position
     */
    Carousel.prototype._setActiveItem = function (item) {
        var _a, _b;
        var _this = this;
        this._activeItem = item;
        var position = item.position;
        // update the indicators if available
        if (this._indicators.length) {
            this._indicators.map(function (indicator) {
                var _a, _b;
                indicator.el.setAttribute('aria-current', 'false');
                (_a = indicator.el.classList).remove.apply(_a, _this._options.indicators.activeClasses.split(' '));
                (_b = indicator.el.classList).add.apply(_b, _this._options.indicators.inactiveClasses.split(' '));
            });
            (_a = this._indicators[position].el.classList).add.apply(_a, this._options.indicators.activeClasses.split(' '));
            (_b = this._indicators[position].el.classList).remove.apply(_b, this._options.indicators.inactiveClasses.split(' '));
            this._indicators[position].el.setAttribute('aria-current', 'true');
        }
    };
    return Carousel;
}());
if (typeof window !== 'undefined') {
    window.Carousel = Carousel;
}
function initCarousels() {
    document.querySelectorAll('[data-carousel]').forEach(function ($carouselEl) {
        var interval = $carouselEl.getAttribute('data-carousel-interval');
        var slide = $carouselEl.getAttribute('data-carousel') === 'slide'
            ? true
            : false;
        var items = [];
        var defaultPosition = 0;
        if ($carouselEl.querySelectorAll('[data-carousel-item]').length) {
            Array.from($carouselEl.querySelectorAll('[data-carousel-item]')).map(function ($carouselItemEl, position) {
                items.push({
                    position: position,
                    el: $carouselItemEl,
                });
                if ($carouselItemEl.getAttribute('data-carousel-item') ===
                    'active') {
                    defaultPosition = position;
                }
            });
        }
        var indicators = [];
        if ($carouselEl.querySelectorAll('[data-carousel-slide-to]').length) {
            Array.from($carouselEl.querySelectorAll('[data-carousel-slide-to]')).map(function ($indicatorEl) {
                indicators.push({
                    position: parseInt($indicatorEl.getAttribute('data-carousel-slide-to')),
                    el: $indicatorEl,
                });
            });
        }
        var carousel = new Carousel(items, {
            defaultPosition: defaultPosition,
            indicators: {
                items: indicators,
            },
            interval: interval ? interval : Default.interval,
        });
        if (slide) {
            carousel.cycle();
        }
        // check for controls
        var carouselNextEl = $carouselEl.querySelector('[data-carousel-next]');
        var carouselPrevEl = $carouselEl.querySelector('[data-carousel-prev]');
        if (carouselNextEl) {
            carouselNextEl.addEventListener('click', function () {
                carousel.next();
            });
        }
        if (carouselPrevEl) {
            carouselPrevEl.addEventListener('click', function () {
                carousel.prev();
            });
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Carousel);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/carousel/interface.js":
/*!************************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/carousel/interface.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/carousel/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/carousel/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/collapse/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/collapse/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initCollapses": () => (/* binding */ initCollapses)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    onCollapse: function () { },
    onExpand: function () { },
    onToggle: function () { },
};
var Collapse = /** @class */ (function () {
    function Collapse(targetEl, triggerEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (triggerEl === void 0) { triggerEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign(__assign({}, Default), options);
        this._visible = false;
        this._init();
    }
    Collapse.prototype._init = function () {
        var _this = this;
        if (this._triggerEl) {
            if (this._triggerEl.hasAttribute('aria-expanded')) {
                this._visible =
                    this._triggerEl.getAttribute('aria-expanded') === 'true';
            }
            else {
                // fix until v2 not to break previous single collapses which became dismiss
                this._visible = !this._targetEl.classList.contains('hidden');
            }
            this._triggerEl.addEventListener('click', function () {
                _this.toggle();
            });
        }
    };
    Collapse.prototype.collapse = function () {
        this._targetEl.classList.add('hidden');
        if (this._triggerEl) {
            this._triggerEl.setAttribute('aria-expanded', 'false');
        }
        this._visible = false;
        // callback function
        this._options.onCollapse(this);
    };
    Collapse.prototype.expand = function () {
        this._targetEl.classList.remove('hidden');
        if (this._triggerEl) {
            this._triggerEl.setAttribute('aria-expanded', 'true');
        }
        this._visible = true;
        // callback function
        this._options.onExpand(this);
    };
    Collapse.prototype.toggle = function () {
        if (this._visible) {
            this.collapse();
        }
        else {
            this.expand();
        }
        // callback function
        this._options.onToggle(this);
    };
    return Collapse;
}());
if (typeof window !== 'undefined') {
    window.Collapse = Collapse;
}
function initCollapses() {
    document
        .querySelectorAll('[data-collapse-toggle]')
        .forEach(function ($triggerEl) {
        var targetId = $triggerEl.getAttribute('data-collapse-toggle');
        var $targetEl = document.getElementById(targetId);
        // check if the target element exists
        if ($targetEl) {
            new Collapse($targetEl, $triggerEl);
        }
        else {
            console.error("The target element with id \"".concat(targetId, "\" does not exist. Please check the data-collapse-toggle attribute."));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Collapse);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/collapse/interface.js":
/*!************************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/collapse/interface.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/collapse/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/collapse/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dial/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dial/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initDials": () => (/* binding */ initDials)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    triggerType: 'hover',
    onShow: function () { },
    onHide: function () { },
    onToggle: function () { },
};
var Dial = /** @class */ (function () {
    function Dial(parentEl, triggerEl, targetEl, options) {
        if (parentEl === void 0) { parentEl = null; }
        if (triggerEl === void 0) { triggerEl = null; }
        if (targetEl === void 0) { targetEl = null; }
        if (options === void 0) { options = Default; }
        this._parentEl = parentEl;
        this._triggerEl = triggerEl;
        this._targetEl = targetEl;
        this._options = __assign(__assign({}, Default), options);
        this._visible = false;
        this._init();
    }
    Dial.prototype._init = function () {
        var _this = this;
        if (this._triggerEl) {
            var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
            triggerEventTypes.showEvents.forEach(function (ev) {
                _this._triggerEl.addEventListener(ev, function () {
                    _this.show();
                });
                _this._targetEl.addEventListener(ev, function () {
                    _this.show();
                });
            });
            triggerEventTypes.hideEvents.forEach(function (ev) {
                _this._parentEl.addEventListener(ev, function () {
                    if (!_this._parentEl.matches(':hover')) {
                        _this.hide();
                    }
                });
            });
        }
    };
    Dial.prototype.hide = function () {
        this._targetEl.classList.add('hidden');
        if (this._triggerEl) {
            this._triggerEl.setAttribute('aria-expanded', 'false');
        }
        this._visible = false;
        // callback function
        this._options.onHide(this);
    };
    Dial.prototype.show = function () {
        this._targetEl.classList.remove('hidden');
        if (this._triggerEl) {
            this._triggerEl.setAttribute('aria-expanded', 'true');
        }
        this._visible = true;
        // callback function
        this._options.onShow(this);
    };
    Dial.prototype.toggle = function () {
        if (this._visible) {
            this.hide();
        }
        else {
            this.show();
        }
    };
    Dial.prototype.isHidden = function () {
        return !this._visible;
    };
    Dial.prototype.isVisible = function () {
        return this._visible;
    };
    Dial.prototype._getTriggerEventTypes = function (triggerType) {
        switch (triggerType) {
            case 'hover':
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
            case 'click':
                return {
                    showEvents: ['click', 'focus'],
                    hideEvents: ['focusout', 'blur'],
                };
            case 'none':
                return {
                    showEvents: [],
                    hideEvents: [],
                };
            default:
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
        }
    };
    return Dial;
}());
if (typeof window !== 'undefined') {
    window.Dial = Dial;
}
function initDials() {
    document.querySelectorAll('[data-dial-init]').forEach(function ($parentEl) {
        var $triggerEl = $parentEl.querySelector('[data-dial-toggle]');
        if ($triggerEl) {
            var dialId = $triggerEl.getAttribute('data-dial-toggle');
            var $dialEl = document.getElementById(dialId);
            if ($dialEl) {
                var triggerType = $triggerEl.getAttribute('data-dial-trigger');
                new Dial($parentEl, $triggerEl, $dialEl, {
                    triggerType: triggerType
                        ? triggerType
                        : Default.triggerType,
                });
            }
            else {
                console.error("Dial with id ".concat(dialId, " does not exist. Are you sure that the data-dial-toggle attribute points to the correct modal id?"));
            }
        }
        else {
            console.error("Dial with id ".concat($parentEl.id, " does not have a trigger element. Are you sure that the data-dial-toggle attribute exists?"));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dial);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dial/interface.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dial/interface.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dial/types.js":
/*!****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dial/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dismiss/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dismiss/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initDismisses": () => (/* binding */ initDismisses)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    transition: 'transition-opacity',
    duration: 300,
    timing: 'ease-out',
    onHide: function () { },
};
var Dismiss = /** @class */ (function () {
    function Dismiss(targetEl, triggerEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (triggerEl === void 0) { triggerEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign(__assign({}, Default), options);
        this._init();
    }
    Dismiss.prototype._init = function () {
        var _this = this;
        if (this._triggerEl) {
            this._triggerEl.addEventListener('click', function () {
                _this.hide();
            });
        }
    };
    Dismiss.prototype.hide = function () {
        var _this = this;
        this._targetEl.classList.add(this._options.transition, "duration-".concat(this._options.duration), this._options.timing, 'opacity-0');
        setTimeout(function () {
            _this._targetEl.classList.add('hidden');
        }, this._options.duration);
        // callback function
        this._options.onHide(this, this._targetEl);
    };
    return Dismiss;
}());
if (typeof window !== 'undefined') {
    window.Dismiss = Dismiss;
}
function initDismisses() {
    document.querySelectorAll('[data-dismiss-target]').forEach(function ($triggerEl) {
        var targetId = $triggerEl.getAttribute('data-dismiss-target');
        var $dismissEl = document.querySelector(targetId);
        if ($dismissEl) {
            new Dismiss($dismissEl, $triggerEl);
        }
        else {
            console.error("The dismiss element with id \"".concat(targetId, "\" does not exist. Please check the data-dismiss-target attribute."));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dismiss);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dismiss/interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dismiss/interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dismiss/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dismiss/types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/drawer/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/drawer/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initDrawers": () => (/* binding */ initDrawers)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    placement: 'left',
    bodyScrolling: false,
    backdrop: true,
    edge: false,
    edgeOffset: 'bottom-[60px]',
    backdropClasses: 'bg-gray-900 bg-opacity-50 dark:bg-opacity-80 fixed inset-0 z-30',
    onShow: function () { },
    onHide: function () { },
    onToggle: function () { },
};
var Drawer = /** @class */ (function () {
    function Drawer(targetEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._options = __assign(__assign({}, Default), options);
        this._visible = false;
        this._init();
    }
    Drawer.prototype._init = function () {
        var _this = this;
        // set initial accessibility attributes
        if (this._targetEl) {
            this._targetEl.setAttribute('aria-hidden', 'true');
            this._targetEl.classList.add('transition-transform');
        }
        // set base placement classes
        this._getPlacementClasses(this._options.placement).base.map(function (c) {
            _this._targetEl.classList.add(c);
        });
        // add keyboard event listener to document
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                // if 'Escape' key is pressed
                if (_this.isVisible()) {
                    // if the Drawer is visible
                    _this.hide(); // hide the Drawer
                }
            }
        });
    };
    Drawer.prototype.hide = function () {
        var _this = this;
        // based on the edge option show placement classes
        if (this._options.edge) {
            this._getPlacementClasses(this._options.placement + '-edge').active.map(function (c) {
                _this._targetEl.classList.remove(c);
            });
            this._getPlacementClasses(this._options.placement + '-edge').inactive.map(function (c) {
                _this._targetEl.classList.add(c);
            });
        }
        else {
            this._getPlacementClasses(this._options.placement).active.map(function (c) {
                _this._targetEl.classList.remove(c);
            });
            this._getPlacementClasses(this._options.placement).inactive.map(function (c) {
                _this._targetEl.classList.add(c);
            });
        }
        // set accessibility attributes
        this._targetEl.setAttribute('aria-hidden', 'true');
        this._targetEl.removeAttribute('aria-modal');
        this._targetEl.removeAttribute('role');
        // enable body scroll
        if (!this._options.bodyScrolling) {
            document.body.classList.remove('overflow-hidden');
        }
        // destroy backdrop
        if (this._options.backdrop) {
            this._destroyBackdropEl();
        }
        this._visible = false;
        // callback function
        this._options.onHide(this);
    };
    Drawer.prototype.show = function () {
        var _this = this;
        if (this._options.edge) {
            this._getPlacementClasses(this._options.placement + '-edge').active.map(function (c) {
                _this._targetEl.classList.add(c);
            });
            this._getPlacementClasses(this._options.placement + '-edge').inactive.map(function (c) {
                _this._targetEl.classList.remove(c);
            });
        }
        else {
            this._getPlacementClasses(this._options.placement).active.map(function (c) {
                _this._targetEl.classList.add(c);
            });
            this._getPlacementClasses(this._options.placement).inactive.map(function (c) {
                _this._targetEl.classList.remove(c);
            });
        }
        // set accessibility attributes
        this._targetEl.setAttribute('aria-modal', 'true');
        this._targetEl.setAttribute('role', 'dialog');
        this._targetEl.removeAttribute('aria-hidden');
        // disable body scroll
        if (!this._options.bodyScrolling) {
            document.body.classList.add('overflow-hidden');
        }
        // show backdrop
        if (this._options.backdrop) {
            this._createBackdrop();
        }
        this._visible = true;
        // callback function
        this._options.onShow(this);
    };
    Drawer.prototype.toggle = function () {
        if (this.isVisible()) {
            this.hide();
        }
        else {
            this.show();
        }
    };
    Drawer.prototype._createBackdrop = function () {
        var _a;
        var _this = this;
        if (!this._visible) {
            var backdropEl = document.createElement('div');
            backdropEl.setAttribute('drawer-backdrop', '');
            (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(' '));
            document.querySelector('body').append(backdropEl);
            backdropEl.addEventListener('click', function () {
                _this.hide();
            });
        }
    };
    Drawer.prototype._destroyBackdropEl = function () {
        if (this._visible) {
            document.querySelector('[drawer-backdrop]').remove();
        }
    };
    Drawer.prototype._getPlacementClasses = function (placement) {
        switch (placement) {
            case 'top':
                return {
                    base: ['top-0', 'left-0', 'right-0'],
                    active: ['transform-none'],
                    inactive: ['-translate-y-full'],
                };
            case 'right':
                return {
                    base: ['right-0', 'top-0'],
                    active: ['transform-none'],
                    inactive: ['translate-x-full'],
                };
            case 'bottom':
                return {
                    base: ['bottom-0', 'left-0', 'right-0'],
                    active: ['transform-none'],
                    inactive: ['translate-y-full'],
                };
            case 'left':
                return {
                    base: ['left-0', 'top-0'],
                    active: ['transform-none'],
                    inactive: ['-translate-x-full'],
                };
            case 'bottom-edge':
                return {
                    base: ['left-0', 'top-0'],
                    active: ['transform-none'],
                    inactive: ['translate-y-full', this._options.edgeOffset],
                };
            default:
                return {
                    base: ['left-0', 'top-0'],
                    active: ['transform-none'],
                    inactive: ['-translate-x-full'],
                };
        }
    };
    Drawer.prototype.isHidden = function () {
        return !this._visible;
    };
    Drawer.prototype.isVisible = function () {
        return this._visible;
    };
    return Drawer;
}());
if (typeof window !== 'undefined') {
    window.Drawer = Drawer;
}
var getDrawerInstance = function (id, instances) {
    if (instances.some(function (drawerInstance) { return drawerInstance.id === id; })) {
        return instances.find(function (drawerInstance) { return drawerInstance.id === id; });
    }
};
function initDrawers() {
    var drawerInstances = [];
    document.querySelectorAll('[data-drawer-target]').forEach(function ($triggerEl) {
        // mandatory
        var drawerId = $triggerEl.getAttribute('data-drawer-target');
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
            // optional
            var placement = $triggerEl.getAttribute('data-drawer-placement');
            var bodyScrolling = $triggerEl.getAttribute('data-drawer-body-scrolling');
            var backdrop = $triggerEl.getAttribute('data-drawer-backdrop');
            var edge = $triggerEl.getAttribute('data-drawer-edge');
            var edgeOffset = $triggerEl.getAttribute('data-drawer-edge-offset');
            if (!getDrawerInstance(drawerId, drawerInstances)) {
                drawerInstances.push({
                    id: drawerId,
                    object: new Drawer($drawerEl, {
                        placement: placement ? placement : Default.placement,
                        bodyScrolling: bodyScrolling
                            ? bodyScrolling === 'true'
                                ? true
                                : false
                            : Default.bodyScrolling,
                        backdrop: backdrop
                            ? backdrop === 'true'
                                ? true
                                : false
                            : Default.backdrop,
                        edge: edge
                            ? edge === 'true'
                                ? true
                                : false
                            : Default.edge,
                        edgeOffset: edgeOffset
                            ? edgeOffset
                            : Default.edgeOffset,
                    }),
                });
            }
        }
        else {
            console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
        }
    });
    document.querySelectorAll('[data-drawer-toggle]').forEach(function ($triggerEl) {
        var drawerId = $triggerEl.getAttribute('data-drawer-toggle');
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
            var drawer_1 = getDrawerInstance(drawerId, drawerInstances);
            if (drawer_1) {
                $triggerEl.addEventListener('click', function () {
                    drawer_1.object.toggle();
                });
            }
            else {
                console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
            }
        }
        else {
            console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
        }
    });
    document
        .querySelectorAll('[data-drawer-dismiss], [data-drawer-hide]')
        .forEach(function ($triggerEl) {
        var drawerId = $triggerEl.getAttribute('data-drawer-dismiss')
            ? $triggerEl.getAttribute('data-drawer-dismiss')
            : $triggerEl.getAttribute('data-drawer-hide');
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
            var drawer_2 = getDrawerInstance(drawerId, drawerInstances);
            if (drawer_2) {
                $triggerEl.addEventListener('click', function () {
                    drawer_2.object.hide();
                });
            }
            else {
                console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
            }
        }
        else {
            console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id"));
        }
    });
    document.querySelectorAll('[data-drawer-show]').forEach(function ($triggerEl) {
        var drawerId = $triggerEl.getAttribute('data-drawer-show');
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
            var drawer_3 = getDrawerInstance(drawerId, drawerInstances);
            if (drawer_3) {
                $triggerEl.addEventListener('click', function () {
                    drawer_3.object.show();
                });
            }
            else {
                console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
            }
        }
        else {
            console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Drawer);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/drawer/interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/drawer/interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/drawer/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/drawer/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dropdown/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dropdown/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initDropdowns": () => (/* binding */ initDropdowns)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/* eslint-disable @typescript-eslint/no-empty-function */

var Default = {
    placement: 'bottom',
    triggerType: 'click',
    offsetSkidding: 0,
    offsetDistance: 10,
    delay: 300,
    onShow: function () { },
    onHide: function () { },
    onToggle: function () { },
};
var Dropdown = /** @class */ (function () {
    function Dropdown(targetElement, triggerElement, options) {
        if (targetElement === void 0) { targetElement = null; }
        if (triggerElement === void 0) { triggerElement = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetElement;
        this._triggerEl = triggerElement;
        this._options = __assign(__assign({}, Default), options);
        this._popperInstance = this._createPopperInstance();
        this._visible = false;
        this._init();
    }
    Dropdown.prototype._init = function () {
        if (this._triggerEl) {
            this._setupEventListeners();
        }
    };
    Dropdown.prototype._setupEventListeners = function () {
        var _this = this;
        var triggerEvents = this._getTriggerEvents();
        // click event handling for trigger element
        if (this._options.triggerType === 'click') {
            triggerEvents.showEvents.forEach(function (ev) {
                _this._triggerEl.addEventListener(ev, function () {
                    _this.toggle();
                });
            });
        }
        // hover event handling for trigger element
        if (this._options.triggerType === 'hover') {
            triggerEvents.showEvents.forEach(function (ev) {
                _this._triggerEl.addEventListener(ev, function () {
                    if (ev === 'click') {
                        _this.toggle();
                    }
                    else {
                        setTimeout(function () {
                            _this.show();
                        }, _this._options.delay);
                    }
                });
                _this._targetEl.addEventListener(ev, function () {
                    _this.show();
                });
            });
            triggerEvents.hideEvents.forEach(function (ev) {
                _this._triggerEl.addEventListener(ev, function () {
                    setTimeout(function () {
                        if (!_this._targetEl.matches(':hover')) {
                            _this.hide();
                        }
                    }, _this._options.delay);
                });
                _this._targetEl.addEventListener(ev, function () {
                    setTimeout(function () {
                        if (!_this._triggerEl.matches(':hover')) {
                            _this.hide();
                        }
                    }, _this._options.delay);
                });
            });
        }
    };
    Dropdown.prototype._createPopperInstance = function () {
        return (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(this._triggerEl, this._targetEl, {
            placement: this._options.placement,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [
                            this._options.offsetSkidding,
                            this._options.offsetDistance,
                        ],
                    },
                },
            ],
        });
    };
    Dropdown.prototype._setupClickOutsideListener = function () {
        var _this = this;
        this._clickOutsideEventListener = function (ev) {
            _this._handleClickOutside(ev, _this._targetEl);
        };
        document.body.addEventListener('click', this._clickOutsideEventListener, true);
    };
    Dropdown.prototype._removeClickOutsideListener = function () {
        document.body.removeEventListener('click', this._clickOutsideEventListener, true);
    };
    Dropdown.prototype._handleClickOutside = function (ev, targetEl) {
        var clickedEl = ev.target;
        if (clickedEl !== targetEl &&
            !targetEl.contains(clickedEl) &&
            !this._triggerEl.contains(clickedEl) &&
            this.isVisible()) {
            this.hide();
        }
    };
    Dropdown.prototype._getTriggerEvents = function () {
        switch (this._options.triggerType) {
            case 'hover':
                return {
                    showEvents: ['mouseenter', 'click'],
                    hideEvents: ['mouseleave'],
                };
            case 'click':
                return {
                    showEvents: ['click'],
                    hideEvents: [],
                };
            case 'none':
                return {
                    showEvents: [],
                    hideEvents: [],
                };
            default:
                return {
                    showEvents: ['click'],
                    hideEvents: [],
                };
        }
    };
    Dropdown.prototype.toggle = function () {
        if (this.isVisible()) {
            this.hide();
        }
        else {
            this.show();
        }
        this._options.onToggle(this);
    };
    Dropdown.prototype.isVisible = function () {
        return this._visible;
    };
    Dropdown.prototype.show = function () {
        this._targetEl.classList.remove('hidden');
        this._targetEl.classList.add('block');
        // Enable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: true },
            ], false) })); });
        this._setupClickOutsideListener();
        // Update its position
        this._popperInstance.update();
        this._visible = true;
        // callback function
        this._options.onShow(this);
    };
    Dropdown.prototype.hide = function () {
        this._targetEl.classList.remove('block');
        this._targetEl.classList.add('hidden');
        // Disable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: false },
            ], false) })); });
        this._visible = false;
        this._removeClickOutsideListener();
        // callback function
        this._options.onHide(this);
    };
    return Dropdown;
}());
if (typeof window !== 'undefined') {
    window.Dropdown = Dropdown;
}
function initDropdowns() {
    document
        .querySelectorAll('[data-dropdown-toggle]')
        .forEach(function ($triggerEl) {
        var dropdownId = $triggerEl.getAttribute('data-dropdown-toggle');
        var $dropdownEl = document.getElementById(dropdownId);
        if ($dropdownEl) {
            var placement = $triggerEl.getAttribute('data-dropdown-placement');
            var offsetSkidding = $triggerEl.getAttribute('data-dropdown-offset-skidding');
            var offsetDistance = $triggerEl.getAttribute('data-dropdown-offset-distance');
            var triggerType = $triggerEl.getAttribute('data-dropdown-trigger');
            var delay = $triggerEl.getAttribute('data-dropdown-delay');
            new Dropdown($dropdownEl, $triggerEl, {
                placement: placement ? placement : Default.placement,
                triggerType: triggerType
                    ? triggerType
                    : Default.triggerType,
                offsetSkidding: offsetSkidding
                    ? parseInt(offsetSkidding)
                    : Default.offsetSkidding,
                offsetDistance: offsetDistance
                    ? parseInt(offsetDistance)
                    : Default.offsetDistance,
                delay: delay ? parseInt(delay) : Default.delay,
            });
        }
        else {
            console.error("The dropdown element with id \"".concat(dropdownId, "\" does not exist. Please check the data-dropdown-toggle attribute."));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dropdown);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dropdown/interface.js":
/*!************************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dropdown/interface.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dropdown/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dropdown/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initFlowbite": () => (/* binding */ initFlowbite)
/* harmony export */ });
/* harmony import */ var _accordion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accordion */ "./node_modules/flowbite/lib/esm/components/accordion/index.js");
/* harmony import */ var _carousel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./carousel */ "./node_modules/flowbite/lib/esm/components/carousel/index.js");
/* harmony import */ var _collapse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collapse */ "./node_modules/flowbite/lib/esm/components/collapse/index.js");
/* harmony import */ var _dial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dial */ "./node_modules/flowbite/lib/esm/components/dial/index.js");
/* harmony import */ var _dismiss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dismiss */ "./node_modules/flowbite/lib/esm/components/dismiss/index.js");
/* harmony import */ var _drawer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./drawer */ "./node_modules/flowbite/lib/esm/components/drawer/index.js");
/* harmony import */ var _dropdown__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dropdown */ "./node_modules/flowbite/lib/esm/components/dropdown/index.js");
/* harmony import */ var _modal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modal */ "./node_modules/flowbite/lib/esm/components/modal/index.js");
/* harmony import */ var _popover__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./popover */ "./node_modules/flowbite/lib/esm/components/popover/index.js");
/* harmony import */ var _tabs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tabs */ "./node_modules/flowbite/lib/esm/components/tabs/index.js");
/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tooltip */ "./node_modules/flowbite/lib/esm/components/tooltip/index.js");











function initFlowbite() {
    (0,_accordion__WEBPACK_IMPORTED_MODULE_0__.initAccordions)();
    (0,_collapse__WEBPACK_IMPORTED_MODULE_2__.initCollapses)();
    (0,_carousel__WEBPACK_IMPORTED_MODULE_1__.initCarousels)();
    (0,_dismiss__WEBPACK_IMPORTED_MODULE_4__.initDismisses)();
    (0,_dropdown__WEBPACK_IMPORTED_MODULE_6__.initDropdowns)();
    (0,_modal__WEBPACK_IMPORTED_MODULE_7__.initModals)();
    (0,_drawer__WEBPACK_IMPORTED_MODULE_5__.initDrawers)();
    (0,_tabs__WEBPACK_IMPORTED_MODULE_9__.initTabs)();
    (0,_tooltip__WEBPACK_IMPORTED_MODULE_10__.initTooltips)();
    (0,_popover__WEBPACK_IMPORTED_MODULE_8__.initPopovers)();
    (0,_dial__WEBPACK_IMPORTED_MODULE_3__.initDials)();
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/modal/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/modal/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initModals": () => (/* binding */ initModals)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    placement: 'center',
    backdropClasses: 'bg-gray-900 bg-opacity-50 dark:bg-opacity-80 fixed inset-0 z-40',
    backdrop: 'dynamic',
    closable: true,
    onHide: function () { },
    onShow: function () { },
    onToggle: function () { },
};
var Modal = /** @class */ (function () {
    function Modal(targetEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._options = __assign(__assign({}, Default), options);
        this._isHidden = true;
        this._backdropEl = null;
        this._init();
    }
    Modal.prototype._init = function () {
        var _this = this;
        if (this._targetEl) {
            this._getPlacementClasses().map(function (c) {
                _this._targetEl.classList.add(c);
            });
        }
    };
    Modal.prototype._createBackdrop = function () {
        var _a;
        if (this._isHidden) {
            var backdropEl = document.createElement('div');
            backdropEl.setAttribute('modal-backdrop', '');
            (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(' '));
            document.querySelector('body').append(backdropEl);
            this._backdropEl = backdropEl;
        }
    };
    Modal.prototype._destroyBackdropEl = function () {
        if (!this._isHidden) {
            document.querySelector('[modal-backdrop]').remove();
        }
    };
    Modal.prototype._setupModalCloseEventListeners = function () {
        var _this = this;
        if (this._options.backdrop === 'dynamic') {
            this._clickOutsideEventListener = function (ev) {
                _this._handleOutsideClick(ev.target);
            };
            this._targetEl.addEventListener('click', this._clickOutsideEventListener, true);
        }
        this._keydownEventListener = function (ev) {
            if (ev.key === 'Escape') {
                _this.hide();
            }
        };
        document.body.addEventListener('keydown', this._keydownEventListener, true);
    };
    Modal.prototype._removeModalCloseEventListeners = function () {
        if (this._options.backdrop === 'dynamic') {
            this._targetEl.removeEventListener('click', this._clickOutsideEventListener, true);
        }
        document.body.removeEventListener('keydown', this._keydownEventListener, true);
    };
    Modal.prototype._handleOutsideClick = function (target) {
        if (target === this._targetEl ||
            (target === this._backdropEl && this.isVisible())) {
            this.hide();
        }
    };
    Modal.prototype._getPlacementClasses = function () {
        switch (this._options.placement) {
            // top
            case 'top-left':
                return ['justify-start', 'items-start'];
            case 'top-center':
                return ['justify-center', 'items-start'];
            case 'top-right':
                return ['justify-end', 'items-start'];
            // center
            case 'center-left':
                return ['justify-start', 'items-center'];
            case 'center':
                return ['justify-center', 'items-center'];
            case 'center-right':
                return ['justify-end', 'items-center'];
            // bottom
            case 'bottom-left':
                return ['justify-start', 'items-end'];
            case 'bottom-center':
                return ['justify-center', 'items-end'];
            case 'bottom-right':
                return ['justify-end', 'items-end'];
            default:
                return ['justify-center', 'items-center'];
        }
    };
    Modal.prototype.toggle = function () {
        if (this._isHidden) {
            this.show();
        }
        else {
            this.hide();
        }
        // callback function
        this._options.onToggle(this);
    };
    Modal.prototype.show = function () {
        if (this.isHidden) {
            this._targetEl.classList.add('flex');
            this._targetEl.classList.remove('hidden');
            this._targetEl.setAttribute('aria-modal', 'true');
            this._targetEl.setAttribute('role', 'dialog');
            this._targetEl.removeAttribute('aria-hidden');
            this._createBackdrop();
            this._isHidden = false;
            // prevent body scroll
            document.body.classList.add('overflow-hidden');
            // Add keyboard event listener to the document
            if (this._options.closable) {
                this._setupModalCloseEventListeners();
            }
            // callback function
            this._options.onShow(this);
        }
    };
    Modal.prototype.hide = function () {
        if (this.isVisible) {
            this._targetEl.classList.add('hidden');
            this._targetEl.classList.remove('flex');
            this._targetEl.setAttribute('aria-hidden', 'true');
            this._targetEl.removeAttribute('aria-modal');
            this._targetEl.removeAttribute('role');
            this._destroyBackdropEl();
            this._isHidden = true;
            // re-apply body scroll
            document.body.classList.remove('overflow-hidden');
            if (this._options.closable) {
                this._removeModalCloseEventListeners();
            }
            // callback function
            this._options.onHide(this);
        }
    };
    Modal.prototype.isVisible = function () {
        return !this._isHidden;
    };
    Modal.prototype.isHidden = function () {
        return this._isHidden;
    };
    return Modal;
}());
if (typeof window !== 'undefined') {
    window.Modal = Modal;
}
var getModalInstance = function (id, instances) {
    if (instances.some(function (modalInstance) { return modalInstance.id === id; })) {
        return instances.find(function (modalInstance) { return modalInstance.id === id; });
    }
    return null;
};
function initModals() {
    var modalInstances = [];
    // initiate modal based on data-modal-target
    document.querySelectorAll('[data-modal-target]').forEach(function ($triggerEl) {
        var modalId = $triggerEl.getAttribute('data-modal-target');
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
            var placement = $modalEl.getAttribute('data-modal-placement');
            var backdrop = $modalEl.getAttribute('data-modal-backdrop');
            if (!getModalInstance(modalId, modalInstances)) {
                modalInstances.push({
                    id: modalId,
                    object: new Modal($modalEl, {
                        placement: placement
                            ? placement
                            : Default.placement,
                        backdrop: backdrop ? backdrop : Default.backdrop,
                    }),
                });
            }
        }
        else {
            console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-target attribute points to the correct modal id?."));
        }
    });
    // support pre v1.6.0 data-modal-toggle initialization
    document.querySelectorAll('[data-modal-toggle]').forEach(function ($triggerEl) {
        var modalId = $triggerEl.getAttribute('data-modal-toggle');
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
            var placement = $modalEl.getAttribute('data-modal-placement');
            var backdrop = $modalEl.getAttribute('data-modal-backdrop');
            var modal_1 = getModalInstance(modalId, modalInstances);
            if (!modal_1) {
                modal_1 = {
                    id: modalId,
                    object: new Modal($modalEl, {
                        placement: placement
                            ? placement
                            : Default.placement,
                        backdrop: backdrop ? backdrop : Default.backdrop,
                    }),
                };
                modalInstances.push(modal_1);
            }
            $triggerEl.addEventListener('click', function () {
                modal_1.object.toggle();
            });
        }
        else {
            console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-toggle attribute points to the correct modal id?"));
        }
    });
    // show modal on click if exists based on id
    document.querySelectorAll('[data-modal-show]').forEach(function ($triggerEl) {
        var modalId = $triggerEl.getAttribute('data-modal-show');
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
            var modal_2 = getModalInstance(modalId, modalInstances);
            if (modal_2) {
                $triggerEl.addEventListener('click', function () {
                    if (modal_2.object.isHidden) {
                        modal_2.object.show();
                    }
                });
            }
            else {
                console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
            }
        }
        else {
            console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-show attribute points to the correct modal id?"));
        }
    });
    // hide modal on click if exists based on id
    document.querySelectorAll('[data-modal-hide]').forEach(function ($triggerEl) {
        var modalId = $triggerEl.getAttribute('data-modal-hide');
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
            var modal_3 = getModalInstance(modalId, modalInstances);
            if (modal_3) {
                $triggerEl.addEventListener('click', function () {
                    if (modal_3.object.isVisible) {
                        modal_3.object.hide();
                    }
                });
            }
            else {
                console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
            }
        }
        else {
            console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-hide attribute points to the correct modal id?"));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Modal);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/modal/interface.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/modal/interface.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/modal/types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/modal/types.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/popover/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/popover/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initPopovers": () => (/* binding */ initPopovers)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/* eslint-disable @typescript-eslint/no-empty-function */

var Default = {
    placement: 'top',
    offset: 10,
    triggerType: 'hover',
    onShow: function () { },
    onHide: function () { },
    onToggle: function () { },
};
var Popover = /** @class */ (function () {
    function Popover(targetEl, triggerEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (triggerEl === void 0) { triggerEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign(__assign({}, Default), options);
        this._popperInstance = this._createPopperInstance();
        this._visible = false;
        this._init();
    }
    Popover.prototype._init = function () {
        if (this._triggerEl) {
            this._setupEventListeners();
        }
    };
    Popover.prototype._setupEventListeners = function () {
        var _this = this;
        var triggerEvents = this._getTriggerEvents();
        triggerEvents.showEvents.forEach(function (ev) {
            _this._triggerEl.addEventListener(ev, function () {
                _this.show();
            });
            _this._targetEl.addEventListener(ev, function () {
                _this.show();
            });
        });
        triggerEvents.hideEvents.forEach(function (ev) {
            _this._triggerEl.addEventListener(ev, function () {
                setTimeout(function () {
                    if (!_this._targetEl.matches(':hover')) {
                        _this.hide();
                    }
                }, 100);
            });
            _this._targetEl.addEventListener(ev, function () {
                setTimeout(function () {
                    if (!_this._triggerEl.matches(':hover')) {
                        _this.hide();
                    }
                }, 100);
            });
        });
    };
    Popover.prototype._createPopperInstance = function () {
        return (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(this._triggerEl, this._targetEl, {
            placement: this._options.placement,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, this._options.offset],
                    },
                },
            ],
        });
    };
    Popover.prototype._getTriggerEvents = function () {
        switch (this._options.triggerType) {
            case 'hover':
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
            case 'click':
                return {
                    showEvents: ['click', 'focus'],
                    hideEvents: ['focusout', 'blur'],
                };
            case 'none':
                return {
                    showEvents: [],
                    hideEvents: [],
                };
            default:
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
        }
    };
    Popover.prototype._setupKeydownListener = function () {
        var _this = this;
        this._keydownEventListener = function (ev) {
            if (ev.key === 'Escape') {
                _this.hide();
            }
        };
        document.body.addEventListener('keydown', this._keydownEventListener, true);
    };
    Popover.prototype._removeKeydownListener = function () {
        document.body.removeEventListener('keydown', this._keydownEventListener, true);
    };
    Popover.prototype._setupClickOutsideListener = function () {
        var _this = this;
        this._clickOutsideEventListener = function (ev) {
            _this._handleClickOutside(ev, _this._targetEl);
        };
        document.body.addEventListener('click', this._clickOutsideEventListener, true);
    };
    Popover.prototype._removeClickOutsideListener = function () {
        document.body.removeEventListener('click', this._clickOutsideEventListener, true);
    };
    Popover.prototype._handleClickOutside = function (ev, targetEl) {
        var clickedEl = ev.target;
        if (clickedEl !== targetEl &&
            !targetEl.contains(clickedEl) &&
            !this._triggerEl.contains(clickedEl) &&
            this.isVisible()) {
            this.hide();
        }
    };
    Popover.prototype.isVisible = function () {
        return this._visible;
    };
    Popover.prototype.toggle = function () {
        if (this.isVisible()) {
            this.hide();
        }
        else {
            this.show();
        }
        this._options.onToggle(this);
    };
    Popover.prototype.show = function () {
        this._targetEl.classList.remove('opacity-0', 'invisible');
        this._targetEl.classList.add('opacity-100', 'visible');
        // Enable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: true },
            ], false) })); });
        // handle click outside
        this._setupClickOutsideListener();
        // handle esc keydown
        this._setupKeydownListener();
        // Update its position
        this._popperInstance.update();
        // set visibility to true
        this._visible = true;
        // callback function
        this._options.onShow(this);
    };
    Popover.prototype.hide = function () {
        this._targetEl.classList.remove('opacity-100', 'visible');
        this._targetEl.classList.add('opacity-0', 'invisible');
        // Disable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: false },
            ], false) })); });
        // handle click outside
        this._removeClickOutsideListener();
        // handle esc keydown
        this._removeKeydownListener();
        // set visibility to false
        this._visible = false;
        // callback function
        this._options.onHide(this);
    };
    return Popover;
}());
if (typeof window !== 'undefined') {
    window.Popover = Popover;
}
function initPopovers() {
    document.querySelectorAll('[data-popover-target]').forEach(function ($triggerEl) {
        var popoverID = $triggerEl.getAttribute('data-popover-target');
        var $popoverEl = document.getElementById(popoverID);
        if ($popoverEl) {
            var triggerType = $triggerEl.getAttribute('data-popover-trigger');
            var placement = $triggerEl.getAttribute('data-popover-placement');
            var offset = $triggerEl.getAttribute('data-popover-offset');
            new Popover($popoverEl, $triggerEl, {
                placement: placement ? placement : Default.placement,
                offset: offset ? parseInt(offset) : Default.offset,
                triggerType: triggerType
                    ? triggerType
                    : Default.triggerType,
            });
        }
        else {
            console.error("The popover element with id \"".concat(popoverID, "\" does not exist. Please check the data-popover-target attribute."));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Popover);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/popover/interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/popover/interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/popover/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/popover/types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tabs/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tabs/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initTabs": () => (/* binding */ initTabs)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    defaultTabId: null,
    activeClasses: 'text-blue-600 hover:text-blue-600 dark:text-blue-500 dark:hover:text-blue-500 border-blue-600 dark:border-blue-500',
    inactiveClasses: 'dark:border-transparent text-gray-500 hover:text-gray-600 dark:text-gray-400 border-gray-100 hover:border-gray-300 dark:border-gray-700 dark:hover:text-gray-300',
    onShow: function () { },
};
var Tabs = /** @class */ (function () {
    function Tabs(items, options) {
        if (items === void 0) { items = []; }
        if (options === void 0) { options = Default; }
        this._items = items;
        this._activeTab = options ? this.getTab(options.defaultTabId) : null;
        this._options = __assign(__assign({}, Default), options);
        this._init();
    }
    Tabs.prototype._init = function () {
        var _this = this;
        if (this._items.length) {
            // set the first tab as active if not set by explicitly
            if (!this._activeTab) {
                this._setActiveTab(this._items[0]);
            }
            // force show the first default tab
            this.show(this._activeTab.id, true);
            // show tab content based on click
            this._items.map(function (tab) {
                tab.triggerEl.addEventListener('click', function () {
                    _this.show(tab.id);
                });
            });
        }
    };
    Tabs.prototype.getActiveTab = function () {
        return this._activeTab;
    };
    Tabs.prototype._setActiveTab = function (tab) {
        this._activeTab = tab;
    };
    Tabs.prototype.getTab = function (id) {
        return this._items.filter(function (t) { return t.id === id; })[0];
    };
    Tabs.prototype.show = function (id, forceShow) {
        var _a, _b;
        var _this = this;
        if (forceShow === void 0) { forceShow = false; }
        var tab = this.getTab(id);
        // don't do anything if already active
        if (tab === this._activeTab && !forceShow) {
            return;
        }
        // hide other tabs
        this._items.map(function (t) {
            var _a, _b;
            if (t !== tab) {
                (_a = t.triggerEl.classList).remove.apply(_a, _this._options.activeClasses.split(' '));
                (_b = t.triggerEl.classList).add.apply(_b, _this._options.inactiveClasses.split(' '));
                t.targetEl.classList.add('hidden');
                t.triggerEl.setAttribute('aria-selected', 'false');
            }
        });
        // show active tab
        (_a = tab.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(' '));
        (_b = tab.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(' '));
        tab.triggerEl.setAttribute('aria-selected', 'true');
        tab.targetEl.classList.remove('hidden');
        this._setActiveTab(tab);
        // callback function
        this._options.onShow(this, tab);
    };
    return Tabs;
}());
if (typeof window !== 'undefined') {
    window.Tabs = Tabs;
}
function initTabs() {
    document.querySelectorAll('[data-tabs-toggle]').forEach(function ($triggerEl) {
        var tabItems = [];
        var defaultTabId = null;
        $triggerEl
            .querySelectorAll('[role="tab"]')
            .forEach(function ($triggerEl) {
            var isActive = $triggerEl.getAttribute('aria-selected') === 'true';
            var tab = {
                id: $triggerEl.getAttribute('data-tabs-target'),
                triggerEl: $triggerEl,
                targetEl: document.querySelector($triggerEl.getAttribute('data-tabs-target')),
            };
            tabItems.push(tab);
            if (isActive) {
                defaultTabId = tab.id;
            }
        });
        new Tabs(tabItems, {
            defaultTabId: defaultTabId,
        });
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tabs);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tabs/interface.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tabs/interface.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tabs/types.js":
/*!****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tabs/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tooltip/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tooltip/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initTooltips": () => (/* binding */ initTooltips)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/* eslint-disable @typescript-eslint/no-empty-function */

var Default = {
    placement: 'top',
    triggerType: 'hover',
    onShow: function () { },
    onHide: function () { },
    onToggle: function () { },
};
var Tooltip = /** @class */ (function () {
    function Tooltip(targetEl, triggerEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (triggerEl === void 0) { triggerEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign(__assign({}, Default), options);
        this._popperInstance = this._createPopperInstance();
        this._visible = false;
        this._init();
    }
    Tooltip.prototype._init = function () {
        if (this._triggerEl) {
            this._setupEventListeners();
        }
    };
    Tooltip.prototype._setupEventListeners = function () {
        var _this = this;
        var triggerEvents = this._getTriggerEvents();
        triggerEvents.showEvents.forEach(function (ev) {
            _this._triggerEl.addEventListener(ev, function () {
                _this.show();
            });
        });
        triggerEvents.hideEvents.forEach(function (ev) {
            _this._triggerEl.addEventListener(ev, function () {
                _this.hide();
            });
        });
    };
    Tooltip.prototype._createPopperInstance = function () {
        return (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(this._triggerEl, this._targetEl, {
            placement: this._options.placement,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, 8],
                    },
                },
            ],
        });
    };
    Tooltip.prototype._getTriggerEvents = function () {
        switch (this._options.triggerType) {
            case 'hover':
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
            case 'click':
                return {
                    showEvents: ['click', 'focus'],
                    hideEvents: ['focusout', 'blur'],
                };
            case 'none':
                return {
                    showEvents: [],
                    hideEvents: [],
                };
            default:
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
        }
    };
    Tooltip.prototype._setupKeydownListener = function () {
        var _this = this;
        this._keydownEventListener = function (ev) {
            if (ev.key === 'Escape') {
                _this.hide();
            }
        };
        document.body.addEventListener('keydown', this._keydownEventListener, true);
    };
    Tooltip.prototype._removeKeydownListener = function () {
        document.body.removeEventListener('keydown', this._keydownEventListener, true);
    };
    Tooltip.prototype._setupClickOutsideListener = function () {
        var _this = this;
        this._clickOutsideEventListener = function (ev) {
            _this._handleClickOutside(ev, _this._targetEl);
        };
        document.body.addEventListener('click', this._clickOutsideEventListener, true);
    };
    Tooltip.prototype._removeClickOutsideListener = function () {
        document.body.removeEventListener('click', this._clickOutsideEventListener, true);
    };
    Tooltip.prototype._handleClickOutside = function (ev, targetEl) {
        var clickedEl = ev.target;
        if (clickedEl !== targetEl &&
            !targetEl.contains(clickedEl) &&
            !this._triggerEl.contains(clickedEl) &&
            this.isVisible()) {
            this.hide();
        }
    };
    Tooltip.prototype.isVisible = function () {
        return this._visible;
    };
    Tooltip.prototype.toggle = function () {
        if (this.isVisible()) {
            this.hide();
        }
        else {
            this.show();
        }
    };
    Tooltip.prototype.show = function () {
        this._targetEl.classList.remove('opacity-0', 'invisible');
        this._targetEl.classList.add('opacity-100', 'visible');
        // Enable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: true },
            ], false) })); });
        // handle click outside
        this._setupClickOutsideListener();
        // handle esc keydown
        this._setupKeydownListener();
        // Update its position
        this._popperInstance.update();
        // set visibility
        this._visible = true;
        // callback function
        this._options.onShow(this);
    };
    Tooltip.prototype.hide = function () {
        this._targetEl.classList.remove('opacity-100', 'visible');
        this._targetEl.classList.add('opacity-0', 'invisible');
        // Disable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: false },
            ], false) })); });
        // handle click outside
        this._removeClickOutsideListener();
        // handle esc keydown
        this._removeKeydownListener();
        // set visibility
        this._visible = false;
        // callback function
        this._options.onHide(this);
    };
    return Tooltip;
}());
if (typeof window !== 'undefined') {
    window.Tooltip = Tooltip;
}
function initTooltips() {
    document.querySelectorAll('[data-tooltip-target]').forEach(function ($triggerEl) {
        var tooltipId = $triggerEl.getAttribute('data-tooltip-target');
        var $tooltipEl = document.getElementById(tooltipId);
        if ($tooltipEl) {
            var triggerType = $triggerEl.getAttribute('data-tooltip-trigger');
            var placement = $triggerEl.getAttribute('data-tooltip-placement');
            new Tooltip($tooltipEl, $triggerEl, {
                placement: placement ? placement : Default.placement,
                triggerType: triggerType
                    ? triggerType
                    : Default.triggerType,
            });
        }
        else {
            console.error("The tooltip element with id \"".concat(tooltipId, "\" does not exist. Please check the data-tooltip-target attribute."));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tooltip);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tooltip/interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tooltip/interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tooltip/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tooltip/types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/dom/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/dom/events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Events = /** @class */ (function () {
    function Events(eventType, eventFunctions) {
        if (eventFunctions === void 0) { eventFunctions = []; }
        this._eventType = eventType;
        this._eventFunctions = eventFunctions;
    }
    Events.prototype.init = function () {
        var _this = this;
        this._eventFunctions.forEach(function (eventFunction) {
            if (typeof window !== 'undefined') {
                window.addEventListener(_this._eventType, eventFunction);
            }
        });
    };
    return Events;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Events);
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Accordion": () => (/* reexport safe */ _components_accordion__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "Carousel": () => (/* reexport safe */ _components_carousel__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "Collapse": () => (/* reexport safe */ _components_collapse__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "Dial": () => (/* reexport safe */ _components_dial__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "Dismiss": () => (/* reexport safe */ _components_dismiss__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "Drawer": () => (/* reexport safe */ _components_drawer__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "Dropdown": () => (/* reexport safe */ _components_dropdown__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "Modal": () => (/* reexport safe */ _components_modal__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "Popover": () => (/* reexport safe */ _components_popover__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "Tabs": () => (/* reexport safe */ _components_tabs__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "Tooltip": () => (/* reexport safe */ _components_tooltip__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "initAccordions": () => (/* reexport safe */ _components_accordion__WEBPACK_IMPORTED_MODULE_1__.initAccordions),
/* harmony export */   "initCarousels": () => (/* reexport safe */ _components_carousel__WEBPACK_IMPORTED_MODULE_3__.initCarousels),
/* harmony export */   "initCollapses": () => (/* reexport safe */ _components_collapse__WEBPACK_IMPORTED_MODULE_2__.initCollapses),
/* harmony export */   "initDials": () => (/* reexport safe */ _components_dial__WEBPACK_IMPORTED_MODULE_11__.initDials),
/* harmony export */   "initDismisses": () => (/* reexport safe */ _components_dismiss__WEBPACK_IMPORTED_MODULE_4__.initDismisses),
/* harmony export */   "initDrawers": () => (/* reexport safe */ _components_drawer__WEBPACK_IMPORTED_MODULE_7__.initDrawers),
/* harmony export */   "initDropdowns": () => (/* reexport safe */ _components_dropdown__WEBPACK_IMPORTED_MODULE_5__.initDropdowns),
/* harmony export */   "initFlowbite": () => (/* reexport safe */ _components_index__WEBPACK_IMPORTED_MODULE_34__.initFlowbite),
/* harmony export */   "initModals": () => (/* reexport safe */ _components_modal__WEBPACK_IMPORTED_MODULE_6__.initModals),
/* harmony export */   "initPopovers": () => (/* reexport safe */ _components_popover__WEBPACK_IMPORTED_MODULE_10__.initPopovers),
/* harmony export */   "initTabs": () => (/* reexport safe */ _components_tabs__WEBPACK_IMPORTED_MODULE_8__.initTabs),
/* harmony export */   "initTooltips": () => (/* reexport safe */ _components_tooltip__WEBPACK_IMPORTED_MODULE_9__.initTooltips)
/* harmony export */ });
/* harmony import */ var _dom_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom/events */ "./node_modules/flowbite/lib/esm/dom/events.js");
/* harmony import */ var _components_accordion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/accordion */ "./node_modules/flowbite/lib/esm/components/accordion/index.js");
/* harmony import */ var _components_collapse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/collapse */ "./node_modules/flowbite/lib/esm/components/collapse/index.js");
/* harmony import */ var _components_carousel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/carousel */ "./node_modules/flowbite/lib/esm/components/carousel/index.js");
/* harmony import */ var _components_dismiss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/dismiss */ "./node_modules/flowbite/lib/esm/components/dismiss/index.js");
/* harmony import */ var _components_dropdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/dropdown */ "./node_modules/flowbite/lib/esm/components/dropdown/index.js");
/* harmony import */ var _components_modal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/modal */ "./node_modules/flowbite/lib/esm/components/modal/index.js");
/* harmony import */ var _components_drawer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/drawer */ "./node_modules/flowbite/lib/esm/components/drawer/index.js");
/* harmony import */ var _components_tabs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/tabs */ "./node_modules/flowbite/lib/esm/components/tabs/index.js");
/* harmony import */ var _components_tooltip__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/tooltip */ "./node_modules/flowbite/lib/esm/components/tooltip/index.js");
/* harmony import */ var _components_popover__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/popover */ "./node_modules/flowbite/lib/esm/components/popover/index.js");
/* harmony import */ var _components_dial__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/dial */ "./node_modules/flowbite/lib/esm/components/dial/index.js");
/* harmony import */ var _components_accordion_types__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/accordion/types */ "./node_modules/flowbite/lib/esm/components/accordion/types.js");
/* harmony import */ var _components_carousel_types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/carousel/types */ "./node_modules/flowbite/lib/esm/components/carousel/types.js");
/* harmony import */ var _components_collapse_types__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/collapse/types */ "./node_modules/flowbite/lib/esm/components/collapse/types.js");
/* harmony import */ var _components_dial_types__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/dial/types */ "./node_modules/flowbite/lib/esm/components/dial/types.js");
/* harmony import */ var _components_dismiss_types__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/dismiss/types */ "./node_modules/flowbite/lib/esm/components/dismiss/types.js");
/* harmony import */ var _components_drawer_types__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/drawer/types */ "./node_modules/flowbite/lib/esm/components/drawer/types.js");
/* harmony import */ var _components_dropdown_types__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/dropdown/types */ "./node_modules/flowbite/lib/esm/components/dropdown/types.js");
/* harmony import */ var _components_modal_types__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/modal/types */ "./node_modules/flowbite/lib/esm/components/modal/types.js");
/* harmony import */ var _components_popover_types__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./components/popover/types */ "./node_modules/flowbite/lib/esm/components/popover/types.js");
/* harmony import */ var _components_tabs_types__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/tabs/types */ "./node_modules/flowbite/lib/esm/components/tabs/types.js");
/* harmony import */ var _components_tooltip_types__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/tooltip/types */ "./node_modules/flowbite/lib/esm/components/tooltip/types.js");
/* harmony import */ var _components_accordion_interface__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/accordion/interface */ "./node_modules/flowbite/lib/esm/components/accordion/interface.js");
/* harmony import */ var _components_carousel_interface__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/carousel/interface */ "./node_modules/flowbite/lib/esm/components/carousel/interface.js");
/* harmony import */ var _components_collapse_interface__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/collapse/interface */ "./node_modules/flowbite/lib/esm/components/collapse/interface.js");
/* harmony import */ var _components_dial_interface__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./components/dial/interface */ "./node_modules/flowbite/lib/esm/components/dial/interface.js");
/* harmony import */ var _components_dismiss_interface__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./components/dismiss/interface */ "./node_modules/flowbite/lib/esm/components/dismiss/interface.js");
/* harmony import */ var _components_drawer_interface__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./components/drawer/interface */ "./node_modules/flowbite/lib/esm/components/drawer/interface.js");
/* harmony import */ var _components_dropdown_interface__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./components/dropdown/interface */ "./node_modules/flowbite/lib/esm/components/dropdown/interface.js");
/* harmony import */ var _components_modal_interface__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./components/modal/interface */ "./node_modules/flowbite/lib/esm/components/modal/interface.js");
/* harmony import */ var _components_popover_interface__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./components/popover/interface */ "./node_modules/flowbite/lib/esm/components/popover/interface.js");
/* harmony import */ var _components_tabs_interface__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./components/tabs/interface */ "./node_modules/flowbite/lib/esm/components/tabs/interface.js");
/* harmony import */ var _components_tooltip_interface__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./components/tooltip/interface */ "./node_modules/flowbite/lib/esm/components/tooltip/interface.js");
/* harmony import */ var _components_index__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./components/index */ "./node_modules/flowbite/lib/esm/components/index.js");












// setup events for data attributes
var events = new _dom_events__WEBPACK_IMPORTED_MODULE_0__["default"]('load', [
    _components_accordion__WEBPACK_IMPORTED_MODULE_1__.initAccordions,
    _components_collapse__WEBPACK_IMPORTED_MODULE_2__.initCollapses,
    _components_carousel__WEBPACK_IMPORTED_MODULE_3__.initCarousels,
    _components_dismiss__WEBPACK_IMPORTED_MODULE_4__.initDismisses,
    _components_dropdown__WEBPACK_IMPORTED_MODULE_5__.initDropdowns,
    _components_modal__WEBPACK_IMPORTED_MODULE_6__.initModals,
    _components_drawer__WEBPACK_IMPORTED_MODULE_7__.initDrawers,
    _components_tabs__WEBPACK_IMPORTED_MODULE_8__.initTabs,
    _components_tooltip__WEBPACK_IMPORTED_MODULE_9__.initTooltips,
    _components_popover__WEBPACK_IMPORTED_MODULE_10__.initPopovers,
    _components_dial__WEBPACK_IMPORTED_MODULE_11__.initDials,
]);
events.init();
// export all components











// export all types











// export all interfaces











// export init functions











// export all init functions

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./src/inbound_order/add.ts":
/*!**********************************!*\
  !*** ./src/inbound_order/add.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initAddInboundOrderModal = void 0;
var flowbite_1 = __webpack_require__(/*! flowbite */ "./node_modules/flowbite/lib/esm/index.js");
var createInboundOrderHandler = function () {
    var createInboundOrderBtn = document.getElementById('inbound-order-create-btn');
    var createInboundOrderBtnSubmit = document.getElementById('inbound-order-add-submit-btn');
    if (!createInboundOrderBtn) {
        console.log("Error: no create inbound order button");
        return;
    }
    createInboundOrderBtn.addEventListener('click', function () {
        var allocatedProductsData = [];
        // Set products as JSON to field
        var productsAllocatedContainers = document.querySelectorAll('.product-allocated');
        productsAllocatedContainers.forEach(function (productContainer) {
            var _a;
            // Get HTML nodes with product values
            var productAllocatedQuantityInput = productContainer.querySelector('.product-allocated-quantity');
            var productAllocatedShelfLifeStartInput = productContainer.querySelector('.product-allocated-shelf-life-start');
            var productAllocatedShelfLifeEndInput = productContainer.querySelector('.product-allocated-shelf-life-end');
            var productId;
            var inputField = productContainer.querySelector('#inbound-order-add-add-product-select');
            var selectedOption = productContainer.querySelector("#product-list option[value=\"".concat(inputField.value, "\"]"));
            if (!selectedOption) {
                event.preventDefault();
                alert('Please select a valid product from the list');
            }
            productId = (_a = parseInt(selectedOption.getAttribute('data-product-id'))) !== null && _a !== void 0 ? _a : 0;
            // Retrieve values from Nodes
            var productAllocatedQuantity = parseInt(productAllocatedQuantityInput.value);
            var productAllocatedShelfLifeStart = productAllocatedShelfLifeStartInput.value;
            var productAllocatedShelfLifeEnd = productAllocatedShelfLifeEndInput.value;
            allocatedProductsData.push({
                id: productId,
                quantity: productAllocatedQuantity,
                shelfLifeStart: productAllocatedShelfLifeStart,
                shelfLifeEnd: productAllocatedShelfLifeEnd,
            });
        });
        var inputProducts = document.querySelector("#inbound-order-add-products");
        inputProducts.value = JSON.stringify(allocatedProductsData);
        createInboundOrderBtnSubmit.click();
    });
};
var initAddInboundOrderModal = function () {
    var addModalButton = document.querySelector('#inbound-order-add-modal-button');
    var addInboundOrderModalElement = document.querySelector('#add-inbound-order-modal');
    var addModalOptions = {
        placement: 'bottom-right',
        backdrop: 'dynamic',
        backdropClasses: 'bg-gray-900 bg-opacity-50 dark:bg-opacity-80 fixed inset-0 z-40',
        closable: true,
        onHide: function () {
            console.log('inbound-order id: ');
        },
        onShow: function () {
            console.log('inbound-order id: ');
        },
        onToggle: function () {
            console.log('modal has been toggled');
        },
    };
    var addModal = new flowbite_1.Modal(addInboundOrderModalElement, addModalOptions);
    addModalButton.addEventListener('click', function () {
        addModal.show();
    });
    var addModalCloseButton = document.querySelector('#add-modal-btn-hide');
    addModalCloseButton.addEventListener('click', function () {
        addModal.hide();
    });
    createInboundOrderHandler();
};
exports.initAddInboundOrderModal = initAddInboundOrderModal;


/***/ }),

/***/ "./src/inbound_order/edit.ts":
/*!***********************************!*\
  !*** ./src/inbound_order/edit.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initEditOrderModal = void 0;
var flowbite_1 = __webpack_require__(/*! flowbite */ "./node_modules/flowbite/lib/esm/index.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./src/inbound_order/utils.ts");
var setNewQuantityView = function (quantityGroupContainer) {
    var quantitiesPerGroup = quantityGroupContainer.querySelectorAll('.inbound-order-edit-add-quantity');
    var quantityView = quantityGroupContainer.querySelector('.inbound-order-edit-check-quantity');
    var quantityAvailable = parseInt(quantityView.getAttribute('data-quantity'));
    var quantityTotal = 0;
    quantitiesPerGroup.forEach(function (quantityPerGroup) {
        if (quantityPerGroup.value) {
            quantityTotal += parseInt(quantityPerGroup.value);
        }
    });
    quantityView.innerHTML = (quantityAvailable - quantityTotal).toString();
};
var createProductGroup = function (allocatedProductContainer) {
    var groupItemTemplate = document.querySelector('.group-quantity-item');
    var groupQuantityItemNew = groupItemTemplate.cloneNode(true);
    groupQuantityItemNew.classList.remove('invisible');
    groupQuantityItemNew.querySelector('#inbound-order-edit-add-group').addEventListener('change', function (e) {
        var uploadGroupInput = e.target;
        var option = uploadGroupInput.list.querySelector('option[value="' + uploadGroupInput.value + '"]');
        // NOTE Use large number if no group selected. Impossible to reach that number in prod.
        // Used to avoid wrong validation in backend wtform when pass 0 and get None
        var groupId;
        if (uploadGroupInput.value) {
            groupId = option.getAttribute('inbound-order-edit-add-group-id');
        }
        else {
            groupId = '';
        }
        var hiddenInput = groupQuantityItemNew.querySelector('#inbound-order-edit-add-group-hidden');
        hiddenInput.value = groupId.toString();
    });
    var buttonDeleteQuantityGroup = groupQuantityItemNew.querySelector('.quantity-group-delete-button');
    buttonDeleteQuantityGroup.addEventListener('click', function (e) {
        groupQuantityItemNew.remove();
        setNewQuantityView(allocatedProductContainer);
    });
    var quantityInput = groupQuantityItemNew.querySelector('.inbound-order-edit-add-quantity');
    var quantityView = allocatedProductContainer.querySelector('.inbound-order-edit-check-quantity');
    var quantitiesGroupInputs = allocatedProductContainer.querySelectorAll('.inbound-order-edit-add-quantity');
    var quantityLeft = parseInt(quantityView.getAttribute('data-quantity'));
    quantitiesGroupInputs.forEach(function (quantityGroupInput) {
        if (quantityGroupInput.value) {
            quantityLeft -= parseInt(quantityGroupInput.value);
        }
    });
    quantityInput.value = quantityLeft.toString();
    allocatedProductContainer.querySelector('.inbound-order-add-product-group-btn').before(groupQuantityItemNew);
    quantityInput.addEventListener('input', function (e) {
        setNewQuantityView(allocatedProductContainer);
    });
    setNewQuantityView(allocatedProductContainer);
    return groupQuantityItemNew;
};
var initEditOrderModal = function () {
    // Nodes
    var orderEditProductsAllocatedContainer = document.querySelector('#inbound-order-edit-check-container');
    var orderEditModalHTML = document.querySelector('#edit-inbound-order-modal');
    var orderEditButtons = document.querySelectorAll('.inbound-order-edit-button');
    var orderUuidInput = document.querySelector('#inbound-order-uuid');
    var orderStatusSelect = document.querySelector('#inbound-order-edit-status');
    var orderStatusDiv = document.querySelector('#inbound-order-edit-status-div');
    var orderTitleInput = document.querySelector('#inbound-order-edit-order-title');
    var orderActiveDateInput = document.querySelector('#inbound-order-edit-active-date');
    var orderActiveTimeInput = document.querySelector('#inbound-order-edit-active-time');
    var orderDeliveryDateInput = document.querySelector('#inbound-order-edit-delivery-date');
    var orderSupplierIdSelect = document.querySelector('#inbound-order-edit-supplier-id');
    var orderWarehouseIdSelect = document.querySelector('#inbound-order-edit-warehouse-id');
    var orderEditAddGroupButtonTemplate = document.querySelector('.inbound-order-add-product-group-btn');
    var saveButton = document.querySelector('#inbound-order-save-products-btn');
    var modalEditOptions = {
        placement: 'bottom-right',
        backdrop: 'dynamic',
        backdropClasses: 'bg-gray-900 bg-opacity-50 dark:bg-opacity-80 fixed inset-0 z-40',
        closable: true,
        onHide: function () {
            console.log(orderEditProductsAllocatedContainer);
            while (orderEditProductsAllocatedContainer.children.length > 1) {
                orderEditProductsAllocatedContainer.removeChild(orderEditProductsAllocatedContainer.lastElementChild);
            }
            var groupsQuantity = orderEditProductsAllocatedContainer.querySelectorAll('.group-quantity-item');
            groupsQuantity.forEach(function (group) { return group.remove(); });
            var buttonsAddGroupQuantity = orderEditProductsAllocatedContainer.querySelectorAll('.inbound-order-add-product-group-btn');
            buttonsAddGroupQuantity.forEach(function (button) { return button.remove(); });
        },
    };
    var orderEditModal = new flowbite_1.Modal(orderEditModalHTML, modalEditOptions);
    var editModalCloseButton = document.querySelector('#edit-modal-btn-hide');
    editModalCloseButton.addEventListener('click', function () {
        orderEditModal.hide();
    });
    orderEditButtons.forEach(function (orderEditButton) {
        var inboundOrderData = JSON.parse(orderEditButton.getAttribute('data-target'));
        orderEditButton.addEventListener('click', function () {
            // Set order edit modal values
            orderUuidInput.value = inboundOrderData.uuid;
            orderStatusSelect.value = inboundOrderData.status;
            orderTitleInput.value = inboundOrderData.title;
            orderActiveDateInput.value = (0, utils_1.getDatepickerDateFormat)(inboundOrderData.activeDate);
            orderActiveTimeInput.value = inboundOrderData.activeTime;
            orderDeliveryDateInput.value = (0, utils_1.getDatepickerDateFormat)(inboundOrderData.deliveryDate);
            orderSupplierIdSelect.value = inboundOrderData.supplier.id.toString();
            orderWarehouseIdSelect.value = inboundOrderData.warehouse.id.toString();
            for (var i = 0; i < inboundOrderData.productsAllocated.length - 1; i++) {
                var productAllocatedEditView = orderEditProductsAllocatedContainer.children[0].cloneNode(true);
                orderEditProductsAllocatedContainer.appendChild(productAllocatedEditView);
            }
            inboundOrderData.productsAllocated.forEach(function (productAllocated, i) {
                var currentProductAllocatedContainer = orderEditProductsAllocatedContainer.children[i];
                var productAllocatedIdInput = currentProductAllocatedContainer.querySelector('.product-allocated-id');
                var productAllocatedNameDiv = currentProductAllocatedContainer.querySelector('.inbound-order-edit-check-product');
                var productAllocatedSKUDiv = currentProductAllocatedContainer.querySelector('.inbound-order-edit-check-product-sku');
                var productAllocatedQuantityDiv = currentProductAllocatedContainer.querySelector('.inbound-order-edit-check-quantity');
                var productAllocatedShelfLifeFromDiv = currentProductAllocatedContainer.querySelector('.inbound-order-edit-shelf-life-from');
                var productAllocatedShelfLifeToDiv = currentProductAllocatedContainer.querySelector('.inbound-order-edit-shelf-life-to');
                var productAllocatedTotalQuantityDiv = currentProductAllocatedContainer.querySelector('.inbound-order-edit-total-quantity');
                productAllocatedIdInput.value = productAllocated.id.toString();
                productAllocatedNameDiv.innerHTML = "<p title='".concat(productAllocated.product.name, "' class='cropped-text'>").concat(productAllocated.product.name, "</p>");
                productAllocatedSKUDiv.innerHTML = "<p title='".concat(productAllocated.product.SKU, "'>").concat(productAllocated.product.SKU, "</p>");
                productAllocatedQuantityDiv.innerHTML = productAllocated.quantity.toString();
                productAllocatedQuantityDiv.setAttribute('data-quantity', productAllocated.quantity.toString());
                productAllocatedTotalQuantityDiv.innerHTML = productAllocated.quantity.toString();
                productAllocatedShelfLifeFromDiv.innerHTML = (0, utils_1.getDatepickerDateFormat)(productAllocated.shelfLifeStart);
                productAllocatedShelfLifeToDiv.innerHTML = (0, utils_1.getDatepickerDateFormat)(productAllocated.shelfLifeEnd);
                var buttonAddNewGroup = orderEditAddGroupButtonTemplate.cloneNode(true);
                // current point
                buttonAddNewGroup.addEventListener('click', function () {
                    return createProductGroup(currentProductAllocatedContainer);
                });
                productAllocatedShelfLifeToDiv.parentNode.parentNode.after(buttonAddNewGroup);
                buttonAddNewGroup.classList.remove('invisible');
                productAllocated.productQuantityGroups.forEach(function (quantityGroup) {
                    var quantityGroupContainer = createProductGroup(currentProductAllocatedContainer);
                    var groupSelect = quantityGroupContainer.querySelector('#inbound-order-edit-add-group');
                    var groupSelectHidden = quantityGroupContainer.querySelector('#inbound-order-edit-add-group-hidden');
                    var groupQuantityInput = quantityGroupContainer.querySelector('.inbound-order-edit-add-quantity');
                    groupSelect.value = quantityGroup.group.name.toString();
                    groupSelectHidden.value = quantityGroup.group.name.toString();
                    groupQuantityInput.value = quantityGroup.quantity.toString();
                });
                var groupsItems = document.querySelectorAll('.group-quantity-item');
                if (groupsItems.length < 2) {
                    buttonAddNewGroup.click();
                }
                setNewQuantityView(currentProductAllocatedContainer);
            });
            if (inboundOrderData.status !== 'Assigned to pickup' && inboundOrderData.status !== 'Draft') {
                saveButton.classList.add('hidden');
                orderStatusDiv.classList.remove('hidden');
                orderStatusDiv.innerHTML = inboundOrderData.status;
                orderStatusSelect.classList.add('hidden');
            }
            else {
                saveButton.classList.remove('hidden');
                orderStatusDiv.classList.add('hidden');
                orderStatusSelect.classList.remove('hidden');
            }
            orderEditModal.show();
        });
    });
    // submit update order
    var buttonSave = document.querySelector('#inbound-order-save-products-btn');
    buttonSave.addEventListener('click', function () {
        var orderStatusSelect = document.querySelector('#inbound-order-edit-status');
        if (orderStatusSelect.value === 'Assigned to pickup') {
            var isValid = validateAssignedToPickUpForm();
            if (!isValid) {
                alert('Available Quantity is not valid');
                return;
            }
        }
        var productAllocatedGroupsContainers = document.querySelectorAll('.product-allocated-groups-container');
        var productGroups = [];
        productAllocatedGroupsContainers.forEach(function (productGroupContainer) {
            var productAllocatedIdInput = productGroupContainer.querySelector('.product-allocated-id');
            var productGroupCreate = {
                productAllocatedId: parseInt(productAllocatedIdInput.value),
                productAllocatedGroups: [],
            };
            var groupQuantityItems = productGroupContainer.querySelectorAll('.group-quantity-item');
            groupQuantityItems.forEach(function (quantityItem) {
                var groupIdSelect = quantityItem.querySelector('#inbound-order-edit-add-group');
                var groupIdSelectHidden = quantityItem.querySelector('#inbound-order-edit-add-group-hidden');
                var groupQuantityInput = quantityItem.querySelector('.inbound-order-edit-add-quantity');
                if (groupIdSelectHidden.value && groupQuantityInput.value) {
                    var groupId = parseInt(groupIdSelectHidden.value);
                    var groupQuantity = parseInt(groupQuantityInput.value);
                    productGroupCreate.productAllocatedGroups.push({
                        groupId: groupId,
                        quantity: groupQuantity,
                    });
                }
            });
            productGroups.push(productGroupCreate);
        });
        var productGroupsQuantitiesInput = document.querySelector('#inbound-order-edit-product-quantities');
        productGroupsQuantitiesInput.value = JSON.stringify(productGroups);
        var buttonSubmit = document.querySelector('#inbound-order-submit-btn');
        buttonSubmit.click();
    });
};
exports.initEditOrderModal = initEditOrderModal;
var validateAssignedToPickUpForm = function () {
    var productAllocatedQuantity = document.querySelectorAll('.inbound-order-edit-check-quantity');
    var isUsedAllProducts = Array.from(productAllocatedQuantity).every(function (quantityNode) {
        var quantity = parseInt(quantityNode.innerHTML);
        return quantity === 0;
    });
    return isUsedAllProducts;
};


/***/ }),

/***/ "./src/inbound_order/inbound_order.ts":
/*!********************************************!*\
  !*** ./src/inbound_order/inbound_order.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tw_elements_1 = __webpack_require__(/*! tw-elements */ "./node_modules/tw-elements/dist/js/tw-elements.es.min.js");
var add_1 = __webpack_require__(/*! ./add */ "./src/inbound_order/add.ts");
var view_1 = __webpack_require__(/*! ./view */ "./src/inbound_order/view.ts");
var edit_1 = __webpack_require__(/*! ./edit */ "./src/inbound_order/edit.ts");
var bundle_1 = __webpack_require__(/*! @easepick/bundle */ "./node_modules/@easepick/bundle/dist/index.esm.js");
var Datepicker_1 = __webpack_require__(/*! flowbite-datepicker/Datepicker */ "./node_modules/flowbite-datepicker/js/Datepicker.js");
//global variables for datepicker
var currentDate = new Date();
var fiveDays = 5 * 24 * 60 * 60 * 1000;
(0, tw_elements_1.initTE)({ Input: tw_elements_1.Input, Timepicker: tw_elements_1.Timepicker });
var $buttonElements = document.querySelectorAll('.inbound-order-edit-button');
$buttonElements.forEach(function (e) {
    return e.addEventListener('click', function () {
        var inboundOrder = JSON.parse(e.getAttribute('data-target'));
    });
});
var pickerInline = document.querySelector('#timepicker-inline-12');
var timepickerMaxMin = new tw_elements_1.Timepicker(pickerInline, {
    format12: true,
    inline: true,
});
// search flow
var searchInput = document.querySelector('#table-search-inbound-orders');
var searchInputButton = document.querySelector('#table-search-inbound-order-button');
if (searchInputButton && searchInput) {
    searchInputButton.addEventListener('click', function () {
        var url = new URL(window.location.href);
        url.searchParams.set('q', searchInput.value);
        window.location.href = "".concat(url.href);
    });
}
var deleteButtons = document.querySelectorAll('.delete-inbound-order-btn');
deleteButtons.forEach(function (e) {
    e.addEventListener('click', function () { return __awaiter(void 0, void 0, void 0, function () {
        var id, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!confirm('Are sure?')) return [3 /*break*/, 2];
                    id = e.getAttribute('data-inbound-order-id');
                    return [4 /*yield*/, fetch("/inbound_order/delete/".concat(id), {
                            method: 'DELETE',
                        })];
                case 1:
                    response = _a.sent();
                    if (response.status == 200) {
                        location.reload();
                    }
                    _a.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    }); });
});
var openCurrentOrder = function () {
    var urlParams = new URLSearchParams(window.location.search);
    var orderUuid = urlParams.get('current_order_uuid');
    console.log(orderUuid);
    if (!orderUuid) {
        return;
    }
    var orderColumn = document.querySelector("#inbound-order-".concat(orderUuid));
    if (!orderColumn) {
        return;
    }
    var orderEditButton = orderColumn.querySelector('.inbound-order-edit-button');
    orderEditButton.click();
};
var deleteAllocatedProduct = function (e) {
    var productAllocatedContainer = e.currentTarget.parentNode;
    var productsAllocatedContainer = productAllocatedContainer.parentNode;
    productAllocatedContainer.remove();
    console.log(productsAllocatedContainer.children.length);
    if (productsAllocatedContainer.children.length == 2) {
        var productAllocatedDeleteButton = productsAllocatedContainer.querySelector('.product-allocated-delete-button');
        console.log(productAllocatedDeleteButton);
        productAllocatedDeleteButton.classList.add('invisible');
    }
};
var createAllocationProductContainer = function (e) {
    var btn = e.currentTarget;
    var productAllocatedContainer = document.querySelector('.product-allocated').parentNode;
    if (productAllocatedContainer.parentNode.children.length == 2) {
        var buttonRemoveProductAllocated = productAllocatedContainer.querySelector('.product-allocated-delete-button');
        buttonRemoveProductAllocated.classList.remove('invisible');
    }
    var productAllocatedNew = productAllocatedContainer.cloneNode(true);
    // Clear inputs
    productAllocatedNew.querySelectorAll('input').forEach(function (input) {
        input.value = '';
    });
    var buttonDeleteAllocatedProduct = productAllocatedNew.querySelector('.product-allocated-delete-button');
    buttonDeleteAllocatedProduct.addEventListener('click', deleteAllocatedProduct);
    var productsAllocatedContainer = btn.parentNode.parentNode;
    productsAllocatedContainer.insertBefore(productAllocatedNew, btn.parentNode);
    addDateRangePicker();
};
// # NOTE: depends on flash from create route on inbound_order_blueprint
document.addEventListener('DOMContentLoaded', function () {
    // view order
    (0, view_1.initViewInboundOrderModal)();
    // Add new inbound order handler
    (0, add_1.initAddInboundOrderModal)();
    // Add edit inbound order handler
    (0, edit_1.initEditOrderModal)();
    var buttonAllocateProduct = document.getElementById('inbound-order-allocate-product-btn');
    buttonAllocateProduct.addEventListener('click', createAllocationProductContainer);
    var buttonDeleteAllocatedProduct = document.querySelector('.product-allocated-delete-button');
    buttonDeleteAllocatedProduct.addEventListener('click', deleteAllocatedProduct);
    // Open current order
    openCurrentOrder();
});
var addDateRangePicker = function () {
    var shelfLifeStartElements = document.querySelectorAll('#datepickerEl-start-add-1');
    var shelfLifeEndElements = document.querySelectorAll('#datepickerEl-end-add-1');
    var currentShelfLifeStart = shelfLifeStartElements[shelfLifeStartElements.length - 1];
    var currentShelfLifeEnd = shelfLifeEndElements[shelfLifeEndElements.length - 1];
    var datepickerStart = new Datepicker_1.default(currentShelfLifeStart, {});
    var datepickerEnd = new Datepicker_1.default(currentShelfLifeEnd, {});
};
// filter flow
var filterButton = document.querySelector('#inbound-order-filter-button');
var orderFilterInputs = document.querySelectorAll('.inbound-order-filter-input');
var hiddenInput = document.querySelector('#sort_by');
filterButton.addEventListener('click', function () {
    orderFilterInputs.forEach(function (input) {
        if (input.checked && input.nextElementSibling.textContent.trim() != 'Default Value') {
            hiddenInput.value = input.nextElementSibling.textContent.trim();
        }
    });
});
var todayDateTime = new Date().toISOString();
var activeTimeInput = document.querySelector('#inbound-order-add-active_time');
var currentTime = new Date().toLocaleTimeString();
var hours = parseInt(currentTime.split(':')[0]);
var minutes = parseInt(currentTime.split(':')[1]);
var amOrPm = hours >= 12 ? 'PM' : 'AM';
var formattedHours = hours % 12 === 0 ? 12 : hours % 12;
var formattedMinutes = minutes.toString().padStart(2, '0');
activeTimeInput.value = "".concat(formattedHours, ":").concat(formattedMinutes, " ").concat(amOrPm);
var datePickers = document.querySelectorAll('.inbound-order-datepicker');
datePickers.forEach(function (datePicker) {
    datePicker.value = todayDateTime.split('T')[0];
    var picker = new bundle_1.easepick.create({
        element: datePicker,
        css: [
            'https://cdn.jsdelivr.net/npm/@easepick/bundle@1.2.1/dist/index.css',
            'https://easepick.com/css/demo_hotelcal.css',
        ],
        plugins: ['LockPlugin'],
        LockPlugin: {
            minDate: new Date(),
            minDays: 1,
            inseparable: true,
        },
        zIndex: 4,
    });
});


/***/ }),

/***/ "./src/inbound_order/utils.ts":
/*!************************************!*\
  !*** ./src/inbound_order/utils.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDatepickerDateFormat = void 0;
var getDatepickerDateFormat = function (dateString) {
    var date = new Date(dateString);
    var month = date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1;
    var day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
    var year = date.getFullYear();
    return year + '-' + month + '-' + day;
};
exports.getDatepickerDateFormat = getDatepickerDateFormat;


/***/ }),

/***/ "./src/inbound_order/view.ts":
/*!***********************************!*\
  !*** ./src/inbound_order/view.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initViewInboundOrderModal = void 0;
var flowbite_1 = __webpack_require__(/*! flowbite */ "./node_modules/flowbite/lib/esm/index.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./src/inbound_order/utils.ts");
var initViewInboundOrderModal = function () {
    // modal Nodes
    var viewInboundOrderModalElement = document.querySelector('#view-inbound-order-modal');
    var orderIdView = viewInboundOrderModalElement.querySelector('#inbound-order-view-order_id');
    var orderStatus = viewInboundOrderModalElement.querySelector('#inbound-order-view-status');
    var orderActiveDate = viewInboundOrderModalElement.querySelector('#inbound-order-view-active_date');
    var orderActiveTime = viewInboundOrderModalElement.querySelector('#inbound-order-view-active_time');
    var orderTitle = viewInboundOrderModalElement.querySelector('#inbound-order-view-order_title');
    var orderDeliveryDate = viewInboundOrderModalElement.querySelector('#inbound-order-view-delivery_date');
    var orderWarehouseName = viewInboundOrderModalElement.querySelector('#inbound-order-view-warehouse-name');
    var orderSupplierName = viewInboundOrderModalElement.querySelector('#inbound-order-view-supplier-name');
    var orderSupplierAddress = viewInboundOrderModalElement.querySelector('#inbound-order-view-supplier-address');
    var modalViewDivs = [orderIdView, orderStatus, orderActiveDate, orderActiveTime, orderTitle, orderDeliveryDate, orderWarehouseName, orderSupplierName, orderSupplierAddress];
    // create modal
    var viewModalOptions = {
        placement: 'bottom-right',
        backdrop: 'dynamic',
        backdropClasses: 'bg-gray-900 bg-opacity-50 dark:bg-opacity-80 fixed inset-0 z-40',
        closable: true,
        onHide: function () {
            modalViewDivs.forEach(function (modalDiv) {
                modalDiv.innerHTML = '';
            });
        },
    };
    var viewModal = new flowbite_1.Modal(viewInboundOrderModalElement, viewModalOptions);
    var orderViewButtons = document.querySelectorAll('.inbound-order-view-button');
    orderViewButtons.forEach(function (viewButton) {
        var inboundOrderData = JSON.parse(viewButton.getAttribute('data-target'));
        // Nodes
        viewButton.addEventListener('click', function () {
            // Fill order view modal data
            orderIdView.innerHTML = inboundOrderData.orderId;
            orderStatus.innerHTML = inboundOrderData.status;
            orderActiveDate.innerHTML = (0, utils_1.getDatepickerDateFormat)(inboundOrderData.activeDate);
            orderActiveTime.innerHTML = inboundOrderData.activeTime;
            orderTitle.innerHTML = inboundOrderData.title;
            orderDeliveryDate.innerHTML = (0, utils_1.getDatepickerDateFormat)(inboundOrderData.deliveryDate);
            orderWarehouseName.innerHTML = inboundOrderData.warehouse.name;
            orderSupplierName.innerHTML = inboundOrderData.supplier.name;
            orderSupplierAddress.innerHTML = inboundOrderData.supplier.address;
            viewModal.show();
        });
    });
    var viewModalCloseButton = document.querySelector('#view-modal-btn-hide');
    viewModalCloseButton.addEventListener('click', function () {
        viewModal.hide();
    });
    var copyLinkButton = document.querySelector('#inbound-order-share');
    copyLinkButton.addEventListener('click', function () {
        copyCurrentLink();
    });
};
exports.initViewInboundOrderModal = initViewInboundOrderModal;
var copyCurrentLink = function () {
    var currentURL = window.location.href;
    var tempInput = document.createElement('input');
    tempInput.value = currentURL;
    document.body.appendChild(tempInput);
    tempInput.select();
    document.execCommand('copy');
    document.body.removeChild(tempInput);
    var linkCopiedPopup = document.querySelector('#link-copied-popup');
    linkCopiedPopup.classList.remove('invisible');
    var hidePopupTimeout = setTimeout(function () {
        linkCopiedPopup.classList.add('invisible');
        clearTimeout(hidePopupTimeout);
    }, 1000);
};


/***/ }),

/***/ "./node_modules/tw-elements/dist/js/tw-elements.es.min.js":
/*!****************************************************************!*\
  !*** ./node_modules/tw-elements/dist/js/tw-elements.es.min.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Alert": () => (/* binding */ Rn),
/* harmony export */   "Animate": () => (/* binding */ ml),
/* harmony export */   "Button": () => (/* binding */ $a),
/* harmony export */   "Carousel": () => (/* binding */ Yt),
/* harmony export */   "Chart": () => (/* binding */ Wl),
/* harmony export */   "Chip": () => (/* binding */ ii),
/* harmony export */   "ChipsInput": () => (/* binding */ Zg),
/* harmony export */   "Collapse": () => (/* binding */ Ut),
/* harmony export */   "Datepicker": () => (/* binding */ Gg),
/* harmony export */   "Dropdown": () => (/* binding */ wt),
/* harmony export */   "Input": () => (/* binding */ V),
/* harmony export */   "Modal": () => (/* binding */ Pn),
/* harmony export */   "Offcanvas": () => (/* binding */ rs),
/* harmony export */   "Popover": () => (/* binding */ ll),
/* harmony export */   "Ripple": () => (/* binding */ Cs),
/* harmony export */   "ScrollSpy": () => (/* binding */ Bn),
/* harmony export */   "Select": () => (/* binding */ Nl),
/* harmony export */   "Sidenav": () => (/* binding */ ni),
/* harmony export */   "Stepper": () => (/* binding */ Qg),
/* harmony export */   "Tab": () => (/* binding */ hl),
/* harmony export */   "Timepicker": () => (/* binding */ qg),
/* harmony export */   "Toast": () => (/* binding */ Vn),
/* harmony export */   "Tooltip": () => (/* binding */ vi),
/* harmony export */   "initTE": () => (/* binding */ eg)
/* harmony export */ });
/*!
* Taliwind Elements 1.0.0-beta2
* 
* Tailwind Elements is an open-source UI kit of advanced components for TailwindCSS.
* Copyright  2023 MDBootstrap.com
* 
* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
* 
*/
var Xl = Object.defineProperty;
var Gl = (s, t, e) => t in s ? Xl(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var Tt = (s, t, e) => (Gl(s, typeof t != "symbol" ? t + "" : t, e), e);
const Bs = (() => {
  const s = {};
  let t = 1;
  return {
    set(e, i, n) {
      typeof e[i] > "u" && (e[i] = {
        key: i,
        id: t
      }, t++), s[e[i].id] = n;
    },
    get(e, i) {
      if (!e || typeof e[i] > "u")
        return null;
      const n = e[i];
      return n.key === i ? s[n.id] : null;
    },
    delete(e, i) {
      if (typeof e[i] > "u")
        return;
      const n = e[i];
      n.key === i && (delete s[n.id], delete e[i]);
    }
  };
})(), I = {
  setData(s, t, e) {
    Bs.set(s, t, e);
  },
  getData(s, t) {
    return Bs.get(s, t);
  },
  removeData(s, t) {
    Bs.delete(s, t);
  }
}, ql = 1e6, Ql = 1e3, Dn = "transitionend", Zl = (s) => s == null ? `${s}` : {}.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase(), Ot = (s) => {
  do
    s += Math.floor(Math.random() * ql);
  while (document.getElementById(s));
  return s;
}, va = (s) => {
  let t = s.getAttribute("data-te-target");
  if (!t || t === "#") {
    let e = s.getAttribute("href");
    if (!e || !e.includes("#") && !e.startsWith("."))
      return null;
    e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t = e && e !== "#" ? e.trim() : null;
  }
  return t;
}, Xn = (s) => {
  const t = va(s);
  return t && document.querySelector(t) ? t : null;
}, Xt = (s) => {
  const t = va(s);
  return t ? document.querySelector(t) : null;
}, Jl = (s) => {
  if (!s)
    return 0;
  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(s);
  const i = Number.parseFloat(t), n = Number.parseFloat(e);
  return !i && !n ? 0 : (t = t.split(",")[0], e = e.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * Ql);
}, Ea = (s) => {
  s.dispatchEvent(new Event(Dn));
}, Ne = (s) => !s || typeof s != "object" ? !1 : (typeof s.jquery < "u" && (s = s[0]), typeof s.nodeType < "u"), Gt = (s) => Ne(s) ? s.jquery ? s[0] : s : typeof s == "string" && s.length > 0 ? document.querySelector(s) : null, N = (s, t, e) => {
  Object.keys(e).forEach((i) => {
    const n = e[i], o = t[i], r = o && Ne(o) ? "element" : Zl(o);
    if (!new RegExp(n).test(r))
      throw new Error(
        `${s.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${n}".`
      );
  });
}, St = (s) => {
  if (!s || s.getClientRects().length === 0)
    return !1;
  if (s.style && s.parentNode && s.parentNode.style) {
    const t = getComputedStyle(s), e = getComputedStyle(s.parentNode);
    return getComputedStyle(s).getPropertyValue("visibility") === "visible" || t.display !== "none" && e.display !== "none" && t.visibility !== "hidden";
  }
  return !1;
}, ue = (s) => !s || s.nodeType !== Node.ELEMENT_NODE || s.classList.contains("disabled") ? !0 : typeof s.disabled < "u" ? s.disabled : s.hasAttribute("disabled") && s.getAttribute("disabled") !== "false", Ta = (s) => {
  if (!document.documentElement.attachShadow)
    return null;
  if (typeof s.getRootNode == "function") {
    const t = s.getRootNode();
    return t instanceof ShadowRoot ? t : null;
  }
  return s instanceof ShadowRoot ? s : s.parentNode ? Ta(s.parentNode) : null;
}, vs = () => function() {
}, Fe = (s) => {
  s.offsetHeight;
}, Ca = () => {
  const { jQuery: s } = window;
  return s && !document.body.hasAttribute("data-te-no-jquery") ? s : null;
}, Vs = [], Aa = (s) => {
  document.readyState === "loading" ? (Vs.length || document.addEventListener("DOMContentLoaded", () => {
    Vs.forEach((t) => t());
  }), Vs.push(s)) : s();
}, F = () => document.documentElement.dir === "rtl", tc = (s) => Array.from(s), M = (s) => document.createElement(s), he = (s) => {
  typeof s == "function" && s();
}, ya = (s, t, e = !0) => {
  if (!e) {
    he(s);
    return;
  }
  const i = 5, n = Jl(t) + i;
  let o = !1;
  const r = ({ target: a }) => {
    a === t && (o = !0, t.removeEventListener(Dn, r), he(s));
  };
  t.addEventListener(Dn, r), setTimeout(() => {
    o || Ea(t);
  }, n);
}, wa = (s, t, e, i) => {
  let n = s.indexOf(t);
  if (n === -1)
    return s[!e && i ? s.length - 1 : 0];
  const o = s.length;
  return n += e ? 1 : -1, i && (n = (n + o) % o), s[Math.max(0, Math.min(n, o - 1))];
}, ec = /[^.]*(?=\..*)\.|.*/, ic = /\..*/, sc = /::\d+$/, Ws = {};
let Eo = 1;
const nc = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, oc = /^(mouseenter|mouseleave)/i, ka = /* @__PURE__ */ new Set([
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
]);
function Oa(s, t) {
  return t && `${t}::${Eo++}` || s.uidEvent || Eo++;
}
function xa(s) {
  const t = Oa(s);
  return s.uidEvent = t, Ws[t] = Ws[t] || {}, Ws[t];
}
function rc(s, t) {
  return function e(i) {
    return i.delegateTarget = s, e.oneOff && u.off(s, i.type, t), t.apply(s, [i]);
  };
}
function ac(s, t, e) {
  return function i(n) {
    const o = s.querySelectorAll(t);
    for (let { target: r } = n; r && r !== this; r = r.parentNode)
      for (let a = o.length; a--; "")
        if (o[a] === r)
          return n.delegateTarget = r, i.oneOff && u.off(s, n.type, e), e.apply(r, [n]);
    return null;
  };
}
function Sa(s, t, e = null) {
  const i = Object.keys(s);
  for (let n = 0, o = i.length; n < o; n++) {
    const r = s[i[n]];
    if (r.originalHandler === t && r.delegationSelector === e)
      return r;
  }
  return null;
}
function Da(s, t, e) {
  const i = typeof t == "string", n = i ? e : t;
  let o = Ia(s);
  return ka.has(o) || (o = s), [i, n, o];
}
function To(s, t, e, i, n) {
  if (typeof t != "string" || !s)
    return;
  if (e || (e = i, i = null), oc.test(t)) {
    const m = (g) => function(b) {
      if (!b.relatedTarget || b.relatedTarget !== b.delegateTarget && !b.delegateTarget.contains(b.relatedTarget))
        return g.call(this, b);
    };
    i ? i = m(i) : e = m(e);
  }
  const [o, r, a] = Da(
    t,
    e,
    i
  ), l = xa(s), c = l[a] || (l[a] = {}), d = Sa(
    c,
    r,
    o ? e : null
  );
  if (d) {
    d.oneOff = d.oneOff && n;
    return;
  }
  const _ = Oa(
    r,
    t.replace(ec, "")
  ), f = o ? ac(s, e, i) : rc(s, e);
  f.delegationSelector = o ? e : null, f.originalHandler = r, f.oneOff = n, f.uidEvent = _, c[_] = f, s.addEventListener(a, f, o);
}
function In(s, t, e, i, n) {
  const o = Sa(t[e], i, n);
  o && (s.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);
}
function lc(s, t, e, i) {
  const n = t[e] || {};
  Object.keys(n).forEach((o) => {
    if (o.includes(i)) {
      const r = n[o];
      In(
        s,
        t,
        e,
        r.originalHandler,
        r.delegationSelector
      );
    }
  });
}
function Ia(s) {
  return s = s.replace(ic, ""), nc[s] || s;
}
const u = {
  on(s, t, e, i) {
    To(s, t, e, i, !1);
  },
  one(s, t, e, i) {
    To(s, t, e, i, !0);
  },
  off(s, t, e, i) {
    if (typeof t != "string" || !s)
      return;
    const [n, o, r] = Da(
      t,
      e,
      i
    ), a = r !== t, l = xa(s), c = t.startsWith(".");
    if (typeof o < "u") {
      if (!l || !l[r])
        return;
      In(
        s,
        l,
        r,
        o,
        n ? e : null
      );
      return;
    }
    c && Object.keys(l).forEach((_) => {
      lc(
        s,
        l,
        _,
        t.slice(1)
      );
    });
    const d = l[r] || {};
    Object.keys(d).forEach((_) => {
      const f = _.replace(sc, "");
      if (!a || t.includes(f)) {
        const m = d[_];
        In(
          s,
          l,
          r,
          m.originalHandler,
          m.delegationSelector
        );
      }
    });
  },
  trigger(s, t, e) {
    if (typeof t != "string" || !s)
      return null;
    const i = Ca(), n = Ia(t), o = t !== n, r = ka.has(n);
    let a, l = !0, c = !0, d = !1, _ = null;
    return o && i && (a = i.Event(t, e), i(s).trigger(a), l = !a.isPropagationStopped(), c = !a.isImmediatePropagationStopped(), d = a.isDefaultPrevented()), r ? (_ = document.createEvent("HTMLEvents"), _.initEvent(n, l, !0)) : _ = new CustomEvent(t, {
      bubbles: l,
      cancelable: !0
    }), typeof e < "u" && Object.keys(e).forEach((f) => {
      Object.defineProperty(_, f, {
        get() {
          return e[f];
        }
      });
    }), d && _.preventDefault(), c && s.dispatchEvent(_), _.defaultPrevented && typeof a < "u" && a.preventDefault(), _;
  }
}, ee = {
  on(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      u.on(s, n[o], e, i);
  },
  off(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      u.off(s, n[o], e, i);
  }
}, cc = "5.1.3";
class vt {
  constructor(t) {
    t = Gt(t), t && (this._element = t, I.setData(this._element, this.constructor.DATA_KEY, this));
  }
  dispose() {
    I.removeData(this._element, this.constructor.DATA_KEY), u.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {
      this[t] = null;
    });
  }
  _queueCallback(t, e, i = !0) {
    ya(t, e, i);
  }
  /** Static */
  static getInstance(t) {
    return I.getData(Gt(t), this.DATA_KEY);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static get VERSION() {
    return cc;
  }
  static get NAME() {
    throw new Error(
      'You have to implement the static method "NAME", for each component!'
    );
  }
  static get DATA_KEY() {
    return `te.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
}
const dc = "button", hc = "active";
class $a extends vt {
  // Getters
  static get NAME() {
    return dc;
  }
  // Public
  toggle() {
    this._element.setAttribute(
      "aria-pressed",
      this._element.classList.toggle(hc)
    );
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = $a.getOrCreateInstance(this);
      t === "toggle" && e[t]();
    });
  }
}
var Z = "top", dt = "bottom", ht = "right", J = "left", mi = "auto", Ye = [Z, dt, ht, J], _e = "start", Re = "end", La = "clippingParents", Gn = "viewport", ye = "popper", Ma = "reference", $n = /* @__PURE__ */ Ye.reduce(function(s, t) {
  return s.concat([t + "-" + _e, t + "-" + Re]);
}, []), qn = /* @__PURE__ */ [].concat(Ye, [mi]).reduce(function(s, t) {
  return s.concat([t, t + "-" + _e, t + "-" + Re]);
}, []), Na = "beforeRead", Ra = "read", Pa = "afterRead", Ha = "beforeMain", Ba = "main", Va = "afterMain", Wa = "beforeWrite", Fa = "write", Ya = "afterWrite", Es = [Na, Ra, Pa, Ha, Ba, Va, Wa, Fa, Ya];
function It(s) {
  return s ? (s.nodeName || "").toLowerCase() : null;
}
function ut(s) {
  if (s == null)
    return window;
  if (s.toString() !== "[object Window]") {
    var t = s.ownerDocument;
    return t && t.defaultView || window;
  }
  return s;
}
function me(s) {
  var t = ut(s).Element;
  return s instanceof t || s instanceof Element;
}
function ct(s) {
  var t = ut(s).HTMLElement;
  return s instanceof t || s instanceof HTMLElement;
}
function Qn(s) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = ut(s).ShadowRoot;
  return s instanceof t || s instanceof ShadowRoot;
}
function uc(s) {
  var t = s.state;
  Object.keys(t.elements).forEach(function(e) {
    var i = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];
    !ct(o) || !It(o) || (Object.assign(o.style, i), Object.keys(n).forEach(function(r) {
      var a = n[r];
      a === !1 ? o.removeAttribute(r) : o.setAttribute(r, a === !0 ? "" : a);
    }));
  });
}
function pc(s) {
  var t = s.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(i) {
      var n = t.elements[i], o = t.attributes[i] || {}, r = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), a = r.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !ct(n) || !It(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {
        n.removeAttribute(l);
      }));
    });
  };
}
const Zn = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: uc,
  effect: pc,
  requires: ["computeStyles"]
};
function gt(s) {
  return s.split("-")[0];
}
var pe = Math.max, Ts = Math.min, Pe = Math.round;
function Ln() {
  var s = navigator.userAgentData;
  return s != null && s.brands && Array.isArray(s.brands) ? s.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function ja() {
  return !/^((?!chrome|android).)*safari/i.test(Ln());
}
function He(s, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var i = s.getBoundingClientRect(), n = 1, o = 1;
  t && ct(s) && (n = s.offsetWidth > 0 && Pe(i.width) / s.offsetWidth || 1, o = s.offsetHeight > 0 && Pe(i.height) / s.offsetHeight || 1);
  var r = me(s) ? ut(s) : window, a = r.visualViewport, l = !ja() && e, c = (i.left + (l && a ? a.offsetLeft : 0)) / n, d = (i.top + (l && a ? a.offsetTop : 0)) / o, _ = i.width / n, f = i.height / o;
  return {
    width: _,
    height: f,
    top: d,
    right: c + _,
    bottom: d + f,
    left: c,
    x: c,
    y: d
  };
}
function Jn(s) {
  var t = He(s), e = s.offsetWidth, i = s.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
    x: s.offsetLeft,
    y: s.offsetTop,
    width: e,
    height: i
  };
}
function Ka(s, t) {
  var e = t.getRootNode && t.getRootNode();
  if (s.contains(t))
    return !0;
  if (e && Qn(e)) {
    var i = t;
    do {
      if (i && s.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function bt(s) {
  return ut(s).getComputedStyle(s);
}
function fc(s) {
  return ["table", "td", "th"].indexOf(It(s)) >= 0;
}
function qt(s) {
  return ((me(s) ? s.ownerDocument : (
    // $FlowFixMe[prop-missing]
    s.document
  )) || window.document).documentElement;
}
function ws(s) {
  return It(s) === "html" ? s : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    s.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    s.parentNode || // DOM Element detected
    (Qn(s) ? s.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    qt(s)
  );
}
function Co(s) {
  return !ct(s) || // https://github.com/popperjs/popper-core/issues/837
  bt(s).position === "fixed" ? null : s.offsetParent;
}
function _c(s) {
  var t = /firefox/i.test(Ln()), e = /Trident/i.test(Ln());
  if (e && ct(s)) {
    var i = bt(s);
    if (i.position === "fixed")
      return null;
  }
  var n = ws(s);
  for (Qn(n) && (n = n.host); ct(n) && ["html", "body"].indexOf(It(n)) < 0; ) {
    var o = bt(n);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function gi(s) {
  for (var t = ut(s), e = Co(s); e && fc(e) && bt(e).position === "static"; )
    e = Co(e);
  return e && (It(e) === "html" || It(e) === "body" && bt(e).position === "static") ? t : e || _c(s) || t;
}
function to(s) {
  return ["top", "bottom"].indexOf(s) >= 0 ? "x" : "y";
}
function li(s, t, e) {
  return pe(s, Ts(t, e));
}
function mc(s, t, e) {
  var i = li(s, t, e);
  return i > e ? e : i;
}
function Ua() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function za(s) {
  return Object.assign({}, Ua(), s);
}
function Xa(s, t) {
  return t.reduce(function(e, i) {
    return e[i] = s, e;
  }, {});
}
var gc = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, za(typeof t != "number" ? t : Xa(t, Ye));
};
function bc(s) {
  var t, e = s.state, i = s.name, n = s.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = gt(e.placement), l = to(a), c = [J, ht].indexOf(a) >= 0, d = c ? "height" : "width";
  if (!(!o || !r)) {
    var _ = gc(n.padding, e), f = Jn(o), m = l === "y" ? Z : J, g = l === "y" ? dt : ht, b = e.rects.reference[d] + e.rects.reference[l] - r[l] - e.rects.popper[d], T = r[l] - e.rects.reference[l], C = gi(o), w = C ? l === "y" ? C.clientHeight || 0 : C.clientWidth || 0 : 0, v = b / 2 - T / 2, E = _[m], A = w - f[d] - _[g], y = w / 2 - f[d] / 2 + v, S = li(E, y, A), O = l;
    e.modifiersData[i] = (t = {}, t[O] = S, t.centerOffset = S - y, t);
  }
}
function vc(s) {
  var t = s.state, e = s.options, i = e.element, n = i === void 0 ? "[data-popper-arrow]" : i;
  if (n != null && !(typeof n == "string" && (n = t.elements.popper.querySelector(n), !n))) {
    if ({}.NODE_ENV !== "production" && (ct(n) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !Ka(t.elements.popper, n)) {
      ({}).NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = n;
  }
}
const Ga = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: bc,
  effect: vc,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Be(s) {
  return s.split("-")[1];
}
var Ec = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Tc(s, t) {
  var e = s.x, i = s.y, n = t.devicePixelRatio || 1;
  return {
    x: Pe(e * n) / n || 0,
    y: Pe(i * n) / n || 0
  };
}
function Ao(s) {
  var t, e = s.popper, i = s.popperRect, n = s.placement, o = s.variation, r = s.offsets, a = s.position, l = s.gpuAcceleration, c = s.adaptive, d = s.roundOffsets, _ = s.isFixed, f = r.x, m = f === void 0 ? 0 : f, g = r.y, b = g === void 0 ? 0 : g, T = typeof d == "function" ? d({
    x: m,
    y: b
  }) : {
    x: m,
    y: b
  };
  m = T.x, b = T.y;
  var C = r.hasOwnProperty("x"), w = r.hasOwnProperty("y"), v = J, E = Z, A = window;
  if (c) {
    var y = gi(e), S = "clientHeight", O = "clientWidth";
    if (y === ut(e) && (y = qt(e), bt(y).position !== "static" && a === "absolute" && (S = "scrollHeight", O = "scrollWidth")), y = y, n === Z || (n === J || n === ht) && o === Re) {
      E = dt;
      var k = _ && y === A && A.visualViewport ? A.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        y[S]
      );
      b -= k - i.height, b *= l ? 1 : -1;
    }
    if (n === J || (n === Z || n === dt) && o === Re) {
      v = ht;
      var D = _ && y === A && A.visualViewport ? A.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        y[O]
      );
      m -= D - i.width, m *= l ? 1 : -1;
    }
  }
  var x = Object.assign({
    position: a
  }, c && Ec), $ = d === !0 ? Tc({
    x: m,
    y: b
  }, ut(e)) : {
    x: m,
    y: b
  };
  if (m = $.x, b = $.y, l) {
    var P;
    return Object.assign({}, x, (P = {}, P[E] = w ? "0" : "", P[v] = C ? "0" : "", P.transform = (A.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + b + "px)" : "translate3d(" + m + "px, " + b + "px, 0)", P));
  }
  return Object.assign({}, x, (t = {}, t[E] = w ? b + "px" : "", t[v] = C ? m + "px" : "", t.transform = "", t));
}
function Cc(s) {
  var t = s.state, e = s.options, i = e.gpuAcceleration, n = i === void 0 ? !0 : i, o = e.adaptive, r = o === void 0 ? !0 : o, a = e.roundOffsets, l = a === void 0 ? !0 : a;
  if ({}.NODE_ENV !== "production") {
    var c = bt(t.elements.popper).transitionProperty || "";
    r && ["transform", "top", "right", "bottom", "left"].some(function(_) {
      return c.indexOf(_) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var d = {
    placement: gt(t.placement),
    variation: Be(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Ao(Object.assign({}, d, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: r,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Ao(Object.assign({}, d, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const eo = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Cc,
  data: {}
};
var Di = {
  passive: !0
};
function Ac(s) {
  var t = s.state, e = s.instance, i = s.options, n = i.scroll, o = n === void 0 ? !0 : n, r = i.resize, a = r === void 0 ? !0 : r, l = ut(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && c.forEach(function(d) {
    d.addEventListener("scroll", e.update, Di);
  }), a && l.addEventListener("resize", e.update, Di), function() {
    o && c.forEach(function(d) {
      d.removeEventListener("scroll", e.update, Di);
    }), a && l.removeEventListener("resize", e.update, Di);
  };
}
const io = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: Ac,
  data: {}
};
var yc = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function ss(s) {
  return s.replace(/left|right|bottom|top/g, function(t) {
    return yc[t];
  });
}
var wc = {
  start: "end",
  end: "start"
};
function yo(s) {
  return s.replace(/start|end/g, function(t) {
    return wc[t];
  });
}
function so(s) {
  var t = ut(s), e = t.pageXOffset, i = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: i
  };
}
function no(s) {
  return He(qt(s)).left + so(s).scrollLeft;
}
function kc(s, t) {
  var e = ut(s), i = qt(s), n = e.visualViewport, o = i.clientWidth, r = i.clientHeight, a = 0, l = 0;
  if (n) {
    o = n.width, r = n.height;
    var c = ja();
    (c || !c && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: o,
    height: r,
    x: a + no(s),
    y: l
  };
}
function Oc(s) {
  var t, e = qt(s), i = so(s), n = (t = s.ownerDocument) == null ? void 0 : t.body, o = pe(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = pe(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + no(s), l = -i.scrollTop;
  return bt(n || e).direction === "rtl" && (a += pe(e.clientWidth, n ? n.clientWidth : 0) - o), {
    width: o,
    height: r,
    x: a,
    y: l
  };
}
function oo(s) {
  var t = bt(s), e = t.overflow, i = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + n + i);
}
function qa(s) {
  return ["html", "body", "#document"].indexOf(It(s)) >= 0 ? s.ownerDocument.body : ct(s) && oo(s) ? s : qa(ws(s));
}
function ci(s, t) {
  var e;
  t === void 0 && (t = []);
  var i = qa(s), n = i === ((e = s.ownerDocument) == null ? void 0 : e.body), o = ut(i), r = n ? [o].concat(o.visualViewport || [], oo(i) ? i : []) : i, a = t.concat(r);
  return n ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(ci(ws(r)))
  );
}
function Mn(s) {
  return Object.assign({}, s, {
    left: s.x,
    top: s.y,
    right: s.x + s.width,
    bottom: s.y + s.height
  });
}
function xc(s, t) {
  var e = He(s, !1, t === "fixed");
  return e.top = e.top + s.clientTop, e.left = e.left + s.clientLeft, e.bottom = e.top + s.clientHeight, e.right = e.left + s.clientWidth, e.width = s.clientWidth, e.height = s.clientHeight, e.x = e.left, e.y = e.top, e;
}
function wo(s, t, e) {
  return t === Gn ? Mn(kc(s, e)) : me(t) ? xc(t, e) : Mn(Oc(qt(s)));
}
function Sc(s) {
  var t = ci(ws(s)), e = ["absolute", "fixed"].indexOf(bt(s).position) >= 0, i = e && ct(s) ? gi(s) : s;
  return me(i) ? t.filter(function(n) {
    return me(n) && Ka(n, i) && It(n) !== "body";
  }) : [];
}
function Dc(s, t, e, i) {
  var n = t === "clippingParents" ? Sc(s) : [].concat(t), o = [].concat(n, [e]), r = o[0], a = o.reduce(function(l, c) {
    var d = wo(s, c, i);
    return l.top = pe(d.top, l.top), l.right = Ts(d.right, l.right), l.bottom = Ts(d.bottom, l.bottom), l.left = pe(d.left, l.left), l;
  }, wo(s, r, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function Qa(s) {
  var t = s.reference, e = s.element, i = s.placement, n = i ? gt(i) : null, o = i ? Be(i) : null, r = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;
  switch (n) {
    case Z:
      l = {
        x: r,
        y: t.y - e.height
      };
      break;
    case dt:
      l = {
        x: r,
        y: t.y + t.height
      };
      break;
    case ht:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case J:
      l = {
        x: t.x - e.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var c = n ? to(n) : null;
  if (c != null) {
    var d = c === "y" ? "height" : "width";
    switch (o) {
      case _e:
        l[c] = l[c] - (t[d] / 2 - e[d] / 2);
        break;
      case Re:
        l[c] = l[c] + (t[d] / 2 - e[d] / 2);
        break;
    }
  }
  return l;
}
function Ve(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = i === void 0 ? s.placement : i, o = e.strategy, r = o === void 0 ? s.strategy : o, a = e.boundary, l = a === void 0 ? La : a, c = e.rootBoundary, d = c === void 0 ? Gn : c, _ = e.elementContext, f = _ === void 0 ? ye : _, m = e.altBoundary, g = m === void 0 ? !1 : m, b = e.padding, T = b === void 0 ? 0 : b, C = za(typeof T != "number" ? T : Xa(T, Ye)), w = f === ye ? Ma : ye, v = s.rects.popper, E = s.elements[g ? w : f], A = Dc(me(E) ? E : E.contextElement || qt(s.elements.popper), l, d, r), y = He(s.elements.reference), S = Qa({
    reference: y,
    element: v,
    strategy: "absolute",
    placement: n
  }), O = Mn(Object.assign({}, v, S)), k = f === ye ? O : y, D = {
    top: A.top - k.top + C.top,
    bottom: k.bottom - A.bottom + C.bottom,
    left: A.left - k.left + C.left,
    right: k.right - A.right + C.right
  }, x = s.modifiersData.offset;
  if (f === ye && x) {
    var $ = x[n];
    Object.keys(D).forEach(function(P) {
      var tt = [ht, dt].indexOf(P) >= 0 ? 1 : -1, et = [Z, dt].indexOf(P) >= 0 ? "y" : "x";
      D[P] += $[et] * tt;
    });
  }
  return D;
}
function Ic(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, c = l === void 0 ? qn : l, d = Be(i), _ = d ? a ? $n : $n.filter(function(g) {
    return Be(g) === d;
  }) : Ye, f = _.filter(function(g) {
    return c.indexOf(g) >= 0;
  });
  f.length === 0 && (f = _, {}.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var m = f.reduce(function(g, b) {
    return g[b] = Ve(s, {
      placement: b,
      boundary: n,
      rootBoundary: o,
      padding: r
    })[gt(b)], g;
  }, {});
  return Object.keys(m).sort(function(g, b) {
    return m[g] - m[b];
  });
}
function $c(s) {
  if (gt(s) === mi)
    return [];
  var t = ss(s);
  return [yo(s), t, yo(t)];
}
function Lc(s) {
  var t = s.state, e = s.options, i = s.name;
  if (!t.modifiersData[i]._skip) {
    for (var n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !0 : r, l = e.fallbackPlacements, c = e.padding, d = e.boundary, _ = e.rootBoundary, f = e.altBoundary, m = e.flipVariations, g = m === void 0 ? !0 : m, b = e.allowedAutoPlacements, T = t.options.placement, C = gt(T), w = C === T, v = l || (w || !g ? [ss(T)] : $c(T)), E = [T].concat(v).reduce(function(be, Nt) {
      return be.concat(gt(Nt) === mi ? Ic(t, {
        placement: Nt,
        boundary: d,
        rootBoundary: _,
        padding: c,
        flipVariations: g,
        allowedAutoPlacements: b
      }) : Nt);
    }, []), A = t.rects.reference, y = t.rects.popper, S = /* @__PURE__ */ new Map(), O = !0, k = E[0], D = 0; D < E.length; D++) {
      var x = E[D], $ = gt(x), P = Be(x) === _e, tt = [Z, dt].indexOf($) >= 0, et = tt ? "width" : "height", z = Ve(t, {
        placement: x,
        boundary: d,
        rootBoundary: _,
        altBoundary: f,
        padding: c
      }), _t = tt ? P ? ht : J : P ? dt : Z;
      A[et] > y[et] && (_t = ss(_t));
      var wi = ss(_t), Zt = [];
      if (o && Zt.push(z[$] <= 0), a && Zt.push(z[_t] <= 0, z[wi] <= 0), Zt.every(function(be) {
        return be;
      })) {
        k = x, O = !1;
        break;
      }
      S.set(x, Zt);
    }
    if (O)
      for (var ki = g ? 3 : 1, Ns = function(Nt) {
        var Xe = E.find(function(xi) {
          var Jt = S.get(xi);
          if (Jt)
            return Jt.slice(0, Nt).every(function(Rs) {
              return Rs;
            });
        });
        if (Xe)
          return k = Xe, "break";
      }, ze = ki; ze > 0; ze--) {
        var Oi = Ns(ze);
        if (Oi === "break")
          break;
      }
    t.placement !== k && (t.modifiersData[i]._skip = !0, t.placement = k, t.reset = !0);
  }
}
const Za = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Lc,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function ko(s, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: s.top - t.height - e.y,
    right: s.right - t.width + e.x,
    bottom: s.bottom - t.height + e.y,
    left: s.left - t.width - e.x
  };
}
function Oo(s) {
  return [Z, ht, dt, J].some(function(t) {
    return s[t] >= 0;
  });
}
function Mc(s) {
  var t = s.state, e = s.name, i = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = Ve(t, {
    elementContext: "reference"
  }), a = Ve(t, {
    altBoundary: !0
  }), l = ko(r, i), c = ko(a, n, o), d = Oo(l), _ = Oo(c);
  t.modifiersData[e] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: d,
    hasPopperEscaped: _
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": d,
    "data-popper-escaped": _
  });
}
const Ja = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Mc
};
function Nc(s, t, e) {
  var i = gt(s), n = [J, Z].indexOf(i) >= 0 ? -1 : 1, o = typeof e == "function" ? e(Object.assign({}, t, {
    placement: s
  })) : e, r = o[0], a = o[1];
  return r = r || 0, a = (a || 0) * n, [J, ht].indexOf(i) >= 0 ? {
    x: a,
    y: r
  } : {
    x: r,
    y: a
  };
}
function Rc(s) {
  var t = s.state, e = s.options, i = s.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = qn.reduce(function(d, _) {
    return d[_] = Nc(_, t.rects, o), d;
  }, {}), a = r[t.placement], l = a.x, c = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[i] = r;
}
const tl = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Rc
};
function Pc(s) {
  var t = s.state, e = s.name;
  t.modifiersData[e] = Qa({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const ro = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Pc,
  data: {}
};
function Hc(s) {
  return s === "x" ? "y" : "x";
}
function Bc(s) {
  var t = s.state, e = s.options, i = s.name, n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !1 : r, l = e.boundary, c = e.rootBoundary, d = e.altBoundary, _ = e.padding, f = e.tether, m = f === void 0 ? !0 : f, g = e.tetherOffset, b = g === void 0 ? 0 : g, T = Ve(t, {
    boundary: l,
    rootBoundary: c,
    padding: _,
    altBoundary: d
  }), C = gt(t.placement), w = Be(t.placement), v = !w, E = to(C), A = Hc(E), y = t.modifiersData.popperOffsets, S = t.rects.reference, O = t.rects.popper, k = typeof b == "function" ? b(Object.assign({}, t.rects, {
    placement: t.placement
  })) : b, D = typeof k == "number" ? {
    mainAxis: k,
    altAxis: k
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, k), x = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, $ = {
    x: 0,
    y: 0
  };
  if (y) {
    if (o) {
      var P, tt = E === "y" ? Z : J, et = E === "y" ? dt : ht, z = E === "y" ? "height" : "width", _t = y[E], wi = _t + T[tt], Zt = _t - T[et], ki = m ? -O[z] / 2 : 0, Ns = w === _e ? S[z] : O[z], ze = w === _e ? -O[z] : -S[z], Oi = t.elements.arrow, be = m && Oi ? Jn(Oi) : {
        width: 0,
        height: 0
      }, Nt = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Ua(), Xe = Nt[tt], xi = Nt[et], Jt = li(0, S[z], be[z]), Rs = v ? S[z] / 2 - ki - Jt - Xe - D.mainAxis : Ns - Jt - Xe - D.mainAxis, Fl = v ? -S[z] / 2 + ki + Jt + xi + D.mainAxis : ze + Jt + xi + D.mainAxis, Ps = t.elements.arrow && gi(t.elements.arrow), Yl = Ps ? E === "y" ? Ps.clientTop || 0 : Ps.clientLeft || 0 : 0, ho = (P = x == null ? void 0 : x[E]) != null ? P : 0, jl = _t + Rs - ho - Yl, Kl = _t + Fl - ho, uo = li(m ? Ts(wi, jl) : wi, _t, m ? pe(Zt, Kl) : Zt);
      y[E] = uo, $[E] = uo - _t;
    }
    if (a) {
      var po, Ul = E === "x" ? Z : J, zl = E === "x" ? dt : ht, te = y[A], Si = A === "y" ? "height" : "width", fo = te + T[Ul], _o = te - T[zl], Hs = [Z, J].indexOf(C) !== -1, mo = (po = x == null ? void 0 : x[A]) != null ? po : 0, go = Hs ? fo : te - S[Si] - O[Si] - mo + D.altAxis, bo = Hs ? te + S[Si] + O[Si] - mo - D.altAxis : _o, vo = m && Hs ? mc(go, te, bo) : li(m ? go : fo, te, m ? bo : _o);
      y[A] = vo, $[A] = vo - te;
    }
    t.modifiersData[i] = $;
  }
}
const el = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: Bc,
  requiresIfExists: ["offset"]
};
function Vc(s) {
  return {
    scrollLeft: s.scrollLeft,
    scrollTop: s.scrollTop
  };
}
function Wc(s) {
  return s === ut(s) || !ct(s) ? so(s) : Vc(s);
}
function Fc(s) {
  var t = s.getBoundingClientRect(), e = Pe(t.width) / s.offsetWidth || 1, i = Pe(t.height) / s.offsetHeight || 1;
  return e !== 1 || i !== 1;
}
function Yc(s, t, e) {
  e === void 0 && (e = !1);
  var i = ct(t), n = ct(t) && Fc(t), o = qt(t), r = He(s, n, e), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !e) && ((It(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  oo(o)) && (a = Wc(t)), ct(t) ? (l = He(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = no(o))), {
    x: r.left + a.scrollLeft - l.x,
    y: r.top + a.scrollTop - l.y,
    width: r.width,
    height: r.height
  };
}
function jc(s) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];
  s.forEach(function(o) {
    t.set(o.name, o);
  });
  function n(o) {
    e.add(o.name);
    var r = [].concat(o.requires || [], o.requiresIfExists || []);
    r.forEach(function(a) {
      if (!e.has(a)) {
        var l = t.get(a);
        l && n(l);
      }
    }), i.push(o);
  }
  return s.forEach(function(o) {
    e.has(o.name) || n(o);
  }), i;
}
function Kc(s) {
  var t = jc(s);
  return Es.reduce(function(e, i) {
    return e.concat(t.filter(function(n) {
      return n.phase === i;
    }));
  }, []);
}
function Uc(s) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(s());
      });
    })), t;
  };
}
function Rt(s) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  return [].concat(e).reduce(function(n, o) {
    return n.replace(/%s/, o);
  }, s);
}
var ie = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', zc = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', xo = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function Xc(s) {
  s.forEach(function(t) {
    [].concat(Object.keys(t), xo).filter(function(e, i, n) {
      return n.indexOf(e) === i;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(Rt(ie, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(Rt(ie, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          Es.indexOf(t.phase) < 0 && console.error(Rt(ie, t.name, '"phase"', "either " + Es.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(Rt(ie, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(Rt(ie, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(Rt(ie, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(Rt(ie, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + xo.map(function(i) {
            return '"' + i + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(i) {
        s.find(function(n) {
          return n.name === i;
        }) == null && console.error(Rt(zc, String(t.name), i, i));
      });
    });
  });
}
function Gc(s, t) {
  var e = /* @__PURE__ */ new Set();
  return s.filter(function(i) {
    var n = t(i);
    if (!e.has(n))
      return e.add(n), !0;
  });
}
function qc(s) {
  var t = s.reduce(function(e, i) {
    var n = e[i.name];
    return e[i.name] = n ? Object.assign({}, n, i, {
      options: Object.assign({}, n.options, i.options),
      data: Object.assign({}, n.data, i.data)
    }) : i, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var So = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", Qc = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", Do = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Io() {
  for (var s = arguments.length, t = new Array(s), e = 0; e < s; e++)
    t[e] = arguments[e];
  return !t.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function ks(s) {
  s === void 0 && (s = {});
  var t = s, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? Do : n;
  return function(a, l, c) {
    c === void 0 && (c = o);
    var d = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Do, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, _ = [], f = !1, m = {
      state: d,
      setOptions: function(C) {
        var w = typeof C == "function" ? C(d.options) : C;
        b(), d.options = Object.assign({}, o, d.options, w), d.scrollParents = {
          reference: me(a) ? ci(a) : a.contextElement ? ci(a.contextElement) : [],
          popper: ci(l)
        };
        var v = Kc(qc([].concat(i, d.options.modifiers)));
        if (d.orderedModifiers = v.filter(function(x) {
          return x.enabled;
        }), {}.NODE_ENV !== "production") {
          var E = Gc([].concat(v, d.options.modifiers), function(x) {
            var $ = x.name;
            return $;
          });
          if (Xc(E), gt(d.options.placement) === mi) {
            var A = d.orderedModifiers.find(function(x) {
              var $ = x.name;
              return $ === "flip";
            });
            A || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var y = bt(l), S = y.marginTop, O = y.marginRight, k = y.marginBottom, D = y.marginLeft;
          [S, O, k, D].some(function(x) {
            return parseFloat(x);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return g(), m.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var C = d.elements, w = C.reference, v = C.popper;
          if (!Io(w, v)) {
            ({}).NODE_ENV !== "production" && console.error(So);
            return;
          }
          d.rects = {
            reference: Yc(w, gi(v), d.options.strategy === "fixed"),
            popper: Jn(v)
          }, d.reset = !1, d.placement = d.options.placement, d.orderedModifiers.forEach(function(x) {
            return d.modifiersData[x.name] = Object.assign({}, x.data);
          });
          for (var E = 0, A = 0; A < d.orderedModifiers.length; A++) {
            if ({}.NODE_ENV !== "production" && (E += 1, E > 100)) {
              console.error(Qc);
              break;
            }
            if (d.reset === !0) {
              d.reset = !1, A = -1;
              continue;
            }
            var y = d.orderedModifiers[A], S = y.fn, O = y.options, k = O === void 0 ? {} : O, D = y.name;
            typeof S == "function" && (d = S({
              state: d,
              options: k,
              name: D,
              instance: m
            }) || d);
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Uc(function() {
        return new Promise(function(T) {
          m.forceUpdate(), T(d);
        });
      }),
      destroy: function() {
        b(), f = !0;
      }
    };
    if (!Io(a, l))
      return {}.NODE_ENV !== "production" && console.error(So), m;
    m.setOptions(c).then(function(T) {
      !f && c.onFirstUpdate && c.onFirstUpdate(T);
    });
    function g() {
      d.orderedModifiers.forEach(function(T) {
        var C = T.name, w = T.options, v = w === void 0 ? {} : w, E = T.effect;
        if (typeof E == "function") {
          var A = E({
            state: d,
            name: C,
            instance: m,
            options: v
          }), y = function() {
          };
          _.push(A || y);
        }
      });
    }
    function b() {
      _.forEach(function(T) {
        return T();
      }), _ = [];
    }
    return m;
  };
}
var Zc = /* @__PURE__ */ ks(), Jc = [io, ro, eo, Zn], td = /* @__PURE__ */ ks({
  defaultModifiers: Jc
}), ed = [io, ro, eo, Zn, tl, Za, el, Ga, Ja], je = /* @__PURE__ */ ks({
  defaultModifiers: ed
});
const il = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  afterMain: Va,
  afterRead: Pa,
  afterWrite: Ya,
  applyStyles: Zn,
  arrow: Ga,
  auto: mi,
  basePlacements: Ye,
  beforeMain: Ha,
  beforeRead: Na,
  beforeWrite: Wa,
  bottom: dt,
  clippingParents: La,
  computeStyles: eo,
  createPopper: je,
  createPopperBase: Zc,
  createPopperLite: td,
  detectOverflow: Ve,
  end: Re,
  eventListeners: io,
  flip: Za,
  hide: Ja,
  left: J,
  main: Ba,
  modifierPhases: Es,
  offset: tl,
  placements: qn,
  popper: ye,
  popperGenerator: ks,
  popperOffsets: ro,
  preventOverflow: el,
  read: Ra,
  reference: Ma,
  right: ht,
  start: _e,
  top: Z,
  variationPlacements: $n,
  viewport: Gn,
  write: Fa
}, Symbol.toStringTag, { value: "Module" }));
function Fs(s) {
  return s === "true" ? !0 : s === "false" ? !1 : s === Number(s).toString() ? Number(s) : s === "" || s === "null" ? null : s;
}
function Ys(s) {
  return s.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
const p = {
  setDataAttribute(s, t, e) {
    s.setAttribute(`data-te-${Ys(t)}`, e);
  },
  removeDataAttribute(s, t) {
    s.removeAttribute(`data-te-${Ys(t)}`);
  },
  getDataAttributes(s) {
    if (!s)
      return {};
    const t = {};
    return Object.keys(s.dataset).filter((e) => e.startsWith("te")).forEach((e) => {
      if (e.startsWith("teClass"))
        return;
      let i = e.replace(/^te/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = Fs(s.dataset[e]);
    }), t;
  },
  getDataClassAttributes(s) {
    if (!s)
      return {};
    const t = {
      ...s.dataset
    };
    return Object.keys(t).filter((e) => e.startsWith("teClass")).forEach((e) => {
      let i = e.replace(/^teClass/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = Fs(t[e]);
    }), t;
  },
  getDataAttribute(s, t) {
    return Fs(
      s.getAttribute(`data-te-${Ys(t)}`)
    );
  },
  offset(s) {
    const t = s.getBoundingClientRect();
    return {
      top: t.top + document.body.scrollTop,
      left: t.left + document.body.scrollLeft
    };
  },
  position(s) {
    return {
      top: s.offsetTop,
      left: s.offsetLeft
    };
  },
  style(s, t) {
    Object.assign(s.style, t);
  },
  toggleClass(s, t) {
    s && js(t).forEach((e) => {
      s.classList.contains(e) ? s.classList.remove(e) : s.classList.add(e);
    });
  },
  addClass(s, t) {
    js(t).forEach(
      (e) => !s.classList.contains(e) && s.classList.add(e)
    );
  },
  addStyle(s, t) {
    Object.keys(t).forEach((e) => {
      s.style[e] = t[e];
    });
  },
  removeClass(s, t) {
    js(t).forEach(
      (e) => s.classList.contains(e) && s.classList.remove(e)
    );
  },
  hasClass(s, t) {
    return s.classList.contains(t);
  }
};
function js(s) {
  return typeof s == "string" ? s.split(" ") : Array.isArray(s) ? s : !1;
}
const id = 3, h = {
  closest(s, t) {
    return s.closest(t);
  },
  matches(s, t) {
    return s.matches(t);
  },
  find(s, t = document.documentElement) {
    return [].concat(
      ...Element.prototype.querySelectorAll.call(t, s)
    );
  },
  findOne(s, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, s);
  },
  children(s, t) {
    return [].concat(...s.children).filter((i) => i.matches(t));
  },
  parents(s, t) {
    const e = [];
    let i = s.parentNode;
    for (; i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== id; )
      this.matches(i, t) && e.push(i), i = i.parentNode;
    return e;
  },
  prev(s, t) {
    let e = s.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  next(s, t) {
    let e = s.nextElementSibling;
    for (; e; ) {
      if (this.matches(e, t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  },
  focusableChildren(s) {
    const t = [
      "a",
      "button",
      "input",
      "textarea",
      "select",
      "details",
      "[tabindex]",
      '[contenteditable="true"]'
    ].map((e) => `${e}:not([tabindex^="-"])`).join(", ");
    return this.find(t, s).filter(
      (e) => !ue(e) && St(e)
    );
  }
}, Ks = "dropdown", sd = "te.dropdown", ge = `.${sd}`, ao = ".data-api", ns = "Escape", $o = "Space", Lo = "Tab", Nn = "ArrowUp", os = "ArrowDown", nd = 2, od = new RegExp(
  `${Nn}|${os}|${ns}`
), rd = `hide${ge}`, ad = `hidden${ge}`, ld = `show${ge}`, cd = `shown${ge}`, dd = `click${ge}${ao}`, Mo = `keydown${ge}${ao}`, hd = `keyup${ge}${ao}`, Pt = "show", ud = "dropup", pd = "dropend", fd = "dropstart", _d = "[data-te-navbar-ref]", Ii = "[data-te-dropdown-toggle-ref]", Us = "[data-te-dropdown-menu-ref]", md = "[data-te-navbar-nav-ref]", gd = "[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)", bd = F() ? "top-end" : "top-start", vd = F() ? "top-start" : "top-end", Ed = F() ? "bottom-end" : "bottom-start", Td = F() ? "bottom-start" : "bottom-end", Cd = F() ? "left-start" : "right-start", Ad = F() ? "right-start" : "left-start", yd = [{ opacity: "0" }, { opacity: "1" }], wd = [{ opacity: "1" }, { opacity: "0" }], $i = {
  duration: 550,
  iterations: 1,
  easing: "ease",
  fill: "both"
}, kd = {
  offset: [0, 2],
  boundary: "clippingParents",
  reference: "toggle",
  display: "dynamic",
  popperConfig: null,
  autoClose: !0,
  dropdownAnimation: "on"
}, Od = {
  offset: "(array|string|function)",
  boundary: "(string|element)",
  reference: "(string|element|object)",
  display: "string",
  popperConfig: "(null|object|function)",
  autoClose: "(boolean|string)",
  dropdownAnimation: "string"
};
class wt extends vt {
  constructor(t, e) {
    super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._fadeOutAnimate = null;
    const i = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    this._animationCanPlay = this._config.dropdownAnimation === "on" && !i, this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return kd;
  }
  static get DefaultType() {
    return Od;
  }
  static get NAME() {
    return Ks;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (ue(this._element) || this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    if (u.trigger(
      this._element,
      ld,
      t
    ).defaultPrevented)
      return;
    const i = wt.getParentFromElement(this._element);
    this._inNavbar ? p.setDataAttribute(this._menu, "popper", "none") : this._createPopper(i), "ontouchstart" in document.documentElement && !i.closest(md) && [].concat(...document.body.children).forEach((n) => u.on(n, "mouseover", vs)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.setAttribute(`data-te-dropdown-${Pt}`, ""), this._animationCanPlay && this._menu.animate(yd, $i), this._element.setAttribute(`data-te-dropdown-${Pt}`, ""), setTimeout(
      () => {
        u.trigger(this._element, cd, t);
      },
      this._animationCanPlay ? $i.duration : 0
    );
  }
  hide() {
    if (ue(this._element) || !this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    this._completeHide(t);
  }
  dispose() {
    this._popper && this._popper.destroy(), super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
  }
  // Private
  _init() {
    this._didInit || (u.on(
      document,
      Mo,
      Ii,
      wt.dataApiKeydownHandler
    ), u.on(
      document,
      Mo,
      Us,
      wt.dataApiKeydownHandler
    ), u.on(document, dd, wt.clearMenus), u.on(document, hd, wt.clearMenus), this._didInit = !0);
  }
  _completeHide(t) {
    this._fadeOutAnimate && this._fadeOutAnimate.playState === "running" || u.trigger(
      this._element,
      rd,
      t
    ).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((i) => u.off(i, "mouseover", vs)), this._animationCanPlay && (this._fadeOutAnimate = this._menu.animate(
      wd,
      $i
    )), setTimeout(
      () => {
        this._popper && this._popper.destroy(), this._menu.removeAttribute(`data-te-dropdown-${Pt}`), this._element.removeAttribute(`data-te-dropdown-${Pt}`), this._element.setAttribute("aria-expanded", "false"), p.removeDataAttribute(this._menu, "popper"), u.trigger(this._element, ad, t);
      },
      this._animationCanPlay ? $i.duration : 0
    ));
  }
  _getConfig(t) {
    if (t = {
      ...this.constructor.Default,
      ...p.getDataAttributes(this._element),
      ...t
    }, N(Ks, t, this.constructor.DefaultType), typeof t.reference == "object" && !Ne(t.reference) && typeof t.reference.getBoundingClientRect != "function")
      throw new TypeError(
        `${Ks.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
      );
    return t;
  }
  _createPopper(t) {
    if (typeof il > "u")
      throw new TypeError(
        "Bootstrap's dropdowns require Popper (https://popper.js.org)"
      );
    let e = this._element;
    this._config.reference === "parent" ? e = t : Ne(this._config.reference) ? e = Gt(this._config.reference) : typeof this._config.reference == "object" && (e = this._config.reference);
    const i = this._getPopperConfig(), n = i.modifiers.find(
      (o) => o.name === "applyStyles" && o.enabled === !1
    );
    this._popper = je(
      e,
      this._menu,
      i
    ), n && p.setDataAttribute(this._menu, "popper", "static");
  }
  _isShown(t = this._element) {
    return t.dataset[`teDropdown${Pt.charAt(0).toUpperCase() + Pt.slice(1)}`] === "";
  }
  _getMenuElement() {
    return h.next(this._element, Us)[0];
  }
  _getPlacement() {
    const t = this._element.parentNode;
    if (t.dataset.teDropdownPosition === pd)
      return Cd;
    if (t.dataset.teDropdownPosition === fd)
      return Ad;
    const e = getComputedStyle(this._menu).getPropertyValue("--te-position").trim() === "end";
    return t.dataset.teDropdownPosition === ud ? e ? vd : bd : e ? Td : Ed;
  }
  _detectNavbar() {
    return this._element.closest(_d) !== null;
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _getPopperConfig() {
    const t = {
      placement: this._getPlacement(),
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }
      ]
    };
    return this._config.display === "static" && (t.modifiers = [
      {
        name: "applyStyles",
        enabled: !1
      }
    ]), {
      ...t,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig
    };
  }
  _selectMenuItem({ key: t, target: e }) {
    const i = h.find(
      gd,
      this._menu
    ).filter(St);
    i.length && wa(
      i,
      e,
      t === os,
      !i.includes(e)
    ).focus();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = wt.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static clearMenus(t) {
    if (t && (t.button === nd || t.type === "keyup" && t.key !== Lo))
      return;
    const e = h.find(Ii);
    for (let i = 0, n = e.length; i < n; i++) {
      const o = wt.getInstance(e[i]);
      if (!o || o._config.autoClose === !1 || !o._isShown())
        continue;
      const r = {
        relatedTarget: o._element
      };
      if (t) {
        const a = t.composedPath(), l = a.includes(o._menu);
        if (a.includes(o._element) || o._config.autoClose === "inside" && !l || o._config.autoClose === "outside" && l || o._menu.contains(t.target) && (t.type === "keyup" && t.key === Lo || /input|select|option|textarea|form/i.test(t.target.tagName)))
          continue;
        t.type === "click" && (r.clickEvent = t);
      }
      o._completeHide(r);
    }
  }
  static getParentFromElement(t) {
    return Xt(t) || t.parentNode;
  }
  static dataApiKeydownHandler(t) {
    if (/input|textarea/i.test(t.target.tagName) ? t.key === $o || t.key !== ns && (t.key !== os && t.key !== Nn || t.target.closest(Us)) : !od.test(t.key))
      return;
    const e = this.dataset[`teDropdown${Pt.charAt(0).toUpperCase() + Pt.slice(1)}`] === "";
    if (!e && t.key === ns || (t.preventDefault(), t.stopPropagation(), ue(this)))
      return;
    const i = this.matches(Ii) ? this : h.prev(this, Ii)[0], n = wt.getOrCreateInstance(i);
    if (t.key === ns) {
      n.hide();
      return;
    }
    if (t.key === Nn || t.key === os) {
      e || n.show(), n._selectMenuItem(t);
      return;
    }
    (!e || t.key === $o) && wt.clearMenus();
  }
}
const zs = "collapse", sl = "te.collapse", Os = `.${sl}`, No = {
  toggle: !0,
  parent: null
}, xd = {
  toggle: "boolean",
  parent: "(null|element)"
}, Sd = `show${Os}`, Dd = `shown${Os}`, Id = `hide${Os}`, $d = `hidden${Os}`, Xs = "data-te-collapse-show", Ro = "data-te-collapse-collapsed", Li = "data-te-collapse-collapsing", Ld = "data-te-collapse-horizontal", Oe = "data-te-collapse-item", Po = `:scope [${Oe}] [${Oe}]`, Md = "width", Nd = "height", Rd = "[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]", Ho = "[data-te-collapse-init]", Pd = {
  visible: "!visible",
  hidden: "hidden",
  baseTransition: "overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsing: "h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsingHorizontal: "w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none"
}, Hd = {
  visible: "string",
  hidden: "string",
  baseTransition: "string",
  collapsing: "string",
  collapsingHorizontal: "string"
};
class Ut extends vt {
  constructor(t, e, i) {
    super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._triggerArray = [];
    const n = h.find(Ho);
    for (let o = 0, r = n.length; o < r; o++) {
      const a = n[o], l = Xn(a), c = h.find(l).filter(
        (d) => d === this._element
      );
      l !== null && c.length && (this._selector = l, this._triggerArray.push(a));
    }
    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
  }
  // Getters
  static get Default() {
    return No;
  }
  static get NAME() {
    return zs;
  }
  // Public
  toggle() {
    this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (this._isTransitioning || this._isShown())
      return;
    let t = [], e;
    if (this._config.parent) {
      const d = h.find(
        Po,
        this._config.parent
      );
      t = h.find(
        Rd,
        this._config.parent
      ).filter((_) => !d.includes(_));
    }
    const i = h.findOne(this._selector);
    if (t.length) {
      const d = t.find((_) => i !== _);
      if (e = d ? Ut.getInstance(d) : null, e && e._isTransitioning)
        return;
    }
    if (u.trigger(this._element, Sd).defaultPrevented)
      return;
    t.forEach((d) => {
      i !== d && Ut.getOrCreateInstance(d, { toggle: !1 }).hide(), e || I.setData(d, sl, null);
    });
    const o = this._getDimension(), r = o === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    p.removeClass(this._element, this._classes.visible), p.removeClass(this._element, this._classes.hidden), p.addClass(this._element, r), this._element.removeAttribute(Oe), this._element.setAttribute(Li, ""), this._element.style[o] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
    const a = () => {
      this._isTransitioning = !1, p.removeClass(this._element, this._classes.hidden), p.removeClass(this._element, r), p.addClass(this._element, this._classes.visible), this._element.removeAttribute(Li), this._element.setAttribute(Oe, ""), this._element.setAttribute(Xs, ""), this._element.style[o] = "", u.trigger(this._element, Dd);
    }, c = `scroll${o[0].toUpperCase() + o.slice(1)}`;
    this._queueCallback(a, this._element, !0), this._element.style[o] = `${this._element[c]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown() || u.trigger(this._element, Id).defaultPrevented)
      return;
    const e = this._getDimension(), i = e === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Fe(this._element), p.addClass(this._element, i), p.removeClass(this._element, this._classes.visible), p.removeClass(this._element, this._classes.hidden), this._element.setAttribute(Li, ""), this._element.removeAttribute(Oe), this._element.removeAttribute(Xs);
    const n = this._triggerArray.length;
    for (let r = 0; r < n; r++) {
      const a = this._triggerArray[r], l = Xt(a);
      l && !this._isShown(l) && this._addAriaAndCollapsedClass([a], !1);
    }
    this._isTransitioning = !0;
    const o = () => {
      this._isTransitioning = !1, p.removeClass(this._element, i), p.addClass(this._element, this._classes.visible), p.addClass(this._element, this._classes.hidden), this._element.removeAttribute(Li), this._element.setAttribute(Oe, ""), u.trigger(this._element, $d);
    };
    this._element.style[e] = "", this._queueCallback(o, this._element, !0);
  }
  _isShown(t = this._element) {
    return t.hasAttribute(Xs);
  }
  // Private
  _getConfig(t) {
    return t = {
      ...No,
      ...p.getDataAttributes(this._element),
      ...t
    }, t.toggle = !!t.toggle, t.parent = Gt(t.parent), N(zs, t, xd), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...Pd,
      ...e,
      ...t
    }, N(zs, t, Hd), t;
  }
  _getDimension() {
    return this._element.hasAttribute(Ld) ? Md : Nd;
  }
  _initializeChildren() {
    if (!this._config.parent)
      return;
    const t = h.find(
      Po,
      this._config.parent
    );
    h.find(Ho, this._config.parent).filter((e) => !t.includes(e)).forEach((e) => {
      const i = Xt(e);
      i && this._addAriaAndCollapsedClass([e], this._isShown(i));
    });
  }
  _addAriaAndCollapsedClass(t, e) {
    t.length && t.forEach((i) => {
      e ? i.removeAttribute(Ro) : i.setAttribute(`${Ro}`, ""), i.setAttribute("aria-expanded", e);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = {};
      typeof t == "string" && /show|hide/.test(t) && (e.toggle = !1);
      const i = Ut.getOrCreateInstance(this, e);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t]();
      }
    });
  }
}
const Bo = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", Vo = ".sticky-top";
class pi {
  constructor() {
    this._element = document.body;
  }
  getWidth() {
    const t = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - t);
  }
  hide() {
    const t = this.getWidth();
    this._disableOverFlow(), this._setElementAttributes(
      this._element,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      Bo,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      Vo,
      "marginRight",
      (e) => e - t
    );
  }
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
  }
  _setElementAttributes(t, e, i) {
    const n = this.getWidth(), o = (r) => {
      if (r !== this._element && window.innerWidth > r.clientWidth + n)
        return;
      this._saveInitialAttribute(r, e);
      const a = window.getComputedStyle(r)[e];
      r.style[e] = `${i(
        Number.parseFloat(a)
      )}px`;
    };
    this._applyManipulationCallback(t, o);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(Bo, "paddingRight"), this._resetElementAttributes(Vo, "marginRight");
  }
  _saveInitialAttribute(t, e) {
    const i = t.style[e];
    i && p.setDataAttribute(t, e, i);
  }
  _resetElementAttributes(t, e) {
    const i = (n) => {
      const o = p.getDataAttribute(n, e);
      typeof o > "u" ? n.style.removeProperty(e) : (p.removeDataAttribute(n, e), n.style[e] = o);
    };
    this._applyManipulationCallback(t, i);
  }
  _applyManipulationCallback(t, e) {
    Ne(t) ? e(t) : h.find(t, this._element).forEach(e);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
}
const Bd = {
  isVisible: !0,
  // if false, we use the backdrop helper without adding any element to the dom
  isAnimated: !1,
  rootElement: "body",
  // give the choice to place backdrop under different elements
  clickCallback: null,
  backdropClasses: null
}, Vd = {
  isVisible: "boolean",
  isAnimated: "boolean",
  rootElement: "(element|string)",
  clickCallback: "(function|null)",
  backdropClasses: "(array|null)"
}, nl = "backdrop", Wo = `mousedown.te.${nl}`;
class lo {
  constructor(t) {
    this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
  }
  show(t) {
    if (!this._config.isVisible) {
      he(t);
      return;
    }
    this._append(), this._config.isAnimated && Fe(this._getElement());
    const e = this._config.backdropClasses || [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      "fixed",
      "top-0",
      "left-0",
      "z-[1040]",
      "bg-black",
      "w-screen",
      "h-screen"
    ];
    p.removeClass(this._getElement(), "opacity-0"), p.addClass(this._getElement(), e), this._element.setAttribute("data-te-backdrop-show", ""), this._emulateAnimation(() => {
      he(t);
    });
  }
  hide(t) {
    if (!this._config.isVisible) {
      he(t);
      return;
    }
    this._element.removeAttribute("data-te-backdrop-show"), this._getElement().classList.add("opacity-0"), this._getElement().classList.remove("opacity-50"), this._emulateAnimation(() => {
      this.dispose(), he(t);
    });
  }
  // Private
  _getElement() {
    if (!this._element) {
      const t = document.createElement("div");
      t.className = this._config.className, this._config.isAnimated && t.classList.add("opacity-50"), this._element = t;
    }
    return this._element;
  }
  _getConfig(t) {
    return t = {
      ...Bd,
      ...typeof t == "object" ? t : {}
    }, t.rootElement = Gt(t.rootElement), N(nl, t, Vd), t;
  }
  _append() {
    this._isAppended || (this._config.rootElement.append(this._getElement()), u.on(this._getElement(), Wo, () => {
      he(this._config.clickCallback);
    }), this._isAppended = !0);
  }
  dispose() {
    this._isAppended && (u.off(this._element, Wo), this._element.remove(), this._isAppended = !1);
  }
  _emulateAnimation(t) {
    ya(
      t,
      this._getElement(),
      this._config.isAnimated
    );
  }
}
class bi {
  constructor(t, e = {}, i) {
    this._element = t, this._toggler = i, this._event = e.event || "blur", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {
      this._condition(n) && !n.shiftKey && n.target === this._lastElement ? (n.preventDefault(), this._firstElement.focus()) : this._condition(n) && n.shiftKey && n.target === this._firstElement && (n.preventDefault(), this._lastElement.focus());
    };
  }
  trap() {
    this._setElements(), this._init(), this._setFocusTrap();
  }
  disable() {
    this._focusableElements.forEach((t) => {
      t.removeEventListener(this._event, this.handler);
    }), this._toggler && this._toggler.focus();
  }
  update() {
    this._setElements(), this._setFocusTrap();
  }
  _init() {
    const t = (e) => {
      !this._firstElement || e.key !== "Tab" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener("keydown", t));
    };
    window.addEventListener("keydown", t);
  }
  _filterVisible(t) {
    return t.filter((e) => {
      if (!St(e))
        return !1;
      const i = h.parents(e, "*");
      for (let n = 0; n < i.length; n++) {
        const o = window.getComputedStyle(i[n]);
        if (o && (o.display === "none" || o.visibility === "hidden"))
          return !1;
      }
      return !0;
    });
  }
  _setElements() {
    this._focusableElements = h.focusableChildren(this._element), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];
  }
  _setFocusTrap() {
    this._focusableElements.forEach((t, e) => {
      e === this._focusableElements.length - 1 || e === 0 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);
    });
  }
}
const xs = (s, t = "hide") => {
  const e = `click.dismiss${s.EVENT_KEY}`, i = s.NAME;
  u.on(
    document,
    e,
    `[data-te-${i}-dismiss]`,
    function(n) {
      if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), ue(this))
        return;
      const o = Xt(this) || this.closest(`.${i}`) || this.closest(`[data-te-${i}-init]`);
      if (!o)
        return;
      s.getOrCreateInstance(o)[t]();
    }
  );
}, Fo = "offcanvas", Wd = "te.offcanvas", Ke = `.${Wd}`, Fd = ".data-api", Yd = `load${Ke}${Fd}`, jd = "Escape", Yo = {
  backdrop: !0,
  keyboard: !0,
  scroll: !1
}, Kd = {
  backdrop: "boolean",
  keyboard: "boolean",
  scroll: "boolean"
}, jo = "show", Ud = "[data-te-offcanvas-init][data-te-offcanvas-show]", zd = `show${Ke}`, Xd = `shown${Ke}`, Gd = `hide${Ke}`, qd = `hidden${Ke}`, Qd = `keydown.dismiss${Ke}`;
class rs extends vt {
  constructor(t, e) {
    super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return Fo;
  }
  static get Default() {
    return Yo;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    if (this._isShown || u.trigger(this._element, zd, {
      relatedTarget: t
    }).defaultPrevented)
      return;
    this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || new pi().hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`data-te-offcanvas-${jo}`, "");
    const i = () => {
      this._config.scroll || this._focustrap.trap(), u.trigger(this._element, Xd, { relatedTarget: t });
    };
    this._queueCallback(i, this._element, !0);
  }
  hide() {
    if (!this._isShown || u.trigger(this._element, Gd).defaultPrevented)
      return;
    this._focustrap.disable(), this._element.blur(), this._isShown = !1, this._element.removeAttribute(`data-te-offcanvas-${jo}`), this._backdrop.hide();
    const e = () => {
      this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new pi().reset(), u.trigger(this._element, qd);
    };
    this._queueCallback(e, this._element, !0);
  }
  dispose() {
    this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (u.on(
      window,
      Yd,
      () => h.find(Ud).forEach(
        (t) => rs.getOrCreateInstance(t).show()
      )
    ), xs(rs), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...Yo,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, N(Fo, t, Kd), t;
  }
  _initializeBackDrop() {
    return new lo({
      isVisible: this._config.backdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      clickCallback: () => this.hide()
    });
  }
  _initializeFocusTrap() {
    return new bi(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _addEventListeners() {
    u.on(this._element, Qd, (t) => {
      this._config.keyboard && t.key === jd && this.hide();
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = rs.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const Gs = "alert", Zd = "te.alert", ol = `.${Zd}`, Jd = `close${ol}`, th = `closed${ol}`, Ge = "data-te-alert-show", eh = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, Ko = {
  animation: !0,
  autohide: !0,
  delay: 1e3
}, ih = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, sh = {
  fadeIn: "string",
  fadeOut: "string"
};
class Rn extends vt {
  constructor(t, e, i) {
    super(t), this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._didInit = !1, this._init();
  }
  // Getters
  static get DefaultType() {
    return eh;
  }
  static get Default() {
    return Ko;
  }
  static get NAME() {
    return Gs;
  }
  // Public
  close() {
    if (u.trigger(this._element, Jd).defaultPrevented)
      return;
    let e = 0;
    this._config.animation && (e = 300, p.addClass(this._element, this._classes.fadeOut)), this._element.removeAttribute(Ge), setTimeout(() => {
      this._queueCallback(
        () => this._destroyElement(),
        this._element,
        this._config.animation
      );
    }, e);
  }
  show() {
    if (this._element) {
      if (this._config.autohide && this._setupAutohide(), !this._element.hasAttribute(Ge) && (p.removeClass(this._element, "hidden"), p.addClass(this._element, "block"), St(this._element))) {
        const t = (e) => {
          p.removeClass(this._element, "hidden"), p.addClass(this._element, "block"), u.off(e.target, "animationend", t);
        };
        this._element.setAttribute(Ge, ""), u.on(this._element, "animationend", t);
      }
      this._config.animation && (p.removeClass(this._element, this._classes.fadeOut), p.addClass(this._element, this._classes.fadeIn));
    }
  }
  hide() {
    if (this._element && this._element.hasAttribute(Ge)) {
      this._element.removeAttribute(Ge);
      const t = (e) => {
        p.addClass(this._element, "hidden"), p.removeClass(this._element, "block"), this._timeout !== null && (clearTimeout(this._timeout), this._timeout = null), u.off(e.target, "animationend", t);
      };
      u.on(this._element, "animationend", t), p.removeClass(this._element, this._classes.fadeIn), p.addClass(this._element, this._classes.fadeOut);
    }
  }
  // Private
  _init() {
    this._didInit || (xs(Rn, "close"), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...Ko,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, N(Gs, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...ih,
      ...e,
      ...t
    }, N(Gs, t, sh), t;
  }
  _setupAutohide() {
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _destroyElement() {
    this._element.remove(), u.trigger(this._element, th), this.dispose();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Rn.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const qs = "carousel", nh = "te.carousel", pt = `.${nh}`, rl = ".data-api", oh = "ArrowLeft", rh = "ArrowRight", ah = 500, lh = 40, Uo = {
  interval: 5e3,
  keyboard: !0,
  slide: !1,
  pause: "hover",
  wrap: !0,
  touch: !0
}, ch = {
  interval: "(number|boolean)",
  keyboard: "boolean",
  slide: "(boolean|string)",
  pause: "(string|boolean)",
  wrap: "boolean",
  touch: "boolean"
}, dh = {
  pointer: "touch-pan-y",
  block: "!block",
  visible: "data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]",
  invisible: "data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-0 data-[te-carousel-fade]:delay-600",
  slideRight: "translate-x-full",
  slideLeft: "-translate-x-full"
}, hh = {
  pointer: "string",
  block: "string",
  visible: "string",
  invisible: "string",
  slideRight: "string",
  slideLeft: "string"
}, se = "next", ne = "prev", ce = "left", si = "right", uh = {
  [oh]: si,
  [rh]: ce
}, ph = `slide${pt}`, zo = `slid${pt}`, fh = `keydown${pt}`, _h = `mouseenter${pt}`, mh = `mouseleave${pt}`, gh = `touchstart${pt}`, bh = `touchmove${pt}`, vh = `touchend${pt}`, Eh = `pointerdown${pt}`, Th = `pointerup${pt}`, Ch = `dragstart${pt}`, Ah = `load${pt}${rl}`, yh = `click${pt}${rl}`, wh = "data-te-carousel-init", oe = "data-te-carousel-active", kh = "data-te-carousel-slide", Oh = "data-te-carousel-item-end", Qs = "data-te-carousel-item-start", xh = "data-te-carousel-item-next", Sh = "data-te-carousel-item-prev", Dh = "data-te-carousel-pointer-event", Ih = "[data-te-carousel-init]", al = "[data-te-carousel-active]", co = "[data-te-carousel-item]", ve = `${al}${co}`, $h = `${co} img`, Lh = "[data-te-carousel-item-next], [data-te-carousel-item-prev]", Mh = "[data-te-carousel-indicators]", Nh = "[data-te-target]", Rh = "[data-te-slide], [data-te-slide-to]", Ph = "touch", Hh = "pen";
class Yt extends vt {
  constructor(t, e, i) {
    super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._indicatorsElement = h.findOne(
      Mh,
      this._element
    ), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = !!window.PointerEvent, this._setActiveElementClass(), this._addEventListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return Uo;
  }
  static get NAME() {
    return qs;
  }
  // Public
  next() {
    this._slide(se);
  }
  nextWhenVisible() {
    !document.hidden && St(this._element) && this.next();
  }
  prev() {
    this._slide(ne);
  }
  pause(t) {
    t || (this._isPaused = !0), h.findOne(Lh, this._element) && (Ea(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;
  }
  cycle(t) {
    t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval(
      (document.visibilityState ? this.nextWhenVisible : this.next).bind(
        this
      ),
      this._config.interval
    ));
  }
  to(t) {
    this._activeElement = h.findOne(
      ve,
      this._element
    );
    const e = this._getItemIndex(this._activeElement);
    if (t > this._items.length - 1 || t < 0)
      return;
    if (this._isSliding) {
      u.one(this._element, zo, () => this.to(t));
      return;
    }
    if (e === t) {
      this.pause(), this.cycle();
      return;
    }
    const i = t > e ? se : ne;
    this._slide(i, this._items[t]);
  }
  // Private
  _init() {
    this._didInit || (u.on(
      document,
      yh,
      Rh,
      Yt.dataApiClickHandler
    ), u.on(window, Ah, () => {
      const t = h.find(Ih);
      for (let e = 0, i = t.length; e < i; e++)
        Yt.carouselInterface(
          t[e],
          Yt.getInstance(t[e])
        );
    }), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...Uo,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, N(qs, t, ch), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...dh,
      ...e,
      ...t
    }, N(qs, t, hh), t;
  }
  _applyInitialClasses() {
    const t = h.findOne(
      ve,
      this._element
    );
    t.classList.add(
      this._classes.block,
      ...this._classes.visible.split(" ")
    ), this._setActiveIndicatorElement(t);
  }
  _handleSwipe() {
    const t = Math.abs(this.touchDeltaX);
    if (t <= lh)
      return;
    const e = t / this.touchDeltaX;
    this.touchDeltaX = 0, e && this._slide(e > 0 ? si : ce);
  }
  _setActiveElementClass() {
    this._activeElement = h.findOne(
      ve,
      this._element
    ), p.addClass(this._activeElement, "hidden");
  }
  _addEventListeners() {
    this._config.keyboard && u.on(
      this._element,
      fh,
      (t) => this._keydown(t)
    ), this._config.pause === "hover" && (u.on(
      this._element,
      _h,
      (t) => this.pause(t)
    ), u.on(
      this._element,
      mh,
      (t) => this.cycle(t)
    )), this._config.touch && this._touchSupported && this._addTouchEventListeners(), this._applyInitialClasses();
  }
  _addTouchEventListeners() {
    const t = (o) => this._pointerEvent && (o.pointerType === Hh || o.pointerType === Ph), e = (o) => {
      t(o) ? this.touchStartX = o.clientX : this._pointerEvent || (this.touchStartX = o.touches[0].clientX);
    }, i = (o) => {
      this.touchDeltaX = o.touches && o.touches.length > 1 ? 0 : o.touches[0].clientX - this.touchStartX;
    }, n = (o) => {
      t(o) && (this.touchDeltaX = o.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(
        (r) => this.cycle(r),
        ah + this._config.interval
      ));
    };
    h.find($h, this._element).forEach(
      (o) => {
        u.on(
          o,
          Ch,
          (r) => r.preventDefault()
        );
      }
    ), this._pointerEvent ? (u.on(
      this._element,
      Eh,
      (o) => e(o)
    ), u.on(this._element, Th, (o) => n(o)), this._element.classList.add(this._classes.pointer), this._element.setAttribute(`${Dh}`, "")) : (u.on(this._element, gh, (o) => e(o)), u.on(this._element, bh, (o) => i(o)), u.on(this._element, vh, (o) => n(o)));
  }
  _keydown(t) {
    if (/input|textarea/i.test(t.target.tagName))
      return;
    const e = uh[t.key];
    e && (t.preventDefault(), this._slide(e));
  }
  _getItemIndex(t) {
    return this._items = t && t.parentNode ? h.find(co, t.parentNode) : [], this._items.indexOf(t);
  }
  _getItemByOrder(t, e) {
    const i = t === se;
    return wa(
      this._items,
      e,
      i,
      this._config.wrap
    );
  }
  _triggerSlideEvent(t, e) {
    const i = this._getItemIndex(t), n = this._getItemIndex(
      h.findOne(ve, this._element)
    );
    return u.trigger(this._element, ph, {
      relatedTarget: t,
      direction: e,
      from: n,
      to: i
    });
  }
  _setActiveIndicatorElement(t) {
    if (this._indicatorsElement) {
      const e = h.findOne(
        al,
        this._indicatorsElement
      );
      e.removeAttribute(oe), e.removeAttribute("aria-current"), e.classList.remove("!opacity-100");
      const i = h.find(
        Nh,
        this._indicatorsElement
      );
      for (let n = 0; n < i.length; n++)
        if (Number.parseInt(
          i[n].getAttribute("data-te-slide-to"),
          10
        ) === this._getItemIndex(t)) {
          i[n].setAttribute(`${oe}`, ""), i[n].setAttribute("aria-current", "true"), i[n].classList.add("!opacity-100");
          break;
        }
    }
  }
  _updateInterval() {
    const t = this._activeElement || h.findOne(ve, this._element);
    if (!t)
      return;
    const e = Number.parseInt(
      t.getAttribute("data-te-interval"),
      10
    );
    e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;
  }
  _slide(t, e) {
    const i = this._directionToOrder(t), n = h.findOne(
      ve,
      this._element
    ), o = this._getItemIndex(n), r = e || this._getItemByOrder(i, n), a = this._getItemIndex(r), l = !!this._interval, c = i === se, d = c ? Qs : Oh, _ = c ? xh : Sh, f = this._orderToDirection(i), m = d === Qs ? this._classes.slideLeft : this._classes.slideRight, g = d !== Qs ? this._classes.slideLeft : this._classes.slideRight;
    if (r && r.hasAttribute(oe)) {
      this._isSliding = !1;
      return;
    }
    if (this._isSliding || this._triggerSlideEvent(r, f).defaultPrevented || !n || !r)
      return;
    this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(r), this._activeElement = r;
    const T = () => {
      u.trigger(this._element, zo, {
        relatedTarget: r,
        direction: f,
        from: o,
        to: a
      });
    };
    if (this._element.hasAttribute(kh)) {
      r.setAttribute(`${_}`, ""), r.classList.add(this._classes.block, g), Fe(r), n.setAttribute(`${d}`, ""), n.classList.add(
        m,
        ...this._classes.invisible.split(" ")
      ), n.classList.remove(...this._classes.visible.split(" ")), r.setAttribute(`${d}`, ""), r.classList.add(...this._classes.visible.split(" ")), r.classList.remove(
        this._classes.slideRight,
        this._classes.slideLeft
      );
      const C = () => {
        r.removeAttribute(d), r.removeAttribute(_), r.setAttribute(`${oe}`, ""), n.removeAttribute(oe), n.classList.remove(
          m,
          ...this._classes.invisible.split(" "),
          this._classes.block
        ), n.removeAttribute(_), n.removeAttribute(d), this._isSliding = !1, setTimeout(T, 0);
      };
      this._queueCallback(C, n, !0);
    } else
      n.removeAttribute(oe), n.classList.remove(this._classes.block), r.setAttribute(`${oe}`, ""), r.classList.add(this._classes.block), this._isSliding = !1, T();
    l && this.cycle();
  }
  _directionToOrder(t) {
    return [si, ce].includes(t) ? F() ? t === ce ? ne : se : t === ce ? se : ne : t;
  }
  _orderToDirection(t) {
    return [se, ne].includes(t) ? F() ? t === ne ? ce : si : t === ne ? si : ce : t;
  }
  // Static
  static carouselInterface(t, e) {
    const i = Yt.getOrCreateInstance(t, e);
    let { _config: n } = i;
    typeof e == "object" && (n = {
      ...n,
      ...e
    });
    const o = typeof e == "string" ? e : n.slide;
    if (typeof e == "number")
      i.to(e);
    else if (typeof o == "string") {
      if (typeof i[o] > "u")
        throw new TypeError(`No method named "${o}"`);
      i[o]();
    } else
      n.interval && n.carouselInit === null && (i.pause(), i.cycle());
  }
  static jQueryInterface(t) {
    return this.each(function() {
      Yt.carouselInterface(this, t);
    });
  }
  static dataApiClickHandler(t) {
    const e = Xt(this);
    if (!e || !e.hasAttribute(wh))
      return;
    const i = {
      ...p.getDataAttributes(e),
      ...p.getDataAttributes(this)
    }, n = this.getAttribute("data-te-slide-to");
    n && (i.interval = !1), Yt.carouselInterface(e, i), n && Yt.getInstance(e).to(n), t.preventDefault();
  }
}
const Zs = "modal", Bh = "te.modal", Et = `.${Bh}`, Xo = "Escape", Go = {
  backdrop: !0,
  keyboard: !0,
  focus: !0
}, Vh = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  focus: "boolean"
}, Wh = {
  show: "transform-none",
  static: "scale-[1.02]",
  staticProperties: "transition-scale duration-300 ease-in-out"
}, Fh = {
  show: "string",
  static: "string",
  staticProperties: "string"
}, Yh = `hide${Et}`, jh = `hidePrevented${Et}`, Kh = `hidden${Et}`, Uh = `show${Et}`, zh = `shown${Et}`, qo = `resize${Et}`, Qo = `click.dismiss${Et}`, Zo = `keydown.dismiss${Et}`, Xh = `mouseup.dismiss${Et}`, Jo = `mousedown.dismiss${Et}`, tr = "data-te-modal-open", er = "data-te-open", qe = "[data-te-modal-dialog-ref]", Gh = "[data-te-modal-body-ref]";
class Pn extends vt {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._dialog = h.findOne(qe, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new pi(), this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return Go;
  }
  static get NAME() {
    return Zs;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    this._isShown || this._isTransitioning || u.trigger(this._element, Uh, {
      relatedTarget: t
    }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.setAttribute(tr, "true"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), u.on(this._dialog, Jo, () => {
      u.one(this._element, Xh, (i) => {
        i.target === this._element && (this._ignoreBackdropClick = !0);
      });
    }), this._showElement(t), this._showBackdrop());
  }
  hide() {
    if (!this._isShown || this._isTransitioning || u.trigger(this._element, Yh).defaultPrevented)
      return;
    this._isShown = !1;
    const e = this._isAnimated();
    e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.disable(), h.findOne(qe, this._element).classList.remove(this._classes.show), u.off(this._element, Qo), u.off(this._dialog, Jo), this._queueCallback(() => this._hideModal(), this._element, e), this._element.removeAttribute(er);
  }
  dispose() {
    [window, this._dialog].forEach(
      (t) => u.off(t, Et)
    ), this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _init() {
    this._didInit || (xs(Pn), this._didInit = !0);
  }
  _initializeBackDrop() {
    return new lo({
      isVisible: !!this._config.backdrop,
      // 'static' option will be translated to true, and booleans will keep their value
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new bi(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _getConfig(t) {
    return t = {
      ...Go,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, N(Zs, t, Vh), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...Wh,
      ...e,
      ...t
    }, N(Zs, t, Fh), t;
  }
  _showElement(t) {
    const e = this._isAnimated(), i = h.findOne(Gh, this._dialog);
    (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = "block", this._element.classList.remove("hidden"), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`${er}`, "true"), this._element.scrollTop = 0;
    const n = h.findOne(qe, this._element);
    n.classList.add(this._classes.show), n.classList.remove("opacity-0"), n.classList.add("opacity-100"), i && (i.scrollTop = 0), e && Fe(this._element);
    const o = () => {
      this._config.focus && this._focustrap.trap(), this._isTransitioning = !1, u.trigger(this._element, zh, {
        relatedTarget: t
      });
    };
    this._queueCallback(o, this._dialog, e);
  }
  _setEscapeEvent() {
    this._isShown ? u.on(document, Zo, (t) => {
      this._config.keyboard && t.key === Xo ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === Xo && this._triggerBackdropTransition();
    }) : u.off(this._element, Zo);
  }
  _setResizeEvent() {
    this._isShown ? u.on(window, qo, () => this._adjustDialog()) : u.off(window, qo);
  }
  _hideModal() {
    const t = h.findOne(qe, this._element);
    t.classList.remove(this._classes.show), t.classList.remove("opacity-100"), t.classList.add("opacity-0"), setTimeout(() => {
      this._element.style.display = "none";
    }, 300), this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
      document.body.removeAttribute(tr), this._resetAdjustments(), this._scrollBar.reset(), u.trigger(this._element, Kh);
    });
  }
  _showBackdrop(t) {
    u.on(this._element, Qo, (e) => {
      if (this._ignoreBackdropClick) {
        this._ignoreBackdropClick = !1;
        return;
      }
      e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === "static" && this._triggerBackdropTransition());
    }), this._backdrop.show(t);
  }
  _isAnimated() {
    return !!h.findOne(qe, this._element);
  }
  _triggerBackdropTransition() {
    if (u.trigger(this._element, jh).defaultPrevented)
      return;
    const { classList: e, scrollHeight: i, style: n } = this._element, o = i > document.documentElement.clientHeight;
    !o && n.overflowY === "hidden" || e.contains(this._classes.static) || (o || (n.overflowY = "hidden"), e.add(...this._classes.static.split(" ")), e.add(...this._classes.staticProperties.split(" ")), this._queueCallback(() => {
      e.remove(this._classes.static), setTimeout(() => {
        e.remove(...this._classes.staticProperties.split(" "));
      }, 300), o || this._queueCallback(() => {
        n.overflowY = "";
      }, this._dialog);
    }, this._dialog), this._element.focus());
  }
  // ----------------------------------------------------------------------
  // the following methods are used to handle overflowing modals
  // ----------------------------------------------------------------------
  _adjustDialog() {
    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), i = e > 0;
    (!i && t && !F() || i && !t && F()) && (this._element.style.paddingLeft = `${e}px`), (i && !t && !F() || !i && t && F()) && (this._element.style.paddingRight = `${e}px`);
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const i = Pn.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
}
const qh = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Qh = /^aria-[\w-]*$/i, Zh = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Jh = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, tu = (s, t) => {
  const e = s.nodeName.toLowerCase();
  if (t.includes(e))
    return qh.has(e) ? !!(Zh.test(s.nodeValue) || Jh.test(s.nodeValue)) : !0;
  const i = t.filter(
    (n) => n instanceof RegExp
  );
  for (let n = 0, o = i.length; n < o; n++)
    if (i[n].test(e))
      return !0;
  return !1;
}, eu = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Qh],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
function ir(s, t, e) {
  if (!s.length)
    return s;
  if (e && typeof e == "function")
    return e(s);
  const n = new window.DOMParser().parseFromString(s, "text/html"), o = [].concat(...n.body.querySelectorAll("*"));
  for (let r = 0, a = o.length; r < a; r++) {
    const l = o[r], c = l.nodeName.toLowerCase();
    if (!Object.keys(t).includes(c)) {
      l.remove();
      continue;
    }
    const d = [].concat(...l.attributes), _ = [].concat(
      t["*"] || [],
      t[c] || []
    );
    d.forEach((f) => {
      tu(f, _) || l.removeAttribute(f.nodeName);
    });
  }
  return n.body.innerHTML;
}
const sr = "tooltip", iu = "te.tooltip", Ct = `.${iu}`, su = "te-tooltip", nu = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), ou = {
  animation: "boolean",
  template: "string",
  title: "(string|element|function)",
  trigger: "string",
  delay: "(number|object)",
  html: "boolean",
  selector: "(string|boolean)",
  placement: "(string|function)",
  offset: "(array|string|function)",
  container: "(string|element|boolean)",
  fallbackPlacements: "array",
  boundary: "(string|element)",
  customClass: "(string|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  allowList: "object",
  popperConfig: "(null|object|function)"
}, ru = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: F() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: F() ? "right" : "left"
}, au = {
  animation: !0,
  template: '<div class="opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal" role="tooltip"><div data-te-tooltip-inner-ref class="tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded"></div></div>',
  trigger: "hover focus",
  title: "",
  delay: 0,
  html: !1,
  selector: !1,
  placement: "top",
  offset: [0, 0],
  container: !1,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  boundary: "clippingParents",
  customClass: "",
  sanitize: !0,
  sanitizeFn: null,
  allowList: eu,
  popperConfig: { hide: !0 }
}, lu = {
  HIDE: `hide${Ct}`,
  HIDDEN: `hidden${Ct}`,
  SHOW: `show${Ct}`,
  SHOWN: `shown${Ct}`,
  INSERTED: `inserted${Ct}`,
  CLICK: `click${Ct}`,
  FOCUSIN: `focusin${Ct}`,
  FOCUSOUT: `focusout${Ct}`,
  MOUSEENTER: `mouseenter${Ct}`,
  MOUSELEAVE: `mouseleave${Ct}`
}, cu = "fade", du = "modal", Js = "show", Qe = "show", tn = "out", nr = ".tooltip-inner", or = `.${du}`, rr = "hide.te.modal", Ze = "hover", en = "focus", hu = "click", uu = "manual";
class vi extends vt {
  constructor(t, e) {
    if (typeof il > "u")
      throw new TypeError(
        "Bootstrap's tooltips require Popper (https://popper.js.org)"
      );
    super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();
  }
  // Getters
  static get Default() {
    return au;
  }
  static get NAME() {
    return sr;
  }
  static get Event() {
    return lu;
  }
  static get DefaultType() {
    return ou;
  }
  // Public
  enable() {
    this._isEnabled = !0;
  }
  disable() {
    this._isEnabled = !1;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle(t) {
    if (this._isEnabled)
      if (t) {
        const e = this._initializeOnDelegatedTarget(t);
        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);
      } else {
        if (this.getTipElement().classList.contains(Js)) {
          this._leave(null, this);
          return;
        }
        this._enter(null, this);
      }
  }
  dispose() {
    clearTimeout(this._timeout), u.off(
      this._element.closest(or),
      rr,
      this._hideModalHandler
    ), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();
  }
  show() {
    if (this._element.style.display === "none")
      throw new Error("Please use show on visible elements");
    if (!(this.isWithContent() && this._isEnabled))
      return;
    const t = u.trigger(
      this._element,
      this.constructor.Event.SHOW
    ), e = Ta(this._element), i = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);
    if (t.defaultPrevented || !i)
      return;
    this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(nr).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);
    const n = this.getTipElement(), o = Ot(this.constructor.NAME);
    n.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this._config.animation && setTimeout(() => {
      this.tip.classList.add("opacity-100"), this.tip.classList.remove("opacity-0");
    }, 100);
    const r = typeof this._config.placement == "function" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(r);
    this._addAttachmentClass(a);
    const { container: l } = this._config;
    if (I.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), u.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = je(
      this._element,
      n,
      this._getPopperConfig(a)
    ), n.getAttribute("id").includes("tooltip"))
      switch (r) {
        case "bottom":
          n.classList.add("py-[0.4rem]");
          break;
        case "left":
          n.classList.add("px-[0.4rem]");
          break;
        case "right":
          n.classList.add("px-[0.4rem]");
          break;
        default:
          n.classList.add("py-[0.4rem]");
          break;
      }
    const d = this._resolvePossibleFunction(this._config.customClass);
    d && n.classList.add(...d.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((m) => {
      u.on(m, "mouseover", vs);
    });
    const _ = () => {
      const m = this._hoverState;
      this._hoverState = null, u.trigger(this._element, this.constructor.Event.SHOWN), m === tn && this._leave(null, this);
    }, f = this.tip.classList.contains("transition-opacity");
    this._queueCallback(_, this.tip, f);
  }
  hide() {
    if (!this._popper)
      return;
    const t = this.getTipElement(), e = () => {
      this._isWithActiveTrigger() || (this._hoverState !== Qe && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), u.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());
    };
    if (u.trigger(
      this._element,
      this.constructor.Event.HIDE
    ).defaultPrevented)
      return;
    t.classList.add("opacity-0"), t.classList.remove("opacity-100"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((o) => u.off(o, "mouseover", vs)), this._activeTrigger[hu] = !1, this._activeTrigger[en] = !1, this._activeTrigger[Ze] = !1;
    const n = this.tip.classList.contains("opacity-0");
    this._queueCallback(e, this.tip, n), this._hoverState = "";
  }
  update() {
    this._popper !== null && this._popper.update();
  }
  // Protected
  isWithContent() {
    return !!this.getTitle();
  }
  getTipElement() {
    if (this.tip)
      return this.tip;
    const t = document.createElement("div");
    t.innerHTML = this._config.template;
    const e = t.children[0];
    return this.setContent(e), e.classList.remove(cu, Js), this.tip = e, this.tip;
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), nr);
  }
  _sanitizeAndSetContent(t, e, i) {
    const n = h.findOne(i, t);
    if (!e && n) {
      n.remove();
      return;
    }
    this.setElementContent(n, e);
  }
  setElementContent(t, e) {
    if (t !== null) {
      if (Ne(e)) {
        e = Gt(e), this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent;
        return;
      }
      this._config.html ? (this._config.sanitize && (e = ir(
        e,
        this._config.allowList,
        this._config.sanitizeFn
      )), t.innerHTML = e) : t.textContent = e;
    }
  }
  getTitle() {
    const t = this._element.getAttribute("data-te-original-title") || this._config.title;
    return this._resolvePossibleFunction(t);
  }
  updateAttachment(t) {
    return t === "right" ? "end" : t === "left" ? "start" : t;
  }
  // Private
  _initializeOnDelegatedTarget(t, e) {
    return e || this.constructor.getOrCreateInstance(
      t.delegateTarget,
      this._getDelegateConfig()
    );
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _resolvePossibleFunction(t) {
    return typeof t == "function" ? t.call(this._element) : t;
  }
  _getPopperConfig(t) {
    const e = {
      placement: t,
      modifiers: [
        {
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        },
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        },
        {
          name: "onChange",
          enabled: !0,
          phase: "afterWrite",
          fn: (i) => this._handlePopperPlacementChange(i)
        }
      ],
      onFirstUpdate: (i) => {
        i.options.placement !== i.placement && this._handlePopperPlacementChange(i);
      }
    };
    return {
      ...e,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig
    };
  }
  _addAttachmentClass(t) {
    this.getTipElement().classList.add(
      `${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`
    );
  }
  _getAttachment(t) {
    return ru[t.toUpperCase()];
  }
  _setListeners() {
    this._config.trigger.split(" ").forEach((e) => {
      if (e === "click")
        u.on(
          this._element,
          this.constructor.Event.CLICK,
          this._config.selector,
          (i) => this.toggle(i)
        );
      else if (e !== uu) {
        const i = e === Ze ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === Ze ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
        u.on(
          this._element,
          i,
          this._config.selector,
          (o) => this._enter(o)
        ), u.on(
          this._element,
          n,
          this._config.selector,
          (o) => this._leave(o)
        );
      }
    }), this._hideModalHandler = () => {
      this._element && this.hide();
    }, u.on(
      this._element.closest(or),
      rr,
      this._hideModalHandler
    ), this._config.selector ? this._config = {
      ...this._config,
      trigger: "manual",
      selector: ""
    } : this._fixTitle();
  }
  _fixTitle() {
    const t = this._element.getAttribute("title"), e = typeof this._element.getAttribute(
      "data-te-original-title"
    );
    (t || e !== "string") && (this._element.setAttribute("data-te-original-title", t || ""), t && !this._element.getAttribute("aria-label") && !this._element.textContent && this._element.setAttribute("aria-label", t), this._element.setAttribute("title", ""));
  }
  _enter(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusin" ? en : Ze] = !0), e.getTipElement().classList.contains(Js) || e._hoverState === Qe) {
      e._hoverState = Qe;
      return;
    }
    if (clearTimeout(e._timeout), e._hoverState = Qe, !e._config.delay || !e._config.delay.show) {
      e.show();
      return;
    }
    e._timeout = setTimeout(() => {
      e._hoverState === Qe && e.show();
    }, e._config.delay.show);
  }
  _leave(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusout" ? en : Ze] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {
      if (clearTimeout(e._timeout), e._hoverState = tn, !e._config.delay || !e._config.delay.hide) {
        e.hide();
        return;
      }
      e._timeout = setTimeout(() => {
        e._hoverState === tn && e.hide();
      }, e._config.delay.hide);
    }
  }
  _isWithActiveTrigger() {
    for (const t in this._activeTrigger)
      if (this._activeTrigger[t])
        return !0;
    return !1;
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._element);
    return Object.keys(e).forEach((i) => {
      nu.has(i) && delete e[i];
    }), t = {
      ...this.constructor.Default,
      ...e,
      ...typeof t == "object" && t ? t : {}
    }, t.container = t.container === !1 ? document.body : Gt(t.container), typeof t.delay == "number" && (t.delay = {
      show: t.delay,
      hide: t.delay
    }), typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), N(sr, t, this.constructor.DefaultType), t.sanitize && (t.template = ir(
      t.template,
      t.allowList,
      t.sanitizeFn
    )), t;
  }
  _getDelegateConfig() {
    const t = {};
    for (const e in this._config)
      this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);
    return t;
  }
  _cleanTipClass() {
    const t = this.getTipElement(), e = new RegExp(
      `(^|\\s)${this._getBasicClassPrefix()}\\S+`,
      "g"
    ), i = t.getAttribute("class").match(e);
    i !== null && i.length > 0 && i.map((n) => n.trim()).forEach((n) => t.classList.remove(n));
  }
  _getBasicClassPrefix() {
    return su;
  }
  _handlePopperPlacementChange(t) {
    const { state: e } = t;
    e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));
  }
  _disposePopper() {
    this._popper && (this._popper.destroy(), this._popper = null);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = vi.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const pu = "popover", fu = "te.popover", At = `.${fu}`, _u = "te-popover", mu = {
  ...vi.Default,
  placement: "right",
  offset: [0, 8],
  trigger: "click",
  content: "",
  template: '<div class="opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden" role="tooltip"><h3 class="popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500"></h3><div class="popover-body p-4 text-[#212529] dark:text-white"></div></div>'
}, gu = {
  ...vi.DefaultType,
  content: "(string|element|function)"
}, bu = {
  HIDE: `hide${At}`,
  HIDDEN: `hidden${At}`,
  SHOW: `show${At}`,
  SHOWN: `shown${At}`,
  INSERTED: `inserted${At}`,
  CLICK: `click${At}`,
  FOCUSIN: `focusin${At}`,
  FOCUSOUT: `focusout${At}`,
  MOUSEENTER: `mouseenter${At}`,
  MOUSELEAVE: `mouseleave${At}`
}, vu = ".popover-header", Eu = ".popover-body";
class ll extends vi {
  // Getters
  static get Default() {
    return mu;
  }
  static get NAME() {
    return pu;
  }
  static get Event() {
    return bu;
  }
  static get DefaultType() {
    return gu;
  }
  // Overrides
  isWithContent() {
    return this.getTitle() || this._getContent();
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), vu), this._sanitizeAndSetContent(t, this._getContent(), Eu);
  }
  // Private
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  _getBasicClassPrefix() {
    return _u;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = ll.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const sn = "scrollspy", Tu = "te.scrollspy", Ss = `.${Tu}`, Cu = ".data-api", ar = {
  offset: 10,
  method: "auto",
  target: ""
}, Au = {
  offset: "number",
  method: "string",
  target: "(string|element)"
}, yu = {
  active: "!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400"
}, wu = {
  active: "string"
}, ku = `activate${Ss}`, Ou = `scroll${Ss}`, xu = `load${Ss}${Cu}`, nn = "data-te-nav-link-active", cl = "[data-te-dropdown-item-ref]", Su = '[data-te-spy="scroll"]', Du = "[data-te-nav-list-ref]", Hn = "[data-te-nav-link-ref]", Iu = "[data-te-nav-item-ref]", dl = "[data-te-list-group-item-ref]", on = `${Hn}, ${dl}, ${cl}`, $u = "[data-te-dropdown-ref]", Lu = "[data-te-dropdown-toggle-ref]", Mu = "offset", lr = "position";
class Bn extends vt {
  constructor(t, e, i) {
    super(t), this._scrollElement = this._element.tagName === "BODY" ? window : this._element, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, u.on(this._scrollElement, Ou, () => this._process()), this.refresh(), this._process(), this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return ar;
  }
  static get NAME() {
    return sn;
  }
  // Public
  refresh() {
    const t = this._scrollElement === this._scrollElement.window ? Mu : lr, e = this._config.method === "auto" ? t : this._config.method, i = e === lr ? this._getScrollTop() : 0;
    this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), h.find(
      on,
      this._config.target
    ).map((o) => {
      const r = Xn(o), a = r ? h.findOne(r) : null;
      if (a) {
        const l = a.getBoundingClientRect();
        if (l.width || l.height)
          return [
            p[e](a).top + i,
            r
          ];
      }
      return null;
    }).filter((o) => o).sort((o, r) => o[0] - r[0]).forEach((o) => {
      this._offsets.push(o[0]), this._targets.push(o[1]);
    });
  }
  dispose() {
    u.off(this._scrollElement, Ss), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (u.on(window, xu, () => {
      h.find(Su).forEach(
        (t) => new Bn(t)
      );
    }), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...ar,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, t.target = Gt(t.target) || document.documentElement, N(sn, t, Au), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...yu,
      ...e,
      ...t
    }, N(sn, t, wu), t;
  }
  _getScrollTop() {
    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
  }
  _getScrollHeight() {
    return this._scrollElement.scrollHeight || Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight
    );
  }
  _getOffsetHeight() {
    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
  }
  _process() {
    const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), i = this._config.offset + e - this._getOffsetHeight();
    if (this._scrollHeight !== e && this.refresh(), t >= i) {
      const n = this._targets[this._targets.length - 1];
      this._activeTarget !== n && this._activate(n);
      return;
    }
    if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {
      this._activeTarget = null, this._clear();
      return;
    }
    for (let n = this._offsets.length; n--; )
      this._activeTarget !== this._targets[n] && t >= this._offsets[n] && (typeof this._offsets[n + 1] > "u" || t < this._offsets[n + 1]) && this._activate(this._targets[n]);
  }
  _activate(t) {
    this._activeTarget = t, this._clear();
    const e = on.split(",").map(
      (n) => `${n}[data-te-target="${t}"],${n}[href="${t}"]`
    ), i = h.findOne(e.join(","), this._config.target);
    i.classList.add(...this._classes.active.split(" ")), i.setAttribute(nn, ""), i.getAttribute(cl) ? h.findOne(
      Lu,
      i.closest($u)
    ).classList.add(...this._classes.active.split(" ")) : h.parents(i, Du).forEach(
      (n) => {
        h.prev(
          n,
          `${Hn}, ${dl}`
        ).forEach((o) => {
          o.classList.add(...this._classes.active.split(" ")), o.setAttribute(nn, "");
        }), h.prev(n, Iu).forEach(
          (o) => {
            h.children(o, Hn).forEach(
              (r) => r.classList.add(...this._classes.active.split(" "))
            );
          }
        );
      }
    ), u.trigger(this._scrollElement, ku, {
      relatedTarget: t
    });
  }
  _clear() {
    h.find(on, this._config.target).filter(
      (t) => t.classList.contains(...this._classes.active.split(" "))
    ).forEach((t) => {
      t.classList.remove(...this._classes.active.split(" ")), t.removeAttribute(nn);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Bn.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const cr = "tab", Nu = "te.tab", Ds = `.${Nu}`, Ru = `hide${Ds}`, Pu = `hidden${Ds}`, Hu = `show${Ds}`, Bu = `shown${Ds}`, Vu = "data-te-dropdown-menu-ref", we = "data-te-tab-active", as = "data-te-nav-active", Wu = "[data-te-dropdown-ref]", Fu = "[data-te-nav-ref]", dr = `[${we}]`, Yu = `[${as}]`, hr = ":scope > li > .active", ju = "[data-te-dropdown-toggle-ref]", Ku = ":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]", Uu = {
  show: "opacity-100",
  hide: "opacity-0"
}, zu = {
  show: "string",
  hide: "string"
};
class hl extends vt {
  constructor(t, e) {
    super(t), this._classes = this._getClasses(e);
  }
  // Getters
  static get NAME() {
    return cr;
  }
  // Public
  show() {
    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(as) === "")
      return;
    let t;
    const e = Xt(this._element), i = this._element.closest(Fu), n = h.findOne(
      Yu,
      i
    );
    if (i) {
      const l = i.nodeName === "UL" || i.nodeName === "OL" ? hr : dr;
      t = h.find(l, i), t = t[t.length - 1];
    }
    const o = t ? u.trigger(t, Ru, {
      relatedTarget: this._element
    }) : null;
    if (u.trigger(this._element, Hu, {
      relatedTarget: t
    }).defaultPrevented || o !== null && o.defaultPrevented)
      return;
    this._activate(
      this._element,
      i,
      null,
      n,
      this._element
    );
    const a = () => {
      u.trigger(t, Pu, {
        relatedTarget: this._element
      }), u.trigger(this._element, Bu, {
        relatedTarget: t
      });
    };
    e ? this._activate(
      e,
      e.parentNode,
      a,
      n,
      this._element
    ) : a();
  }
  // Private
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...Uu,
      ...e,
      ...t
    }, N(cr, t, zu), t;
  }
  _activate(t, e, i, n, o) {
    const a = (e && (e.nodeName === "UL" || e.nodeName === "OL") ? h.find(hr, e) : h.children(e, dr))[0], l = i && a && a.hasAttribute(we), c = () => this._transitionComplete(
      t,
      a,
      i,
      n,
      o
    );
    a && l ? (p.removeClass(a, this._classes.show), p.addClass(a, this._classes.hide), this._queueCallback(c, t, !0)) : c();
  }
  _transitionComplete(t, e, i, n, o) {
    if (e && n) {
      e.removeAttribute(we), n.removeAttribute(as);
      const a = h.findOne(
        Ku,
        e.parentNode
      );
      a && a.removeAttribute(we), e.getAttribute("role") === "tab" && e.setAttribute("aria-selected", !1);
    }
    t.setAttribute(we, ""), o.setAttribute(as, ""), t.getAttribute("role") === "tab" && t.setAttribute("aria-selected", !0), Fe(t), t.classList.contains(this._classes.hide) && (p.removeClass(t, this._classes.hide), p.addClass(t, this._classes.show));
    let r = t.parentNode;
    if (r && r.nodeName === "LI" && (r = r.parentNode), r && r.hasAttribute(Vu)) {
      const a = t.closest(Wu);
      a && h.find(ju, a).forEach(
        (l) => l.setAttribute(we, "")
      ), t.setAttribute("aria-expanded", !0);
    }
    i && i();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = hl.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const rn = "toast", Xu = "te.toast", Qt = `.${Xu}`, Gu = `mouseover${Qt}`, qu = `mouseout${Qt}`, Qu = `focusin${Qt}`, Zu = `focusout${Qt}`, Ju = `hide${Qt}`, tp = `hidden${Qt}`, ep = `show${Qt}`, ip = `shown${Qt}`, ur = "data-te-toast-hide", an = "data-te-toast-show", Mi = "data-te-toast-showing", sp = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, pr = {
  animation: !0,
  autohide: !0,
  delay: 5e3
}, np = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, op = {
  fadeIn: "string",
  fadeOut: "string"
};
class Vn extends vt {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get DefaultType() {
    return sp;
  }
  static get Default() {
    return pr;
  }
  static get NAME() {
    return rn;
  }
  // Public
  show() {
    if (u.trigger(this._element, ep).defaultPrevented)
      return;
    this._clearTimeout(), this._config.animation && (p.removeClass(this._element, this._classes.fadeOut), p.addClass(this._element, this._classes.fadeIn));
    const e = () => {
      this._element.removeAttribute(Mi), u.trigger(this._element, ip), this._maybeScheduleHide();
    };
    this._element.removeAttribute(ur), Fe(this._element), this._element.setAttribute(an, ""), this._element.setAttribute(Mi, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  hide() {
    if (!this._element || this._element.dataset.teToastShow === void 0 || u.trigger(this._element, Ju).defaultPrevented)
      return;
    const e = () => {
      let i = 0;
      this._config.animation && (i = 300, p.removeClass(this._element, this._classes.fadeIn), p.addClass(this._element, this._classes.fadeOut)), setTimeout(() => {
        this._element.setAttribute(ur, ""), this._element.removeAttribute(Mi), this._element.removeAttribute(an), u.trigger(this._element, tp);
      }, i);
    };
    this._element.setAttribute(Mi, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout(), this._element.dataset.teToastShow !== void 0 && this._element.removeAttribute(an), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (xs(Vn), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...pr,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, N(rn, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...np,
      ...e,
      ...t
    }, N(rn, t, op), t;
  }
  _maybeScheduleHide() {
    this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay)));
  }
  _onInteraction(t, e) {
    switch (t.type) {
      case "mouseover":
      case "mouseout":
        this._hasMouseInteraction = e;
        break;
      case "focusin":
      case "focusout":
        this._hasKeyboardInteraction = e;
        break;
    }
    if (e) {
      this._clearTimeout();
      return;
    }
    const i = t.relatedTarget;
    this._element === i || this._element.contains(i) || this._maybeScheduleHide();
  }
  _setListeners() {
    u.on(
      this._element,
      Gu,
      (t) => this._onInteraction(t, !0)
    ), u.on(
      this._element,
      qu,
      (t) => this._onInteraction(t, !1)
    ), u.on(
      this._element,
      Qu,
      (t) => this._onInteraction(t, !0)
    ), u.on(
      this._element,
      Zu,
      (t) => this._onInteraction(t, !1)
    );
  }
  _clearTimeout() {
    clearTimeout(this._timeout), this._timeout = null;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Vn.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
(() => {
  var s = { 454: (i, n, o) => {
    o.d(n, { Z: () => l });
    var r = o(645), a = o.n(r)()(function(c) {
      return c[1];
    });
    a.push([i.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
    const l = a;
  }, 645: (i) => {
    i.exports = function(n) {
      var o = [];
      return o.toString = function() {
        return this.map(function(r) {
          var a = n(r);
          return r[2] ? "@media ".concat(r[2], " {").concat(a, "}") : a;
        }).join("");
      }, o.i = function(r, a, l) {
        typeof r == "string" && (r = [[null, r, ""]]);
        var c = {};
        if (l)
          for (var d = 0; d < this.length; d++) {
            var _ = this[d][0];
            _ != null && (c[_] = !0);
          }
        for (var f = 0; f < r.length; f++) {
          var m = [].concat(r[f]);
          l && c[m[0]] || (a && (m[2] ? m[2] = "".concat(a, " and ").concat(m[2]) : m[2] = a), o.push(m));
        }
      }, o;
    };
  }, 810: () => {
    (function() {
      if (typeof window < "u")
        try {
          var i = new window.CustomEvent("test", { cancelable: !0 });
          if (i.preventDefault(), i.defaultPrevented !== !0)
            throw new Error("Could not prevent default");
        } catch {
          var n = function(r, a) {
            var l, c;
            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent("CustomEvent")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), c = l.preventDefault, l.preventDefault = function() {
              c.call(this);
              try {
                Object.defineProperty(this, "defaultPrevented", { get: function() {
                  return !0;
                } });
              } catch {
                this.defaultPrevented = !0;
              }
            }, l;
          };
          n.prototype = window.Event.prototype, window.CustomEvent = n;
        }
    })();
  }, 379: (i, n, o) => {
    var r, a = function() {
      var v = {};
      return function(E) {
        if (v[E] === void 0) {
          var A = document.querySelector(E);
          if (window.HTMLIFrameElement && A instanceof window.HTMLIFrameElement)
            try {
              A = A.contentDocument.head;
            } catch {
              A = null;
            }
          v[E] = A;
        }
        return v[E];
      };
    }(), l = [];
    function c(v) {
      for (var E = -1, A = 0; A < l.length; A++)
        if (l[A].identifier === v) {
          E = A;
          break;
        }
      return E;
    }
    function d(v, E) {
      for (var A = {}, y = [], S = 0; S < v.length; S++) {
        var O = v[S], k = E.base ? O[0] + E.base : O[0], D = A[k] || 0, x = "".concat(k, " ").concat(D);
        A[k] = D + 1;
        var $ = c(x), P = { css: O[1], media: O[2], sourceMap: O[3] };
        $ !== -1 ? (l[$].references++, l[$].updater(P)) : l.push({ identifier: x, updater: w(P, E), references: 1 }), y.push(x);
      }
      return y;
    }
    function _(v) {
      var E = document.createElement("style"), A = v.attributes || {};
      if (A.nonce === void 0) {
        var y = o.nc;
        y && (A.nonce = y);
      }
      if (Object.keys(A).forEach(function(O) {
        E.setAttribute(O, A[O]);
      }), typeof v.insert == "function")
        v.insert(E);
      else {
        var S = a(v.insert || "head");
        if (!S)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        S.appendChild(E);
      }
      return E;
    }
    var f, m = (f = [], function(v, E) {
      return f[v] = E, f.filter(Boolean).join(`
`);
    });
    function g(v, E, A, y) {
      var S = A ? "" : y.media ? "@media ".concat(y.media, " {").concat(y.css, "}") : y.css;
      if (v.styleSheet)
        v.styleSheet.cssText = m(E, S);
      else {
        var O = document.createTextNode(S), k = v.childNodes;
        k[E] && v.removeChild(k[E]), k.length ? v.insertBefore(O, k[E]) : v.appendChild(O);
      }
    }
    function b(v, E, A) {
      var y = A.css, S = A.media, O = A.sourceMap;
      if (S ? v.setAttribute("media", S) : v.removeAttribute("media"), O && typeof btoa < "u" && (y += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(O)))), " */")), v.styleSheet)
        v.styleSheet.cssText = y;
      else {
        for (; v.firstChild; )
          v.removeChild(v.firstChild);
        v.appendChild(document.createTextNode(y));
      }
    }
    var T = null, C = 0;
    function w(v, E) {
      var A, y, S;
      if (E.singleton) {
        var O = C++;
        A = T || (T = _(E)), y = g.bind(null, A, O, !1), S = g.bind(null, A, O, !0);
      } else
        A = _(E), y = b.bind(null, A, E), S = function() {
          (function(k) {
            if (k.parentNode === null)
              return !1;
            k.parentNode.removeChild(k);
          })(A);
        };
      return y(v), function(k) {
        if (k) {
          if (k.css === v.css && k.media === v.media && k.sourceMap === v.sourceMap)
            return;
          y(v = k);
        } else
          S();
      };
    }
    i.exports = function(v, E) {
      (E = E || {}).singleton || typeof E.singleton == "boolean" || (E.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));
      var A = d(v = v || [], E);
      return function(y) {
        if (y = y || [], Object.prototype.toString.call(y) === "[object Array]") {
          for (var S = 0; S < A.length; S++) {
            var O = c(A[S]);
            l[O].references--;
          }
          for (var k = d(y, E), D = 0; D < A.length; D++) {
            var x = c(A[D]);
            l[x].references === 0 && (l[x].updater(), l.splice(x, 1));
          }
          A = k;
        }
      };
    };
  } }, t = {};
  function e(i) {
    var n = t[i];
    if (n !== void 0)
      return n.exports;
    var o = t[i] = { id: i, exports: {} };
    return s[i](o, o.exports, e), o.exports;
  }
  e.n = (i) => {
    var n = i && i.__esModule ? () => i.default : () => i;
    return e.d(n, { a: n }), n;
  }, e.d = (i, n) => {
    for (var o in n)
      e.o(n, o) && !e.o(i, o) && Object.defineProperty(i, o, { enumerable: !0, get: n[o] });
  }, e.o = (i, n) => Object.prototype.hasOwnProperty.call(i, n), (() => {
    var i = e(379), n = e.n(i), o = e(454);
    function r(l) {
      if (!l.hasAttribute("autocompleted")) {
        l.setAttribute("autocompleted", "");
        var c = new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !0, detail: null });
        l.dispatchEvent(c) || (l.value = "");
      }
    }
    function a(l) {
      l.hasAttribute("autocompleted") && (l.removeAttribute("autocompleted"), l.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !1, detail: null })));
    }
    n()(o.Z, { insert: "head", singleton: !1 }), o.Z.locals, e(810), document.addEventListener("animationstart", function(l) {
      l.animationName === "onautofillstart" ? r(l.target) : a(l.target);
    }, !0), document.addEventListener("input", function(l) {
      l.inputType !== "insertReplacementText" && "data" in l ? a(l.target) : r(l.target);
    }, !0);
  })();
})();
const ln = "input", Ni = "te.input", ul = "data-te-input-wrapper-init", pl = "data-te-input-notch-ref", fl = "data-te-input-notch-leading-ref", _l = "data-te-input-notch-middle-ref", rp = "data-te-input-notch-trailing-ref", ap = "data-te-input-helper-ref", lp = "data-te-input-placeholder-active", Ht = "data-te-input-state-active", fr = "data-te-input-focused", _r = "data-te-input-form-counter", re = `[${ul}] input`, ae = `[${ul}] textarea`, Ee = `[${pl}]`, mr = `[${fl}]`, gr = `[${_l}]`, cp = `[${ap}]`, dp = {
  inputFormWhite: !1
}, hp = {
  inputFormWhite: "(boolean)"
}, up = {
  notch: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
  notchLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0",
  notchLeadingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchLeadingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent",
  notchMiddleNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchMiddleWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0",
  notchTrailingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchTrailingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  counter: "text-right leading-[1.6]"
}, pp = {
  notch: "string",
  notchLeading: "string",
  notchLeadingNormal: "string",
  notchLeadingWhite: "string",
  notchMiddle: "string",
  notchMiddleNormal: "string",
  notchMiddleWhite: "string",
  notchTrailing: "string",
  notchTrailingNormal: "string",
  notchTrailingWhite: "string",
  counter: "string"
};
class V {
  constructor(t, e, i) {
    this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(i), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (I.setData(t, Ni, this), this.init());
  }
  // Getters
  static get NAME() {
    return ln;
  }
  get input() {
    return h.findOne("input", this._element) || h.findOne("textarea", this._element);
  }
  // Public
  init() {
    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = !0);
  }
  update() {
    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();
  }
  forceActive() {
    this.input.setAttribute(Ht, ""), h.findOne(Ee, this.input.parentNode).setAttribute(
      Ht,
      ""
    );
  }
  forceInactive() {
    this.input.removeAttribute(Ht), h.findOne(
      Ee,
      this.input.parentNode
    ).removeAttribute(Ht);
  }
  dispose() {
    this._removeBorder(), I.removeData(this._element, Ni), this._element = null;
  }
  // Private
  _getConfig(t, e) {
    return t = {
      ...dp,
      ...p.getDataAttributes(e),
      ...typeof t == "object" ? t : {}
    }, N(ln, t, hp), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...up,
      ...e,
      ...t
    }, N(ln, t, pp), t;
  }
  _getLabelData() {
    this._label = h.findOne("label", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());
  }
  _getHelper() {
    this._helper = h.findOne(cp, this._element);
  }
  _getCounter() {
    this._counter = p.getDataAttribute(
      this.input,
      "inputShowcounter"
    ), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());
  }
  _getEvents() {
    u.on(
      document,
      "focus",
      re,
      V.activate(new V())
    ), u.on(
      document,
      "input",
      re,
      V.activate(new V())
    ), u.on(
      document,
      "blur",
      re,
      V.deactivate(new V())
    ), u.on(
      document,
      "focus",
      ae,
      V.activate(new V())
    ), u.on(
      document,
      "input",
      ae,
      V.activate(new V())
    ), u.on(
      document,
      "blur",
      ae,
      V.deactivate(new V())
    ), u.on(window, "shown.te.modal", (t) => {
      h.find(re, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        }
      ), h.find(ae, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        }
      );
    }), u.on(window, "shown.te.dropdown", (t) => {
      const e = t.target.parentNode.querySelector(
        "[data-te-dropdown-menu-ref]"
      );
      e && (h.find(re, e).forEach(
        (i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }
      ), h.find(ae, e).forEach(
        (i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }
      ));
    }), u.on(window, "shown.te.tab", (t) => {
      let e;
      t.target.href ? e = t.target.href.split("#")[1] : e = p.getDataAttribute(t.target, "target").split(
        "#"
      )[1];
      const i = h.findOne(`#${e}`);
      h.find(re, i).forEach((n) => {
        const o = V.getInstance(n.parentNode);
        o && o.update();
      }), h.find(ae, i).forEach(
        (n) => {
          const o = V.getInstance(n.parentNode);
          o && o.update();
        }
      );
    }), u.on(window, "reset", (t) => {
      h.find(re, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      ), h.find(ae, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      );
    }), u.on(window, "onautocomplete", (t) => {
      const e = V.getInstance(t.target.parentNode);
      !e || !t.cancelable || e.forceActive();
    });
  }
  _showCounter() {
    if (h.find(
      `[${_r}]`,
      this._element
    ).length > 0)
      return;
    this._counterElement = document.createElement("div"), p.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(_r, "");
    const e = this.input.value.length;
    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();
  }
  _bindCounter() {
    u.on(this.input, "input", () => {
      const t = this.input.value.length;
      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;
    });
  }
  _toggleDefaultDatePlaceholder(t = this.input) {
    if (!(t.getAttribute("type") === "date"))
      return;
    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;
  }
  _showPlaceholder() {
    this.input.setAttribute(lp, "");
  }
  _getNotchData() {
    this._notchMiddle = h.findOne(
      gr,
      this._element
    ), this._notchLeading = h.findOne(
      mr,
      this._element
    );
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _getLabelPositionInInputGroup() {
    if (this._labelMarginLeft = 0, !this._element.hasAttribute("data-te-input-group-ref"))
      return;
    const t = this.input, e = h.prev(
      t,
      "[data-te-input-group-text-ref]"
    )[0];
    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;
  }
  _applyDivs() {
    const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, i = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = h.find(Ee, this._element), o = M("div");
    p.addClass(o, this._classes.notch), o.setAttribute(pl, ""), this._notchLeading = M("div"), p.addClass(
      this._notchLeading,
      `${this._classes.notchLeading} ${t}`
    ), this._notchLeading.setAttribute(fl, ""), this._notchMiddle = M("div"), p.addClass(
      this._notchMiddle,
      `${this._classes.notchMiddle} ${e}`
    ), this._notchMiddle.setAttribute(_l, ""), this._notchTrailing = M("div"), p.addClass(
      this._notchTrailing,
      `${this._classes.notchTrailing} ${i}`
    ), this._notchTrailing.setAttribute(rp, ""), !(n.length >= 1) && (o.append(this._notchLeading), o.append(this._notchMiddle), o.append(this._notchTrailing), this._element.append(o));
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
  }
  _removeBorder() {
    const t = h.findOne(Ee, this._element);
    t && t.remove();
  }
  _activate(t) {
    Aa(() => {
      this._getElements(t);
      const e = t ? t.target : this.input, i = h.findOne(
        Ee,
        this._element
      );
      t && t.type === "focus" && i.setAttribute(fr, ""), e.value !== "" && (e.setAttribute(Ht, ""), i.setAttribute(Ht, "")), this._toggleDefaultDatePlaceholder(e);
    });
  }
  _getElements(t) {
    if (t && (this._element = t.target.parentNode, this._label = h.findOne("label", this._element)), t && this._label) {
      const e = this._labelWidth;
      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = h.findOne(
        gr,
        t.target.parentNode
      ), this._notchLeading = h.findOne(
        mr,
        t.target.parentNode
      ), this._applyNotch());
    }
  }
  _deactivate(t) {
    const e = t ? t.target : this.input, i = h.findOne(
      Ee,
      e.parentNode
    );
    i.removeAttribute(fr), e.value === "" && (e.removeAttribute(Ht), i.removeAttribute(Ht)), this._toggleDefaultDatePlaceholder(e);
  }
  static activate(t) {
    return function(e) {
      t._activate(e);
    };
  }
  static deactivate(t) {
    return function(e) {
      t._deactivate(e);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, Ni);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new V(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, Ni);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const br = "animation", cn = "te.animation", fp = {
  animation: "string",
  animationStart: "string",
  animationShowOnLoad: "boolean",
  onStart: "(null|function)",
  onEnd: "(null|function)",
  onHide: "(null|function)",
  onShow: "(null|function)",
  animationOnScroll: "(string)",
  animationWindowHeight: "number",
  animationOffset: "(number|string)",
  animationDelay: "(number|string)",
  animationReverse: "boolean",
  animationInterval: "(number|string)",
  animationRepeat: "(number|boolean)",
  animationReset: "boolean"
}, _p = {
  animation: "fade",
  animationStart: "onClick",
  animationShowOnLoad: !0,
  onStart: null,
  onEnd: null,
  onHide: null,
  onShow: null,
  animationOnScroll: "once",
  animationWindowHeight: 0,
  animationOffset: 0,
  animationDelay: 0,
  animationReverse: !1,
  animationInterval: 0,
  animationRepeat: !1,
  animationReset: !1
};
class ml {
  constructor(t, e) {
    this._element = t, this._animateElement = this._getAnimateElement(), this._isFirstScroll = !0, this._repeatAnimateOnScroll = !0, this._options = this._getConfig(e), this._element && (I.setData(t, cn, this), this._init());
  }
  // Getters
  static get NAME() {
    return br;
  }
  // Public
  init() {
    this._init();
  }
  startAnimation() {
    this._startAnimation();
  }
  stopAnimation() {
    this._clearAnimationClass();
  }
  changeAnimationType(t) {
    this._options.animation = t;
  }
  dispose() {
    u.off(this._element, "mousedown"), u.off(this._animateElement, "animationend"), u.off(window, "scroll"), u.off(this._element, "mouseover"), I.removeData(this._element, cn), this._element = null, this._animateElement = null, this._isFirstScroll = null, this._repeatAnimateOnScroll = null, this._options = null;
  }
  // Private
  _init() {
    switch (this._options.animationStart) {
      case "onHover":
        this._bindHoverEvents();
        break;
      case "onLoad":
        this._startAnimation();
        break;
      case "onScroll":
        this._bindScrollEvents();
        break;
      case "onClick":
        this._bindClickEvents();
        break;
    }
    this._bindTriggerOnEndCallback(), this._options.animationReset && this._bindResetAnimationAfterFinish();
  }
  _getAnimateElement() {
    const t = p.getDataAttribute(
      this._element,
      "animation-target"
    );
    return t ? h.find(t)[0] : this._element;
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._animateElement);
    return t = {
      ..._p,
      ...e,
      ...t
    }, N(br, t, fp), t;
  }
  _animateOnScroll() {
    const t = p.offset(this._animateElement).top, e = this._animateElement.offsetHeight, i = window.innerHeight, n = t + this._options.animationOffset <= i && t + this._options.animationOffset + e >= 0, o = this._animateElement.style.visibility === "visible";
    switch (!0) {
      case (n && this._isFirstScroll):
        this._isFirstScroll = !1, this._startAnimation();
        break;
      case (!n && this._isFirstScroll):
        this._isFirstScroll = !1, this._hideAnimateElement();
        break;
      case (n && !o && this._repeatAnimateOnScroll):
        this._options.animationOnScroll !== "repeat" && (this._repeatAnimateOnScroll = !1), this._callback(this._options.onShow), this._showAnimateElement(), this._startAnimation();
        break;
      case (!n && o && this._repeatAnimateOnScroll):
        this._hideAnimateElement(), this._clearAnimationClass(), this._callback(this._options.onHide);
        break;
    }
  }
  _addAnimatedClass() {
    p.addClass(
      this._animateElement,
      `animate-${this._options.animation}`
    );
  }
  _clearAnimationClass() {
    this._animateElement.classList.remove(`animate-${this._options.animation}`);
  }
  _startAnimation() {
    this._callback(this._options.onStart), this._addAnimatedClass(), this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(), this._options.animationReverse && this._setAnimationReverse(), this._options.animationDelay && this._setAnimationDelay(), this._options.animationDuration && this._setAnimationDuration(), this._options.animationInterval && this._setAnimationInterval();
  }
  _setAnimationReverse() {
    p.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : "2",
      animationDirection: "alternate"
    });
  }
  _setAnimationDuration() {
    p.style(this._animateElement, {
      animationDuration: `${this._options.animationDuration}ms`
    });
  }
  _setAnimationDelay() {
    p.style(this._animateElement, {
      animationDelay: `${this._options.animationDelay}ms`
    });
  }
  _setAnimationRepeat() {
    p.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : this._options.animationRepeat
    });
  }
  _setAnimationInterval() {
    u.on(this._animateElement, "click", () => {
      this._clearAnimationClass(), setTimeout(() => {
        this._addAnimatedClass();
      }, this._options.animationInterval);
    });
  }
  _hideAnimateElement() {
    p.style(this._animateElement, { visibility: "hidden" });
  }
  _showAnimateElement() {
    p.style(this._animateElement, { visibility: "visible" });
  }
  _bindResetAnimationAfterFinish() {
    u.on(this._animateElement, "animationend", () => {
      this._clearAnimationClass();
    });
  }
  _bindTriggerOnEndCallback() {
    u.on(this._animateElement, "animationend", () => {
      this._callback(this._options.onEnd);
    });
  }
  _bindScrollEvents() {
    this._options.animationShowOnLoad || this._animateOnScroll(), u.on(window, "scroll", () => {
      this._animateOnScroll();
    });
  }
  _bindClickEvents() {
    u.on(this._element, "mousedown", () => {
      this._startAnimation();
    });
  }
  _bindHoverEvents() {
    u.one(this._element, "mouseover", () => {
      this._startAnimation();
    }), u.one(this._animateElement, "animationend", () => {
      setTimeout(() => {
        this._bindHoverEvents();
      }, 100);
    });
  }
  _callback(t) {
    t instanceof Function && t();
  }
  // Static
  static autoInit(t) {
    t._init();
  }
  static jQueryInterface(t) {
    new ml(this[0], t).init();
  }
  static getInstance(t) {
    return I.getData(t, cn);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const dn = "ripple", Ri = "te.ripple", mp = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%", gp = ["[data-te-ripple-init]"], Pi = [0, 0, 0], bp = [
  { name: "primary", gradientColor: "#3B71CA" },
  { name: "secondary", gradientColor: "#9FA6B2" },
  { name: "success", gradientColor: "#14A44D" },
  { name: "danger", gradientColor: "#DC4C64" },
  { name: "warning", gradientColor: "#E4A11B" },
  { name: "info", gradientColor: "#54B4D3" },
  { name: "light", gradientColor: "#fbfbfb" },
  { name: "dark", gradientColor: "#262626" }
], vr = 0.5, vp = {
  rippleCentered: !1,
  rippleColor: "",
  rippleColorDark: "",
  rippleDuration: "500ms",
  rippleRadius: 0,
  rippleUnbound: !1
}, Ep = {
  rippleCentered: "boolean",
  rippleColor: "string",
  rippleColorDark: "string",
  rippleDuration: "string",
  rippleRadius: "number",
  rippleUnbound: "boolean"
}, Tp = {
  ripple: "relative overflow-hidden inline-block align-bottom",
  rippleWave: "rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]",
  unbound: "overflow-visible"
}, Cp = {
  ripple: "string",
  rippleWave: "string",
  unbound: "string"
};
class Cs {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && (I.setData(t, Ri, this), p.addClass(this._element, this._classes.ripple)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._initialClasses = null, this.init();
  }
  // Getters
  static get NAME() {
    return dn;
  }
  // Public
  init() {
    this._addClickEvent(this._element);
  }
  dispose() {
    I.removeData(this._element, Ri), u.off(this._element, "click", this._clickHandler), this._element = null, this._options = null;
  }
  // Private
  _autoInit(t) {
    gp.forEach((e) => {
      h.closest(t.target, e) && (this._element = h.closest(t.target, e));
    }), this._element.style.minWidth || (p.style(this._element, {
      "min-width": getComputedStyle(this._element).width
    }), this._isMinWidthSet = !0), this._initialClasses = [...this._element.classList], p.addClass(this._element, this._classes.ripple), this._options = this._getConfig(), this._createRipple(t);
  }
  _addClickEvent(t) {
    u.on(t, "mousedown", this._clickHandler);
  }
  _createRipple(t) {
    this._element.className.indexOf(this._classes.ripple) < 0 && p.addClass(this._element, this._classes.ripple);
    const { layerX: e, layerY: i } = t, n = e, o = i, r = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), c = {
      offsetX: this._options.rippleCentered ? r / 2 : n,
      offsetY: this._options.rippleCentered ? a / 2 : o,
      height: r,
      width: a
    }, d = this._getDiameter(c), _ = this._options.rippleRadius || d / 2, f = {
      delay: l * vr,
      duration: l - l * vr
    }, m = {
      left: this._options.rippleCentered ? `${a / 2 - _}px` : `${n - _}px`,
      top: this._options.rippleCentered ? `${r / 2 - _}px` : `${o - _}px`,
      height: `${this._options.rippleRadius * 2 || d}px`,
      width: `${this._options.rippleRadius * 2 || d}px`,
      transitionDelay: `0s, ${f.delay}ms`,
      transitionDuration: `${l}ms, ${f.duration}ms`
    }, g = M("div");
    this._createHTMLRipple({
      wrapper: this._element,
      ripple: g,
      styles: m
    }), this._removeHTMLRipple({ ripple: g, duration: l });
  }
  _createHTMLRipple({ wrapper: t, ripple: e, styles: i }) {
    Object.keys(i).forEach(
      (n) => e.style[n] = i[n]
    ), p.addClass(e, this._classes.rippleWave), e.setAttribute("data-te-ripple-ref", ""), this._addColor(e, t), this._toggleUnbound(t), this._appendRipple(e, t);
  }
  _removeHTMLRipple({ ripple: t, duration: e }) {
    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), t && setTimeout(() => {
      t.classList.add("!opacity-0");
    }, 10), this._rippleTimer = setTimeout(() => {
      if (t && (t.remove(), this._element)) {
        h.find("[data-te-ripple-ref]", this._element).forEach(
          (n) => {
            n.remove();
          }
        ), this._isMinWidthSet && (p.style(this._element, { "min-width": "" }), this._isMinWidthSet = !1);
        const i = this._initialClasses ? this._addedNewRippleClasses(
          this._classes.ripple,
          this._initialClasses
        ) : this._classes.ripple.split(" ");
        p.removeClass(this._element, i);
      }
    }, e);
  }
  _addedNewRippleClasses(t, e) {
    return t.split(" ").filter(
      (i) => e.findIndex((n) => i === n) === -1
    );
  }
  _durationToMsNumber(t) {
    return Number(t.replace("ms", "").replace("s", "000"));
  }
  _getConfig(t = {}) {
    const e = p.getDataAttributes(this._element);
    return t = {
      ...vp,
      ...e,
      ...t
    }, N(dn, t, Ep), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...Tp,
      ...e,
      ...t
    }, N(dn, t, Cp), t;
  }
  _getDiameter({ offsetX: t, offsetY: e, height: i, width: n }) {
    const o = e <= i / 2, r = t <= n / 2, a = (f, m) => Math.sqrt(f ** 2 + m ** 2), l = e === i / 2 && t === n / 2, c = {
      first: o === !0 && r === !1,
      second: o === !0 && r === !0,
      third: o === !1 && r === !0,
      fourth: o === !1 && r === !1
    }, d = {
      topLeft: a(t, e),
      topRight: a(n - t, e),
      bottomLeft: a(t, i - e),
      bottomRight: a(n - t, i - e)
    };
    let _ = 0;
    return l || c.fourth ? _ = d.topLeft : c.third ? _ = d.topRight : c.second ? _ = d.bottomRight : c.first && (_ = d.bottomLeft), _ * 2;
  }
  _appendRipple(t, e) {
    e.appendChild(t), setTimeout(() => {
      p.addClass(t, "opacity-0 scale-100");
    }, 50);
  }
  _toggleUnbound(t) {
    this._options.rippleUnbound === !0 ? p.addClass(t, this._classes.unbound) : p.removeClass(t, this._classes.unbound);
  }
  _addColor(t) {
    let e = this._options.rippleColor || "rgb(0,0,0)";
    (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (e = this._options.rippleColorDark || this._options.rippleColor);
    const i = bp.find(
      (r) => r.name === e.toLowerCase()
    ), n = i ? this._colorToRGB(i.gradientColor).join(",") : this._colorToRGB(e).join(","), o = mp.split("{{color}}").join(`${n}`);
    t.style.backgroundImage = `radial-gradient(circle, ${o})`;
  }
  _colorToRGB(t) {
    function e(o) {
      return o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [
        parseInt(o.substr(1, 2), 16),
        parseInt(o.substr(3, 2), 16),
        parseInt(o.substr(5, 2), 16)
      ];
    }
    function i(o) {
      const r = document.body.appendChild(
        document.createElement("fictum")
      ), a = "rgb(1, 2, 3)";
      return r.style.color = a, r.style.color !== a || (r.style.color = o, r.style.color === a || r.style.color === "") ? Pi : (o = getComputedStyle(r).color, document.body.removeChild(r), o);
    }
    function n(o) {
      return o = o.match(/[.\d]+/g).map((r) => +Number(r)), o.length = 3, o;
    }
    return t.toLowerCase() === "transparent" ? Pi : t[0] === "#" ? e(t) : (t.indexOf("rgb") === -1 && (t = i(t)), t.indexOf("rgb") === 0 ? n(t) : Pi);
  }
  // Static
  static autoInitial(t) {
    return function(e) {
      t._autoInit(e);
    };
  }
  static jQueryInterface(t) {
    return this.each(function() {
      return I.getData(this, Ri) ? null : new Cs(this, t);
    });
  }
  static getInstance(t) {
    return I.getData(t, Ri);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
function Q(s) {
  return s.getDate();
}
function ls(s) {
  return s.getDay();
}
function Y(s) {
  return s.getMonth();
}
function H(s) {
  return s.getFullYear();
}
function Ap(s, t, e) {
  const i = e.startDay, n = i > 0 ? 7 - i : 0, r = new Date(s, t).getDay() + n;
  return r >= 7 ? r - 7 : r;
}
function Wn(s) {
  return yp(s).getDate();
}
function yp(s) {
  return Dt(s.getFullYear(), s.getMonth() + 1, 0);
}
function De() {
  return /* @__PURE__ */ new Date();
}
function it(s, t) {
  return nt(s, t * 12);
}
function nt(s, t) {
  const e = Dt(
    s.getFullYear(),
    s.getMonth() + t,
    s.getDate()
  ), i = Q(s), n = Q(e);
  return i !== n && e.setDate(0), e;
}
function Te(s, t) {
  return Dt(s.getFullYear(), s.getMonth(), s.getDate() + t);
}
function Dt(s, t, e) {
  const i = new Date(s, t, e);
  return s >= 0 && s < 100 && i.setFullYear(i.getFullYear() - 1900), i;
}
function Er(s) {
  const t = s.split("-"), e = t[0], i = t[1], n = t[2];
  return Dt(e, i, n);
}
function wp(s) {
  return !Number.isNaN(s.getTime());
}
function xe(s, t) {
  return H(s) - H(t) || Y(s) - Y(t) || Q(s) - Q(t);
}
function de(s, t) {
  return s.setHours(0, 0, 0, 0), t.setHours(0, 0, 0, 0), s.getTime() === t.getTime();
}
function cs(s, t) {
  const i = H(s) - Op();
  return kp(i, t);
}
function kp(s, t) {
  return (s % t + t) % t;
}
function Op(s, t, e) {
  let i = 0;
  return e ? i = H(e) - s + 1 : t && (i = H(t)), i;
}
function As(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date();
  r.setHours(0, 0, 0, 0);
  const a = t && xe(s, t) <= -1, l = e && xe(s, e) >= 1, c = n && xe(s, r) <= -1, d = o && xe(s, r) >= 1, _ = i && i(s) === !1;
  return a || l || _ || c || d;
}
function gl(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date(), a = i && H(i), l = i && Y(i), c = e && H(e), d = e && Y(e), _ = H(r), f = Y(r), m = l && a && (t > a || t === a && s > l), g = d && c && (t < c || t === c && s < d), b = n && (t < _ || t === _ && s < f), T = o && (t > _ || t === _ && s > f);
  return m || g || b || T;
}
function Fn(s, t, e, i, n) {
  const o = t && H(t), r = e && H(e), a = H(/* @__PURE__ */ new Date()), l = r && s > r, c = o && s < o, d = i && s < a, _ = n && s > a;
  return l || c || d || _;
}
function xp(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && o && xe(o, l) < 0 || s) && (o = l), o && di(
    t,
    o,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function Sp(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && n && xe(n, l) < 0 || s) && (n = l), n && di(
    t,
    n,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function di(s, t, e, i, n, o, r, a) {
  return e === "days" ? H(s) === H(t) && Y(s) === Y(t) : e === "months" ? H(s) === H(t) : e === "years" ? H(t) >= a && H(t) <= r : !1;
}
const Dp = "data-te-datepicker-modal-container-ref", Ip = "data-te-datepicker-dropdown-container-ref", $p = "data-te-dropdown-backdrop-ref", Lp = "data-te-datepicker-date-text-ref", Tr = "data-te-datepicker-view-ref", Mp = "data-te-datepicker-previous-button-ref", Np = "data-te-datepicker-next-button-ref", Rp = "data-te-datepicker-ok-button-ref", Pp = "data-te-datepicker-cancel-button-ref", Hp = "data-te-datepicker-clear-button-ref", Bp = "data-te-datepicker-view-change-button-ref";
function Vp(s, t, e, i, n, o, r, a, l, c) {
  const d = Y(s), _ = H(s), f = Q(s), m = ls(s), g = M("div"), b = `
        ${Cr(
    s,
    d,
    _,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    c
  )}
    `, T = `
      ${Fp(f, m, d, n, c)}
      ${Cr(
    s,
    d,
    _,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    c
  )}
    `;
  return n.inline ? (p.addClass(g, c.datepickerDropdownContainer), g.setAttribute(Ip, l), g.innerHTML = b) : (p.addClass(g, c.modalContainer), g.setAttribute(Dp, l), g.innerHTML = T), g;
}
function Wp(s) {
  const t = M("div");
  return p.addClass(t, s), t.setAttribute($p, ""), t;
}
function Fp(s, t, e, i, n) {
  return `
      <div class="${n.datepickerHeader}">
        <div class="${n.datepickerTitle}">
          <span class="${n.datepickerTitleText}">${i.title}</span>
        </div>
        <div class="${n.datepickerDate}">
          <span class="${n.datepickerDateText}" ${Lp} >${i.weekdaysShort[t]}, ${i.monthsShort[e]} ${s}</span>
        </div>
      </div>
    `;
}
function Cr(s, t, e, i, n, o, r, a, l, c, d) {
  let _;
  return r.inline ? _ = `
    <div class="${d.datepickerMain}">
      ${yr(t, e, r, d)}
      <div class="${d.datepickerView}" ${Tr} tabindex="0">
        ${Ar(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    c,
    d
  )}
      </div>
    </div>
  ` : _ = `
    <div class="${d.datepickerMain}">
      ${yr(t, e, r, d)}
      <div class="${d.datepickerView}" ${Tr} tabindex="0">
        ${Ar(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    c,
    d
  )}
      </div>
      ${Yp(r, d)}
    </div>
  `, _;
}
function Ar(s, t, e, i, n, o, r, a, l, c) {
  let d;
  return o.view === "days" ? d = ds(s, e, o, c) : o.view === "months" ? d = hs(
    t,
    i,
    n,
    o,
    r,
    c
  ) : d = us(
    s,
    i,
    o,
    a,
    l,
    c
  ), d;
}
function yr(s, t, e, i) {
  return `
    <div class="${i.datepickerDateControls}">
      <button class="${i.datepickerViewChangeButton}" aria-label="${e.switchToMultiYearViewLabel}" ${Bp}>
        ${e.monthsFull[s]} ${t} ${kt(
    e,
    i
  )}
      </button>
      <div class="${i.datepickerArrowControls}">
        <button class="${i.datepickerPreviousButton}" aria-label="${e.prevMonthLabel}" ${Mp}>${e.changeMonthIconTemplate}</button>
        <button class="${i.datepickerNextButton}" aria-label="${e.nextMonthLabel}" ${Np}>${e.changeMonthIconTemplate}</button>
      </div>
    </div>
    `;
}
function kt(s, t) {
  return `
  <span class="${t.datepickerViewChangeIcon}">
  ${s.viewChangeIconTemplate}
  </span>
  `;
}
function Yp(s, t) {
  const e = `<button class="${t.datepickerFooterBtn}" aria-label="${s.okBtnLabel}" ${Rp}>${s.okBtnText}</button>`, i = `<button class="${t.datepickerFooterBtn}" aria-label="${s.cancelBtnLabel}" ${Pp}>${s.cancelBtnText}</button>`, n = `<button class="${t.datepickerFooterBtn} ${t.datepickerClearBtn}" aria-label="${s.clearBtnLabel}" ${Hp}>${s.clearBtnText}</button>`;
  return `
        <div class="${t.datepickerFooter}">
          
        ${s.removeClearBtn ? "" : n}
        ${s.removeCancelBtn ? "" : i}
        ${s.removeOkBtn ? "" : e}
        </div>
      `;
}
function ds(s, t, e, i) {
  const n = jp(s, t, e), r = `
      <tr>
        ${e.weekdaysNarrow.map((l, c) => `<th class="${i.datepickerDayHeading}" scope="col" aria-label="${e.weekdaysFull[c]}">${l}</th>`).join("")}
      </tr>
    `, a = n.map((l) => `
        <tr>
          ${l.map((c) => `
              <td
              class="${i.datepickerCell} ${i.datepickerCellSmall}"
              data-te-date="${H(c.date)}-${Y(
    c.date
  )}-${Q(c.date)}"
              aria-label="${c.date}"
              aria-selected="${c.isSelected}"
              ${c.isSelected ? "data-te-datepicker-cell-selected" : ""}
              ${!c.currentMonth || c.disabled ? "data-te-datepicker-cell-disabled" : ""}
              ${c.isToday ? "data-te-datepicker-cell-current" : ""}
              >
                <div
                  class="${i.datepickerCellContent} ${i.datepickerCellContentSmall}"
                  style="${c.currentMonth ? "display: block" : "display: none"}"
                  >
                  ${c.dayNumber}
                  </div>
              </td>
            `).join("")}
        </tr>
      `).join("");
  return `
      <table class="${i.datepickerTable}">
        <thead>
          ${r}
        </thead>
        <tbody>
         ${a}
        </tbody>
      </table>
    `;
}
function jp(s, t, e) {
  const i = [], n = Y(s), o = Y(nt(s, -1)), r = Y(nt(s, 1)), a = H(s), l = Ap(a, n, e), c = Wn(s), d = Wn(nt(s, -1)), _ = 7;
  let f = 1, m = !1;
  for (let g = 1; g < _; g++) {
    const b = [];
    if (g === 1) {
      const T = d - l + 1;
      for (let w = T; w <= d; w++) {
        const v = Dt(a, o, w);
        b.push({
          date: v,
          currentMonth: m,
          isSelected: t && de(v, t),
          isToday: de(v, De()),
          dayNumber: Q(v)
        });
      }
      m = !0;
      const C = _ - b.length;
      for (let w = 0; w < C; w++) {
        const v = Dt(a, n, f);
        b.push({
          date: v,
          currentMonth: m,
          isSelected: t && de(v, t),
          isToday: de(v, De()),
          dayNumber: Q(v),
          disabled: As(
            v,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), f++;
      }
    } else
      for (let T = 1; T < 8; T++) {
        f > c && (f = 1, m = !1);
        const C = Dt(
          a,
          m ? n : r,
          f
        );
        b.push({
          date: C,
          currentMonth: m,
          isSelected: t && de(C, t),
          isToday: de(C, De()),
          dayNumber: Q(C),
          disabled: As(
            C,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), f++;
      }
    i.push(b);
  }
  return i;
}
function hs(s, t, e, i, n, o) {
  const r = Kp(i, n), a = Y(De()), l = H(De()), c = `
      ${r.map((d) => `
          <tr>
            ${d.map((_) => {
    const f = i.monthsShort.indexOf(_);
    return `
                <td class="${o.datepickerCell} ${o.datepickerCellLarge}"
                ${gl(
      f,
      s,
      i.min,
      i.max,
      i.disablePast,
      i.disableFuture
    ) ? "data-te-datepicker-cell-disabled" : ""}
                
                data-te-month="${f}" data-te-year="${s}" aria-label="${_}, ${s}"
                ${f === e && s === t ? "data-te-datepicker-cell-selected" : ""}
                ${f === a && s === l ? "data-te-datepicker-cell-current" : ""}" data-te-month="${f}" data-te-year="${s}" aria-label="${_}, ${s}">
                  <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${_}</div>
                </td>
              `;
  }).join("")}
          </tr>
        `).join("")}
    `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
         ${c}
        </tbody>
      </table>
    `;
}
function Kp(s, t) {
  const e = [];
  let i = [];
  for (let n = 0; n < s.monthsShort.length; n++)
    if (i.push(s.monthsShort[n]), i.length === t) {
      const o = i;
      e.push(o), i = [];
    }
  return e;
}
function us(s, t, e, i, n, o) {
  const r = Up(s, i, n), a = H(De()), l = `
    ${r.map((c) => `
        <tr>
          ${c.map((d) => `
              <td class="${o.datepickerCell} ${o.datepickerCellLarge}"  aria-label="${d}" data-te-year="${d}"
              ${Fn(
    d,
    e.min,
    e.max,
    e.disablePast,
    e.disableFuture
  ) ? "data-te-datepicker-cell-disabled" : ""}
              ${d === t ? "data-te-datepicker-cell-selected" : ""}
              ${d === a ? "data-te-datepicker-cell-current" : ""}
              >
                <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${d}</div>
              </td>
            `).join("")}
        </tr>
      `).join("")}
  `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
        ${l}
        </tbody>
      </table>
    `;
}
function Up(s, t, e) {
  const i = [], n = H(s), o = cs(s, t), r = n - o;
  let a = [];
  for (let l = 0; l < t; l++)
    if (a.push(r + l), a.length === e) {
      const c = a;
      i.push(c), a = [];
    }
  return i;
}
function zp(s, t) {
  return `
    <button id="${s}" type="button" class="${t}" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
      <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z" clip-rule="evenodd" />
      </svg>  
    </button>
  `;
}
const Ie = 37, rt = 38, $e = 39, U = 40, Le = 36, Me = 35, hn = 33, un = 34, lt = 13, ps = 32, Is = 27, fi = 9, Xp = 8, Gp = 46, mt = 24, Hi = 4, Bi = 4, pn = "datepicker", fs = "te.datepicker", $s = `.${fs}`, qp = ".data-api", Qp = `close${$s}`, Zp = `open${$s}`, Jp = `dateChange${$s}`, Vi = `click${$s}${qp}`, bl = "data-te-datepicker-modal-container-ref", vl = "data-te-datepicker-dropdown-container-ref", Wi = "[data-te-datepicker-toggle-ref]", tf = `[${bl}]`, ef = `[${vl}]`, sf = "[data-te-datepicker-view-change-button-ref]", nf = "[data-te-datepicker-previous-button-ref]", of = "[data-te-datepicker-next-button-ref]", rf = "[data-te-datepicker-ok-button-ref]", af = "[data-te-datepicker-cancel-button-ref]", lf = "[data-te-datepicker-clear-button-ref]", cf = "[data-te-datepicker-view-ref]", df = "[data-te-datepicker-toggle-button-ref]", hf = "[data-te-datepicker-date-text-ref]", uf = "[data-te-dropdown-backdrop-ref]", pf = "animate-[fade-in_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", ff = "animate-[fade-out_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", _f = "animate-[fade-in_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", mf = "animate-[fade-out_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", gf = "flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700", bf = "w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]", vf = "relative h-full", Ef = "xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800", Tf = "h-8 flex flex-col justify-end", Cf = "text-[10px] font-normal uppercase tracking-[1.7px] text-white", Af = "xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end", yf = "text-[34px] font-normal text-white", wf = "outline-none px-3", kf = "px-3 pt-2.5 pb-0 flex justify-between text-black/[64]", Of = "flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", xf = "mt-2.5", Sf = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto", Df = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto", If = "h-14 flex absolute w-full bottom-0 justify-end items-center px-3", $f = "outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", Lf = "mr-auto", Mf = "w-10 h-10 text-center text-[12px] font-normal dark:text-white", Nf = "text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group", Rf = "w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8", Pf = "w-[76px] h-[42px]", Hf = "mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:text-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10 dark:group-[[data-te-datepicker-cell-disabled]]:text-neutral-500", Bf = "w-9 h-9 leading-9 rounded-[50%] text-[13px]", Vf = "w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]", Wf = "mx-auto w-[304px]", Ff = "flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200", Yf = "inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white", jf = "w-[328px] h-[380px] bg-white rounded-lg shadow-[0px_2px_15px_-3px_rgba(0,0,0,.07),_0px_10px_20px_-2px_rgba(0,0,0,.04)] z-[1066] dark:bg-zinc-700", Kf = {
  title: "Select date",
  container: "body",
  disablePast: !1,
  disableFuture: !1,
  monthsFull: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  monthsShort: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  weekdaysFull: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  weekdaysNarrow: ["S", "M", "T", "W", "T", "F", "S"],
  okBtnText: "Ok",
  clearBtnText: "Clear",
  cancelBtnText: "Cancel",
  okBtnLabel: "Confirm selection",
  clearBtnLabel: "Clear selection",
  cancelBtnLabel: "Cancel selection",
  nextMonthLabel: "Next month",
  prevMonthLabel: "Previous month",
  nextYearLabel: "Next year",
  prevYearLabel: "Previous year",
  changeMonthIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
  </svg>
  `,
  nextMultiYearLabel: "Next 24 years",
  prevMultiYearLabel: "Previous 24 years",
  switchToMultiYearViewLabel: "Choose year and month",
  switchToMonthViewLabel: "Choose date",
  switchToDayViewLabel: "Choose date",
  startDate: null,
  startDay: 0,
  format: "dd/mm/yyyy",
  view: "days",
  viewChangeIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="0" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
  </svg>
  `,
  min: null,
  max: null,
  filter: null,
  inline: !1,
  toggleButton: !0,
  disableToggleButton: !1,
  disableInput: !1,
  animations: !0,
  confirmDateOnSelect: !1,
  removeOkBtn: !1,
  removeCancelBtn: !1,
  removeClearBtn: !1
}, Uf = {
  title: "string",
  container: "string",
  disablePast: "boolean",
  disableFuture: "boolean",
  monthsFull: "array",
  monthsShort: "array",
  weekdaysFull: "array",
  weekdaysShort: "array",
  weekdaysNarrow: "array",
  okBtnText: "string",
  clearBtnText: "string",
  cancelBtnText: "string",
  okBtnLabel: "string",
  clearBtnLabel: "string",
  cancelBtnLabel: "string",
  nextMonthLabel: "string",
  prevMonthLabel: "string",
  nextYearLabel: "string",
  prevYearLabel: "string",
  nextMultiYearLabel: "string",
  prevMultiYearLabel: "string",
  changeMonthIconTemplate: "string",
  switchToMultiYearViewLabel: "string",
  switchToMonthViewLabel: "string",
  switchToDayViewLabel: "string",
  startDate: "(null|string|date)",
  startDay: "number",
  format: "string",
  view: "string",
  viewChangeIconTemplate: "string",
  min: "(null|string|date)",
  max: "(null|string|date)",
  filter: "(null|function)",
  inline: "boolean",
  toggleButton: "boolean",
  disableToggleButton: "boolean",
  disableInput: "boolean",
  animations: "boolean",
  confirmDateOnSelect: "boolean",
  removeOkBtn: "boolean",
  removeCancelBtn: "boolean",
  removeClearBtn: "boolean"
}, zf = {
  fadeIn: pf,
  fadeOut: ff,
  fadeInShort: _f,
  fadeOutShort: mf,
  modalContainer: gf,
  datepickerBackdrop: bf,
  datepickerMain: vf,
  datepickerHeader: Ef,
  datepickerTitle: Tf,
  datepickerTitleText: Cf,
  datepickerDate: Af,
  datepickerDateText: yf,
  datepickerView: wf,
  datepickerDateControls: kf,
  datepickerViewChangeButton: Of,
  datepickerViewChangeIcon: Yf,
  datepickerArrowControls: xf,
  datepickerPreviousButton: Sf,
  datepickerNextButton: Df,
  datepickerFooter: If,
  datepickerFooterBtn: $f,
  datepickerClearBtn: Lf,
  datepickerDayHeading: Mf,
  datepickerCell: Nf,
  datepickerCellSmall: Rf,
  datepickerCellLarge: Pf,
  datepickerCellContent: Hf,
  datepickerCellContentSmall: Bf,
  datepickerCellContentLarge: Vf,
  datepickerTable: Wf,
  datepickerToggleButton: Ff,
  datepickerDropdownContainer: jf
}, Xf = {
  fadeIn: "string",
  fadeOut: "string",
  fadeInShort: "string",
  fadeOutShort: "string",
  modalContainer: "string",
  datepickerBackdrop: "string",
  datepickerMain: "string",
  datepickerHeader: "string",
  datepickerTitle: "string",
  datepickerTitleText: "string",
  datepickerDate: "string",
  datepickerDateText: "string",
  datepickerView: "string",
  datepickerDateControls: "string",
  datepickerViewChangeButton: "string",
  datepickerArrowControls: "string",
  datepickerPreviousButton: "string",
  datepickerNextButton: "string",
  datepickerFooter: "string",
  datepickerFooterBtn: "string",
  datepickerClearBtn: "string",
  datepickerDayHeading: "string",
  datepickerCell: "string",
  datepickerCellSmall: "string",
  datepickerCellLarge: "string",
  datepickerCellContent: "string",
  datepickerCellContentSmall: "string",
  datepickerCellContentLarge: "string",
  datepickerTable: "string",
  datepickerToggleButton: "string",
  datepickerDropdownContainer: "string"
};
class Gg {
  constructor(t, e, i) {
    this._element = t, this._input = h.findOne("input", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = Ot("datepicker-toggle-"), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this._scrollBar = new pi(), this._element && I.setData(t, fs, this), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = "true"), this._options.disableInput && (this._input.disabled = "true");
  }
  // Getters
  static get NAME() {
    return pn;
  }
  get container() {
    return h.findOne(
      `[${bl}='${this._toggleButtonId}']`
    ) || h.findOne(
      `[${vl}='${this._toggleButtonId}']`
    );
  }
  get options() {
    return this._options;
  }
  get activeCell() {
    let t;
    return this._view === "days" && (t = this._getActiveDayCell()), this._view === "months" && (t = this._getActiveMonthCell()), this._view === "years" && (t = this._getActiveYearCell()), t;
  }
  get activeDay() {
    return Q(this._activeDate);
  }
  get activeMonth() {
    return Y(this._activeDate);
  }
  get activeYear() {
    return H(this._activeDate);
  }
  get firstYearInView() {
    return this.activeYear - cs(this._activeDate, mt);
  }
  get lastYearInView() {
    return this.firstYearInView + mt - 1;
  }
  get viewChangeButton() {
    return h.findOne(sf, this.container);
  }
  get previousButton() {
    return h.findOne(nf, this.container);
  }
  get nextButton() {
    return h.findOne(of, this.container);
  }
  get okButton() {
    return h.findOne(rf, this.container);
  }
  get cancelButton() {
    return h.findOne(af, this.container);
  }
  get clearButton() {
    return h.findOne(lf, this.container);
  }
  get datesContainer() {
    return h.findOne(cf, this.container);
  }
  get toggleButton() {
    return h.findOne(df, this._element);
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._element);
    if (t = {
      ...Kf,
      ...e,
      ...t
    }, N(pn, t, Uf), t.max && typeof t.max == "string" && (t.max = new Date(t.max)), t.min && typeof t.min == "string" && (t.min = new Date(t.min)), t.startDay && t.startDay !== 0) {
      const i = this._getNewDaysOrderArray(t);
      t.weekdaysNarrow = i;
    }
    return t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...zf,
      ...e,
      ...t
    }, N(pn, t, Xf), t;
  }
  _getContainer() {
    return h.findOne(this._options.container);
  }
  _getNewDaysOrderArray(t) {
    const e = t.startDay, i = t.weekdaysNarrow;
    return i.slice(e).concat(i.slice(0, e));
  }
  _init() {
    !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = "none")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown();
  }
  _appendToggleButton() {
    const t = zp(
      this._toggleButtonId,
      this._classes.datepickerToggleButton
    );
    this._element.insertAdjacentHTML("beforeend", t);
  }
  open() {
    if (this._input.readOnly || this._input.disabled)
      return;
    const t = u.trigger(this._element, Zp);
    if (this._isOpen || t.defaultPrevented)
      return;
    this._setInitialDate();
    const e = Wp(this._classes.datepickerBackdrop), i = Vp(
      this._activeDate,
      this._selectedDate,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Bi,
      mt,
      Hi,
      this._toggleButtonId,
      this._classes
    );
    this._options.inline ? this._openDropdown(i) : (this._openModal(e, i), this._scrollBar.hide()), this._animations && (p.addClass(this.container, this._classes.fadeIn), p.addClass(e, this._classes.fadeInShort)), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(() => {
      this._listenToOutsideClick();
    }, 0);
  }
  _openDropdown(t) {
    this._popper = je(this._input, t, {
      placement: "bottom-start"
    }), this._getContainer().appendChild(t);
  }
  _openModal(t, e) {
    const i = this._getContainer();
    i.appendChild(t), i.appendChild(e);
  }
  _setFocusTrap(t) {
    this._focusTrap = new bi(t, {
      event: "keydown",
      condition: (e) => e.key === "Tab"
    }), this._focusTrap.trap();
  }
  _listenToUserInput() {
    u.on(this._input, "input", (t) => {
      this._handleUserInput(t.target.value);
    });
  }
  _listenToToggleClick() {
    u.on(
      this._element,
      Vi,
      Wi,
      (t) => {
        t.preventDefault(), this.open();
      }
    );
  }
  _listenToToggleKeydown() {
    u.on(
      this._element,
      "keydown",
      Wi,
      (t) => {
        t.keyCode === lt && !this._isOpen && this.open();
      }
    );
  }
  _listenToDateSelection() {
    u.on(this.datesContainer, "click", (t) => {
      this._handleDateSelection(t);
    });
  }
  _handleDateSelection(t) {
    const e = t.target.nodeName === "DIV" ? t.target.parentNode.dataset : t.target.dataset, i = t.target.nodeName === "DIV" ? t.target.parentNode : t.target;
    if (e.teDate && this._pickDay(e.teDate, i), e.teMonth && e.teYear) {
      const n = parseInt(e.teMonth, 10), o = parseInt(e.teYear, 10);
      this._pickMonth(n, o);
    }
    if (e.teYear && !e.teMonth) {
      const n = parseInt(e.teYear, 10);
      this._pickYear(n);
    }
    this._options.inline || this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _updateHeaderDate(t, e, i) {
    const n = h.findOne(
      hf,
      this.container
    ), o = Y(t), r = Q(t), a = ls(t);
    n.innerHTML = `${i[a]}, ${e[o]} ${r}`;
  }
  _addControlsListeners() {
    u.on(this.nextButton, "click", () => {
      this._view === "days" ? this.nextMonth() : this._view === "years" ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState();
    }), u.on(this.previousButton, "click", () => {
      this._view === "days" ? this.previousMonth() : this._view === "years" ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState();
    }), u.on(this.viewChangeButton, "click", () => {
      this._view === "days" ? this._changeView("years") : (this._view === "years" || this._view === "months") && this._changeView("days");
    }), this._options.inline || this._listenToFooterButtonsClick();
  }
  _listenToFooterButtonsClick() {
    u.on(this.okButton, "click", () => this.handleOk()), u.on(this.cancelButton, "click", () => this.handleCancel()), u.on(this.clearButton, "click", () => this.handleClear());
  }
  _listenToOutsideClick() {
    u.on(document, Vi, (t) => {
      const e = t.target === this.container, i = this.container && this.container.contains(t.target);
      !e && !i && this.close();
    });
  }
  _listenToEscapeClick() {
    u.on(document, "keydown", (t) => {
      t.keyCode === Is && this._isOpen && this.close();
    });
  }
  _listenToKeyboardNavigation() {
    u.on(this.datesContainer, "keydown", (t) => {
      this._handleKeydown(t);
    });
  }
  _listenToDatesContainerFocus() {
    u.on(this.datesContainer, "focus", () => {
      this._focusActiveCell(this.activeCell);
    });
  }
  _listenToDatesContainerBlur() {
    u.on(this.datesContainer, "blur", () => {
      this._removeCurrentFocusStyles();
    });
  }
  _handleKeydown(t) {
    this._view === "days" && this._handleDaysViewKeydown(t), this._view === "months" && this._handleMonthsViewKeydown(t), this._view === "years" && this._handleYearsViewKeydown(t);
  }
  _handleDaysViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Ie:
        this._activeDate = Te(this._activeDate, F() ? 1 : -1);
        break;
      case $e:
        this._activeDate = Te(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = Te(this._activeDate, -7);
        break;
      case U:
        this._activeDate = Te(this._activeDate, 7);
        break;
      case Le:
        this._activeDate = Te(
          this._activeDate,
          1 - Q(this._activeDate)
        );
        break;
      case Me:
        this._activeDate = Te(
          this._activeDate,
          Wn(this._activeDate) - Q(this._activeDate)
        );
        break;
      case hn:
        this._activeDate = nt(this._activeDate, -1);
        break;
      case un:
        this._activeDate = nt(this._activeDate, 1);
        break;
      case lt:
      case ps:
        this._selectDate(this._activeDate), this._handleDateSelection(t), t.preventDefault();
        return;
      default:
        return;
    }
    di(
      e,
      this._activeDate,
      this._view,
      mt,
      this._options.min,
      this._options.max
    ) || this._changeView("days"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _asyncFocusDatesContainer() {
    setTimeout(() => {
      this.datesContainer.focus();
    }, 0);
  }
  _focusActiveCell(t) {
    t && t.setAttribute("data-te-datepicker-cell-focused", "");
  }
  _removeHighlightFromCell(t) {
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  _getActiveDayCell() {
    const t = h.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = Er(i.dataset.teDate);
      return de(n, this._activeDate);
    });
  }
  _handleMonthsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Ie:
        this._activeDate = nt(this._activeDate, F() ? 1 : -1);
        break;
      case $e:
        this._activeDate = nt(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = nt(this._activeDate, -4);
        break;
      case U:
        this._activeDate = nt(this._activeDate, 4);
        break;
      case Le:
        this._activeDate = nt(this._activeDate, -this.activeMonth);
        break;
      case Me:
        this._activeDate = nt(this._activeDate, 11 - this.activeMonth);
        break;
      case hn:
        this._activeDate = it(this._activeDate, -1);
        break;
      case un:
        this._activeDate = it(this._activeDate, 1);
        break;
      case lt:
      case ps:
        this._selectMonth(this.activeMonth);
        return;
      default:
        return;
    }
    di(
      e,
      this._activeDate,
      this._view,
      mt,
      this._options.min,
      this._options.max
    ) || this._changeView("months"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveMonthCell() {
    const t = h.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = parseInt(i.dataset.teYear, 10), o = parseInt(i.dataset.teMonth, 10);
      return n === this.activeYear && o === this.activeMonth;
    });
  }
  _handleYearsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell, n = 4, o = 24;
    switch (t.keyCode) {
      case Ie:
        this._activeDate = it(this._activeDate, F() ? 1 : -1);
        break;
      case $e:
        this._activeDate = it(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = it(this._activeDate, -n);
        break;
      case U:
        this._activeDate = it(this._activeDate, n);
        break;
      case Le:
        this._activeDate = it(
          this._activeDate,
          -cs(this._activeDate, o)
        );
        break;
      case Me:
        this._activeDate = it(
          this._activeDate,
          o - cs(this._activeDate, o) - 1
        );
        break;
      case hn:
        this._activeDate = it(this._activeDate, -o);
        break;
      case un:
        this._activeDate = it(this._activeDate, o);
        break;
      case lt:
      case ps:
        this._selectYear(this.activeYear);
        return;
      default:
        return;
    }
    di(
      e,
      this._activeDate,
      this._view,
      mt,
      this._options.min,
      this._options.max
    ) || this._changeView("years"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveYearCell() {
    const t = h.find("td", this.datesContainer);
    return Array.from(t).find((i) => parseInt(i.dataset.teYear, 10) === this.activeYear);
  }
  _setInitialDate() {
    this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = /* @__PURE__ */ new Date();
  }
  close() {
    const t = u.trigger(this._element, Qp);
    !this._isOpen || t.defaultPrevented || (this._removeDatepickerListeners(), this._animations && p.addClass(this.container, this._classes.fadeOut), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, this.toggleButton ? this.toggleButton.focus() : this._input.focus());
  }
  _closeDropdown() {
    const t = h.findOne(ef);
    window.matchMedia("(prefers-reduced-motion: reduce)").matches && (t && document.body.removeChild(t), this._popper && this._popper.destroy()), t.addEventListener("animationend", () => {
      t && document.body.removeChild(t), this._popper && this._popper.destroy();
    }), this._removeFocusTrap();
  }
  _closeModal() {
    const t = h.findOne(uf), e = h.findOne(tf);
    !e || !t || (this._animations ? (p.addClass(t, this._classes.fadeOutShort), t.addEventListener("animationend", () => {
      this._removePicker(t, e), this._scrollBar.reset();
    })) : (this._removePicker(t, e), this._scrollBar.reset()));
  }
  _removePicker(t, e) {
    const i = this._getContainer();
    i.removeChild(t), i.removeChild(e);
  }
  _removeFocusTrap() {
    this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null);
  }
  _removeDatepickerListeners() {
    u.off(this.nextButton, "click"), u.off(this.previousButton, "click"), u.off(this.viewChangeButton, "click"), u.off(this.okButton, "click"), u.off(this.cancelButton, "click"), u.off(this.clearButton, "click"), u.off(this.datesContainer, "click"), u.off(this.datesContainer, "keydown"), u.off(this.datesContainer, "focus"), u.off(this.datesContainer, "blur"), u.off(document, Vi);
  }
  dispose() {
    this._isOpen && this.close(), this._removeInputAndToggleListeners();
    const t = h.findOne(
      `#${this._toggleButtonId}`
    );
    t && this._element.removeChild(t), I.removeData(this._element, fs), this._element = null, this._input = null, this._options = null, this._activeDate = null, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = null, this._popper = null, this._focusTrap = null;
  }
  _removeInputAndToggleListeners() {
    u.off(this._input, "input"), u.off(
      this._element,
      Vi,
      Wi
    ), u.off(this._element, "keydown", Wi);
  }
  handleOk() {
    this._confirmSelection(this._headerDate), this.close();
  }
  _selectDate(t, e = this.activeCell) {
    const { min: i, max: n, filter: o, disablePast: r, disableFuture: a } = this._options;
    As(t, i, n, o, r, a) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = H(t), this._selectedMonth = Y(t), this._headerDate = t, (this._options.inline || this.options.confirmDateOnSelect) && (this._confirmSelection(t), this.close()));
  }
  _selectYear(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView("months");
  }
  _selectMonth(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView("days");
  }
  _removeSelectedStyles(t) {
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _addSelectedStyles(t) {
    t && t.setAttribute("data-te-datepicker-cell-selected", "");
  }
  _confirmSelection(t) {
    if (t) {
      const e = this.formatDate(t);
      this._input.value = e, u.trigger(this._element, Jp, { date: t }), u.trigger(this._input, "input");
    }
  }
  handleCancel() {
    this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close();
  }
  handleClear() {
    this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = "", this._setInitialDate(), this._changeView("days"), this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _removeCurrentSelectionStyles() {
    const t = h.findOne(
      "[data-te-datepicker-cell-selected]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _removeCurrentFocusStyles() {
    const t = h.findOne(
      "[data-te-datepicker-cell-focused]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  formatDate(t) {
    const e = Q(t), i = this._addLeadingZero(Q(t)), n = this._options.weekdaysShort[ls(t)], o = this._options.weekdaysFull[ls(t)], r = Y(t) + 1, a = this._addLeadingZero(Y(t) + 1), l = this._options.monthsShort[Y(t)], c = this._options.monthsFull[Y(t)], d = H(t).toString().length === 2 ? H(t) : H(t).toString().slice(2, 4), _ = H(t), f = this._options.format.split(
      /(d{1,4}|m{1,4}|y{4}|yy|!.)/g
    );
    let m = "";
    return f.forEach((g) => {
      switch (g) {
        case "dddd":
          g = g.replace(g, o);
          break;
        case "ddd":
          g = g.replace(g, n);
          break;
        case "dd":
          g = g.replace(g, i);
          break;
        case "d":
          g = g.replace(g, e);
          break;
        case "mmmm":
          g = g.replace(g, c);
          break;
        case "mmm":
          g = g.replace(g, l);
          break;
        case "mm":
          g = g.replace(g, a);
          break;
        case "m":
          g = g.replace(g, r);
          break;
        case "yyyy":
          g = g.replace(g, _);
          break;
        case "yy":
          g = g.replace(g, d);
          break;
      }
      m += g;
    }), m;
  }
  _addLeadingZero(t) {
    return parseInt(t, 10) < 10 ? `0${t}` : t;
  }
  _pickDay(t, e) {
    const i = Er(t), { min: n, max: o, filter: r, disablePast: a, disableFuture: l } = this._options;
    As(i, n, o, r, a, l) || (this._activeDate = i, this._selectDate(i, e));
  }
  _pickYear(t) {
    const { min: e, max: i, disablePast: n, disableFuture: o } = this._options;
    if (Fn(t, e, i, n, o))
      return;
    const r = Dt(t, this.activeMonth, this.activeDay);
    this._activeDate = r, this._selectedDate = r, this._selectYear(t);
  }
  _pickMonth(t, e) {
    const { min: i, max: n, disablePast: o, disableFuture: r } = this._options;
    if (gl(t, e, i, n, o, r) || Fn(e, i, n, o, r))
      return;
    const a = Dt(e, t, this.activeDay);
    this._activeDate = a, this._selectMonth(t);
  }
  nextMonth() {
    const t = nt(this._activeDate, 1), e = ds(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this._activeDate = t, this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousMonth() {
    const t = nt(this._activeDate, -1);
    this._activeDate = t;
    const e = ds(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  nextYear() {
    const t = it(this._activeDate, 1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    );
    const e = hs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Bi,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  previousYear() {
    const t = it(this._activeDate, -1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    );
    const e = hs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Bi,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  nextYears() {
    const t = it(this._activeDate, 24);
    this._activeDate = t;
    const e = us(
      t,
      this._selectedYear,
      this._options,
      mt,
      Hi,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousYears() {
    const t = it(this._activeDate, -24);
    this._activeDate = t;
    const e = us(
      t,
      this._selectedYear,
      this._options,
      mt,
      Hi,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  _asyncChangeView(t) {
    setTimeout(() => {
      this._changeView(t);
    }, 0);
  }
  _changeView(t) {
    this._view = t, this.datesContainer.blur(), t === "days" && (this.datesContainer.innerHTML = ds(
      this._activeDate,
      this._headerDate,
      this._options,
      this._classes
    )), t === "months" && (this.datesContainer.innerHTML = hs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Bi,
      this._classes
    )), t === "years" && (this.datesContainer.innerHTML = us(
      this._activeDate,
      this._selectedYear,
      this._options,
      mt,
      Hi,
      this._classes
    )), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState();
  }
  _updateViewControlsAndAttributes(t) {
    t === "days" && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMultiYearViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMonthLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextMonthLabel)), t === "months" && (this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToDayViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevYearLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextYearLabel)), t === "years" && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMonthViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMultiYearLabel
    ), this.nextButton.setAttribute(
      "aria-label",
      this._options.nextMultiYearLabel
    ));
  }
  _updateControlsDisabledState() {
    xp(
      this._options.disableFuture,
      this._activeDate,
      this._view,
      mt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.nextButton.disabled = !0 : this.nextButton.disabled = !1, Sp(
      this._options.disablePast,
      this._activeDate,
      this._view,
      mt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.previousButton.disabled = !0 : this.previousButton.disabled = !1;
  }
  _handleUserInput(t) {
    const e = this._getDelimeters(this._options.format), i = this._parseDate(t, this._options.format, e);
    wp(i) ? (this._activeDate = i, this._selectedDate = i, this._selectedYear = H(i), this._selectedMonth = Y(i), this._headerDate = i) : (this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null);
  }
  _getDelimeters(t) {
    return t.match(/[^(dmy)]{1,}/g);
  }
  _parseDate(t, e, i) {
    let n;
    i[0] !== i[1] ? n = i[0] + i[1] : n = i[0];
    const o = new RegExp(`[${n}]`), r = t.split(o), a = e.split(o), l = e.indexOf("mmm") !== -1, c = [];
    for (let b = 0; b < a.length; b++)
      a[b].indexOf("yy") !== -1 && (c[0] = { value: r[b], format: a[b] }), a[b].indexOf("m") !== -1 && (c[1] = { value: r[b], format: a[b] }), a[b].indexOf("d") !== -1 && a[b].length <= 2 && (c[2] = { value: r[b], format: a[b] });
    let d;
    e.indexOf("mmmm") !== -1 ? d = this._options.monthsFull : d = this._options.monthsShort;
    const _ = Number(c[0].value), f = l ? this.getMonthNumberByMonthName(c[1].value, d) : Number(c[1].value) - 1, m = Number(c[2].value);
    return Dt(_, f, m);
  }
  getMonthNumberByMonthName(t, e) {
    return e.findIndex((i) => i === t);
  }
  static getInstance(t) {
    return I.getData(t, fs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Gf = ({
  format24: s,
  okLabel: t,
  cancelLabel: e,
  headID: i,
  footerID: n,
  bodyID: o,
  pickerID: r,
  clearLabel: a,
  inline: l,
  showClearBtn: c,
  amLabel: d,
  pmLabel: _
}, f) => {
  const m = `<div id='${r}' class='${f.timepickerWrapper}' data-te-timepicker-wrapper>
      <div class="${f.timepickerContainer}">
        <div class="${f.timepickerElements}">
        <div id='${i}' class='${f.timepickerHead}' style='padding-right:${s ? 50 : 10}px'>
        <div class='${f.timepickerHeadContent}'>
            <div class="${f.timepickerCurrentWrapper}">
              <span class="${f.timepickerCurrentButtonWrapper}">
                <button type='button' class='${f.timepickerCurrentButton}' tabindex="0" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>
              </span>
              <button type='button' class='${f.timepickerDot}' disabled>:</button>
            <span class="${f.timepickerCurrentButtonWrapper}">
              <button type='button' class='${f.timepickerCurrentButton}' tabindex="0" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>
            </span>
            </div>
            ${s ? "" : `<div class="${f.timepickerModeWrapper}">
                  <button type='button' class="${f.timepickerModeAm}" tabindex="0" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${d}</button>
                  <button class="${f.timepickerModePm}" tabindex="0" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${_}</button>
                </div>`}
        </div>
      </div>
      ${l ? "" : `<div id='${o}' class='${f.timepickerClockWrapper}' data-te-timepicker-clock-wrapper>
            <div class='${f.timepickerClock}' data-te-timepicker-clock>
              <span class='${f.timepickerMiddleDot}' data-te-timepicker-middle-dot></span>
              <div class='${f.timepickerHandPointer}' data-te-timepicker-hand-pointer>
                <div class='${f.timepickerPointerCircle}' data-te-timepicker-circle></div>
              </div>
              ${s ? '<div class="' + f.timepickerClockInner + '" data-te-timepicker-clock-inner></div>' : ""}
            </div>
          </div>`}
    </div>
    <div id='${n}' class='${f.timepickerFooterWrapper}'>
      <div class="${f.timepickerFooter}">
        ${c ? `<button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-clear tabindex="0" data-te-ripple-init>${a}</button>` : ""}
        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-cancel tabindex="0" data-te-ripple-init>${e}</button>
        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
      </div>
    </div>
  </div>
</div>`, g = `<div id='${r}' class='${f.timepickerInlineWrapper}' data-te-timepicker-wrapper>
        <div class="${f.timepickerInlineContainer}">
          <div class="${f.timepickerInlineElements}">
          <div id='${i}' class='${f.timepickerInlineHead}'
          style='padding-right:10px'>
          <div class='${f.timepickerInlineHeadContent}'>
              <div class="${f.timepickerCurrentWrapper}">
                <span class="${f.timepickerInlineHourWrapper}" data-te-timepicker-inline-hour-icons>
                  <span class="${f.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>
                    <span class="${f.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                      </svg>   
                    </span>
                  </span>
                  <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                  <span class="${f.timepickerInlineIconDown}" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>
                    <span class="${f.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                      </svg>  
                    </span>
                  </span>
                </span>
                <button type='button' class='${f.timepickerInlineDot}' data-te-timepicker-current-inline disabled>:</button>
              <span class="${f.timepickerCurrentMinuteWrapper}">
                <span class="${f.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>
                  <span class="${f.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                    </svg>
                  </span>
                </span>
                <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                <span class="${f.timepickerInlineIconDown}" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>
                  <span class="${f.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                    </svg> 
                  </span>
                </span>
              </span>
              </div>
              ${s ? "" : `<div class="${f.timepickerInlineModeWrapper}">
                      <button type='button' class="${f.timepickerInlineModeAm}" data-te-timepicker-am data-te-timepicker-hour-mode tabindex="0" data-te-ripple-init>${d}</button>
                      <button class="${f.timepickerInlineModePm}" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex="0" data-te-ripple-init>${_}</button>
                      <button type='button' class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
                    </div>`}
              ${s ? `<button class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>` : ""}
          </div>
        </div>
      </div>
    </div>
</div>`;
  return l ? g : m;
}, qf = (s, t, e) => {
  const { iconSVG: i } = s;
  return `
  <button id="${t}" tabindex="0" type="button" class="${e.timepickerToggleButton}" data-te-toggle="timepicker" data-te-timepicker-toggle-button data-te-timepicker-icon>
    ${i}
  </button>
`;
}, Ls = "data-te-timepicker-disabled", Fi = "data-te-timepicker-active", fe = (s) => {
  if (s === "")
    return;
  let t, e, i, n;
  return El(s) ? (t = s.getHours(), n = t, e = s.getMinutes(), t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM"), e = e < 10 ? `0${e}` : e) : ([t, e, i] = R(s, !1), n = t, t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM")), {
    hours: t,
    minutes: e,
    amOrPm: i
  };
}, El = (s) => s && Object.prototype.toString.call(s) === "[object Date]" && !Number.isNaN(s), wr = (s) => {
  if (s === "")
    return;
  let t, e;
  return El(s) ? (t = s.getHours(), e = s.getMinutes()) : [t, e] = R(s, !1), e = Number(e) < 10 ? `0${Number(e)}` : e, {
    hours: t,
    minutes: e
  };
}, Qf = (s, t, e) => u.on(document, s, t, ({ target: i }) => {
  if (i.hasAttribute(Fi))
    return;
  document.querySelectorAll(t).forEach((o) => {
    o.hasAttribute(Fi) && (p.removeClass(o, e.opacity), o.removeAttribute(Fi));
  }), p.addClass(i, e.opacity), i.setAttribute(Fi, "");
}), kr = ({ clientX: s, clientY: t, touches: e }, i, n = !1) => {
  const { left: o, top: r } = i.getBoundingClientRect();
  let a = {};
  return !n || !e ? a = {
    x: s - o,
    y: t - r
  } : n && Object.keys(e).length > 0 && (a = {
    x: e[0].clientX - o,
    y: e[0].clientY - r
  }), a;
}, Yi = () => navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  navigator.userAgent
), R = (s, t = !0) => t ? s.value.replace(/:/gi, " ").split(" ") : s.replace(/:/gi, " ").split(" "), Tl = (s, t) => {
  const [e, i, n] = R(s, !1), [o, r, a] = R(t, !1);
  return n === "PM" && a === "AM" || n === a && e > o || i > r;
}, Cl = () => {
  const s = /* @__PURE__ */ new Date(), t = s.getHours(), e = s.getMinutes();
  return `${t}:${e < 10 ? `0${e}` : e}`;
}, jt = (s, t, e) => {
  if (!t)
    return s;
  let i = Cl();
  return e && (i = `${fe(i).hours}:${fe(i).minutes} ${fe(i).amOrPm}`), (s !== "" && Tl(i, s) || s === "") && (s = i), s;
}, Kt = (s, t, e) => {
  if (!t)
    return s;
  let i = Cl();
  return e && (i = `${fe(i).hours}:${fe(i).minutes} ${fe(i).amOrPm}`), (s !== "" && !Tl(i, s) || s === "") && (s = i), s;
}, Zf = ({ format12: s, maxTime: t, minTime: e, disablePast: i, disableFuture: n }, o, r) => {
  const a = R(o)[1];
  e = jt(e, i, s), t = Kt(t, n, s);
  const [l, c, d] = R(t, !1), [_, f, m] = R(e, !1);
  if (d !== void 0 || m !== void 0)
    return [r, a];
  if (!(l !== "" && _ === "" && Number(r) > Number(l)) && !(l === "" && _ !== "" && c === void 0 && f !== "" && Number(r) < Number(_)))
    return [r, a];
}, Or = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, (n.textContent === "00" || Number(n.textContent === "12" && i ? "0" : n.textContent) > t) && (p.addClass(n, e.tipsDisabled), n.setAttribute(Ls, ""));
  });
}, xr = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, n.textContent !== "00" && Number(n.textContent === "12" && i ? "0" : n.textContent) < Number(t) && (p.addClass(n, e.tipsDisabled), n.setAttribute(Ls, ""));
  });
}, Al = (s, t, e, i) => {
  if (t === "12" || t === "24")
    return;
  const n = e ? 12 : 24;
  return i === "max" ? (Number(s) === n ? 0 : Number(s)) > Number(t) : (Number(s) === n ? 0 : Number(s)) < Number(t);
}, Jf = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (Al(i, e, o, "max") || Number(r.textContent) > t && Number(i) === Number(e)) && (p.addClass(r, n.tipsDisabled), r.setAttribute(Ls, ""));
  });
}, t_ = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (Al(i, e, o, "min") || Number(r.textContent) < t && Number(i) === Number(e)) && (p.addClass(r, n.tipsDisabled), r.setAttribute(Ls, ""));
  });
}, e_ = (s) => s.startsWith("0") ? Number(s.slice(1)) : Number(s), hi = "timepicker", L = `data-te-${hi}`, Sr = "[data-te-toggle]", _s = `te.${hi}`, $t = `.${_s}`, Lt = ".data-api", Dr = `click${$t}${Lt}`, ji = `keydown${$t}${Lt}`, Ir = `mousedown${$t}${Lt}`, $r = `mouseup${$t}${Lt}`, Lr = `mousemove${$t}${Lt}`, Mr = `mouseleave${$t}${Lt}`, Nr = `mouseover${$t}${Lt}`, Rr = `touchmove${$t}${Lt}`, Pr = `touchend${$t}${Lt}`, Hr = `touchstart${$t}${Lt}`, i_ = `[${L}-am]`, s_ = `[${L}-pm]`, n_ = `[${L}-format24]`, Ki = `[${L}-current]`, Ui = `[${L}-hour-mode]`, o_ = `[${L}-toggle-button]`, fn = `${L}-cancel`, Br = `${L}-clear`, _n = `${L}-submit`, r_ = `${L}-icon`, mn = `${L}-icon-up`, gn = `${L}-icon-down`, a_ = `${L}-icon-inline-hour`, l_ = `${L}-icon-inline-minute`, Vr = `${L}-inline-hour-icons`, c_ = `${L}-current-inline`, d_ = "readonly", Wr = `${L}-invalid-feedback`, bn = `${L}-is-invalid`, Bt = `${L}-disabled`, B = `${L}-active`, h_ = `${L}-input`, le = `${L}-clock`, Je = `${L}-clock-inner`, vn = `${L}-wrapper`, Fr = `${L}-clock-wrapper`, zi = `${L}-hour`, En = `${L}-minute`, Xi = `${L}-tips-element`, K = `${L}-tips-hours`, X = `${L}-tips-minutes`, at = `${L}-tips-inner`, Gi = `${L}-tips-inner-element`, Yr = `${L}-middle-dot`, Tn = `${L}-hand-pointer`, Cn = `${L}-circle`, jr = `${L}-modal`, u_ = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>`, p_ = {
  appendValidationInfo: !0,
  bodyID: "",
  cancelLabel: "Cancel",
  clearLabel: "Clear",
  closeModalOnBackdropClick: !0,
  closeModalOnMinutesClick: !1,
  container: "body",
  defaultTime: "",
  disabled: !1,
  disablePast: !1,
  disableFuture: !1,
  enableValidation: !0,
  focusInputAfterApprove: !1,
  footerID: "",
  format12: !0,
  format24: !1,
  headID: "",
  increment: !1,
  inline: !1,
  invalidLabel: "Invalid Time Format",
  maxTime: "",
  minTime: "",
  modalID: "",
  okLabel: "Ok",
  overflowHidden: !0,
  pickerID: "",
  readOnly: !1,
  showClearBtn: !0,
  switchHoursToMinutesOnClick: !0,
  iconSVG: u_,
  withIcon: !0,
  pmLabel: "PM",
  amLabel: "AM",
  animations: !0
}, f_ = {
  appendValidationInfo: "boolean",
  bodyID: "string",
  cancelLabel: "string",
  clearLabel: "string",
  closeModalOnBackdropClick: "boolean",
  closeModalOnMinutesClick: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  enableValidation: "boolean",
  footerID: "string",
  format12: "boolean",
  format24: "boolean",
  headID: "string",
  increment: "boolean",
  inline: "boolean",
  invalidLabel: "string",
  modalID: "string",
  okLabel: "string",
  overflowHidden: "boolean",
  pickerID: "string",
  readOnly: "boolean",
  showClearBtn: "boolean",
  switchHoursToMinutesOnClick: "boolean",
  defaultTime: "(string|date|number)",
  iconSVG: "string",
  withIcon: "boolean",
  pmLabel: "string",
  amLabel: "string",
  animations: "boolean"
}, __ = {
  tips: "absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent",
  tipsActive: "text-white bg-[#3b71ca] font-normal",
  tipsDisabled: "text-[#b3afaf] pointer-events-none bg-transparent",
  transform: "transition-[transform,height] ease-in-out duration-[400ms]",
  modal: "z-[1065]",
  clockAnimation: "animate-[show-up-clock_350ms_linear]",
  opacity: "!opacity-100",
  timepickerWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed",
  timepickerContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg",
  timepickerElements: "flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center",
  timepickerHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly",
  timepickerCurrentWrapper: "[direction:ltr] rtl:[direction:rtl]",
  timepickerCurrentButtonWrapper: "relative h-full",
  timepickerCurrentButton: "text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none ",
  timepickerDot: "font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal",
  timepickerModeWrapper: "flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerModeAm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerModePm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerClockWrapper: "min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500",
  timepickerClock: "relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50",
  timepickerMiddleDot: "top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute",
  timepickerHandPointer: "bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute",
  timepickerPointerCircle: "-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute",
  timepickerClockInner: "absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]",
  timepickerFooterWrapper: "rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500",
  timepickerFooter: "w-full flex justify-between",
  timepickerFooterButton: "text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none",
  timepickerInlineWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg",
  timepickerInlineContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]",
  timepickerInlineElements: "flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerInlineHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg",
  timepickerInlineHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center",
  timepickerInlineHourWrapper: "relative h-full !opacity-100",
  timepickerCurrentMinuteWrapper: "relative h-full",
  timepickerInlineIconUp: "absolute fill-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineIconSvg: "h-4 w-4",
  timepickerInlineCurrentButton: "font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]",
  timepickerInlineIconDown: "absolute fill-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineDot: "font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]",
  timepickerInlineModeWrapper: "flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerInlineModeAm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6",
  timepickerInlineModePm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer",
  timepickerInlineSubmitButton: "hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0",
  timepickerToggleButton: "h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-1.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca] dark:text-white"
}, m_ = {
  tips: "string",
  tipsActive: "string",
  tipsDisabled: "string",
  transform: "string",
  modal: "string",
  clockAnimation: "string",
  opacity: "string",
  timepickerWrapper: "string",
  timepickerContainer: "string",
  timepickerElements: "string",
  timepickerHead: "string",
  timepickerHeadContent: "string",
  timepickerCurrentWrapper: "string",
  timepickerCurrentButtonWrapper: "string",
  timepickerCurrentButton: "string",
  timepickerDot: "string",
  timepickerModeWrapper: "string",
  timepickerModeAm: "string",
  timepickerModePm: "string",
  timepickerClockWrapper: "string",
  timepickerClock: "string",
  timepickerMiddleDot: "string",
  timepickerHandPointer: "string",
  timepickerPointerCircle: "string",
  timepickerClockInner: "string",
  timepickerFooterWrapper: "string",
  timepickerFooterButton: "string",
  timepickerInlineWrapper: "string",
  timepickerInlineContainer: "string",
  timepickerInlineElements: "string",
  timepickerInlineHead: "string",
  timepickerInlineHeadContent: "string",
  timepickerInlineHourWrapper: "string",
  timepickerCurrentMinuteWrapper: "string",
  timepickerInlineIconUp: "string",
  timepickerInlineIconSvg: "string",
  timepickerInlineCurrentButton: "string",
  timepickerInlineIconDown: "string",
  timepickerInlineDot: "string",
  timepickerInlineModeWrapper: "string",
  timepickerInlineModeAm: "string",
  timepickerInlineModePm: "string",
  timepickerInlineSubmitButton: "string",
  timepickerToggleButton: "string"
};
class qg {
  constructor(t, e = {}, i) {
    Tt(this, "_toggleAmPm", (t) => {
      t === "PM" ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : t === "AM" && (this._isPmEnabled = !1, this._isAmEnabled = !0);
    });
    Tt(this, "_toggleBackgroundColorCircle", (t) => {
      if (this._modal.querySelector(`${t}[${B}]`) !== null) {
        p.addStyle(this._circle, {
          backgroundColor: "#1976d2"
        });
        return;
      }
      p.addStyle(this._circle, {
        backgroundColor: "transparent"
      });
    });
    Tt(this, "_toggleClassActive", (t, { textContent: e }, i) => {
      const n = [...t].find(
        (o) => Number(o) === Number(e)
      );
      return i.forEach((o) => {
        if (!o.hasAttribute(Bt)) {
          if (o.textContent === n) {
            p.addClass(o, this._classes.tipsActive), o.setAttribute(B, "");
            return;
          }
          p.removeClass(o, this._classes.tipsActive), o.removeAttribute(B);
        }
      });
    });
    Tt(this, "_makeMinutesDegrees", (t, e) => {
      const { increment: i } = this._options;
      return t < 0 ? (e = Math.round(360 + t / 6) % 60, t = 360 + Math.round(t / 6) * 6) : (e = Math.round(t / 6) % 60, t = Math.round(t / 6) * 6), i && (t = Math.round(t / 30) * 30, e = Math.round(t / 6) * 6 / 6, e === 60 && (e = "00")), t >= 360 && (t = 0), {
        degrees: t,
        minute: e,
        addDegrees: i ? 30 : 6
      };
    });
    Tt(this, "_makeHourDegrees", (t, e, i) => {
      if (t)
        return this._hasTargetInnerClass(t) ? e < 0 ? (i = Math.round(360 + e / 30) % 24, e = 360 + e) : (i = Math.round(e / 30) + 12, i === 12 && (i = "00")) : e < 0 ? (i = Math.round(360 + e / 30) % 12, e = 360 + e) : (i = Math.round(e / 30) % 12, (i === 0 || i > 12) && (i = 12)), e >= 360 && (e = 0), {
          degrees: e,
          hour: i,
          addDegrees: 30
        };
    });
    Tt(this, "_makeInnerHoursDegrees", (t, e) => (t < 0 ? (e = Math.round(360 + t / 30) % 24, t = 360 + t) : (e = Math.round(t / 30) + 12, e === 12 && (e = "00")), {
      degrees: t,
      hour: e,
      addDegrees: 30
    }));
    Tt(this, "_getAppendClock", (t = [], e = `[${le}]`, i) => {
      let { minTime: n, maxTime: o } = this._options;
      const { inline: r, format12: a, disablePast: l, disableFuture: c } = this._options;
      n = jt(n, l, a), o = Kt(o, c, a);
      const [d, _, f] = R(
        o,
        !1
      ), [m, g, b] = R(
        n,
        !1
      );
      !r && a && this._isInvalidTimeFormat && !this._AM.hasAttribute(B) && (p.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(B, ""));
      const T = h.findOne(e), C = 360 / t.length;
      function w(y) {
        return y * (Math.PI / 180);
      }
      if (T === null)
        return;
      const v = (T.offsetWidth - 32) / 2, E = (T.offsetHeight - 32) / 2, A = v - 4;
      setTimeout(() => {
        let y;
        a && (y = h.findOne(
          `${Ui}[${B}]`
        ).textContent), this._handleDisablingTipsMinTime(
          y,
          b,
          g,
          m
        ), this._handleDisablingTipsMaxTime(
          y,
          f,
          _,
          d
        );
      }, 0), [...t].forEach((y, S) => {
        const O = w(S * C), k = M("span"), D = M("span");
        D.innerHTML = y, p.addClass(k, this._classes.tips), k.setAttribute(i, "");
        const x = k.offsetWidth, $ = k.offsetHeight;
        return p.addStyle(k, {
          left: `${v + Math.sin(O) * A - x}px`,
          bottom: `${E + Math.cos(O) * A - $}px`
        }), t.includes("05") && k.setAttribute(X, ""), t.includes("13") ? D.setAttribute(Gi, "") : D.setAttribute(Xi, ""), k.appendChild(D), T.appendChild(k);
      });
    });
    this._element = t, this._element && I.setData(t, _s, this), this._document = document, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._currentTime = null, this._toggleButtonId = Ot("timepicker-toggle-"), this.hoursArray = [
      "12",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "10",
      "11"
    ], this.innerHours = [
      "00",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "20",
      "21",
      "22",
      "23"
    ], this.minutesArray = [
      "00",
      "05",
      "10",
      "15",
      "20",
      "25",
      "30",
      "35",
      "40",
      "45",
      "50",
      "55"
    ], this.input = h.findOne("input", this._element), this.dataWithIcon = t.dataset.withIcon, this.dataToggle = t.dataset.toggle, this.customIcon = h.findOne(
      o_,
      this._element
    ), this._checkToggleButton(), this.inputFormatShow = h.findOne(
      n_,
      this._element
    ), this.inputFormat = this.inputFormatShow === null ? "" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = h.findOne(
      Sr,
      this._element
    ), this.toggleElement = Object.values(
      t.querySelector(Sr).dataset
    )[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._inputValue = this._options.defaultTime !== "" ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = wr(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = fe(this._inputValue)), this._options.readOnly && this.input.setAttribute(d_, !0), this.inputFormat === "true" && this.inputFormat !== "" && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = wr(this._inputValue)), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = { degrees: null }, this._scrollBar = new pi();
  }
  // Getters
  static get NAME() {
    return hi;
  }
  // Public
  init() {
    const { format12: t, format24: e, enableValidation: i } = this._options;
    let n, o, r;
    if (this.input.setAttribute(h_, ""), this._currentTime !== void 0) {
      const { hours: a, minutes: l, amOrPm: c } = this._currentTime;
      n = Number(a) < 10 ? 0 : "", o = `${n}${Number(a)}:${l}`, r = c, t ? this.input.value = `${o} ${r}` : e && (this.input.value = `${o}`);
    } else
      n = "", o = "", r = "", this.input.value = "";
    this.input.value.length > 0 && this.input.value !== "" && (this.input.setAttribute(B, ""), u.trigger(this.input, "input")), !(this._options === null && this._element === null) && (i && this._getValidate("keydown change blur focus"), this._handleOpen(), this._listenToToggleKeydown());
  }
  dispose() {
    this._removeModal(), this._element !== null && I.removeData(this._element, _s), setTimeout(() => {
      this._element = null, this._options = null, this.input = null, this._focusTrap = null;
    }, 350), u.off(
      this._document,
      "click",
      `[data-te-toggle='${this.toggleElement}']`
    ), u.off(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`
    );
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  // private
  _checkToggleButton() {
    this.customIcon === null && (this.dataWithIcon !== void 0 && (this._options.withIcon = null, this.dataWithIcon === "true" && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options));
  }
  _appendToggleButton() {
    const t = qf(
      this._options,
      this._toggleButtonId,
      this._classes
    );
    this.input.insertAdjacentHTML("afterend", t);
  }
  _getDomElements() {
    this._hour = h.findOne(`[${zi}]`), this._minutes = h.findOne(`[${En}]`), this._AM = h.findOne(i_), this._PM = h.findOne(s_), this._wrapper = h.findOne(`[${vn}]`), this._modal = h.findOne(`[${jr}]`), this._hand = h.findOne(`[${Tn}]`), this._circle = h.findOne(`[${Cn}]`), this._clock = h.findOne(`[${le}]`), this._clockInner = h.findOne(
      `[${Je}]`
    );
  }
  _handlerMaxMinHoursOptions(t, e, i, n, o, r) {
    if (!e && !i)
      return !0;
    const { format24: a, format12: l, disablePast: c, disableFuture: d } = this._options, { _isAmEnabled: _, _isPmEnabled: f } = this, m = r.keyCode, g = r.target.hasAttribute(Je) || r.target.hasAttribute(at) || r.target.hasAttribute(Gi);
    i = jt(i, c, l), e = Kt(e, d, l), typeof e != "number" && (e = R(e, !1)[0]);
    const b = e !== "" ? e * 30 : "", T = i !== "" ? i * 30 : "";
    t < 0 && (t = 360 + t), t = t === 360 ? 0 : t;
    const C = () => {
      const S = document.querySelectorAll(
        `[${Xi}]`
      ), O = document.querySelectorAll(
        `[${Gi}]`
      ), k = e_(this._hour.innerText);
      let D, x, $;
      return m === rt ? x = 1 : m === U && (x = -1), k === 12 && m === rt ? $ = 1 : k === 0 && m === rt ? $ = 13 : k === 0 && m === U ? $ = 23 : k === 13 && m === U ? $ = 0 : k === 1 && m === U ? $ = 12 : $ = k + x, S.forEach((P) => {
        Number(P.textContent) === $ && (D = P);
      }), O.forEach((P) => {
        Number(P.textContent) === $ && (D = P);
      }), !D.parentElement.hasAttribute(Bt);
    }, w = () => {
      const S = i !== "" && i > 12 ? (i - 12) * 30 : "", O = e !== "" && e > 12 ? (e - 12) * 30 : "";
      if (!(S && t < S || O && t > O || e && e < 12))
        return !0;
    };
    if (a && r.type !== "keydown" && g)
      return w();
    if (r.type === "keydown")
      return C();
    const v = !o || o === "PM" && f || i !== "" && o === "AM" && _, E = !n || n === "PM" && f || e !== "" && n === "AM" && _, A = () => {
      const S = T === 360 && l ? 0 : T;
      if (i) {
        if (o === "PM" && _ || v && t < S)
          return;
      } else
        return !0;
      return !0;
    }, y = () => {
      const S = b === 360 && l ? 0 : b;
      if (e) {
        if (n === "AM" && f || E && t > S)
          return;
      } else
        return !0;
      return !0;
    };
    return A() && y();
  }
  _handleKeyboard() {
    u.on(this._document, ji, "", (t) => {
      let e, i, n;
      const {
        increment: o,
        maxTime: r,
        minTime: a,
        format12: l,
        disablePast: c,
        disableFuture: d
      } = this._options;
      let _ = R(a, !1)[0], f = R(r, !1)[0];
      const m = R(a, !1)[2], g = R(r, !1)[2];
      _ = jt(_, c, l), f = Kt(f, d, l), typeof f != "number" && (f = R(f, !1)[0]);
      const b = h.findOne(`[${X}]`) === null, T = h.findOne(`[${at}]`) !== null, C = Number(this._hand.style.transform.replace(/[^\d-]/g, "")), w = h.find(
        `[${X}]`,
        this._modal
      ), v = h.find(
        `[${K}]`,
        this._modal
      ), E = h.find(
        `[${at}]`,
        this._modal
      );
      let A = this._makeHourDegrees(t.target, C, e).hour;
      const { degrees: y, addDegrees: S } = this._makeHourDegrees(
        t.target,
        C,
        e
      );
      let { minute: O, degrees: k } = this._makeMinutesDegrees(C, i);
      const D = this._makeMinutesDegrees(
        C,
        i
      ).addDegrees;
      let { hour: x } = this._makeInnerHoursDegrees(
        C,
        n
      );
      if (t.keyCode === Is) {
        const $ = h.findOne(
          `[${fn}]`,
          this._modal
        );
        u.trigger($, "click");
      } else if (b) {
        if (T && (t.keyCode === $e && (this._isInner = !1, p.addStyle(this._hand, {
          height: "calc(40% + 1px)"
        }), this._hour.textContent = this._setHourOrMinute(
          A > 12 ? 1 : A
        ), this._toggleClassActive(this.hoursArray, this._hour, v), this._toggleClassActive(this.innerHours, this._hour, E)), t.keyCode === Ie && (this._isInner = !0, p.addStyle(this._hand, {
          height: "21.5%"
        }), this._hour.textContent = this._setHourOrMinute(
          x >= 24 || x === "00" ? 0 : x
        ), this._toggleClassActive(this.innerHours, this._hour, E), this._toggleClassActive(
          this.hoursArray,
          this._hour - 1,
          v
        ))), t.keyCode === rt) {
          if (!this._handlerMaxMinHoursOptions(
            y + 30,
            f,
            _,
            g,
            m,
            t
          ))
            return;
          p.addStyle(this._hand, {
            transform: `rotateZ(${y + S}deg)`
          }), this._isInner ? (x += 1, x === 24 ? x = 0 : (x === 25 || x === "001") && (x = 13), this._hour.textContent = this._setHourOrMinute(x), this._toggleClassActive(this.innerHours, this._hour, E)) : (A += 1, this._hour.textContent = this._setHourOrMinute(
            A > 12 ? 1 : A
          ), this._toggleClassActive(this.hoursArray, this._hour, v));
        }
        if (t.keyCode === U) {
          if (!this._handlerMaxMinHoursOptions(
            y - 30,
            f,
            _,
            g,
            m,
            t
          ))
            return;
          p.addStyle(this._hand, {
            transform: `rotateZ(${y - S}deg)`
          }), this._isInner ? (x -= 1, x === 12 ? x = 0 : x === -1 && (x = 23), this._hour.textContent = this._setHourOrMinute(x), this._toggleClassActive(this.innerHours, this._hour, E)) : (A -= 1, this._hour.textContent = this._setHourOrMinute(
            A === 0 ? 12 : A
          ), this._toggleClassActive(this.hoursArray, this._hour, v));
        }
      } else
        t.keyCode === rt && (k += D, p.addStyle(this._hand, {
          transform: `rotateZ(${k}deg)`
        }), O += 1, o && (O += 4, O === "0014" && (O = 5)), this._minutes.textContent = this._setHourOrMinute(
          O > 59 ? 0 : O
        ), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          w
        ), this._toggleBackgroundColorCircle(
          `[${X}]`
        )), t.keyCode === U && (k -= D, p.addStyle(this._hand, {
          transform: `rotateZ(${k}deg)`
        }), o ? O -= 5 : O -= 1, O === -1 ? O = 59 : O === -5 && (O = 55), this._minutes.textContent = this._setHourOrMinute(O), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          w
        ), this._toggleBackgroundColorCircle(
          `[${X}]`
        ));
    });
  }
  _setActiveClassToTipsOnOpen(t, ...e) {
    if (!this._isInvalidTimeFormat)
      if (this._options.format24) {
        const i = h.find(
          `[${K}]`,
          this._modal
        ), n = h.find(
          `[${at}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t), this._addActiveClassToTip(n, t);
      } else {
        [...e].filter((n) => (n === "PM" ? (p.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(B, "")) : n === "AM" ? (p.addClass(this._AM, this._classes.opacity), this._AM.setAttribute(B, "")) : (p.removeClass(this._AM, this._classes.opacity), p.removeClass(this._PM, this._classes.opacity), this._AM.removeAttribute(B), this._PM.removeAttribute(B)), n));
        const i = h.find(
          `[${K}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t);
      }
  }
  _setTipsAndTimesDependOnInputValue(t, e) {
    const { inline: i, format12: n } = this._options;
    if (this._isInvalidTimeFormat)
      this._hour.textContent = "12", this._minutes.textContent = "00", i || p.addStyle(this._hand, {
        transform: "rotateZ(0deg)"
      }), n && (p.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(B, ""));
    else {
      const o = t > 12 ? t * 30 - 360 : t * 30;
      this._hour.textContent = t, this._minutes.textContent = e, i || (p.addStyle(this._hand, {
        transform: `rotateZ(${o}deg)`
      }), p.addStyle(this._circle, {
        backgroundColor: "#1976d2"
      }), (Number(t) > 12 || t === "00") && p.addStyle(this._hand, {
        height: "21.5%"
      }));
    }
  }
  _listenToToggleKeydown() {
    u.on(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`,
      (t) => {
        t.keyCode === lt && (t.preventDefault(), u.trigger(this.elementToggle, "click"));
      }
    );
  }
  _handleOpen() {
    const t = this._getContainer();
    ee.on(
      this._element,
      "click",
      `[data-te-toggle='${this.toggleElement}']`,
      (e) => {
        if (this._options === null)
          return;
        const i = p.getDataAttribute(this.input, "toggle") !== null ? 200 : 0;
        setTimeout(() => {
          p.addStyle(this.elementToggle, {
            pointerEvents: "none"
          }), this.elementToggle.blur();
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const { modalID: o, inline: r, format12: a } = this._options, [l, c, d] = n, _ = M("div");
          if ((Number(l) > 12 || l === "00") && (this._isInner = !0), this.input.blur(), e.target.blur(), _.innerHTML = Gf(this._options, this._classes), p.addClass(_, this._classes.modal), _.setAttribute(jr, ""), _.setAttribute("role", "dialog"), _.setAttribute("tabIndex", "-1"), _.setAttribute("id", o), r ? (this._popper = je(this.input, _, {
            placement: "bottom-start"
          }), t.appendChild(_)) : (t.appendChild(_), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : p.addClass(this._wrapper, this._classes.opacity), this._setActiveClassToTipsOnOpen(l, c, d), this._appendTimes(), this._setActiveClassToTipsOnOpen(l, c, d), this._setTipsAndTimesDependOnInputValue(l, c), this.input.value === "") {
            const f = h.find(
              `[${K}]`,
              this._modal
            );
            a && (p.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(B, "")), this._hour.textContent = "12", this._minutes.textContent = "00", this._addActiveClassToTip(
              f,
              Number(this._hour.textContent)
            );
          }
          if (this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), r)
            this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks();
          else {
            this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard();
            const f = document.querySelector(
              `${Ki}[${B}]`
            );
            p.addClass(f, this._classes.opacity), p.addStyle(this._hour, {
              pointerEvents: "none"
            }), p.addStyle(this._minutes, {
              pointerEvents: ""
            });
          }
          this._focusTrap = new bi(this._wrapper, {
            event: "keydown",
            condition: ({ key: f }) => f === "Tab"
          }), this._focusTrap.trap();
        }, i);
      }
    );
  }
  _handleInlineClicks() {
    let t, e;
    const i = (f) => {
      let m = f;
      return m > 59 ? m = 0 : m < 0 && (m = 59), m;
    }, n = (f) => {
      let m = f;
      return this._options.format24 ? (m > 24 ? m = 1 : m < 0 && (m = 23), m > 23 && (m = 0)) : (m > 12 ? m = 1 : m < 1 && (m = 12), m > 12 && (m = 1)), m;
    }, o = (f) => {
      const m = n(f);
      this._hour.textContent = this._setHourOrMinute(m);
    }, r = (f) => {
      const m = i(f);
      this._minutes.textContent = this._setHourOrMinute(m);
    }, a = () => {
      t += 1, o(t);
    }, l = () => {
      e += 1, r(e);
    }, c = () => {
      t -= 1, o(t);
    }, d = () => {
      e -= 1, r(e);
    }, _ = (f) => {
      clearInterval(this._interval), this._interval = setInterval(f, 100);
    };
    ee.on(
      this._modal,
      "click mousedown mouseup touchstart touchend contextmenu",
      `[${mn}], [${gn}]`,
      (f) => {
        t = Number(this._hour.textContent), e = Number(this._minutes.textContent);
        const { target: m, type: g } = f, b = g === "mousedown" || g === "touchstart";
        m.closest(`[${mn}]`) ? m.closest(`[${mn}]`).parentNode.hasAttribute(Vr) ? b ? _(a) : g === "mouseup" || g === "touchend" || g === "contextmenu" ? clearInterval(this._interval) : a() : b ? _(l) : g === "mouseup" || g === "touchend" || g === "contextmenu" ? clearInterval(this._interval) : l() : m.closest(`[${gn}]`) && (m.closest(`[${gn}]`).parentNode.hasAttribute(Vr) ? b ? _(c) : g === "mouseup" || g === "touchend" ? clearInterval(this._interval) : c() : b ? _(d) : g === "mouseup" || g === "touchend" ? clearInterval(this._interval) : d());
      }
    ), u.on(window, ji, (f) => {
      const m = f.code, g = document.activeElement.hasAttribute(zi), b = document.activeElement.hasAttribute(
        En
      ), T = document.activeElement === document.body;
      switch (t = Number(this._hour.textContent), e = Number(this._minutes.textContent), m) {
        case "ArrowUp":
          f.preventDefault(), T || g ? (this._hour.focus(), a()) : b && l();
          break;
        case "ArrowDown":
          f.preventDefault(), T || g ? (this._hour.focus(), c()) : b && d();
          break;
      }
    });
  }
  _handleClose() {
    u.on(
      this._modal,
      "click",
      `[${vn}], [${fn}], [${Br}]`,
      ({ target: t }) => {
        const { closeModalOnBackdropClick: e } = this._options, i = () => {
          var n;
          p.addStyle(this.elementToggle, {
            pointerEvents: "auto"
          }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), (n = this._focusTrap) == null || n.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus();
        };
        if (t.hasAttribute(Br)) {
          this._toggleAmPm("PM"), this.input.value = "", this.input.removeAttribute(B);
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const [o, r, a] = n;
          this._setTipsAndTimesDependOnInputValue("12", "00"), this._setActiveClassToTipsOnOpen(o, r, a), this._hour.click();
        } else
          (t.hasAttribute(fn) || t.hasAttribute(_n) || t.hasAttribute(vn) && e) && i();
      }
    );
  }
  showValueInput() {
    return this.input.value;
  }
  _handleOkButton() {
    ee.on(
      this._modal,
      "click",
      `[${_n}]`,
      () => {
        let { maxTime: t, minTime: e } = this._options;
        const {
          format12: i,
          format24: n,
          readOnly: o,
          focusInputAfterApprove: r,
          disablePast: a,
          disableFuture: l
        } = this._options, c = this._document.querySelector(
          `${Ui}[${B}]`
        ), d = `${this._hour.textContent}:${this._minutes.textContent}`, _ = Number(this._hour.textContent), f = _ === 12 && i ? 0 : _, m = Number(this._minutes.textContent);
        e = jt(e, a, i), t = Kt(t, l, i);
        let [g, b, T] = R(
          t,
          !1
        ), [C, w, v] = R(
          e,
          !1
        );
        C = C === "12" && i ? "00" : C, g = g === "12" && i ? "00" : g;
        const E = f < Number(C), A = f > Number(g);
        let y = !0;
        c && (y = T === c.textContent);
        let S = !0;
        c && (S = v === c.textContent);
        const O = m > b && f === Number(g), k = m < w && f === Number(C);
        if (this.input.setAttribute(B, ""), p.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), t !== "") {
          if (y && (A || O))
            return;
          if (T === "AM" && c.textContent === "PM")
            return;
        }
        e !== "" && (S && (E || k) || v === "PM" && c.textContent === "AM") || Zf(
          this._options,
          this.input,
          this._hour.textContent
        ) !== void 0 && (this._isInvalidTimeFormat && this.input.removeAttribute(bn), !o && r && this.input.focus(), p.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), n ? this.input.value = d : c === null ? this.input.value = `${d} PM` : this.input.value = `${d} ${c.textContent}`, this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), u.trigger(this.input, "input.te.timepicker"), u.trigger(this.input, "input"));
      }
    );
  }
  _handleHoverInlineBtn() {
    ee.on(
      this._modal,
      "mouseover mouseleave",
      `[${c_}]`,
      ({ type: t, target: e }) => {
        const i = h.find(
          `[${a_}]`,
          this._modal
        ), n = h.find(
          `[${l_}]`,
          this._modal
        ), o = (l, c) => l.forEach((d) => {
          if (c) {
            p.addClass(d, this._classes.opacity), d.setAttribute(B, "");
            return;
          }
          p.removeClass(d, this._classes.opacity), d.removeAttribute(B);
        }), a = e.hasAttribute(zi) ? i : n;
        o(a, t === "mouseover");
      }
    );
  }
  _handleDocumentClickInline() {
    u.on(document, Dr, ({ target: t }) => {
      if (this._modal && !this._modal.contains(t) && !t.hasAttribute(r_)) {
        if (clearInterval(this._interval), p.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), this._removeModal(), !this._animations)
          return;
        this._toggleBackdropAnimation(!0);
      }
    });
  }
  _handleSwitchHourMinute() {
    Qf(
      "click",
      Ki,
      this._classes
    ), u.on(
      this._modal,
      "click",
      Ki,
      () => {
        const { format24: t } = this._options, e = h.find(
          Ki,
          this._modal
        ), i = h.find(
          `[${X}]`,
          this._modal
        ), n = h.find(
          `[${K}]`,
          this._modal
        ), o = h.find(
          `[${at}]`,
          this._modal
        ), r = Number(this._hour.textContent), a = Number(this._minutes.textContent), l = (c, d) => {
          n.forEach((f) => f.remove()), i.forEach((f) => f.remove()), p.addClass(this._hand, this._classes.transform), setTimeout(() => {
            p.removeClass(this._hand, this._classes.transform);
          }, 401), this._getAppendClock(c, `[${le}]`, d);
          const _ = () => {
            const f = h.find(
              `[${K}]`,
              this._modal
            ), m = h.find(
              `[${X}]`,
              this._modal
            );
            this._addActiveClassToTip(f, r), this._addActiveClassToTip(m, a);
          };
          if (!t)
            setTimeout(() => {
              _();
            }, 401);
          else {
            const f = h.find(
              `[${at}]`,
              this._modal
            );
            setTimeout(() => {
              this._addActiveClassToTip(f, r), _();
            }, 401);
          }
        };
        e.forEach((c) => {
          c.hasAttribute(B) && (c.hasAttribute(En) ? (p.addClass(this._hand, this._classes.transform), p.addStyle(this._hand, {
            transform: `rotateZ(${this._minutes.textContent * 6}deg)`,
            height: "calc(40% + 1px)"
          }), t && o.length > 0 && o.forEach((d) => d.remove()), l(
            this.minutesArray,
            X
          ), this._hour.style.pointerEvents = "", this._minutes.style.pointerEvents = "none") : c.hasAttribute(zi) && (p.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30}deg)`
          }), Number(this._hour.textContent) > 12 ? (p.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,
            height: "21.5%"
          }), Number(this._hour.textContent) > 12 && p.addStyle(this._hand, {
            height: "21.5%"
          })) : p.addStyle(this._hand, {
            height: "calc(40% + 1px)"
          }), t && this._getAppendClock(
            this.innerHours,
            `[${Je}]`,
            at
          ), o.length > 0 && o.forEach((d) => d.remove()), l(
            this.hoursArray,
            K
          ), p.addStyle(this._hour, {
            pointerEvents: "none"
          }), p.addStyle(this._minutes, {
            pointerEvents: ""
          })));
        });
      }
    );
  }
  _handleDisablingTipsMaxTime(t, e, i, n) {
    if (!this._options.maxTime && !this._options.disableFuture)
      return;
    const o = h.find(
      `[${K}]`
    ), r = h.find(
      `[${at}]`
    ), a = h.find(
      `[${X}]`
    );
    if (!e || e === t) {
      Or(
        r,
        n,
        this._classes,
        this._options.format12
      ), Or(
        o,
        n,
        this._classes,
        this._options.format12
      ), Jf(
        a,
        i,
        n,
        this._hour.textContent,
        this._classes,
        this._options.format12
      );
      return;
    }
    e === "AM" && t === "PM" && (o.forEach((l) => {
      p.addClass(l, this._classes.tipsDisabled), l.setAttribute(Bt, "");
    }), a.forEach((l) => {
      p.addClass(l, this._classes.tipsDisabled), l.setAttribute(Bt, "");
    }));
  }
  _handleDisablingTipsMinTime(t, e, i, n) {
    if (!this._options.minTime && !this._options.disablePast)
      return;
    const o = h.find(
      `[${K}]`
    ), r = h.find(
      `[${at}]`
    ), a = h.find(
      `[${X}]`
    );
    !e || e === t ? (xr(
      o,
      n,
      this._classes,
      this._options.format12
    ), xr(
      r,
      n,
      this._classes,
      this._options.format12
    ), t_(
      a,
      i,
      n,
      this._hour.textContent,
      this._classes,
      this._options.format12
    )) : e === "PM" && t === "AM" && (o.forEach((l) => {
      p.addClass(l, this._classes.tipsDisabled), l.setAttribute(Bt, "");
    }), a.forEach((l) => {
      p.addClass(l, this._classes.tipsDisabled), l.setAttribute(Bt, "");
    }));
  }
  _handleSwitchTimeMode() {
    u.on(
      document,
      "click",
      Ui,
      ({ target: t }) => {
        let { maxTime: e, minTime: i } = this._options;
        const { disablePast: n, disableFuture: o, format12: r } = this._options;
        i = jt(i, n, r), e = Kt(e, o, r);
        const [a, l, c] = R(
          e,
          !1
        ), [d, _, f] = R(
          i,
          !1
        ), m = h.find(
          `[${K}]`
        ), g = h.find(
          `[${X}]`
        );
        (() => {
          m.forEach((T) => {
            p.removeClass(T, this._classes.tipsDisabled), T.removeAttribute(Bt);
          }), g.forEach((T) => {
            p.removeClass(T, this._classes.tipsDisabled), T.removeAttribute(Bt);
          });
        })(), this._handleDisablingTipsMinTime(
          t.textContent,
          f,
          _,
          d
        ), this._handleDisablingTipsMaxTime(
          t.textContent,
          c,
          l,
          a
        ), this._toggleAmPm(t.textContent), t.hasAttribute(B) || (h.find(
          Ui
        ).forEach((C) => {
          C.hasAttribute(B) && (p.removeClass(C, this._classes.opacity), C.removeAttribute(B));
        }), p.addClass(t, this._classes.opacity), t.setAttribute(B, ""));
      }
    );
  }
  _handleClockClick() {
    let { maxTime: t, minTime: e } = this._options;
    const { disablePast: i, disableFuture: n, format12: o } = this._options;
    e = jt(e, i, o), t = Kt(t, n, o);
    const r = R(t, !1)[2], a = R(e, !1)[2], l = R(t, !1)[0], c = R(e, !1)[0], d = h.findOne(
      `[${Fr}]`
    );
    ee.on(
      document,
      `${Ir} ${$r} ${Lr} ${Mr} ${Nr} ${Hr} ${Rr} ${Pr}`,
      "",
      (_) => {
        Yi() || _.preventDefault();
        const { type: f, target: m } = _, { closeModalOnMinutesClick: g, switchHoursToMinutesOnClick: b } = this._options, T = h.findOne(
          `[${X}]`,
          this._modal
        ) !== null, C = h.findOne(
          `[${K}]`,
          this._modal
        ) !== null, w = h.findOne(
          `[${at}]`,
          this._modal
        ) !== null, v = h.find(
          `[${X}]`,
          this._modal
        ), E = kr(_, d), A = d.offsetWidth / 2;
        let y = Math.atan2(E.y - A, E.x - A);
        if (Yi()) {
          const D = kr(_, d, !0);
          y = Math.atan2(D.y - A, D.x - A);
        }
        let S = null, O = null, k = null;
        if (f === "mousedown" || f === "mousemove" || f === "touchmove" || f === "touchstart")
          (f === "mousedown" || f === "touchstart" || f === "touchmove") && (this._hasTargetInnerClass(m) || m.hasAttribute(Fr) || m.hasAttribute(le) || m.hasAttribute(X) || m.hasAttribute(K) || m.hasAttribute(Cn) || m.hasAttribute(Tn) || m.hasAttribute(Yr) || m.hasAttribute(Xi)) && (this._isMouseMove = !0, Yi() && _.touches && (S = _.touches[0].clientX, O = _.touches[0].clientY, k = document.elementFromPoint(S, O)));
        else if (f === "mouseup" || f === "touchend") {
          if (this._isMouseMove = !1, this._hasTargetInnerClass(m) || m.hasAttribute(le) || m.hasAttribute(K) || m.hasAttribute(Cn) || m.hasAttribute(Tn) || m.hasAttribute(Yr) || m.hasAttribute(Xi)) {
            if ((C || w) && b) {
              const D = Number(this._hour.textContent) > l || Number(this._hour.textContent) < c;
              if (this._options.format24 && l !== "" && c !== "" && D)
                return;
              if (this._options.format24 && c !== "" && Number(this._hour.textContent) < c)
                return;
            }
            u.trigger(this._minutes, "click");
          }
          if (T && g) {
            const D = h.findOne(
              `[${_n}]`,
              this._modal
            );
            u.trigger(D, "click");
          }
        }
        if (T) {
          let D;
          const x = Math.trunc(y * 180 / Math.PI) + 90, { degrees: $, minute: P } = this._makeMinutesDegrees(x, D);
          if (this._handlerMaxMinMinutesOptions($, P) === void 0)
            return;
          const { degrees: tt, minute: et } = this._handlerMaxMinMinutesOptions($, P);
          if (this._isMouseMove) {
            if (p.addStyle(this._hand, {
              transform: `rotateZ(${tt}deg)`
            }), et === void 0)
              return;
            const z = () => et >= 10 || et === "00" ? et : `0${et}`;
            this._minutes.textContent = z(), this._toggleClassActive(
              this.minutesArray,
              this._minutes,
              v
            ), this._toggleBackgroundColorCircle(
              `[${X}]`
            ), this._objWithDataOnChange.degreesMinutes = tt, this._objWithDataOnChange.minutes = et;
          }
        }
        if (C || w) {
          let D, x = Math.trunc(y * 180 / Math.PI) + 90;
          if (x = Math.round(x / 30) * 30, p.addStyle(this._circle, {
            backgroundColor: "#1976d2"
          }), this._makeHourDegrees(m, x, D) === void 0)
            return;
          const $ = () => {
            if (Yi() && x && k) {
              const { degrees: P, hour: tt } = this._makeHourDegrees(k, x, D);
              return this._handleMoveHand(
                k,
                tt,
                P
              );
            } else {
              const { degrees: P, hour: tt } = this._makeHourDegrees(m, x, D);
              return this._handleMoveHand(m, tt, P);
            }
          };
          this._objWithDataOnChange.degreesHours = x, this._handlerMaxMinHoursOptions(
            x,
            l,
            c,
            r,
            a,
            _
          ) && $();
        }
        _.stopPropagation();
      }
    );
  }
  _hasTargetInnerClass(t) {
    return t.hasAttribute(Je) || t.hasAttribute(at) || t.hasAttribute(Gi);
  }
  _handleMoveHand(t, e, i) {
    const n = h.find(
      `[${K}]`,
      this._modal
    ), o = h.find(
      `[${at}]`,
      this._modal
    );
    this._isMouseMove && (this._hasTargetInnerClass(t) ? p.addStyle(this._hand, {
      height: "21.5%"
    }) : p.addStyle(this._hand, {
      height: "calc(40% + 1px)"
    }), p.addStyle(this._hand, {
      transform: `rotateZ(${i}deg)`
    }), this._hour.textContent = e >= 10 || e === "00" ? e : `0${e}`, this._toggleClassActive(this.hoursArray, this._hour, n), this._toggleClassActive(this.innerHours, this._hour, o), this._objWithDataOnChange.hour = e >= 10 || e === "00" ? e : `0${e}`);
  }
  _handlerMaxMinMinutesOptions(t, e) {
    let { maxTime: i, minTime: n } = this._options;
    const { format12: o, increment: r, disablePast: a, disableFuture: l } = this._options;
    n = jt(n, a, o), i = Kt(i, l, o);
    const c = R(i, !1)[1], d = R(n, !1)[1], _ = R(i, !1)[0], f = R(n, !1)[0], m = f === "12" && o ? "0" : f, g = _ === "12" && o ? "0" : _, b = R(i, !1)[2], T = R(n, !1)[2], C = c !== "" ? c * 6 : "", w = d !== "" ? d * 6 : "", v = Number(this._hour.textContent), E = v === 12 && o ? 0 : v;
    if (!b && !T) {
      if (i !== "" && n !== "") {
        if (Number(g) === E && t > C || Number(m) === E && t < w)
          return t;
      } else if (n !== "" && E <= Number(m)) {
        if (t <= w - 6)
          return t;
      } else if (i !== "" && E >= Number(g) && t >= C + 6)
        return t;
    } else {
      if (n !== "") {
        if (T === "PM" && this._isAmEnabled)
          return;
        if (T === "PM" && this._isPmEnabled) {
          if (E < Number(m))
            return;
          if (E <= Number(m) && t <= w - 6)
            return t;
        } else if (T === "AM" && this._isAmEnabled) {
          if (E < Number(m))
            return;
          if (E <= Number(m) && t <= w - 6)
            return t;
        }
      }
      if (i !== "") {
        if (b === "AM" && this._isPmEnabled)
          return;
        if (b === "PM" && this._isPmEnabled) {
          if (E >= Number(g) && t >= C + 6)
            return t;
        } else if (b === "AM" && this._isAmEnabled && E >= Number(g) && t >= C + 6)
          return t;
      }
    }
    return r && (t = Math.round(t / 30) * 30), t < 0 ? t = 360 + t : t >= 360 && (t = 0), {
      degrees: t,
      minute: e
    };
  }
  _removeModal() {
    this._animations ? setTimeout(() => {
      this._removeModalElements(), this._scrollBar.reset();
    }, 300) : (this._removeModalElements(), this._scrollBar.reset()), ee.off(
      this._document,
      `${Dr} ${ji} ${Ir} ${$r} ${Lr} ${Mr} ${Nr} ${Hr} ${Rr} ${Pr}`
    ), u.off(window, ji);
  }
  _removeModalElements() {
    this._modal && this._modal.remove();
  }
  _toggleBackdropAnimation(t = !1) {
    t ? this._wrapper.classList.add("animate-[fade-out_350ms_ease-in-out]") : (this._wrapper.classList.add("animate-[fade-in_350ms_ease-in-out]"), this._options.inline || p.addClass(this._clock, this._classes.clockAnimation)), setTimeout(() => {
      this._wrapper.classList.remove(
        "animate-[fade-out_350ms_ease-in-out]",
        "animate-[fade-in_350ms_ease-in-out]"
      );
    }, 351);
  }
  _addActiveClassToTip(t, e) {
    t.forEach((i) => {
      Number(i.textContent) === Number(e) && (p.addClass(i, this._classes.tipsActive), i.setAttribute(B, ""));
    });
  }
  _setHourOrMinute(t) {
    return t < 10 ? `0${t}` : t;
  }
  _appendTimes() {
    const { format24: t } = this._options;
    if (t) {
      this._getAppendClock(
        this.hoursArray,
        `[${le}]`,
        K
      ), this._getAppendClock(
        this.innerHours,
        `[${Je}]`,
        at
      );
      return;
    }
    this._getAppendClock(
      this.hoursArray,
      `[${le}]`,
      K
    );
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._element);
    return t = {
      ...p_,
      ...e,
      ...t
    }, N(hi, t, f_), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...__,
      ...e,
      ...t
    }, N(hi, t, m_), t;
  }
  _getContainer() {
    return h.findOne(this._options.container);
  }
  _getValidate(t) {
    const { invalidLabel: e, format24: i, format12: n, appendValidationInfo: o } = this._options;
    let r;
    o && (r = M("div"), r.setAttribute(Wr, ""), r.innerHTML = e), ee.on(this.input, t, ({ target: a }) => {
      if (this._options === null || this.input.value === "")
        return;
      const l = /^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/, c = /^([01]\d|2[0-3])(:[0-5]\d)$/, d = l.test(a.value);
      if (c.test(a.value) !== !0 && i || d !== !0 && n) {
        o && (this.input.setAttribute(bn, ""), this.input.parentNode.insertBefore(
          r,
          this.input.nextSibling
        )), p.addStyle(a, { marginBottom: 0 }), p.addStyle(r, { bottom: "-23px" }), this._isInvalidTimeFormat = !0;
        return;
      }
      this.input.removeAttribute(bn), this._isInvalidTimeFormat = !1;
      const f = h.findOne(
        `[${Wr}]`
      );
      f !== null && f.remove();
    });
  }
  // Static
  static getInstance(t) {
    return I.getData(t, _s);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function xt(s) {
  return getComputedStyle(s);
}
function ot(s, t) {
  for (var e in t) {
    var i = t[e];
    typeof i == "number" && (i = i + "px"), s.style[e] = i;
  }
  return s;
}
function qi(s) {
  var t = document.createElement("div");
  return t.className = s, t;
}
var Kr = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function zt(s, t) {
  if (!Kr)
    throw new Error("No element matching method supported");
  return Kr.call(s, t);
}
function Se(s) {
  s.remove ? s.remove() : s.parentNode && s.parentNode.removeChild(s);
}
function Ur(s, t) {
  return Array.prototype.filter.call(
    s.children,
    function(e) {
      return zt(e, t);
    }
  );
}
var j = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(s) {
      return "ps__thumb-" + s;
    },
    rail: function(s) {
      return "ps__rail-" + s;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(s) {
      return "ps--active-" + s;
    },
    scrolling: function(s) {
      return "ps--scrolling-" + s;
    }
  }
}, yl = { x: null, y: null };
function wl(s, t) {
  var e = s.element.classList, i = j.state.scrolling(t);
  e.contains(i) ? clearTimeout(yl[t]) : e.add(i);
}
function kl(s, t) {
  yl[t] = setTimeout(
    function() {
      return s.isAlive && s.element.classList.remove(j.state.scrolling(t));
    },
    s.settings.scrollingThreshold
  );
}
function g_(s, t) {
  wl(s, t), kl(s, t);
}
var Ei = function(t) {
  this.element = t, this.handlers = {};
}, Ol = { isEmpty: { configurable: !0 } };
Ei.prototype.bind = function(t, e) {
  typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);
};
Ei.prototype.unbind = function(t, e) {
  var i = this;
  this.handlers[t] = this.handlers[t].filter(function(n) {
    return e && n !== e ? !0 : (i.element.removeEventListener(t, n, !1), !1);
  });
};
Ei.prototype.unbindAll = function() {
  for (var t in this.handlers)
    this.unbind(t);
};
Ol.isEmpty.get = function() {
  var s = this;
  return Object.keys(this.handlers).every(
    function(t) {
      return s.handlers[t].length === 0;
    }
  );
};
Object.defineProperties(Ei.prototype, Ol);
var Ue = function() {
  this.eventElements = [];
};
Ue.prototype.eventElement = function(t) {
  var e = this.eventElements.filter(function(i) {
    return i.element === t;
  })[0];
  return e || (e = new Ei(t), this.eventElements.push(e)), e;
};
Ue.prototype.bind = function(t, e, i) {
  this.eventElement(t).bind(e, i);
};
Ue.prototype.unbind = function(t, e, i) {
  var n = this.eventElement(t);
  n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);
};
Ue.prototype.unbindAll = function() {
  this.eventElements.forEach(function(t) {
    return t.unbindAll();
  }), this.eventElements = [];
};
Ue.prototype.once = function(t, e, i) {
  var n = this.eventElement(t), o = function(r) {
    n.unbind(e, o), i(r);
  };
  n.bind(e, o);
};
function Qi(s) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(s);
  var t = document.createEvent("CustomEvent");
  return t.initCustomEvent(s, !1, !1, void 0), t;
}
function ys(s, t, e, i, n) {
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var o;
  if (t === "top")
    o = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  else if (t === "left")
    o = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  else
    throw new Error("A proper axis should be provided");
  b_(s, e, o, i, n);
}
function b_(s, t, e, i, n) {
  var o = e[0], r = e[1], a = e[2], l = e[3], c = e[4], d = e[5];
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var _ = s.element;
  s.reach[l] = null, _[a] < 1 && (s.reach[l] = "start"), _[a] > s[o] - s[r] - 1 && (s.reach[l] = "end"), t && (_.dispatchEvent(Qi("ps-scroll-" + l)), t < 0 ? _.dispatchEvent(Qi("ps-scroll-" + c)) : t > 0 && _.dispatchEvent(Qi("ps-scroll-" + d)), i && g_(s, l)), s.reach[l] && (t || n) && _.dispatchEvent(Qi("ps-" + l + "-reach-" + s.reach[l]));
}
function W(s) {
  return parseInt(s, 10) || 0;
}
function v_(s) {
  return zt(s, "input,[contenteditable]") || zt(s, "select,[contenteditable]") || zt(s, "textarea,[contenteditable]") || zt(s, "button,[contenteditable]");
}
function E_(s) {
  var t = xt(s);
  return W(t.width) + W(t.paddingLeft) + W(t.paddingRight) + W(t.borderLeftWidth) + W(t.borderRightWidth);
}
var ke = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function Mt(s) {
  var t = s.element, e = Math.floor(t.scrollTop), i = t.getBoundingClientRect();
  s.containerWidth = Math.round(i.width), s.containerHeight = Math.round(i.height), s.contentWidth = t.scrollWidth, s.contentHeight = t.scrollHeight, t.contains(s.scrollbarXRail) || (Ur(t, j.element.rail("x")).forEach(
    function(n) {
      return Se(n);
    }
  ), t.appendChild(s.scrollbarXRail)), t.contains(s.scrollbarYRail) || (Ur(t, j.element.rail("y")).forEach(
    function(n) {
      return Se(n);
    }
  ), t.appendChild(s.scrollbarYRail)), !s.settings.suppressScrollX && s.containerWidth + s.settings.scrollXMarginOffset < s.contentWidth ? (s.scrollbarXActive = !0, s.railXWidth = s.containerWidth - s.railXMarginWidth, s.railXRatio = s.containerWidth / s.railXWidth, s.scrollbarXWidth = zr(
    s,
    W(s.railXWidth * s.containerWidth / s.contentWidth)
  ), s.scrollbarXLeft = W(
    (s.negativeScrollAdjustment + t.scrollLeft) * (s.railXWidth - s.scrollbarXWidth) / (s.contentWidth - s.containerWidth)
  )) : s.scrollbarXActive = !1, !s.settings.suppressScrollY && s.containerHeight + s.settings.scrollYMarginOffset < s.contentHeight ? (s.scrollbarYActive = !0, s.railYHeight = s.containerHeight - s.railYMarginHeight, s.railYRatio = s.containerHeight / s.railYHeight, s.scrollbarYHeight = zr(
    s,
    W(s.railYHeight * s.containerHeight / s.contentHeight)
  ), s.scrollbarYTop = W(
    e * (s.railYHeight - s.scrollbarYHeight) / (s.contentHeight - s.containerHeight)
  )) : s.scrollbarYActive = !1, s.scrollbarXLeft >= s.railXWidth - s.scrollbarXWidth && (s.scrollbarXLeft = s.railXWidth - s.scrollbarXWidth), s.scrollbarYTop >= s.railYHeight - s.scrollbarYHeight && (s.scrollbarYTop = s.railYHeight - s.scrollbarYHeight), T_(t, s), s.scrollbarXActive ? t.classList.add(j.state.active("x")) : (t.classList.remove(j.state.active("x")), s.scrollbarXWidth = 0, s.scrollbarXLeft = 0, t.scrollLeft = s.isRtl === !0 ? s.contentWidth : 0), s.scrollbarYActive ? t.classList.add(j.state.active("y")) : (t.classList.remove(j.state.active("y")), s.scrollbarYHeight = 0, s.scrollbarYTop = 0, t.scrollTop = 0);
}
function zr(s, t) {
  return s.settings.minScrollbarLength && (t = Math.max(t, s.settings.minScrollbarLength)), s.settings.maxScrollbarLength && (t = Math.min(t, s.settings.maxScrollbarLength)), t;
}
function T_(s, t) {
  var e = { width: t.railXWidth }, i = Math.floor(s.scrollTop);
  t.isRtl ? e.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth - t.contentWidth : e.left = s.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - i : e.top = t.scrollbarXTop + i, ot(t.scrollbarXRail, e);
  var n = { top: i, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + s.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - s.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + s.scrollLeft, ot(t.scrollbarYRail, n), ot(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), ot(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function C_(s) {
  s.element, s.event.bind(s.scrollbarY, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarYRail, "mousedown", function(t) {
    var e = t.pageY - window.pageYOffset - s.scrollbarYRail.getBoundingClientRect().top, i = e > s.scrollbarYTop ? 1 : -1;
    s.element.scrollTop += i * s.containerHeight, Mt(s), t.stopPropagation();
  }), s.event.bind(s.scrollbarX, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarXRail, "mousedown", function(t) {
    var e = t.pageX - window.pageXOffset - s.scrollbarXRail.getBoundingClientRect().left, i = e > s.scrollbarXLeft ? 1 : -1;
    s.element.scrollLeft += i * s.containerWidth, Mt(s), t.stopPropagation();
  });
}
function A_(s) {
  Xr(s, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]), Xr(s, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function Xr(s, t) {
  var e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], a = t[5], l = t[6], c = t[7], d = t[8], _ = s.element, f = null, m = null, g = null;
  function b(w) {
    w.touches && w.touches[0] && (w[n] = w.touches[0].pageY), _[l] = f + g * (w[n] - m), wl(s, c), Mt(s), w.stopPropagation(), w.type.startsWith("touch") && w.changedTouches.length > 1 && w.preventDefault();
  }
  function T() {
    kl(s, c), s[d].classList.remove(j.state.clicking), s.event.unbind(s.ownerDocument, "mousemove", b);
  }
  function C(w, v) {
    f = _[l], v && w.touches && (w[n] = w.touches[0].pageY), m = w[n], g = (s[i] - s[e]) / (s[o] - s[a]), v ? s.event.bind(s.ownerDocument, "touchmove", b) : (s.event.bind(s.ownerDocument, "mousemove", b), s.event.once(s.ownerDocument, "mouseup", T), w.preventDefault()), s[d].classList.add(j.state.clicking), w.stopPropagation();
  }
  s.event.bind(s[r], "mousedown", function(w) {
    C(w);
  }), s.event.bind(s[r], "touchstart", function(w) {
    C(w, !0);
  });
}
function y_(s) {
  var t = s.element, e = function() {
    return zt(t, ":hover");
  }, i = function() {
    return zt(s.scrollbarX, ":focus") || zt(s.scrollbarY, ":focus");
  };
  function n(o, r) {
    var a = Math.floor(t.scrollTop);
    if (o === 0) {
      if (!s.scrollbarYActive)
        return !1;
      if (a === 0 && r > 0 || a >= s.contentHeight - s.containerHeight && r < 0)
        return !s.settings.wheelPropagation;
    }
    var l = t.scrollLeft;
    if (r === 0) {
      if (!s.scrollbarXActive)
        return !1;
      if (l === 0 && o < 0 || l >= s.contentWidth - s.containerWidth && o > 0)
        return !s.settings.wheelPropagation;
    }
    return !0;
  }
  s.event.bind(s.ownerDocument, "keydown", function(o) {
    if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !i())) {
      var r = document.activeElement ? document.activeElement : s.ownerDocument.activeElement;
      if (r) {
        if (r.tagName === "IFRAME")
          r = r.contentDocument.activeElement;
        else
          for (; r.shadowRoot; )
            r = r.shadowRoot.activeElement;
        if (v_(r))
          return;
      }
      var a = 0, l = 0;
      switch (o.which) {
        case 37:
          o.metaKey ? a = -s.contentWidth : o.altKey ? a = -s.containerWidth : a = -30;
          break;
        case 38:
          o.metaKey ? l = s.contentHeight : o.altKey ? l = s.containerHeight : l = 30;
          break;
        case 39:
          o.metaKey ? a = s.contentWidth : o.altKey ? a = s.containerWidth : a = 30;
          break;
        case 40:
          o.metaKey ? l = -s.contentHeight : o.altKey ? l = -s.containerHeight : l = -30;
          break;
        case 32:
          o.shiftKey ? l = s.containerHeight : l = -s.containerHeight;
          break;
        case 33:
          l = s.containerHeight;
          break;
        case 34:
          l = -s.containerHeight;
          break;
        case 36:
          l = s.contentHeight;
          break;
        case 35:
          l = -s.contentHeight;
          break;
        default:
          return;
      }
      s.settings.suppressScrollX && a !== 0 || s.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, Mt(s), n(a, l) && o.preventDefault());
    }
  });
}
function w_(s) {
  var t = s.element;
  function e(r, a) {
    var l = Math.floor(t.scrollTop), c = t.scrollTop === 0, d = l + t.offsetHeight === t.scrollHeight, _ = t.scrollLeft === 0, f = t.scrollLeft + t.offsetWidth === t.scrollWidth, m;
    return Math.abs(a) > Math.abs(r) ? m = c || d : m = _ || f, m ? !s.settings.wheelPropagation : !0;
  }
  function i(r) {
    var a = r.deltaX, l = -1 * r.deltaY;
    return (typeof a > "u" || typeof l > "u") && (a = -1 * r.wheelDeltaX / 6, l = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = r.wheelDelta), r.shiftKey ? [-l, -a] : [a, l];
  }
  function n(r, a, l) {
    if (!ke.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(r))
      return !1;
    for (var c = r; c && c !== t; ) {
      if (c.classList.contains(j.element.consuming))
        return !0;
      var d = xt(c);
      if (l && d.overflowY.match(/(scroll|auto)/)) {
        var _ = c.scrollHeight - c.clientHeight;
        if (_ > 0 && (c.scrollTop > 0 && l < 0 || c.scrollTop < _ && l > 0))
          return !0;
      }
      if (a && d.overflowX.match(/(scroll|auto)/)) {
        var f = c.scrollWidth - c.clientWidth;
        if (f > 0 && (c.scrollLeft > 0 && a < 0 || c.scrollLeft < f && a > 0))
          return !0;
      }
      c = c.parentNode;
    }
    return !1;
  }
  function o(r) {
    var a = i(r), l = a[0], c = a[1];
    if (!n(r.target, l, c)) {
      var d = !1;
      s.settings.useBothWheelAxes ? s.scrollbarYActive && !s.scrollbarXActive ? (c ? t.scrollTop -= c * s.settings.wheelSpeed : t.scrollTop += l * s.settings.wheelSpeed, d = !0) : s.scrollbarXActive && !s.scrollbarYActive && (l ? t.scrollLeft += l * s.settings.wheelSpeed : t.scrollLeft -= c * s.settings.wheelSpeed, d = !0) : (t.scrollTop -= c * s.settings.wheelSpeed, t.scrollLeft += l * s.settings.wheelSpeed), Mt(s), d = d || e(l, c), d && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? s.event.bind(t, "wheel", o) : typeof window.onmousewheel < "u" && s.event.bind(t, "mousewheel", o);
}
function k_(s) {
  if (!ke.supportsTouch && !ke.supportsIePointer)
    return;
  var t = s.element;
  function e(g, b) {
    var T = Math.floor(t.scrollTop), C = t.scrollLeft, w = Math.abs(g), v = Math.abs(b);
    if (v > w) {
      if (b < 0 && T === s.contentHeight - s.containerHeight || b > 0 && T === 0)
        return window.scrollY === 0 && b > 0 && ke.isChrome;
    } else if (w > v && (g < 0 && C === s.contentWidth - s.containerWidth || g > 0 && C === 0))
      return !0;
    return !0;
  }
  function i(g, b) {
    t.scrollTop -= b, t.scrollLeft -= g, Mt(s);
  }
  var n = {}, o = 0, r = {}, a = null;
  function l(g) {
    return g.targetTouches ? g.targetTouches[0] : g;
  }
  function c(g) {
    return g.pointerType && g.pointerType === "pen" && g.buttons === 0 ? !1 : !!(g.targetTouches && g.targetTouches.length === 1 || g.pointerType && g.pointerType !== "mouse" && g.pointerType !== g.MSPOINTER_TYPE_MOUSE);
  }
  function d(g) {
    if (c(g)) {
      var b = l(g);
      n.pageX = b.pageX, n.pageY = b.pageY, o = (/* @__PURE__ */ new Date()).getTime(), a !== null && clearInterval(a);
    }
  }
  function _(g, b, T) {
    if (!t.contains(g))
      return !1;
    for (var C = g; C && C !== t; ) {
      if (C.classList.contains(j.element.consuming))
        return !0;
      var w = xt(C);
      if (T && w.overflowY.match(/(scroll|auto)/)) {
        var v = C.scrollHeight - C.clientHeight;
        if (v > 0 && (C.scrollTop > 0 && T < 0 || C.scrollTop < v && T > 0))
          return !0;
      }
      if (b && w.overflowX.match(/(scroll|auto)/)) {
        var E = C.scrollWidth - C.clientWidth;
        if (E > 0 && (C.scrollLeft > 0 && b < 0 || C.scrollLeft < E && b > 0))
          return !0;
      }
      C = C.parentNode;
    }
    return !1;
  }
  function f(g) {
    if (c(g)) {
      var b = l(g), T = { pageX: b.pageX, pageY: b.pageY }, C = T.pageX - n.pageX, w = T.pageY - n.pageY;
      if (_(g.target, C, w))
        return;
      i(C, w), n = T;
      var v = (/* @__PURE__ */ new Date()).getTime(), E = v - o;
      E > 0 && (r.x = C / E, r.y = w / E, o = v), e(C, w) && g.preventDefault();
    }
  }
  function m() {
    s.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {
      if (s.isInitialized) {
        clearInterval(a);
        return;
      }
      if (!r.x && !r.y) {
        clearInterval(a);
        return;
      }
      if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {
        clearInterval(a);
        return;
      }
      if (!s.element) {
        clearInterval(a);
        return;
      }
      i(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;
    }, 10));
  }
  ke.supportsTouch ? (s.event.bind(t, "touchstart", d), s.event.bind(t, "touchmove", f), s.event.bind(t, "touchend", m)) : ke.supportsIePointer && (window.PointerEvent ? (s.event.bind(t, "pointerdown", d), s.event.bind(t, "pointermove", f), s.event.bind(t, "pointerup", m)) : window.MSPointerEvent && (s.event.bind(t, "MSPointerDown", d), s.event.bind(t, "MSPointerMove", f), s.event.bind(t, "MSPointerUp", m)));
}
var O_ = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, x_ = {
  "click-rail": C_,
  "drag-thumb": A_,
  keyboard: y_,
  wheel: w_,
  touch: k_
}, Ti = function(t, e) {
  var i = this;
  if (e === void 0 && (e = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = t, t.classList.add(j.main), this.settings = O_();
  for (var n in e)
    this.settings[n] = e[n];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var o = function() {
    return t.classList.add(j.state.focus);
  }, r = function() {
    return t.classList.remove(j.state.focus);
  };
  this.isRtl = xt(t).direction === "rtl", this.isRtl === !0 && t.classList.add(j.rtl), this.isNegativeScroll = function() {
    var c = t.scrollLeft, d = null;
    return t.scrollLeft = -1, d = t.scrollLeft < 0, t.scrollLeft = c, d;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new Ue(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = qi(j.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = qi(j.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", o), this.event.bind(this.scrollbarX, "blur", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var a = xt(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = W(a.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = W(a.borderLeftWidth) + W(a.borderRightWidth), ot(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = W(a.marginLeft) + W(a.marginRight), ot(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = qi(j.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = qi(j.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", o), this.event.bind(this.scrollbarY, "blur", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var l = xt(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = W(l.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? E_(this.scrollbarY) : null, this.railBorderYWidth = W(l.borderTopWidth) + W(l.borderBottomWidth), ot(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = W(l.marginTop) + W(l.marginBottom), ot(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(c) {
    return x_[c](i);
  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(c) {
    return i.onScroll(c);
  }), Mt(this);
};
Ti.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ot(this.scrollbarXRail, { display: "block" }), ot(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = W(xt(this.scrollbarXRail).marginLeft) + W(xt(this.scrollbarXRail).marginRight), this.railYMarginHeight = W(xt(this.scrollbarYRail).marginTop) + W(xt(this.scrollbarYRail).marginBottom), ot(this.scrollbarXRail, { display: "none" }), ot(this.scrollbarYRail, { display: "none" }), Mt(this), ys(this, "top", 0, !1, !0), ys(this, "left", 0, !1, !0), ot(this.scrollbarXRail, { display: "" }), ot(this.scrollbarYRail, { display: "" }));
};
Ti.prototype.onScroll = function(t) {
  this.isAlive && (Mt(this), ys(this, "top", this.element.scrollTop - this.lastScrollTop), ys(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
Ti.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), Se(this.scrollbarX), Se(this.scrollbarY), Se(this.scrollbarXRail), Se(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
Ti.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(t) {
    return !t.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const S_ = {
  threshold: 10,
  direction: "all"
};
class D_ {
  constructor(t, e) {
    this._element = t, this._startPosition = null, this._options = {
      ...S_,
      ...e
    };
  }
  handleTouchStart(t) {
    this._startPosition = this._getCoordinates(t);
  }
  handleTouchMove(t) {
    if (!this._startPosition)
      return;
    const e = this._getCoordinates(t), i = {
      x: e.x - this._startPosition.x,
      y: e.y - this._startPosition.y
    }, n = this._getDirection(i);
    if (this._options.direction === "all") {
      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
        return;
      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;
      u.trigger(this._element, `swipe${r}`), u.trigger(this._element, "swipe", { direction: r }), this._startPosition = null;
      return;
    }
    const o = this._options.direction === "left" || this._options === "right" ? "x" : "y";
    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (u.trigger(this._element, `swipe${n[o].direction}`), this._startPosition = null);
  }
  handleTouchEnd() {
    this._startPosition = null;
  }
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection(t) {
    return {
      x: {
        direction: t.x < 0 ? "left" : "right",
        value: Math.abs(t.x)
      },
      y: {
        direction: t.y < 0 ? "up" : "down",
        value: Math.abs(t.y)
      }
    };
  }
}
class I_ {
  constructor(t, e = "swipe", i = {}) {
    this._element = t, this._event = e, this.swipe = new D_(t, i), this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this);
  }
  dispose() {
    this._element.removeEventListener("touchstart", this._touchStartHandler), this._element.removeEventListener("touchmove", this._touchMoveHandler), window.removeEventListener("touchend", this._touchEndHandler);
  }
  init() {
    this._element.addEventListener(
      "touchstart",
      (t) => this._handleTouchStart(t)
    ), this._element.addEventListener(
      "touchmove",
      (t) => this._handleTouchMove(t)
    ), window.addEventListener("touchend", (t) => this._handleTouchEnd(t));
  }
  _handleTouchStart(t) {
    this[this._event].handleTouchStart(t);
  }
  _handleTouchMove(t) {
    this[this._event].handleTouchMove(t);
  }
  _handleTouchEnd(t) {
    this[this._event].handleTouchEnd(t);
  }
}
const $_ = "group/ps overflow-hidden [overflow-anchor:none] [overflow-style:none] touch-none", L_ = "group/x absolute bottom-0 !top-auto h-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-x]/ps:block group-[&.ps--active-x]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none", M_ = "absolute bottom-[2px] rounded-md h-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:bg-[#999] group-hover/x:h-[11px] group-focus/x:bg-[#999] group-focus/x:h-[11px] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none", N_ = "group/y absolute right-0 !left-auto w-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-y]/ps:block group-[&.ps--active-y]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none", R_ = "absolute right-[2px] rounded-md w-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_width_.2s_ease-in-out] group-hover/y:bg-[#999] group-hover/y:w-[11px] group-focus/y:bg-[#999] group-focus/y:w-[11px] group-[&.ps--clicking]/y:bg-[#999] group-[&.ps--clicking]/y:w-[11px] outline-none", P_ = (s = document) => {
  [
    { ps: "ps__rail-x", te: L_ },
    { ps: "ps__rail-y", te: N_ },
    { ps: "ps__thumb-x", te: M_ },
    { ps: "ps__thumb-y", te: R_ }
  ].forEach((e) => {
    p.addClass(
      h.findOne(`.${e.ps}`, s),
      e.te
    ), p.removeClass(
      h.findOne(`.${e.ps}`, s),
      e.ps
    );
  }), p.addClass(s, $_), p.removeClass(s, "ps");
}, Gr = "sidenav", Zi = "te.sidenav", H_ = "data-te-sidenav-rotate-icon-ref", An = "[data-te-sidenav-toggle-ref]", B_ = "[data-te-collapse-init]", V_ = '[data-te-sidenav-slim="true"]', W_ = '[data-te-sidenav-slim="false"]', F_ = "[data-te-sidenav-menu-ref]", Ce = "[data-te-sidenav-collapse-ref]", ti = "[data-te-sidenav-link-ref]", Y_ = F() ? 100 : -100, j_ = F() ? -100 : 100, K_ = {
  sidenavAccordion: "(boolean)",
  sidenavBackdrop: "(boolean)",
  sidenavBackdropClass: "(null|string)",
  sidenavCloseOnEsc: "(boolean)",
  sidenavColor: "(string)",
  sidenavContent: "(null|string)",
  sidenavExpandable: "(boolean)",
  sidenavExpandOnHover: "(boolean)",
  sidenavFocusTrap: "(boolean)",
  sidenavHidden: "(boolean)",
  sidenavMode: "(string)",
  sidenavModeBreakpointOver: "(null|string|number)",
  sidenavModeBreakpointSide: "(null|string|number)",
  sidenavModeBreakpointPush: "(null|string|number)",
  sidenavBreakpointSm: "(number)",
  sidenavBreakpointMd: "(number)",
  sidenavBreakpointLg: "(number)",
  sidenavBreakpointXl: "(number)",
  sidenavBreakpoint2xl: "(number)",
  sidenavScrollContainer: "(null|string)",
  sidenavSlim: "(boolean)",
  sidenavSlimCollapsed: "(boolean)",
  sidenavSlimWidth: "(number)",
  sidenavPosition: "(string)",
  sidenavRight: "(boolean)",
  sidenavTransitionDuration: "(number)",
  sidenavWidth: "(number)"
}, U_ = {
  sidenavAccordion: !1,
  sidenavBackdrop: !0,
  sidenavBackdropClass: null,
  sidenavCloseOnEsc: !0,
  sidenavColor: "primary",
  sidenavContent: null,
  sidenavExpandable: !0,
  sidenavExpandOnHover: !1,
  sidenavFocusTrap: !0,
  sidenavHidden: !0,
  sidenavMode: "over",
  sidenavModeBreakpointOver: null,
  sidenavModeBreakpointSide: null,
  sidenavModeBreakpointPush: null,
  sidenavBreakpointSm: 640,
  sidenavBreakpointMd: 768,
  sidenavBreakpointLg: 1024,
  sidenavBreakpointXl: 1280,
  sidenavBreakpoint2xl: 1536,
  sidenavScrollContainer: null,
  sidenavSlim: !1,
  sidenavSlimCollapsed: !1,
  sidenavSlimWidth: 77,
  sidenavPosition: "fixed",
  sidenavRight: !1,
  sidenavTransitionDuration: 300,
  sidenavWidth: 240
};
class ni {
  constructor(t, e = {}) {
    Tt(this, "_addBackdropOnInit", () => {
      this._options.sidenavHidden || (this._backdrop.show(), u.off(this._element, "transitionend", this._addBackdropOnInit));
    });
    this._element = t, this._options = e, this._ID = Ot(""), this._content = null, this._initialContentStyle = null, this._slimCollapsed = !1, this._activeNode = null, this._tempSlim = !1, this._backdrop = this._initializeBackDrop(), this._focusTrap = null, this._perfectScrollbar = null, this._touch = null, this._setModeFromBreakpoints(), this.escHandler = (i) => {
      i.keyCode === Is && this.toggler && St(this.toggler) && (this._update(!1), u.off(window, "keydown", this.escHandler));
    }, this.hashHandler = () => {
      this._setActiveElements();
    }, t && (I.setData(t, Zi, this), this._setup()), this.options.sidenavBackdrop && !this.options.sidenavHidden && this.options.sidenavMode === "over" && u.on(this._element, "transitionend", this._addBackdropOnInit), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return Gr;
  }
  get container() {
    if (this.options.sidenavPosition === "fixed")
      return h.findOne("body");
    const t = (e) => !e.parentNode || e.parentNode === document ? e : e.parentNode.style.position === "relative" || e.parentNode.classList.contains("relative") ? e.parentNode : t(e.parentNode);
    return t(this._element);
  }
  get isVisible() {
    let t = 0, e = window.innerWidth;
    if (this.options.sidenavPosition !== "fixed") {
      const n = this.container.getBoundingClientRect();
      t = n.x, e = n.x + n.width;
    }
    const { x: i } = this._element.getBoundingClientRect();
    return this.options.sidenavRight ? Math.abs(i - e) > 10 : Math.abs(i - t) < 10;
  }
  get links() {
    return h.find(ti, this._element);
  }
  get navigation() {
    return h.find(F_, this._element);
  }
  get options() {
    const t = {
      ...U_,
      ...p.getDataAttributes(this._element),
      ...this._options
    };
    return N(Gr, t, K_), t;
  }
  get sidenavStyle() {
    return {
      width: `${this.width}px`,
      height: this.options.sidenavPosition === "fixed" ? "100vh" : "100%",
      position: this.options.sidenavPosition,
      transition: `all ${this.transitionDuration} linear`
    };
  }
  get toggler() {
    return h.find(An).find(
      (e) => {
        const i = p.getDataAttribute(e, "target");
        return h.findOne(i) === this._element;
      }
    );
  }
  get transitionDuration() {
    return `${this.options.sidenavTransitionDuration / 1e3}s`;
  }
  get translation() {
    return this.options.sidenavRight ? j_ : Y_;
  }
  get width() {
    return this._slimCollapsed ? this.options.sidenavSlimWidth : this.options.sidenavWidth;
  }
  get isBackdropVisible() {
    return !!this._backdrop._element;
  }
  // Public
  changeMode(t) {
    this._setMode(t);
  }
  dispose() {
    u.off(window, "keydown", this.escHandler), this.options.sidenavBackdrop && this._backdrop.dispose(), u.off(window, "hashchange", this.hashHandler), this._touch.dispose(), I.removeData(this._element, Zi), this._element = null;
  }
  hide() {
    this._emitEvents(!1), this._update(!1), this._options.sidenavBackdrop && this.isBackdropVisible && this._backdrop.hide();
  }
  show() {
    this._emitEvents(!0), this._update(!0), this._options.sidenavBackdrop && this._options.sidenavMode === "over" && this._backdrop.show();
  }
  toggle() {
    this._emitEvents(!this.isVisible), this._update(!this.isVisible);
  }
  toggleSlim() {
    this._setSlim(!this._slimCollapsed);
  }
  update(t) {
    this._options = t, this._setup();
  }
  getBreakpoint(t) {
    return this._transformBreakpointValuesToObject()[t];
  }
  // Private
  _init() {
    this._didInit || (u.on(
      document,
      "click",
      An,
      ni.toggleSidenav()
    ), this._didInit = !0);
  }
  _transformBreakpointValuesToObject() {
    return {
      sm: this.options.sidenavBreakpointSm,
      md: this.options.sidenavBreakpointMd,
      lg: this.options.sidenavBreakpointLg,
      xl: this.options.sidenavBreakpointXl,
      "2xl": this.options.sidenavBreakpoint2xl
    };
  }
  _setModeFromBreakpoints() {
    const t = window.innerWidth, e = this._transformBreakpointValuesToObject();
    if (t === void 0 || !e)
      return;
    const i = typeof this.options.sidenavModeBreakpointOver == "number" ? t - this.options.sidenavModeBreakpointOver : t - e[this.options.sidenavModeBreakpointOver], n = typeof this.options.sidenavModeBreakpointSide == "number" ? t - this.options.sidenavModeBreakpointSide : t - e[this.options.sidenavModeBreakpointSide], o = typeof this.options.sidenavModeBreakpointPush == "number" ? t - this.options.sidenavModeBreakpointPush : t - e[this.options.sidenavModeBreakpointPush], r = (l, c) => l - c < 0 ? -1 : c - l < 0 ? 1 : 0, a = [i, n, o].filter((l) => l != null && l >= 0).sort(r)[0];
    i > 0 && i === a ? (this._options.sidenavMode = "over", this._options.sidenavHidden = !0) : n > 0 && n === a ? this._options.sidenavMode = "side" : o > 0 && o === a && (this._options.sidenavMode = "push");
  }
  _collapseItems() {
    this.navigation.forEach((t) => {
      h.find(Ce, t).forEach((i) => {
        Ut.getInstance(i).hide();
      });
    });
  }
  _getOffsetValue(t, { index: e, property: i, offsets: n }) {
    const o = this._getPxValue(
      this._initialContentStyle[e][n[i].property]
    ), r = t ? n[i].value : 0;
    return o + r;
  }
  _getProperty(...t) {
    return t.map((e, i) => i === 0 ? e : e[0].toUpperCase().concat(e.slice(1))).join("");
  }
  _getPxValue(t) {
    return t ? parseFloat(t) : 0;
  }
  _handleSwipe(t, e) {
    e && this._slimCollapsed && this.options.sidenavSlim && this.options.sidenavExpandable ? this.toggleSlim() : e || (this._slimCollapsed || !this.options.sidenavSlim || !this.options.sidenavExpandable ? this.toggler && St(this.toggler) && this.toggle() : this.toggleSlim());
  }
  _isActive(t, e) {
    return e ? e === t : t.attributes.href ? new URL(t, window.location.href).href === window.location.href : !1;
  }
  _isAllToBeCollapsed() {
    return h.find(
      B_,
      this._element
    ).filter(
      (i) => i.getAttribute("aria-expanded") === "true"
    ).length === 0;
  }
  _isAllCollapsed() {
    return h.find(Ce, this._element).filter(
      (t) => St(t)
    ).length === 0;
  }
  _initializeBackDrop() {
    if (!this.options.sidenavBackdrop)
      return;
    const t = this.options.sidenavBackdropClass ? this.options.sidenavBackdropClass.split(" ") : this.options.sidenavPosition ? [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      this.options.sidenavPosition,
      "top-0",
      "left-0",
      "z-50",
      "bg-black/10",
      "dark:bg-black-60",
      "w-full",
      "h-full",
      this._element.id
    ] : null;
    return new lo({
      isVisible: this.options.sidenavBackdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      backdropClasses: t,
      clickCallback: () => this.hide()
    });
  }
  _updateBackdrop(t) {
    if (this.options.sidenavMode === "over") {
      t ? this._backdrop.show() : this.isBackdropVisible && this._backdrop.hide();
      return;
    }
    this.isBackdropVisible && this._backdrop.hide();
  }
  _setup() {
    this._setupTouch(), this.options.sidenavFocusTrap && this._setupFocusTrap(), this._setupCollapse(), this.options.sidenavSlim && this._setupSlim(), this._setupInitialStyling(), this._setupScrolling(), this.options.sidenavContent && this._setupContent(), this._setupActiveState(), this._setupRippleEffect(), this.options.sidenavHidden || this._updateOffsets(!0, !0), this.options.sidenavMode === "over" && this._setTabindex(!0);
  }
  _setupActiveState() {
    this._setActiveElements(), this.links.forEach((t) => {
      u.on(t, "click", () => this._setActiveElements(t)), u.on(t, "keydown", (e) => {
        e.keyCode === lt && this._setActiveElements(t);
      });
    }), u.on(window, "hashchange", this.hashHandler);
  }
  _setupCollapse() {
    this.navigation.forEach((t, e) => {
      h.find(Ce, t).forEach(
        (n, o) => this._setupCollapseList({ list: n, index: o, menu: t, menuIndex: e })
      );
    });
  }
  _generateCollpaseID(t, e) {
    return `sidenav-collapse-${this._ID}-${e}-${t}`;
  }
  _setupCollapseList({ list: t, index: e, menu: i, menuIndex: n }) {
    const o = this._generateCollpaseID(e, n);
    t.setAttribute("id", o), t.setAttribute("data-te-collapse-item", "");
    const [r] = h.prev(t, ti);
    p.setDataAttribute(r, "collapse-init", ""), r.setAttribute("href", `#${o}`), r.setAttribute("role", "button");
    const a = Ut.getInstance(t) || new Ut(t, {
      toggle: !1,
      parent: this.options.sidenavAccordion ? i : t
    });
    (t.dataset.teSidenavStateShow === "" || t.dataset.teCollapseShow === "") && this._rotateArrow(r, !1), u.on(r, "click", (l) => {
      this._toggleCategory(l, a, t), this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), u.on(
      t,
      "show.te.collapse",
      () => this._rotateArrow(r, !1)
    ), u.on(
      t,
      "hide.te.collapse",
      () => this._rotateArrow(r, !0)
    ), u.on(t, "shown.te.collapse", () => {
      this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), u.on(t, "hidden.te.collapse", () => {
      this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    });
  }
  _setupContent() {
    this._content = h.find(this.options.sidenavContent), this._content.forEach((t) => {
      const e = [
        "!p",
        "!m",
        "!px",
        "!pl",
        "!pr",
        "!mx",
        "!ml",
        "!mr",
        "!-p",
        "!-m",
        "!-px",
        "!-pl",
        "!-pr",
        "!-mx",
        "!-ml",
        "!-mr"
      ];
      [...t.classList].filter(
        (n) => e.findIndex((o) => n.includes(o)) >= 0
      ).forEach((n) => t.classList.remove(n));
    }), this._initialContentStyle = this._content.map((t) => {
      const { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r } = window.getComputedStyle(t);
      return { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r };
    });
  }
  _setupFocusTrap() {
    this._focusTrap = new bi(
      this._element,
      {
        event: "keydown",
        condition: (t) => t.keyCode === fi,
        onlyVisible: !0
      },
      this.toggler
    );
  }
  _setupInitialStyling() {
    this._setColor(), p.style(this._element, this.sidenavStyle);
  }
  _setupScrolling() {
    let t = this._element;
    if (this.options.sidenavScrollContainer) {
      t = h.findOne(
        this.options.sidenavScrollContainer,
        this._element
      );
      const i = tc(t.parentNode.children).filter(
        (n) => n !== t
      ).reduce((n, o) => n + o.clientHeight, 0);
      p.style(t, {
        maxHeight: `calc(100% - ${i}px)`,
        position: "relative"
      });
    }
    this._perfectScrollbar = new Ti(t, {
      suppressScrollX: !0,
      handlers: ["click-rail", "drag-thumb", "wheel", "touch"]
    }), P_(t);
  }
  _setupSlim() {
    this._slimCollapsed = this.options.sidenavSlimCollapsed, this._toggleSlimDisplay(this._slimCollapsed), this.options.sidenavExpandOnHover && (this._element.addEventListener("mouseenter", () => {
      this._slimCollapsed && this._setSlim(!1);
    }), this._element.addEventListener("mouseleave", () => {
      this._slimCollapsed || this._setSlim(!0);
    }));
  }
  _setupRippleEffect() {
    this.links.forEach((t) => {
      let e = Cs.getInstance(t), i = this.options.sidenavColor;
      if (e && e._options.sidenavColor !== this.options.sidenavColor)
        e.dispose();
      else if (e)
        return;
      (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (i = "white"), e = new Cs(t, { rippleColor: i });
    });
  }
  _setupTouch() {
    this._touch = new I_(this._element, "swipe", { threshold: 20 }), this._touch.init(), u.on(
      this._element,
      "swipeleft",
      (t) => this._handleSwipe(t, this.options.sidenavRight)
    ), u.on(
      this._element,
      "swiperight",
      (t) => this._handleSwipe(t, !this.options.sidenavRight)
    );
  }
  _setActive(t, e) {
    t.setAttribute("data-te-sidebar-state-active", ""), this._activeNode && t.removeAttribute("data-te-sidebar-state-active"), this._activeNode = t;
    const [i] = h.parents(
      this._activeNode,
      Ce
    );
    if (!i) {
      this._setActiveCategory();
      return;
    }
    const [n] = h.prev(i, ti);
    this._setActiveCategory(n), !e && !this._slimCollapsed && Ut.getInstance(i).show();
  }
  _setActiveCategory(t) {
    this.navigation.forEach((e) => {
      h.find(Ce, e).forEach((n) => {
        const [o] = h.prev(n, ti);
        o !== t ? o.removeAttribute("data-te-sidenav-state-active") : o.setAttribute("data-te-sidenav-state-active", "");
      });
    });
  }
  _setActiveElements(t) {
    this.navigation.forEach((e) => {
      h.find(ti, e).filter((n) => h.next(n, Ce).length === 0).forEach((n) => {
        this._isActive(n, t) && n !== this._activeNode && this._setActive(n, t);
      });
    }), t && this._updateFocus(this.isVisible);
  }
  _setColor() {
    const t = [
      "primary",
      "secondary",
      "success",
      "info",
      "warning",
      "danger",
      "light",
      "dark"
    ], { sidenavColor: e } = this.options, i = t.includes(e) ? e : "primary";
    t.forEach((n) => {
      this._element.classList.remove(`sidenav-${n}`);
    }), p.addClass(this._element, `sidenav-${i}`);
  }
  _setContentOffsets(t, e, i) {
    this._content.forEach((n, o) => {
      const r = this._getOffsetValue(t, {
        index: o,
        property: "padding",
        offsets: e
      }), a = this._getOffsetValue(t, {
        index: o,
        property: "margin",
        offsets: e
      }), l = {};
      if (i || (l.transition = `all ${this.transitionDuration} linear`), l[e.padding.property] = `${r}px`, l[e.margin.property] = `${a}px`, p.style(n, l), !!t) {
        if (i) {
          p.style(n, {
            transition: this._initialContentStyle[o].transition
          });
          return;
        }
        u.on(n, "transitionend", () => {
          p.style(n, {
            transition: this._initialContentStyle[o].transition
          });
        });
      }
    });
  }
  _setMode(t) {
    this.options.sidenavMode !== t && (this._options.sidenavMode = t, this._update(this.isVisible));
  }
  _setSlim(t) {
    const e = t ? ["collapse", "collapsed"] : ["expand", "expanded"];
    this._triggerEvents(...e), t && this._collapseItems(), this._slimCollapsed = t, this._toggleSlimDisplay(t), p.style(this._element, { width: `${this.width}px` }), this._updateOffsets(this.isVisible);
  }
  _setTabindex(t) {
    this.links.forEach((e) => {
      e.tabIndex = t ? 0 : -1;
    });
  }
  _emitEvents(t) {
    const e = t ? ["show", "shown"] : ["hide", "hidden"];
    this._triggerEvents(...e);
  }
  _rotateArrow(t, e) {
    const [i] = h.children(t, `[${H_}]`);
    i && (e ? p.removeClass(i, "rotate-180") : p.addClass(i, "rotate-180"));
  }
  _toggleCategory(t, e) {
    t.preventDefault(), e.toggle(), this._slimCollapsed && this.options.sidenavExpandable && (this._tempSlim = !0, this._setSlim(!1));
  }
  _toggleSlimDisplay(t) {
    const e = h.find(
      V_,
      this._element
    ), i = h.find(
      W_,
      this._element
    ), n = () => {
      e.forEach((o) => {
        p.style(o, {
          display: this._slimCollapsed ? "unset" : "none"
        });
      }), i.forEach((o) => {
        p.style(o, {
          display: this._slimCollapsed ? "none" : "unset"
        });
      });
    };
    t ? setTimeout(
      () => n(),
      this.options.sidenavTransitionDuration
    ) : n();
  }
  async _triggerEvents(t, e) {
    u.trigger(this._element, `${t}.te.sidenav`), e && await setTimeout(() => {
      u.trigger(this._element, `${e}.te.sidenav`);
    }, this.options.sidenavTransitionDuration + 5);
  }
  _update(t) {
    this.toggler && this._updateTogglerAria(t), this._updateDisplay(t), this.options.sidenavBackdrop && this._updateBackdrop(t), this._updateOffsets(t), t && this.options.sidenavCloseOnEsc && this.options.sidenavMode !== "side" && u.on(window, "keydown", this.escHandler), this.options.sidenavFocusTrap && this._updateFocus(t);
  }
  _updateDisplay(t) {
    const e = t ? 0 : this.translation;
    p.style(this._element, {
      transform: `translateX(${e}%)`
    });
  }
  _updateFocus(t) {
    if (this._setTabindex(t), this.options.sidenavMode === "over" && this.options.sidenavFocusTrap) {
      if (t) {
        this._focusTrap.trap();
        return;
      }
      this._focusTrap.disable();
    }
    this._focusTrap.disable();
  }
  _updateOffsets(t, e = !1) {
    const [i, n] = this.options.sidenavRight ? ["right", "left"] : ["left", "right"], o = {
      property: this._getProperty("padding", i),
      value: this.options.sidenavMode === "over" ? 0 : this.width
    }, r = {
      property: this._getProperty("margin", n),
      value: this.options.sidenavMode === "push" ? -1 * this.width : 0
    };
    u.trigger(this._element, "update.te.sidenav", {
      margin: r,
      padding: o
    }), this._content && (this._content.className = "", this._setContentOffsets(t, { padding: o, margin: r }, e));
  }
  _updateTogglerAria(t) {
    this.toggler.setAttribute("aria-expanded", t);
  }
  // Static
  static toggleSidenav() {
    return function(t) {
      const e = h.closest(t.target, An), i = p.getDataAttributes(e).target;
      h.find(i).forEach((n) => {
        (ni.getInstance(n) || new ni(n)).toggle();
      });
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, Zi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new ni(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, Zi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Yn = "stepper", ms = "te.stepper", Ms = `.${ms}`, Ci = `data-te-${Yn}`, oi = "horizontal", yt = "vertical", z_ = {
  stepperType: "string",
  stepperLinear: "boolean",
  stepperNoEditable: "boolean",
  stepperActive: "string",
  stepperCompleted: "string",
  stepperInvalid: "string",
  stepperDisabled: "string",
  stepperVerticalBreakpoint: "number",
  stepperMobileBreakpoint: "number",
  stepperMobileBarBreakpoint: "number"
}, X_ = {
  stepperType: oi,
  stepperLinear: !1,
  stepperNoEditable: !1,
  stepperActive: "",
  stepperCompleted: "",
  stepperInvalid: "",
  stepperDisabled: "",
  stepperVerticalBreakpoint: 0,
  stepperMobileBreakpoint: 0,
  stepperMobileBarBreakpoint: 4
}, qr = `mousedown${Ms}`, Qr = `keydown${Ms}`, G_ = `keyup${Ms}`, Zr = `resize${Ms}`, Vt = `[${Ci}-step-ref]`, G = `[${Ci}-head-ref]`, Jr = `[${Ci}-head-text-ref]`, Ji = `[${Ci}-head-icon-ref]`, st = `[${Ci}-content-ref]`;
class Qg {
  constructor(t, e) {
    this._element = t, this._options = this._getConfig(e), this._elementHeight = 0, this._steps = h.find(`${Vt}`, this._element), this._currentView = "", this._activeStepIndex = 0, this._verticalStepperStyles = [], this._element && (I.setData(t, ms, this), this._init());
  }
  // Getters
  static get NAME() {
    return Yn;
  }
  get activeStep() {
    return this._steps[this._activeStepIndex];
  }
  get activeStepIndex() {
    return this._activeStepIndex;
  }
  // Public
  dispose() {
    this._steps.forEach((t) => {
      u.off(t, qr), u.off(t, Qr);
    }), u.off(window, Zr), I.removeData(this._element, ms), this._element = null;
  }
  changeStep(t) {
    this._toggleStep(t);
  }
  nextStep() {
    this._toggleStep(this._activeStepIndex + 1);
  }
  previousStep() {
    this._toggleStep(this._activeStepIndex - 1);
  }
  // Private
  _init() {
    const t = h.find(`${Vt}`, this._element)[this._activeStepIndex].setAttribute("data-te", "active-step"), e = h.find(
      `${Jr}`,
      this._element
    ), i = h.find(
      `${Ji}`,
      this._element
    );
    switch (t ? (this._activeStepIndex = this._steps.indexOf(t), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    ), e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700")) : (e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    )), this._bindMouseDown(), this._bindKeysNavigation(), this._options.stepperType) {
      case yt:
        this._toggleVertical();
        break;
      default:
        this._toggleHorizontal();
        break;
    }
    (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(), this._bindResize();
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._element);
    return t = {
      ...X_,
      ...e,
      ...t
    }, N(Yn, t, z_), t;
  }
  _bindMouseDown() {
    this._steps.forEach((t) => {
      const e = h.findOne(`${G}`, t);
      u.on(e, qr, (i) => {
        const n = h.parents(i.target, `${Vt}`)[0], o = this._steps.indexOf(n);
        i.preventDefault(), this._toggleStep(o);
      });
    });
  }
  _bindResize() {
    u.on(window, Zr, () => {
      this._currentView === yt && this._setSingleStepHeight(this.activeStep), this._currentView === oi && this._setHeight(this.activeStep), (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView();
    });
  }
  _toggleStepperView() {
    const t = this._options.stepperVerticalBreakpoint < window.innerWidth, e = this._options.stepperVerticalBreakpoint > window.innerWidth, i = this._options.stepperMobileBreakpoint > window.innerWidth;
    t && this._currentView !== oi && this._toggleHorizontal(), e && !i && this._currentView !== yt && (this._steps.forEach((n) => {
      const o = h.findOne(`${st}`, n);
      this._resetStepperHeight(), this._showElement(o);
    }), this._toggleVertical());
  }
  _toggleStep(t) {
    this._activeStepIndex !== t && (this._options.stepperNoEditable && this._toggleDisabled(), this._showElement(
      h.findOne(`${st}`, this._steps[t])
    ), this._toggleActive(t), t > this._activeStepIndex && this._toggleCompleted(this._activeStepIndex), this._currentView === oi ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t), this._setSingleStepHeight(this._steps[t])), this._toggleStepTabIndex(
      h.findOne(`${G}`, this.activeStep),
      h.findOne(`${G}`, this._steps[t])
    ), this._activeStepIndex = t, this._steps[this._activeStepIndex].setAttribute("data-te", "active-step"), this._steps.forEach((e, i) => {
      e[this._activeStepIndex] !== i && e.removeAttribute("data-te");
    }));
  }
  _resetStepperHeight() {
    this._element.style.height = "";
  }
  _setStepsHeight() {
    this._steps.forEach((t) => {
      const e = h.findOne(`${st}`, t), i = window.getComputedStyle(e);
      this._verticalStepperStyles.push({
        paddingTop: parseFloat(i.paddingTop),
        paddingBottom: parseFloat(i.paddingBottom)
      });
      const n = e.scrollHeight;
      e.style.height = `${n}px`;
    });
  }
  _setSingleStepHeight(t) {
    const e = h.findOne(`${st}`, t), i = this.activeStep === t, n = this._steps.indexOf(t);
    let o;
    i ? (e.style.height = "", o = e.scrollHeight) : o = e.scrollHeight + this._verticalStepperStyles[n].paddingTop + this._verticalStepperStyles[n].paddingBottom, e.style.height = `${o}px`;
  }
  _toggleVertical() {
    this._currentView = yt, this._setStepsHeight(), this._hideInactiveSteps();
  }
  _toggleHorizontal() {
    this._currentView = oi, this._setHeight(this.activeStep), this._hideInactiveSteps();
  }
  _toggleStepperClass() {
    h.findOne(
      "[data-te-stepper-type]",
      this._element
    ) !== null && this._steps.forEach((e) => {
      h.findOne(`${st}`, e).classList.remove("!my-0"), h.findOne(`${st}`, e).classList.remove("!py-0"), h.findOne(`${st}`, e).classList.remove("!h-0");
    });
  }
  _toggleStepClass(t, e, i) {
    i && this._steps[t].classList[e](i);
  }
  _bindKeysNavigation() {
    this._toggleStepTabIndex(
      !1,
      h.findOne(`${G}`, this.activeStep)
    ), this._steps.forEach((t) => {
      const e = h.findOne(`${G}`, t);
      u.on(e, Qr, (i) => {
        const n = h.parents(
          i.currentTarget,
          `${Vt}`
        )[0], o = h.next(n, `${Vt}`)[0], r = h.prev(n, `${Vt}`)[0], a = h.findOne(
          `${G}`,
          n
        ), l = h.findOne(
          `${G}`,
          this.activeStep
        );
        let c = null, d = null;
        if (o && (c = h.findOne(`${G}`, o)), r && (d = h.findOne(`${G}`, r)), i.keyCode === Ie && this._currentView !== yt && (d ? (this._toggleStepTabIndex(a, d), this._toggleOutlineStyles(a, d), d.focus()) : c && (this._toggleStepTabIndex(a, c), this._toggleOutlineStyles(a, c), c.focus())), i.keyCode === $e && this._currentView !== yt && (c ? (this._toggleStepTabIndex(a, c), this._toggleOutlineStyles(a, c), c.focus()) : d && (this._toggleStepTabIndex(a, d), this._toggleOutlineStyles(a, d), d.focus())), i.keyCode === U && this._currentView === yt && (i.preventDefault(), c && (this._toggleStepTabIndex(a, c), this._toggleOutlineStyles(a, c), c.focus())), i.keyCode === rt && this._currentView === yt && (i.preventDefault(), d && (this._toggleStepTabIndex(a, d), this._toggleOutlineStyles(a, d), d.focus())), i.keyCode === Le) {
          const _ = h.findOne(
            `${G}`,
            this._steps[0]
          );
          this._toggleStepTabIndex(a, _), this._toggleOutlineStyles(a, _), _.focus();
        }
        if (i.keyCode === Me) {
          const _ = this._steps[this._steps.length - 1], f = h.findOne(`${G}`, _);
          this._toggleStepTabIndex(a, f), this._toggleOutlineStyles(a, f), f.focus();
        }
        (i.keyCode === lt || i.keyCode === ps) && (i.preventDefault(), this.changeStep(this._steps.indexOf(n))), i.keyCode === fi && (this._toggleStepTabIndex(a, l), this._toggleOutlineStyles(a, !1), l.focus());
      }), u.on(e, G_, (i) => {
        const n = h.parents(
          i.currentTarget,
          `${Vt}`
        )[0], o = h.findOne(
          `${G}`,
          n
        ), r = h.findOne(
          `${G}`,
          this.activeStep
        );
        i.keyCode === fi && (this._toggleStepTabIndex(o, r), this._toggleOutlineStyles(!1, r), r.focus());
      });
    });
  }
  _toggleStepTabIndex(t, e) {
    t && t.setAttribute("tabIndex", -1), e && e.setAttribute("tabIndex", 0);
  }
  _toggleOutlineStyles(t, e) {
    t && (t.style.outline = ""), e && (e.style.outline = "revert");
  }
  _toggleDisabled() {
    const t = h.find(`${G}`, this._element), e = h.find(
      `${Ji}`,
      this._element
    );
    t[this._activeStepIndex].classList.add("color-[#858585]"), t[this._activeStepIndex].classList.add("cursor-default"), e[this._activeStepIndex].classList.add("!bg-[#858585]"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperDisabled
    );
  }
  _toggleActive(t) {
    const e = h.find(
      `${Jr}`,
      this._element
    ), i = h.find(
      `${Ji}`,
      this._element
    );
    e[t].classList.add("font-medium"), i[t].classList.add("!bg-primary-100"), i[t].classList.add("!text-primary-700"), i[t].classList.remove("!bg-success-100"), i[t].classList.remove("!text-success-700"), e[this._activeStepIndex].classList.remove("font-medium"), i[this._activeStepIndex].classList.remove("!bg-primary-100"), i[this._activeStepIndex].classList.remove(
      "!text-primary-700"
    ), this._toggleStepClass(t, "add", this._options.stepperActive), this._toggleStepClass(
      this._activeStepIndex,
      "remove",
      this._options.stepperActive
    );
  }
  _toggleCompleted(t) {
    const e = h.find(
      `${Ji}`,
      this._element
    );
    e[t].classList.add("!bg-success-100"), e[t].classList.add("!text-success-700"), e[t].classList.remove("!bg-danger-100"), e[t].classList.remove("!text-danger-700"), this._toggleStepClass(t, "add", this._options.stepperCompleted), this._toggleStepClass(t, "remove", this._options.stepperInvalid);
  }
  _hideInactiveSteps() {
    this._steps.forEach((t) => {
      t.getAttribute("data-te") || this._hideElement(h.findOne(`${st}`, t));
    });
  }
  _setHeight(t) {
    const e = h.findOne(`${st}`, t), i = getComputedStyle(e), n = h.findOne(`${G}`, t), o = getComputedStyle(n), r = e.offsetHeight + parseFloat(i.marginTop) + parseFloat(i.marginBottom), a = n.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);
    this._element.style.height = `${a + r}px`;
  }
  _hideElement(t) {
    !h.parents(
      t,
      `${Vt}`
    )[0].getAttribute("data-te") && this._currentView !== yt || (t.classList.add("!my-0"), t.classList.add("!py-0"), t.classList.add("!h-0"));
  }
  _showElement(t) {
    this._currentView === yt ? (t.classList.remove("!my-0"), t.classList.remove("!py-0"), t.classList.remove("!h-0")) : t.style.display = "block";
  }
  _animateHorizontalStep(t) {
    const e = t > this._activeStepIndex, i = h.findOne(
      `${st}`,
      this._steps[t]
    ), n = h.findOne(
      `${st}`,
      this.activeStep
    );
    let o, r;
    this._steps.forEach((d, _) => {
      const f = h.findOne(`${st}`, d);
      _ !== t && _ !== this._activeStepIndex && this._hideElement(f);
    });
    const a = "translate-x-[150%]", l = "-translate-x-[150%]", c = "translate-0";
    e ? (r = l, o = c, i.classList.remove("translate-x-[150%]"), i.classList.remove("-translate-x-[150%]")) : (r = a, o = c, i.classList.remove("-translate-x-[150%]"), i.classList.remove("translate-x-[150%]")), n.classList.add(r), i.classList.add(o), this._setHeight(this._steps[t]);
  }
  _animateVerticalStep(t) {
    const e = h.findOne(
      `${st}`,
      this._steps[t]
    ), i = h.findOne(
      `${st}`,
      this.activeStep
    );
    this._hideElement(i), this._showElement(e);
  }
  static getInstance(t) {
    return I.getData(t, ms);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const ta = "data-te-input-state-active", ts = "data-te-input-selected", ea = "data-te-input-multiple-active", ia = "[data-te-form-check-input]";
class sa {
  constructor(t, e, i, n, o, r, a, l, c, d, _) {
    this.id = t, this.nativeOption = e, this.multiple = i, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = c, this.groupId = d, this.icon = _, this.node = null, this.active = !1;
  }
  select() {
    this.multiple ? this._selectMultiple() : this._selectSingle();
  }
  _selectSingle() {
    this.selected || (this.node.setAttribute(ts, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0));
  }
  _selectMultiple() {
    if (!this.selected) {
      const t = h.findOne(
        ia,
        this.node
      );
      t.checked = !0, this.node.setAttribute(ts, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0);
    }
  }
  deselect() {
    this.multiple ? this._deselectMultiple() : this._deselectSingle();
  }
  _deselectSingle() {
    this.selected && (this.node.removeAttribute(ts), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1));
  }
  _deselectMultiple() {
    if (this.selected) {
      const t = h.findOne(
        ia,
        this.node
      );
      t.checked = !1, this.node.removeAttribute(ts), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1);
    }
  }
  setNode(t) {
    this.node = t;
  }
  setActiveStyles() {
    if (!this.active) {
      if (this.multiple) {
        this.node.setAttribute(ea, "");
        return;
      }
      this.active = !0, this.node.setAttribute(ta, "");
    }
  }
  removeActiveStyles() {
    this.active && (this.active = !1, this.node.removeAttribute(ta)), this.multiple && this.node.removeAttribute(ea);
  }
}
class q_ {
  constructor(t = !1) {
    this._multiple = t, this._selections = [];
  }
  select(t) {
    this._multiple ? this._selections.push(t) : this._selections = [t];
  }
  deselect(t) {
    if (this._multiple) {
      const e = this._selections.findIndex(
        (i) => t === i
      );
      this._selections.splice(e, 1);
    } else
      this._selections = [];
  }
  clear() {
    this._selections = [];
  }
  get selection() {
    return this._selections[0];
  }
  get selections() {
    return this._selections;
  }
  get label() {
    return this._selections[0] && this.selection.label;
  }
  get labels() {
    return this._selections.map((t) => t.label).join(", ");
  }
  get value() {
    return this.selections[0] && this.selection.value;
  }
  get values() {
    return this._selections.map((t) => t.value);
  }
}
function jn(s) {
  return s.filter((t) => !t.disabled).every((t) => t.selected);
}
const Q_ = "data-te-select-form-outline-ref", Z_ = "data-te-select-wrapper-ref", J_ = "data-te-select-input-ref", tm = "data-te-select-clear-btn-ref", em = "data-te-select-dropdown-container-ref", im = "data-te-select-dropdown-ref", sm = "data-te-select-options-wrapper-ref", nm = "data-te-select-options-list-ref", om = "data-te-select-input-filter-ref", xl = "data-te-select-option-ref", rm = "data-te-select-option-all-ref", am = "data-te-select-option-text-ref", lm = "data-te-form-check-input", cm = "data-te-select-option-group-ref", dm = "data-te-select-option-group-label-ref", Sl = "data-te-select-selected", hm = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
</svg>
`, um = (s) => {
  s.code === "Tab" || s.code === "Esc" || s.preventDefault();
};
function es(s, t, e, i, n) {
  t.selectSize === "default" && p.addClass(s, e), t.selectSize === "sm" && p.addClass(s, i), t.selectSize === "lg" && p.addClass(s, n);
}
function pm(s, t, e, i) {
  const n = document.createElement("div");
  n.setAttribute("id", s), n.setAttribute(Z_, "");
  const o = M("div");
  o.setAttribute(Q_, ""), p.addClass(o, i.formOutline);
  const r = M("input"), a = t.selectFilter ? "combobox" : "listbox", l = t.multiple ? "true" : "false", c = t.disabled ? "true" : "false";
  r.setAttribute(J_, ""), p.addClass(r, i.selectInput), es(
    r,
    t,
    i.selectInputSizeDefault,
    i.selectInputSizeSm,
    i.selectInputSizeLg
  ), t.selectFormWhite && p.addClass(r, i.selectInputWhite), r.setAttribute("type", "text"), r.setAttribute("role", a), r.setAttribute("aria-multiselectable", l), r.setAttribute("aria-disabled", c), r.setAttribute("aria-haspopup", "true"), r.setAttribute("aria-expanded", !1), t.tabIndex && r.setAttribute("tabIndex", t.tabIndex), t.disabled && r.setAttribute("disabled", ""), t.selectPlaceholder !== "" && r.setAttribute("placeholder", t.selectPlaceholder), t.selectValidation ? (p.addStyle(r, {
    "pointer-events": "none",
    "caret-color": "transparent"
  }), p.addStyle(o, { cursor: "pointer" })) : r.setAttribute("readonly", "true"), t.selectValidation && (r.setAttribute("required", "true"), r.setAttribute("aria-required", "true"), r.addEventListener("keydown", um));
  const d = M("div");
  p.addClass(d, i.selectValidationValid);
  const _ = document.createTextNode(
    `${t.selectValidFeedback}`
  );
  d.appendChild(_);
  const f = M("div");
  p.addClass(f, i.selectValidationInvalid);
  const m = document.createTextNode(
    `${t.selectInvalidFeedback}`
  );
  f.appendChild(m);
  const g = M("span");
  g.setAttribute(tm, ""), p.addClass(g, i.selectClearBtn), es(
    g,
    t,
    i.selectClearBtnDefault,
    i.selectClearBtnSm,
    i.selectClearBtnLg
  ), t.selectFormWhite && p.addClass(g, i.selectClearBtnWhite);
  const b = document.createTextNode("");
  g.appendChild(b), g.setAttribute("tabindex", "0");
  const T = M("span");
  return p.addClass(T, i.selectArrow), es(
    T,
    t,
    i.selectArrowDefault,
    i.selectArrowSm,
    i.selectArrowLg
  ), t.selectFormWhite && p.addClass(T, i.selectArrowWhite), T.innerHTML = hm, o.appendChild(r), e && (p.addClass(e, i.selectLabel), es(
    e,
    t,
    i.selectLabelSizeDefault,
    i.selectLabelSizeSm,
    i.selectLabelSizeLg
  ), t.selectFormWhite && p.addClass(e, i.selectLabelWhite), o.appendChild(e)), t.selectValidation && (o.appendChild(d), o.appendChild(f)), t.selectClearButton && o.appendChild(g), o.appendChild(T), n.appendChild(o), n;
}
function na(s, t, e, i, n, o, r, a) {
  const l = document.createElement("div");
  l.setAttribute(em, ""), p.addClass(l, a.selectDropdownContainer), l.setAttribute("id", `${s}`), l.style.width = `${e}px`;
  const c = document.createElement("div");
  c.setAttribute("tabindex", 0), c.setAttribute(im, ""), p.addClass(c, a.dropdown);
  const d = M("div");
  d.setAttribute(sm, ""), p.addClass(d, a.optionsWrapper), p.addClass(d, a.optionsWrapperScrollbar), d.style.maxHeight = `${i}px`;
  const _ = Dl(
    o,
    n,
    t,
    a
  );
  return d.appendChild(_), t.selectFilter && c.appendChild(
    fm(t.selectSearchPlaceholder, a)
  ), c.appendChild(d), r && c.appendChild(r), l.appendChild(c), l;
}
function Dl(s, t, e, i) {
  const n = M("div");
  n.setAttribute(nm, ""), p.addClass(n, i.optionsList);
  let o;
  return e.multiple ? o = mm(
    s,
    t,
    e,
    i
  ) : o = _m(s, e, i), o.forEach((r) => {
    n.appendChild(r);
  }), n;
}
function fm(s, t) {
  const e = M("div");
  p.addClass(e, t.inputGroup);
  const i = M("input");
  return i.setAttribute(om, ""), p.addClass(i, t.selectFilterInput), i.placeholder = s, i.setAttribute("role", "searchbox"), i.setAttribute("type", "text"), e.appendChild(i), e;
}
function _m(s, t, e) {
  return Il(s, t, e);
}
function mm(s, t, e, i) {
  let n = null;
  e.selectAll && (n = gm(
    t,
    s,
    e,
    i
  ));
  const o = Il(s, e, i);
  return n ? [n, ...o] : o;
}
function Il(s, t, e) {
  const i = [];
  return s.forEach((n) => {
    if (Object.prototype.hasOwnProperty.call(
      n,
      "options"
    )) {
      const r = Tm(n, t, e);
      i.push(r);
    } else
      i.push($l(n, t, e));
  }), i;
}
function gm(s, t, e, i) {
  const n = jn(t), o = M("div");
  return o.setAttribute(xl, ""), p.addClass(o, i.selectOption), o.setAttribute(rm, ""), p.addStyle(o, {
    height: `${e.selectOptionHeight}px`
  }), o.setAttribute("role", "option"), o.setAttribute("aria-selected", n), n && o.setAttribute(Sl, ""), o.appendChild(Ll(s, e, i)), s.setNode(o), o;
}
function $l(s, t, e) {
  if (s.node)
    return s.node;
  const i = M("div");
  return i.setAttribute(xl, ""), p.addClass(i, e.selectOption), p.addStyle(i, {
    height: `${t.selectOptionHeight}px`
  }), p.setDataAttribute(i, "id", s.id), i.setAttribute("role", "option"), i.setAttribute("aria-selected", s.selected), i.setAttribute("aria-disabled", s.disabled), s.selected && i.setAttribute(Sl, ""), s.disabled && i.setAttribute("data-te-select-option-disabled", !0), s.hidden && p.addClass(i, "hidden"), i.appendChild(Ll(s, t, e)), s.icon && i.appendChild(Em(s, e)), s.setNode(i), i;
}
function Ll(s, t, e) {
  const i = M("span");
  i.setAttribute(am, ""), p.addClass(i, e.selectOptionText);
  const n = document.createTextNode(s.label);
  return t.multiple && i.appendChild(vm(s, e)), i.appendChild(n), (s.secondaryText || typeof s.secondaryText == "number") && i.appendChild(
    bm(s.secondaryText, e)
  ), i;
}
function bm(s, t) {
  const e = M("span");
  p.addClass(e, t.selectOptionSecondaryText);
  const i = document.createTextNode(s);
  return e.appendChild(i), e;
}
function vm(s, t) {
  const e = M("input");
  e.setAttribute("type", "checkbox"), p.addClass(e, t.formCheckInput), e.setAttribute(lm, "");
  const i = M("label");
  return s.selected && e.setAttribute("checked", !0), s.disabled && e.setAttribute("disabled", !0), e.appendChild(i), e;
}
function Em(s, t) {
  const e = M("span"), i = M("img");
  return p.addClass(i, t.selectOptionIcon), i.src = s.icon, e.appendChild(i), e;
}
function Tm(s, t, e) {
  const i = M("div");
  i.setAttribute(cm, ""), p.addClass(i, e.selectOptionGroup), i.setAttribute("role", "group"), i.setAttribute("id", s.id), s.hidden && p.addClass(i, "hidden");
  const n = M("label");
  return n.setAttribute(dm, ""), p.addClass(n, e.selectOptionGroupLabel), p.addStyle(n, { height: `${t.selectOptionHeight}px` }), n.setAttribute("for", s.id), n.textContent = s.label, i.appendChild(n), s.options.forEach((o) => {
    i.appendChild($l(o, t, e));
  }), i;
}
function Cm(s, t) {
  const e = M("div");
  return e.innerHTML = s, p.addClass(e, t.selectLabel), p.addClass(e, t.selectFakeValue), e;
}
const yn = "select", ri = "te.select", Ai = `.${ri}`, Am = `close${Ai}`, ym = `open${Ai}`, oa = `optionSelect${Ai}`, ra = `optionDeselect${Ai}`, wm = `valueChange${Ai}`, km = "change", aa = "data-te-select-init", Ml = "data-te-select-no-results-ref", la = "data-te-select-open", q = "data-te-input-state-active", Wt = "data-te-input-focused", wn = "data-te-input-disabled", Om = "data-te-select-option-group-label-ref", xm = "data-te-select-option-all-ref", ei = "data-te-select-selected", Sm = "[data-te-select-label-ref]", ca = "[data-te-select-input-ref]", Dm = "[data-te-select-input-filter-ref]", Im = "[data-te-select-dropdown-ref]", $m = "[data-te-select-options-wrapper-ref]", da = "[data-te-select-options-list-ref]", Lm = "[data-te-select-option-ref]", Mm = "[data-te-select-clear-btn-ref]", Nm = "[data-te-select-custom-content-ref]", Rm = `[${Ml}]`, ha = "[data-te-select-form-outline-ref]", Pm = "[data-te-select-toggle]", kn = "[data-te-input-notch-ref]", Hm = 200, Bm = {
  selectAutoSelect: !1,
  selectContainer: "body",
  selectClearButton: !1,
  disabled: !1,
  selectDisplayedLabels: 5,
  selectFormWhite: !1,
  multiple: !1,
  selectOptionsSelectedLabel: "options selected",
  selectOptionHeight: 38,
  selectAll: !0,
  selectAllLabel: "Select all",
  selectSearchPlaceholder: "Search...",
  selectSize: "default",
  selectVisibleOptions: 5,
  selectFilter: !1,
  selectFilterDebounce: 300,
  selectNoResultText: "No results",
  selectValidation: !1,
  selectValidFeedback: "Valid",
  selectInvalidFeedback: "Invalid",
  selectPlaceholder: ""
}, Vm = {
  selectAutoSelect: "boolean",
  selectContainer: "string",
  selectClearButton: "boolean",
  disabled: "boolean",
  selectDisplayedLabels: "number",
  selectFormWhite: "boolean",
  multiple: "boolean",
  selectOptionsSelectedLabel: "string",
  selectOptionHeight: "number",
  selectAll: "boolean",
  selectAllLabel: "string",
  selectSearchPlaceholder: "string",
  selectSize: "string",
  selectVisibleOptions: "number",
  selectFilter: "boolean",
  selectFilterDebounce: "number",
  selectNoResultText: "string",
  selectValidation: "boolean",
  selectValidFeedback: "string",
  selectInvalidFeedback: "string",
  selectPlaceholder: "string"
}, Wm = {
  dropdown: "relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700",
  formCheckInput: "relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent",
  formOutline: "relative",
  initialized: "hidden",
  inputGroup: "flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200",
  noResult: "flex items-center px-4",
  optionsList: "list-none m-0 p-0",
  optionsWrapper: "overflow-y-auto",
  optionsWrapperScrollbar: "[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded",
  selectArrow: "absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5",
  selectArrowWhite: "text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white",
  selectArrowDefault: "top-2",
  selectArrowLg: "top-[13px]",
  selectArrowSm: "top-1",
  selectClearBtn: "absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200",
  selectClearBtnWhite: "!text-gray-50",
  selectClearBtnDefault: "top-2 text-base",
  selectClearBtnLg: "top-[11px] text-base",
  selectClearBtnSm: "top-1 text-[0.8rem]",
  selectDropdownContainer: "z-[1070]",
  selectFakeValue: "transform-none hidden data-[te-input-state-active]:block",
  selectFilterInput: "relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200",
  selectInput: "peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600",
  selectInputWhite: "!text-gray-50",
  selectInputSizeDefault: "py-[0.32rem] px-3 leading-[1.6]",
  selectInputSizeLg: "py-[0.32rem] px-3 leading-[2.15]",
  selectInputSizeSm: "py-[0.33rem] px-3 text-xs leading-[1.5]",
  selectLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary",
  selectLabelWhite: "!text-gray-50",
  selectLabelSizeDefault: "pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]",
  selectLabelSizeLg: "pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]",
  selectLabelSizeSm: "pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]",
  selectOption: "flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30",
  selectOptionGroup: "group/opt",
  selectOptionGroupLabel: "flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300",
  selectOptionIcon: "w-7 h-7 rounded-full",
  selectOptionSecondaryText: "block text-[0.8rem] text-gray-500 dark:text-gray-300",
  selectOptionText: "group",
  selectValidationValid: "hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block",
  selectValidationInvalid: "hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block"
}, Fm = {
  dropdown: "string",
  formCheckInput: "string",
  formOutline: "string",
  initialized: "string",
  inputGroup: "string",
  noResult: "string",
  optionsList: "string",
  optionsWrapper: "string",
  optionsWrapperScrollbar: "string",
  selectArrow: "string",
  selectArrowDefault: "string",
  selectArrowLg: "string",
  selectArrowSm: "string",
  selectClearBtn: "string",
  selectClearBtnDefault: "string",
  selectClearBtnLg: "string",
  selectClearBtnSm: "string",
  selectDropdownContainer: "string",
  selectFakeValue: "string",
  selectFilterInput: "string",
  selectInput: "string",
  selectInputSizeDefault: "string",
  selectInputSizeLg: "string",
  selectInputSizeSm: "string",
  selectLabel: "string",
  selectLabelSizeDefault: "string",
  selectLabelSizeLg: "string",
  selectLabelSizeSm: "string",
  selectOption: "string",
  selectOptionGroup: "string",
  selectOptionGroupLabel: "string",
  selectOptionIcon: "string",
  selectOptionSecondaryText: "string",
  selectOptionText: "string"
};
class Nl {
  constructor(t, e, i) {
    this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new q_(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = Ot("select-wrapper-"), this._dropdownContainerId = Ot("select-dropdown-container-"), this._selectAllId = Ot("select-all-"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions, this._popper = null, this._input = null, this._label = h.next(this._element, Sm)[0], this._notch = null, this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = h.next(
      t,
      Nm
    )[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), this._element && I.setData(t, ri, this);
  }
  static get NAME() {
    return yn;
  }
  get filterInput() {
    return h.findOne(
      Dm,
      this._dropdownContainer
    );
  }
  get dropdown() {
    return h.findOne(Im, this._dropdownContainer);
  }
  get optionsList() {
    return h.findOne(
      da,
      this._dropdownContainer
    );
  }
  get optionsWrapper() {
    return h.findOne(
      $m,
      this._dropdownContainer
    );
  }
  get clearButton() {
    return h.findOne(Mm, this._wrapper);
  }
  get options() {
    return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;
  }
  get value() {
    return this.multiple ? this._selectionModel.values : this._selectionModel.value;
  }
  get multiple() {
    return this._config.multiple;
  }
  get hasSelectAll() {
    return this.multiple && this._config.selectAll;
  }
  get hasSelection() {
    return this._selectionModel.selection || this._selectionModel.selections.length > 0;
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._element);
    return t = {
      ...Bm,
      ...e,
      ...t
    }, this._element.hasAttribute("multiple") && (t.multiple = !0), this._element.hasAttribute("disabled") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute("tabIndex")), N(yn, t, Vm), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...Wm,
      ...e,
      ...t
    }, N(yn, t, Fm), t;
  }
  _getOptionsToRender(t) {
    const e = [];
    return t.childNodes.forEach((n) => {
      if (n.nodeName === "OPTGROUP") {
        const o = {
          id: Ot("group-"),
          label: n.label,
          disabled: n.hasAttribute("disabled"),
          hidden: n.hasAttribute("hidden"),
          options: []
        };
        n.childNodes.forEach((a) => {
          a.nodeName === "OPTION" && o.options.push(
            this._createOptionObject(a, o)
          );
        }), e.push(o);
      } else
        n.nodeName === "OPTION" && e.push(this._createOptionObject(n));
    }), e;
  }
  _getPlainOptions(t) {
    if (!h.findOne("optgroup", this._element))
      return t;
    const i = [];
    return t.forEach((n) => {
      Object.prototype.hasOwnProperty.call(
        n,
        "options"
      ) ? n.options.forEach((r) => {
        i.push(r);
      }) : i.push(n);
    }), i;
  }
  _createOptionObject(t, e = {}) {
    const i = Ot("option-"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : !1, r = t.selected || t.hasAttribute(ei), a = t.hasAttribute("disabled") || o, l = t.hasAttribute("hidden") || e && e.hidden, c = this.multiple, d = t.value, _ = t.label, f = p.getDataAttribute(
      t,
      "selectSecondaryText"
    ), m = p.getDataAttribute(t, "select-icon");
    return new sa(
      i,
      t,
      c,
      d,
      _,
      r,
      a,
      l,
      f,
      n,
      m
    );
  }
  _getNavigationOptions() {
    const t = this.options.filter((e) => !e.hidden);
    return this.hasSelectAll ? [this._selectAllOption, ...t] : t;
  }
  _init() {
    this._renderMaterialWrapper(), this._wrapper = h.findOne(`#${this._wrapperId}`), this._input = h.findOne(ca, this._wrapper), this._config.disabled && this._input.setAttribute(wn, "");
    const t = this._config.selectContainer;
    t === "body" ? this._container = document.body : this._container = h.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = na(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    ), this._setFirstActiveOption(), this._listenToFocusChange();
  }
  _renderMaterialWrapper() {
    const t = pm(
      this._wrapperId,
      this._config,
      this._label,
      this._classes
    );
    this._element.parentNode.insertBefore(t, this._element), p.addClass(this._element, this._classes.initialized), t.appendChild(this._element);
  }
  _initOutlineInput() {
    const t = h.findOne(
      ha,
      this._wrapper
    );
    new V(t, {
      inputFormWhite: this._config.selectFormWhite
    }).init(), this._notch = h.findOne(kn, this._wrapper);
  }
  _bindComponentEvents() {
    this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();
  }
  _setDefaultSelections() {
    this.options.forEach((t) => {
      t.selected && this._selectionModel.select(t);
    });
  }
  _listenToComponentKeydown() {
    u.on(this._wrapper, "keydown", this._handleKeydown.bind(this));
  }
  _handleKeydown(t) {
    this._isOpen && !this._config.selectFilter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
  }
  _handleOpenKeydown(t) {
    const e = t.keyCode, i = e === Is || e === rt && t.altKey || e === fi;
    if (e === fi && this._config.selectAutoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), i) {
      this.close(), this._input.focus();
      return;
    }
    switch (e) {
      case U:
        this._setNextOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case rt:
        this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case Le:
        this._setFirstOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case Me:
        this._setLastOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case lt:
        t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));
        return;
      default:
        return;
    }
    t.preventDefault();
  }
  _handleClosedKeydown(t) {
    const e = t.keyCode;
    if (e === lt && t.preventDefault(), (e === lt || e === U && t.altKey || e === U && this.multiple) && this.open(), this.multiple)
      switch (e) {
        case U:
          this.open();
          break;
        case rt:
          this.open();
          break;
        default:
          return;
      }
    else
      switch (e) {
        case U:
          this._setNextOptionActive(), this._handleSelection(this._activeOption);
          break;
        case rt:
          this._setPreviousOptionActive(), this._handleSelection(this._activeOption);
          break;
        case Le:
          this._setFirstOptionActive(), this._handleSelection(this._activeOption);
          break;
        case Me:
          this._setLastOptionActive(), this._handleSelection(this._activeOption);
          break;
        default:
          return;
      }
    t.preventDefault();
  }
  _scrollToOption(t) {
    if (!t)
      return;
    let e;
    const i = this.options.filter((d) => !d.hidden);
    this.hasSelectAll ? e = i.indexOf(t) + 1 : e = i.indexOf(t);
    const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.selectOptionHeight, c = r.scrollTop;
    if (e > -1) {
      const d = o * l, _ = d + l > c + a;
      d < c ? r.scrollTop = d : _ ? r.scrollTop = d - a + l : r.scrollTop = c;
    }
  }
  _getNumberOfGroupsBeforeOption(t) {
    const e = this.options.filter((r) => !r.hidden), i = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t - 1 : t;
    let o = 0;
    for (let r = 0; r <= n; r++)
      e[r].groupId && i[o] && i[o].id && e[r].groupId === i[o].id && o++;
    return o;
  }
  _setNextOptionActive() {
    let t = this._activeOptionIndex + 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t += 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setPreviousOptionActive() {
    let t = this._activeOptionIndex - 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t -= 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setFirstOptionActive() {
    const e = this._getNavigationOptions();
    this._updateActiveOption(e[0], 0);
  }
  _setLastOptionActive() {
    const t = this._getNavigationOptions(), e = t.length - 1;
    this._updateActiveOption(t[e], e);
  }
  _updateActiveOption(t, e) {
    const i = this._activeOption;
    i && i.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;
  }
  _listenToWrapperClick() {
    u.on(this._wrapper, "click", () => {
      this.toggle();
    });
  }
  _listenToClearBtnClick() {
    u.on(this.clearButton, "click", (t) => {
      t.preventDefault(), t.stopPropagation(), this._handleClear();
    });
  }
  _listenToClearBtnKeydown() {
    u.on(this.clearButton, "keydown", (t) => {
      t.keyCode === lt && (this._handleClear(), t.preventDefault(), t.stopPropagation());
    });
  }
  _handleClear() {
    if (this.multiple)
      this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();
    else {
      const t = this._selectionModel.selection;
      this._selectionModel.clear(), t.deselect();
    }
    this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();
  }
  _listenToOptionsClick() {
    u.on(this.optionsWrapper, "click", (t) => {
      if (t.target.hasAttribute(
        Om
      ))
        return;
      const i = t.target.nodeName === "DIV" ? t.target : h.closest(t.target, Lm);
      if (i.hasAttribute(xm)) {
        this._handleSelectAll();
        return;
      }
      const o = i.dataset.teId, r = this.options.find((a) => a.id === o);
      r && !r.disabled && this._handleSelection(r);
    });
  }
  _handleSelectAll() {
    this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _selectAllOptions(t) {
    t.forEach((e) => {
      !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());
    });
  }
  _deselectAllOptions(t) {
    t.forEach((e) => {
      e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());
    });
  }
  _handleSelection(t) {
    this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleAutoSelection(t) {
    this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleSingleSelection(t) {
    this._singleOptionSelect(t), this.close(), this._input.focus();
  }
  _singleOptionSelect(t) {
    const e = this._selectionModel.selections[0];
    e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute(ei, !1), u.trigger(this._element, ra, {
      value: e.value
    })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute(ei, !0), u.trigger(this._element, oa, {
      value: t.value
    }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());
  }
  _handleMultiSelection(t) {
    t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute(ei, !1), u.trigger(this._element, ra, {
      value: t.value
    })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute(ei, !0), u.trigger(this._element, oa, {
      value: t.value
    })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _emitValueChangeEvent(t) {
    u.trigger(this._element, wm, { value: t });
  }
  _emitNativeChangeEvent() {
    u.trigger(this._element, km);
  }
  _updateInputValue() {
    const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
    let e;
    this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = "" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label;
  }
  _isSelectionValid(t) {
    return !(t && (t.disabled || t.value === ""));
  }
  _isLabelEmpty(t) {
    return !!(t && t.label === "");
  }
  _appendFakeValue() {
    if (!this._selectionModel.selection || this._selectionModel._multiple)
      return;
    const t = this._selectionModel.selection.label;
    this._fakeValue = Cm(t, this._classes), h.findOne(
      ha,
      this._wrapper
    ).appendChild(this._fakeValue);
  }
  _updateLabelPosition() {
    const t = this._element.hasAttribute(aa), e = this._input.value !== "";
    this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q, "")));
  }
  _updateLabelPositionWhileClosing() {
    this._label && (this._input.value !== "" || this._isFakeValueActive ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q)));
  }
  _updateFakeLabelPosition() {
    this._fakeValue && (this._input.value === "" && this._fakeValue.innerHTML !== "" ? (this._isFakeValueActive = !0, this._fakeValue.setAttribute(q, "")) : (this._isFakeValueActive = !1, this._fakeValue.removeAttribute(q)));
  }
  _updateClearButtonVisibility() {
    if (!this.clearButton)
      return;
    this._selectionModel.selection || this._selectionModel.selections.length > 0 ? p.addStyle(this.clearButton, { display: "block" }) : p.addStyle(this.clearButton, { display: "none" });
  }
  _updateSelectAllState() {
    const t = this._selectAllOption.selected, e = jn(this.options);
    !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();
  }
  toggle() {
    this._isOpen ? this.close() : this.open();
  }
  open() {
    const t = this._config.disabled, e = u.trigger(this._element, ym);
    this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.selectFilter && (setTimeout(() => {
      this.filterInput.focus();
    }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, this._updateLabelPosition(), this._setInputActiveStyles());
  }
  _openDropdown() {
    this._popper = je(this._input, this._dropdownContainer, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {
      this.dropdown.setAttribute(la, "");
    }, 0);
  }
  _updateDropdownWidth() {
    const t = this._input.offsetWidth;
    p.addStyle(this._dropdownContainer, { width: `${t}px` });
  }
  _setFirstActiveOption() {
    const t = this._getNavigationOptions(), e = this._activeOption;
    e && e.removeActiveStyles();
    const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
    i ? (this._activeOption = i, i.setActiveStyles(), this._activeOptionIndex = t.findIndex(
      (n) => n === i
    )) : (this._activeOption = null, this._activeOptionIndex = -1);
  }
  _setInputActiveStyles() {
    this._input.setAttribute(Wt, ""), h.findOne(kn, this._wrapper).setAttribute(
      Wt,
      ""
    );
  }
  _listenToWindowResize() {
    u.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    this._dropdownContainer && this._updateDropdownWidth();
  }
  _listenToSelectSearch() {
    this.filterInput.addEventListener("input", (t) => {
      const e = t.target.value, i = this._config.selectFilterDebounce;
      this._debounceFilter(e, i);
    });
  }
  _debounceFilter(t, e) {
    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
      this._filterOptions(t);
    }, e);
  }
  _filterOptions(t) {
    const e = [];
    this._optionsToRender.forEach((o) => {
      const r = Object.prototype.hasOwnProperty.call(
        o,
        "options"
      ), a = !r && o.label.toLowerCase().includes(t.toLowerCase()), l = {};
      r && (l.label = o.label, l.options = this._filter(t, o.options), l.options.length > 0 && e.push(l)), a && e.push(o);
    });
    const i = this._config.selectNoResultText !== "", n = e.length !== 0;
    if (n)
      this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();
    else if (!n && i) {
      const o = this._getNoResultTemplate();
      this.optionsWrapper.innerHTML = o;
    }
  }
  _updateOptionsListTemplate(t) {
    const e = h.findOne(da, this._dropdownContainer) || h.findOne(Rm, this._dropdownContainer), i = Dl(
      t,
      this._selectAllOption,
      this._config,
      this._classes
    );
    this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(i);
  }
  _getNoResultTemplate() {
    return `<div class="${this._classes.noResult}" ${Ml} style="height: ${this._config.selectOptionHeight}px">${this._config.selectNoResultText}</div>`;
  }
  _filter(t, e) {
    const i = t.toLowerCase();
    return e.filter(
      (n) => n.label.toLowerCase().includes(i)
    );
  }
  _listenToDropdownKeydown() {
    u.on(
      this.dropdown,
      "keydown",
      this._handleOpenKeydown.bind(this)
    );
  }
  _listenToOutsideClick() {
    this._outsideClick = this._handleOutSideClick.bind(this), u.on(document, "click", this._outsideClick);
  }
  _listenToFocusChange(t = !0) {
    if (t === !1) {
      u.remove(
        this._input,
        "focus",
        () => this._notch.setAttribute(Wt, "")
      ), u.remove(
        this._input,
        "blur",
        () => this._notch.removeAttribute(Wt)
      );
      return;
    }
    u.on(
      this._input,
      "focus",
      () => this._notch.setAttribute(Wt, "")
    ), u.on(
      this._input,
      "blur",
      () => this._notch.removeAttribute(Wt)
    );
  }
  _handleOutSideClick(t) {
    const e = this._wrapper && this._wrapper.contains(t.target), i = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
    let o;
    this._toggleButton || (this._elementToggle = h.find(Pm)), this._elementToggle && this._elementToggle.forEach((r) => {
      const a = p.getDataAttribute(
        r,
        "select-toggle"
      );
      (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));
    }), !e && !i && !n && !o && this.close();
  }
  close() {
    const t = u.trigger(this._element, Am);
    !this._isOpen || t.defaultPrevented || (this._config.selectFilter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), this.dropdown.removeAttribute(la), setTimeout(() => {
      this._input.removeAttribute(Wt), this._input.blur(), h.findOne(kn, this._wrapper).removeAttribute(
        Wt
      ), this._label && !this.hasSelection && (this._label.removeAttribute(q), this._notch.setAttribute(q, ""), this._input.removeAttribute(q), this._notch.removeAttribute(q)), this._updateLabelPositionWhileClosing();
    }, 0), setTimeout(() => {
      this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, u.off(this.dropdown, "transitionend");
    }, Hm));
  }
  _resetFilterState() {
    this.filterInput.value = "", this._filteredOptionsList = null;
  }
  _removeDropdownEvents() {
    u.off(document, "click", this._outsideClick), this._config.selectFilter && u.off(this.dropdown, "keydown"), u.off(this.optionsWrapper, "click");
  }
  _addMutationObserver() {
    this._mutationObserver = new MutationObserver(() => {
      this._wrapper && (this._updateSelections(), this._updateDisabledState());
    }), this._observeMutationObserver();
  }
  _updateSelections() {
    this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();
    const t = this._config.filter && this.filterInput && this.filterInput.value;
    this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = na(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    );
  }
  _updateDisabledState() {
    const t = h.findOne(ca, this._wrapper);
    this._element.hasAttribute("disabled") ? (this._config.disabled = !0, t.setAttribute("disabled", ""), t.setAttribute(wn, "")) : (this._config.disabled = !1, t.removeAttribute("disabled"), t.removeAttribute(wn));
  }
  _observeMutationObserver() {
    this._mutationObserver && this._mutationObserver.observe(this._element, {
      attributes: !0,
      childList: !0,
      characterData: !0,
      subtree: !0
    });
  }
  _disconnectMutationObserver() {
    this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);
  }
  _createSelectAllOption() {
    const t = this._selectAllId, e = null, i = !0, n = "select-all", o = this._config.selectAllLabel, r = jn(this.options), a = !1, l = !1, c = null, d = null, _ = null;
    return new sa(
      t,
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      c,
      d,
      _
    );
  }
  dispose() {
    this._removeComponentEvents(), this._destroyMaterialSelect(), this._listenToFocusChange(!1), I.removeData(this._element, ri);
  }
  _removeComponentEvents() {
    u.off(this.input, "click"), u.off(this.wrapper, this._handleKeydown.bind(this)), u.off(this.clearButton, "click"), u.off(this.clearButton, "keydown"), u.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _destroyMaterialSelect() {
    this._isOpen && this.close(), this._destroyMaterialTemplate();
  }
  _destroyMaterialTemplate() {
    const t = this._wrapper.parentNode, e = h.find("label", this._wrapper);
    t.appendChild(this._element), e.forEach((i) => {
      t.appendChild(i);
    }), e.forEach((i) => {
      i.removeAttribute(q);
    }), p.removeClass(this._element, this._classes.initialized), this._element.removeActiveStyles(aa), t.removeChild(this._wrapper);
  }
  setValue(t) {
    this.options.filter((i) => i.selected).forEach((i) => i.nativeOption.selected = !1), Array.isArray(t) ? t.forEach((i) => {
      this._selectByValue(i);
    }) : this._selectByValue(t), this._updateSelections();
  }
  _selectByValue(t) {
    const e = this.options.find(
      (i) => i.value === t
    );
    return e ? (e.nativeOption.selected = !0, !0) : !1;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, ri);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new Nl(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, ri);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Ym = (s) => {
  Aa(() => {
    const t = Ca();
    if (t) {
      const e = s.NAME, i = t.fn[e];
      t.fn[e] = s.jQueryInterface, t.fn[e].Constructor = s, t.fn[e].noConflict = () => (t.fn[e] = i, s.jQueryInterface);
    }
  });
}, jm = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      e.preventDefault(), s.getOrCreateInstance(this).toggle();
    }
  );
}, Km = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), ue(this))
        return;
      s.getOrCreateInstance(this).show();
    }
  );
}, Um = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      const i = Xt(this);
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), ue(this))
        return;
      u.one(i, s.EVENT_HIDDEN, () => {
        St(this) && this.focus();
      });
      const n = h.findOne(s.OPEN_SELECTOR);
      n && n !== i && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, zm = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}`,
    t,
    (e) => {
      e.preventDefault();
      const i = e.target.closest(t);
      s.getOrCreateInstance(i).toggle();
    }
  );
}, Xm = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      const i = Xt(this);
      ["A", "AREA"].includes(this.tagName) && e.preventDefault(), u.one(i, s.EVENT_SHOW, (r) => {
        r.defaultPrevented || u.one(i, s.EVENT_HIDDEN, () => {
          St(this) && this.focus();
        });
      });
      const n = h.findOne(
        `[${s.OPEN_SELECTOR}="true"]`
      );
      n && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, Gm = (s, t) => {
  u.one(
    document,
    "mousedown",
    t,
    s.autoInitial(new s())
  );
}, qm = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      (e.target.tagName === "A" || e.delegateTarget && e.delegateTarget.tagName === "A") && e.preventDefault();
      const i = Xn(this);
      h.find(i).forEach((o) => {
        s.getOrCreateInstance(o, { toggle: !1 }).toggle();
      });
    }
  );
}, Ft = {
  plugins: {
    legend: {
      labels: {
        color: "rgb(102,102,102)"
      }
    }
  }
}, gs = {
  line: {
    options: {
      ...Ft,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.0)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bar: {
    options: {
      ...Ft,
      backgroundColor: "rgb(59, 112, 202)",
      borderWidth: 0,
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !0,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  pie: {
    options: {
      ...Ft,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  doughnut: {
    options: {
      ...Ft,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  polarArea: {
    options: {
      ...Ft,
      elements: {
        arc: { backgroundColor: "rgba(59, 112, 202, 0.5)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  radar: {
    options: {
      ...Ft,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  scatter: {
    options: {
      ...Ft,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bubble: {
    options: {
      ...Ft,
      elements: {
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      scales: {
        x: {
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  }
}, Qm = (s, t) => {
  const e = (o) => o[0] === "{" && o[o.length - 1] === "}" || o[0] === "[" && o[o.length - 1] === "]", i = (o) => typeof o != "string" ? o : e(o) ? JSON.parse(o.replace(/'/g, '"')) : o, n = (o) => {
    const r = {};
    return Object.keys(o).forEach((a) => {
      if (a.match(/dataset.*/)) {
        const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));
        r[l] = i(o[a]);
      }
    }), r;
  };
  h.find(t).forEach((o) => {
    if (p.getDataAttribute(o, "chart") !== "bubble" && p.getDataAttribute(o, "chart") !== "scatter") {
      const r = p.getDataAttributes(o), a = {
        data: {
          datasets: [n(r)]
        }
      };
      return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '"'))), new s(o, {
        ...a,
        ...gs[a.type]
      });
    }
    return null;
  });
}, ai = {
  alert: {
    name: "Alert",
    selector: "[data-te-alert-init]",
    isToggler: !1
  },
  animation: {
    name: "Animate",
    selector: "[data-te-animation-init]",
    isToggler: !1
  },
  carousel: {
    name: "Carousel",
    selector: "[data-te-carousel-init]",
    isToggler: !1
  },
  chips: {
    name: "ChipsInput",
    selector: "[data-te-chips-init]",
    isToggler: !1
  },
  chip: {
    name: "Chip",
    selector: "[data-te-chip-init]",
    isToggler: !1
  },
  datepicker: {
    name: "Datepicker",
    selector: "[data-te-datepicker-init]",
    isToggler: !1
  },
  input: {
    name: "Input",
    selector: "[data-te-input-wrapper-init]",
    isToggler: !1
  },
  scrollspy: {
    name: "ScrollSpy",
    selector: "[data-te-spy='scroll']",
    isToggler: !1
  },
  select: {
    name: "Select",
    selector: "[data-te-select-init]",
    isToggler: !1
  },
  sidenav: {
    name: "Sidenav",
    selector: "[data-te-sidenav-init]",
    isToggler: !1
  },
  stepper: {
    name: "Stepper",
    selector: "[data-te-stepper-init]",
    isToggler: !1
  },
  timepicker: {
    name: "Timepicker",
    selector: "[data-te-timepicker-init]",
    isToggler: !1
  },
  toast: {
    name: "Toast",
    selector: "[data-te-toast-init]",
    isToggler: !1
  },
  // advancedInits
  chart: {
    name: "Chart",
    selector: "[data-te-chart]",
    isToggler: !1,
    advanced: Qm
  },
  // togglers
  button: {
    name: "Button",
    selector: "[data-te-toggle='button']",
    isToggler: !0,
    callback: zm
  },
  collapse: {
    name: "Collapse",
    selector: "[data-te-collapse-init]",
    isToggler: !0,
    callback: qm
  },
  dropdown: {
    name: "Dropdown",
    selector: "[data-te-dropdown-toggle-ref]",
    isToggler: !0,
    callback: jm
  },
  modal: {
    name: "Modal",
    selector: "[data-te-toggle='modal']",
    isToggler: !0,
    callback: Xm
  },
  ripple: {
    name: "Ripple",
    selector: "[data-te-ripple-init]",
    isToggler: !0,
    callback: Gm
  },
  offcanvas: {
    name: "Offcanvas",
    selector: "[data-te-offcanvas-toggle]",
    isToggler: !0,
    callback: Um
  },
  tab: {
    name: "Tab",
    selector: "[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']",
    isToggler: !0,
    callback: Km
  }
}, Zm = (s) => ai[s.NAME] || null, Jm = (s) => {
  if (!s || [].includes(s.NAME))
    return;
  [].push(s.NAME);
  const t = Zm(s), e = (t == null ? void 0 : t.isToggler) || !1;
  if (Ym(s), t != null && t.advanced) {
    t == null || t.advanced(s, t == null ? void 0 : t.selector);
    return;
  }
  if (e) {
    t == null || t.callback(s, t == null ? void 0 : t.selector);
    return;
  }
  h.find(t == null ? void 0 : t.selector).forEach((i) => {
    let n = s.getInstance(i);
    n || (n = new s(i));
  });
}, tg = (s) => {
  s.forEach((t) => Jm(t));
}, eg = (s, t = !1) => {
  const e = Object.keys(ai).map((i) => {
    if (!!document.body.querySelector(ai[i].selector)) {
      const o = s[ai[i].name];
      return !o && ![].includes(i) && t && console.warn(
        `Please import ${ai[i].name} from "tw-elements" package and add it to a object parameter inside "initTE" function`
      ), o;
    }
  });
  tg(e);
}, ig = ({ inputID: s, labelText: t }, e) => (eg({ Input: V }, !1), `<div data-te-chips-input-wrapper data-te-input-wrapper-init class="${e.chipsInputWrapper}">
      <input
          type="text"
          class="${e.chipsInput}"
          id="${s}"
          placeholder="Example label" />
        <label
          for="${s}"
          class="${e.chipsLabel}"
          >${t}
        </label>

        <div data-te-input-notch-ref class="${e.chipsNotchesWrapper}">
        <div class="${e.chipsNotchesLeading}" data-te-input-notch-leading-ref style="width: 9px;"></div>
        <div class="${e.chipsNotchesMiddle}" data-te-input-notch-middle-ref style="width: 87.2px;"></div>
        <div class="${e.chipsNotchesTrailing}" data-te-input-notch-trailing-ref></div>
      </div>
    </div>`), sg = ({ text: s, iconSVG: t }, e) => `<div data-te-chip-init data-te-ripple-init class="${e.chipElement}">
    <span data-te-chip-text>${s}</span> 
      <span data-te-chip-close class="${e.chipCloseIcon}">
        ${t}
      </span>
  </div>`, bs = "chip", ng = `te.${bs}`, Rl = "data-te-chip-close", On = `[${Rl}]`, og = "delete.te.chips", rg = "select.te.chip", ag = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3 h-3"> <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>', lg = {
  text: "string",
  closeIcon: "boolean",
  img: "object",
  iconSVG: "string"
}, cg = {
  text: "",
  closeIcon: !1,
  img: { path: "", alt: "" },
  iconSVG: ag
}, dg = {
  icon: "float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out",
  chipElement: "flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded",
  chipCloseIcon: "w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out"
}, hg = {
  icon: "string",
  chipElement: "string",
  chipCloseIcon: "string"
};
class ii {
  constructor(t, e = {}, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i);
  }
  // Getters
  static get NAME() {
    return bs;
  }
  // Public
  init() {
    this._appendCloseIcon(), this._handleDelete(), this._handleTextChip(), this._handleClickOnChip();
  }
  dispose() {
    this._element = null, this._options = null, u.off(this._element, "click");
  }
  appendChip() {
    const { text: t, closeIcon: e, iconSVG: i } = this._options;
    return sg({ text: t, closeIcon: e, iconSVG: i }, this._classes);
  }
  // Private
  _appendCloseIcon(t = this._element) {
    if (!(h.find(On, this._element).length > 0) && this._options.closeIcon) {
      const e = M("span");
      e.classList = this._classes.icon, e.setAttribute(Rl), e.innerHTML = this._options.iconSVG, t.insertAdjacentElement("beforeend", e);
    }
  }
  _handleClickOnChip() {
    u.on(this._element, "click", (t) => {
      const { textContent: e } = t.target, i = {};
      i.tag = e.trim(), u.trigger(rg, { event: t, obj: i });
    });
  }
  _handleDelete() {
    h.find(
      On,
      this._element
    ).length !== 0 && u.on(this._element, "click", On, () => {
      u.trigger(this._element, og), this._element.remove();
    });
  }
  _handleTextChip() {
    this._element.innerText === "" && (this._element.innerText = this._options.text);
  }
  _getConfig(t) {
    const e = {
      ...cg,
      ...p.getDataAttributes(this._element),
      ...t
    };
    return N(bs, e, lg), e;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...dg,
      ...e,
      ...t
    }, N(bs, t, hg), t;
  }
  static getInstance(t) {
    return I.getData(t, ng);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const ui = "chips", yi = `data-te-${ui}`, ua = `te.${ui}`, ug = `${yi}-init`, ft = `${yi}-active`, pa = `${yi}-initial`, Pl = `${yi}-placeholder`, pg = `${yi}-input-wrapper`, Kn = "data-te-chip-init", Hl = "data-te-chip-close", Bl = "data-te-chip-text", fg = `[${ft}]`, Un = `[${Kn}]`, _g = `${Un}${fg}`, xn = `[${Hl}]`, mg = `[${pg}]`, gg = `[${Bl}]`, bg = `[${Pl}]`, vg = "data-te-input-notch-leading-ref", Eg = "data-te-input-notch-middle-ref", Tg = `[${vg}]`, Cg = `[${Eg}]`, Ae = "data-te-input-state-active", Sn = "[data-te-input-notch-ref]", Ag = "add.te.chips", yg = "arrowDown.te.chips", wg = "arrowLeft.te.chips", kg = "arrowRight.te.chips", Og = "arrowUp.te.chips", fa = "delete.te.chips", _a = "select.te.chips", xg = {
  inputID: "string",
  parentSelector: "string",
  initialValues: "array",
  editable: "boolean",
  labelText: "string"
}, Sg = {
  inputID: Ot("chips-input-"),
  parentSelector: "",
  initialValues: [{ tag: "init1" }, { tag: "init2" }],
  editable: !1,
  labelText: "Example label"
}, Dg = {
  opacity: "opacity-0",
  inputWrapperPadding: "p-[5px]",
  transition: "transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  contentEditable: "outline-none !border-[3px] !border-solid !border-[#b2b3b4]",
  chipsInputWrapper: "relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  chipsInput: "peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0",
  chipsLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200",
  chipsNotchesWrapper: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
  chipsNotchesLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  chipsNotchesMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  chipsNotchesTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary"
}, Ig = {
  opacity: "string",
  inputWrapperPadding: "string",
  transition: "string",
  contentEditable: "string",
  chipsInputWrapper: "string",
  chipsInput: "string",
  chipsLabel: "string",
  chipsNotchesWrapper: "string",
  chipsNotchesLeading: "string",
  chipsNotchesMiddle: "string",
  chipsNotchesTrailing: "string"
};
class Zg extends ii {
  constructor(e, i = {}, n) {
    super(e, i);
    Tt(this, "_handleBlurInput", ({ target: e }) => {
      e.value.length > 0 && this._handleCreateChip(e, e.value), this.allChips.length > 0 ? (e.setAttribute(ft, ""), this.input.setAttribute(Ae, ""), h.findOne(
        Sn,
        this.input.parentNode
      ).setAttribute(Ae, ""), this.chipsInputWrapper.classList.add(
        ...this._classes.inputWrapperPadding.split(" ")
      )) : (e.removeAttribute(ft), this.input.removeAttribute(Ae), h.findOne(
        Sn,
        this.input.parentNode
      ).removeAttribute(Ae), this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      )), this.allChips.forEach((i) => i.removeAttribute(ft));
    });
    this._element = e, this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._element && I.setData(e, ua, this), this._options = this._getConfig(i), this._classes = this._getClasses(n), this.numberClicks = 0, this.init();
  }
  // Getters
  static get NAME() {
    return ui;
  }
  get activeChip() {
    return h.findOne(_g, this._element);
  }
  get input() {
    return h.findOne("input", this._element);
  }
  get allChips() {
    return h.find(Un, this._element);
  }
  get chipsInputWrapper() {
    return h.findOne(mg, this._element);
  }
  // Public
  init() {
    this._setChipsClass(), this._appendInputToElement(Pl), this._handleInitialValue(), this._handleInputText(), this._handleKeyboard(), this._handleChipsOnSelect(), this._handleEditable(), this._handleChipsFocus(), this._handleClicksOnChips(), this._getLabelData(), this._getLabelWidth(), this._getNotchData(), this._applyNotch();
  }
  dispose() {
    this._element = null, this._options = null;
  }
  // Private
  _getNotchData() {
    this._notchMiddle = h.findOne(
      Cg,
      this._element
    ), this._notchLeading = h.findOne(
      Tg,
      this._element
    );
  }
  _getLabelData() {
    this._label = h.findOne("label", this._element);
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
  }
  _setChipsClass() {
    this._element.setAttribute(ug, "");
  }
  _handleDeleteEvents(e) {
    const [i] = this.allChips.slice(-1);
    if (this.activeChip === null)
      i.remove(), this._handleEvents(e, fa);
    else {
      const n = this.allChips.findIndex((a) => a === this.activeChip), o = this._handleActiveChipAfterRemove(n), r = [];
      if (this.activeChip === null)
        return;
      this.activeChip.remove(), this._handleEvents(e, fa), this.numberClicks = n, o.setAttribute(ft, ""), this.allChips.forEach((a) => {
        a.hasAttribute(ft) && (r.push(a), r.length > 1 && this.allChips.forEach((l) => l.remove()));
      });
    }
  }
  _handleUpEvents(e) {
    this.numberClicks += 1, this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0), this._handleRightKeyboardArrow(this.numberClicks), this._handleEvents(e, kg), this._handleEvents(e, Og);
  }
  _handleDownEvents(e) {
    this.numberClicks -= 1, this.numberClicks <= 0 && (this.numberClicks = this.allChips.length), this._handleLeftKeyboardArrow(this.numberClicks), this._handleEvents(e, wg), this._handleEvents(e, yg);
  }
  _keyboardEvents(e) {
    const { target: i, keyCode: n, ctrlKey: o } = e;
    i.value.length > 0 || this.allChips.length === 0 || (n === Xp || n === Gp ? this._handleDeleteEvents(e) : n === $e || n === rt ? this._handleUpEvents(e) : n === Ie || n === U ? this._handleDownEvents(e) : n === 65 && o && this._handleAddActiveClass());
  }
  _handleKeyboard() {
    u.on(
      this.input,
      "keydown",
      (e) => this._keyboardEvents(e)
    );
  }
  _handleEditable() {
    const { editable: e } = this._options;
    e && this.allChips.forEach((i) => {
      u.on(i, "dblclick", (n) => {
        const o = h.findOne(xn, i);
        i.classList.add(...this._classes.contentEditable.split(" ")), i.contentEditable = !0, i.focus(), setTimeout(() => {
          p.addStyle(o, { display: "none" });
        }, 200), o.classList.add(...this._classes.opacity.split(" ")), n.target.textContent, u.trigger(i, _a, {
          event: n,
          allChips: this.allChips
        });
      }), u.on(document, "click", ({ target: n }) => {
        const o = h.findOne(xn, i), r = h.findOne(gg, i), a = n === i, l = i && i.contains(n);
        !a && !l && (i.contentEditable = !1, i.classList.remove(...this._classes.contentEditable.split(" ")), r.textContent !== "" && setTimeout(() => {
          p.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
        }, 160)), r.textContent === "" && (setTimeout(() => {
          i.classList.add(...this._classes.opacity.split(" "));
        }, 200), setTimeout(() => {
          i.remove();
        }, 300));
      });
    });
  }
  _handleRemoveActiveClass() {
    this.allChips.forEach((e) => e.removeAttribute(ft));
  }
  _handleAddActiveClass() {
    this.allChips.forEach((e) => e.setAttribute(ft, ""));
  }
  _handleRightKeyboardArrow(e) {
    this._handleRemoveActiveClass(), e === 0 && (e = 1), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleLeftKeyboardArrow(e) {
    this._handleRemoveActiveClass(), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleActiveChipAfterRemove(e) {
    const i = e === 0 ? 1 : e - 1;
    return this.allChips[i];
  }
  _handleClicksOnChips() {
    u.on(this._element, "click", () => {
      this.allChips.length === 0 && (this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      ), this.input.removeAttribute(ft));
    });
  }
  _handleTextContent() {
    const e = [];
    return this.allChips.forEach((i) => e.push({ tag: i.textContent.trim() })), e;
  }
  _handleEvents(e, i) {
    const n = this._handleTextContent(), o = this.allChips.filter(
      (r) => r.hasAttribute(ft) && r
    );
    u.trigger(this._element, i, {
      event: e,
      allChips: this.allChips,
      arrOfObjects: n,
      active: o,
      activeObj: {
        tag: o.length <= 0 ? "" : o[0].textContent.trim()
      }
    });
  }
  _handleChipsFocus() {
    u.on(this._element, "click", ({ target: { attributes: e } }) => {
      const i = [...e];
      i.includes(Kn) || i.includes(Hl) || i.includes(Bl) || this.input.focus();
    });
  }
  _handleInitialValue() {
    if (this._appendInputToElement(pa), this._element.hasAttribute(pa)) {
      const { initialValues: e } = this._options;
      e.forEach(
        ({ tag: i }) => this._handleCreateChip(this.input, i)
      ), h.findOne(
        Sn,
        this.input.parentNode
      ).setAttribute(Ae, ""), this.input.setAttribute(ft, ""), this.input.setAttribute(Ae, "");
    }
    this.allChips.length > 0 && (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    ));
  }
  _handleKeysInputToElement(e) {
    const { keyCode: i, target: n } = e;
    if (n.hasAttribute(Kn)) {
      const o = h.findOne(xn, n);
      i === lt && (n.contentEditable = !1, n.classList.remove(...this._classes.contentEditable.split(" ")), n.textContent !== "" ? setTimeout(() => {
        p.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
      }, 160) : n.textContent === "" && (setTimeout(() => {
        n.classList.add(...this._classes.opacity.split(" "));
      }, 200), setTimeout(() => {
        n.remove();
      }, 300)));
      return;
    }
    if (i === lt) {
      if (n.value === "")
        return;
      this._handleCreateChip(n, n.value), this._handleRemoveActiveClass(), this.numberClicks = this.allChips.length + 1, this._handleEvents(e, Ag);
    }
    this.allChips.length > 0 ? (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    )) : this.chipsInputWrapper.classList.remove(
      ...this._classes.inputWrapperPadding.split(" ")
    );
  }
  _handleInputText() {
    const e = h.findOne(
      bg,
      this._element
    );
    u.on(
      this._element,
      "keyup",
      e,
      (i) => this._handleKeysInputToElement(i)
    ), u.on(this.input, "blur", (i) => this._handleBlurInput(i));
  }
  _appendInputToElement(e) {
    if (!this._element.hasAttribute(e))
      return;
    const i = ig(this._options, this._classes);
    this._element.insertAdjacentHTML("beforeend", i);
  }
  _handleCreateChip(e, i) {
    const n = M("div"), o = ii.getInstance(n), r = new ii(o, { text: i }, this._classes);
    this._options.parentSelector !== "" ? document.querySelector(this._options.parentSelector).insertAdjacentHTML("beforeend", r.appendChip()) : e.insertAdjacentHTML("beforebegin", r.appendChip()), e.value = "", h.find(Un).forEach((a) => {
      let l = ii.getInstance(a);
      return l || (l = new ii(a, {}, this._classes)), l.init();
    }), this._handleEditable();
  }
  _handleChipsOnSelect() {
    this.allChips.forEach((e) => {
      u.on(this._element, "click", (i) => {
        u.trigger(e, _a, {
          event: i,
          allChips: this.allChips
        });
      });
    });
  }
  _handleAddActiveClassWithKebyboard(e) {
    let i;
    this.allChips[e - 1] === void 0 ? i = this.allChips[e - 2] : i = this.allChips[e - 1], i.setAttribute(ft);
  }
  _getConfig(e) {
    const i = {
      ...Sg,
      ...p.getDataAttributes(this._element),
      ...e
    };
    return N(ui, i, xg), i;
  }
  _getClasses(e) {
    const i = p.getDataClassAttributes(this._element);
    return e = {
      ...Dg,
      ...i,
      ...e
    }, N(ui, e, Ig), e;
  }
  static getInstance(e) {
    return I.getData(e, ua);
  }
  static getOrCreateInstance(e, i = {}) {
    return this.getInstance(e) || new this(e, typeof i == "object" ? i : null);
  }
}
var $g = function(t) {
  return Lg(t) && !Mg(t);
};
function Lg(s) {
  return !!s && typeof s == "object";
}
function Mg(s) {
  var t = Object.prototype.toString.call(s);
  return t === "[object RegExp]" || t === "[object Date]" || Pg(s);
}
var Ng = typeof Symbol == "function" && Symbol.for, Rg = Ng ? Symbol.for("react.element") : 60103;
function Pg(s) {
  return s.$$typeof === Rg;
}
function Hg(s) {
  return Array.isArray(s) ? [] : {};
}
function _i(s, t) {
  return t.clone !== !1 && t.isMergeableObject(s) ? We(Hg(s), s, t) : s;
}
function Bg(s, t, e) {
  return s.concat(t).map(function(i) {
    return _i(i, e);
  });
}
function Vg(s, t) {
  if (!t.customMerge)
    return We;
  var e = t.customMerge(s);
  return typeof e == "function" ? e : We;
}
function Wg(s) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(s).filter(function(t) {
    return Object.propertyIsEnumerable.call(s, t);
  }) : [];
}
function ma(s) {
  return Object.keys(s).concat(Wg(s));
}
function Vl(s, t) {
  try {
    return t in s;
  } catch {
    return !1;
  }
}
function Fg(s, t) {
  return Vl(s, t) && !(Object.hasOwnProperty.call(s, t) && Object.propertyIsEnumerable.call(s, t));
}
function Yg(s, t, e) {
  var i = {};
  return e.isMergeableObject(s) && ma(s).forEach(function(n) {
    i[n] = _i(s[n], e);
  }), ma(t).forEach(function(n) {
    Fg(s, n) || (Vl(s, n) && e.isMergeableObject(t[n]) ? i[n] = Vg(n, e)(s[n], t[n], e) : i[n] = _i(t[n], e));
  }), i;
}
function We(s, t, e) {
  e = e || {}, e.arrayMerge = e.arrayMerge || Bg, e.isMergeableObject = e.isMergeableObject || $g, e.cloneUnlessOtherwiseSpecified = _i;
  var i = Array.isArray(t), n = Array.isArray(s), o = i === n;
  return o ? i ? e.arrayMerge(s, t, e) : Yg(s, t, e) : _i(t, e);
}
We.all = function(t, e) {
  if (!Array.isArray(t))
    throw new Error("first argument should be an array");
  return t.reduce(function(i, n) {
    return We(i, n, e);
  }, {});
};
var jg = We, zn = jg;
const ga = "chart", is = "te.chart", Kg = "chart", ba = (s, t, e) => {
  const i = (n, o, r) => {
    const a = n.slice();
    return o.forEach((l, c) => {
      typeof a[c] > "u" ? a[c] = r.cloneUnlessOtherwiseSpecified(
        l,
        r
      ) : r.isMergeableObject(l) ? a[c] = zn(n[c], l, r) : n.indexOf(l) === -1 && a.push(l);
    }), a;
  };
  return zn(e[t], s, {
    arrayMerge: i
  });
}, Ug = {
  darkTicksColor: "#fff",
  darkLabelColor: "#fff",
  darkGridLinesColor: "#555",
  darkmodeOff: "undefined",
  darkBgColor: "#262626",
  options: null
}, zg = {
  darkTicksColor: "string",
  darkLabelColor: "string",
  darkGridLinesColor: "string",
  darkmodeOff: "(string|null)",
  darkBgColor: "string",
  options: "(object|null)"
};
class Wl {
  constructor(t, e, i = {}, n = {}) {
    this._waitForCharts(t, e, i, n);
  }
  async _getChartjs() {
    const {
      Chart: t,
      ArcElement: e,
      LineElement: i,
      BarElement: n,
      PointElement: o,
      BarController: r,
      BubbleController: a,
      DoughnutController: l,
      LineController: c,
      PieController: d,
      PolarAreaController: _,
      RadarController: f,
      ScatterController: m,
      CategoryScale: g,
      LinearScale: b,
      LogarithmicScale: T,
      RadialLinearScale: C,
      TimeScale: w,
      TimeSeriesScale: v,
      Decimation: E,
      Filler: A,
      Legend: y,
      Title: S,
      Tooltip: O,
      SubTitle: k
    } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_tw-elements_dist_js_chart_es_js").then(__webpack_require__.bind(__webpack_require__, /*! ./chart.es.js */ "./node_modules/tw-elements/dist/js/chart.es.js")).then((D) => D.f);
    return t.register(
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      c,
      d,
      _,
      f,
      m,
      g,
      b,
      T,
      C,
      w,
      v,
      E,
      A,
      y,
      S,
      O,
      k
    ), t;
  }
  async _getChartDataLabels() {
    const { ChartDataLabels: t } = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_tw-elements_dist_js_chart_es_js"), __webpack_require__.e("vendors-node_modules_tw-elements_dist_js_chartjs-plugin-datalabels_es_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./chartjs-plugin-datalabels.es.js */ "./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js"));
    return t;
  }
  async _waitForCharts(t, e, i = {}, n = {}) {
    this._Chartjs = await this._getChartjs(), this._ChartDataLabels = await this._getChartDataLabels(), this._element = t, this._data = e, this._options = i, this._type = e.type, this._canvas = null, this._chart = null, this._darkOptions = this._getDarkConfig(n), this._darkModeClassContainer = document.querySelector("html"), this._prevConfig = null, this._observer = null, this._element && (I.setData(t, is, this), p.addClass(this._element, Kg), this._chartConstructor()), this._darkOptions.darkmodeOff !== null && (this._handleMode(this.systemColorMode), this._observer = new MutationObserver(this._observerCallback.bind(this)), this._observer.observe(this._darkModeClassContainer, {
      attributes: !0
    }));
  }
  // Getters
  static get NAME() {
    return ga;
  }
  get systemColorMode() {
    return localStorage.theme || (this._darkModeClassContainer.classList.contains("dark") ? "dark" : "light");
  }
  // Public
  dispose() {
    this._observer.disconnect(), I.removeData(this._element, is), this._element = null;
  }
  update(t, e) {
    t && (this._data = { ...this._data, ...t }, this._chart.data = this._data), this._prevConfig = this._chart.options, this._options = { ...this._options, ...e }, this._chart.options = zn(this._chart.options, this._options), this._chart.update();
  }
  // Private
  _getDarkConfig(t) {
    let e = {};
    const i = p.getDataAttributes(this._element);
    Object.keys(i).forEach(
      (c) => c.startsWith("dark") && (e[c] = i[c])
    ), e = {
      ...Ug,
      ...e
    };
    const n = {
      y: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      },
      x: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      }
    }, o = {
      r: {
        ticks: {
          color: e.darkTicksColor,
          backdropColor: e.darkBgColor
        },
        grid: {
          color: e.darkGridLinesColor
        },
        pointLabels: {
          color: e.darkTicksColor
        }
      }
    }, l = {
      scales: ["pie", "doughnut", "polarArea", "radar"].includes(this._type) ? ["polarArea", "radar"].includes(this._type) ? o : {} : n,
      plugins: {
        legend: {
          labels: {
            color: e.darkLabelColor
          }
        }
      }
    };
    return t = {
      ...e,
      options: {
        ...l
      },
      ...t
    }, N(ga, t, zg), t;
  }
  _chartConstructor() {
    if (this._data) {
      this._createCanvas();
      const t = ba(this._options, this._type, gs), e = [];
      t.dataLabelsPlugin && e.push(this._ChartDataLabels), this._chart = new this._Chartjs(this._canvas, {
        ...this._data,
        ...t,
        plugins: e
      });
    }
  }
  _createCanvas() {
    this._canvas || (this._element.nodeName === "CANVAS" ? this._canvas = this._element : (this._canvas = M("canvas"), this._element.appendChild(this._canvas)));
  }
  _handleMode(t) {
    t === "dark" ? (this._changeDatasetBorderColor(), this.update(null, this._darkOptions.options)) : (this._changeDatasetBorderColor(!1), this._prevConfig && this.update(null, this._prevConfig));
  }
  _observerCallback(t) {
    for (const e of t)
      e.type === "attributes" && this._handleMode(this.systemColorMode);
  }
  _changeDatasetBorderColor(t = !0) {
    [...this._data.data.datasets].forEach(
      (e) => ["pie", "doughnut", "polarArea"].includes(this._type) && (e.borderColor = t ? this._darkOptions.darkBgColor : "#fff")
    );
  }
  static jQueryInterface(t, e, i) {
    return this.each(function() {
      let n = I.getData(this, is);
      if (!(!n && /dispose/.test(t))) {
        if (!n) {
          const o = e ? ba(e, i, gs) : gs[i];
          n = new Wl(this, {
            ...t,
            ...o
          });
        }
        if (typeof t == "string") {
          if (typeof n[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          n[t](e, i);
        }
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, is);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}

//# sourceMappingURL=tw-elements.es.min.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "js/" + chunkId + ".inbound_order.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "static:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkstatic"] = self["webpackChunkstatic"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/inbound_order/inbound_order.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQVM7QUFDNUIsa0NBQWtDLHlEQUFVO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixzREFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQywwREFBVyxDQUFDLDBEQUFjO0FBQy9EO0FBQ0E7QUFDQSxH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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFB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QUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtDQUFrQztBQUNyRiwwREFBMEQsa0NBQWtDO0FBQzVGO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpQ0FBaUM7QUFDbkYseURBQXlELGlDQUFpQztBQUMxRjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlFQUFlLEtBQUssRUFBQztBQUNyQjs7Ozs7Ozs7Ozs7QUM1UVU7QUFDVjs7Ozs7Ozs7Ozs7QUNEVTtBQUNWOzs7Ozs7Ozs7Ozs7Ozs7O0FDREEsZ0JBQWdCLFNBQUksSUFBSSxTQUFJO0FBQzVCO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFJLElBQUksU0FBSTtBQUNqQyw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG9DQUFvQztBQUNwQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsNERBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsNEJBQTRCLGNBQWM7QUFDdkcsa0JBQWtCLHVDQUF1QztBQUN6RCx1QkFBdUIsS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsNEJBQTRCLGNBQWM7QUFDdkcsa0JBQWtCLHdDQUF3QztBQUMxRCx1QkFBdUIsS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUVBQWUsT0FBTyxFQUFDO0FBQ3ZCOzs7Ozs7Ozs7OztBQ3hOVTtBQUNWOzs7Ozs7Ozs7OztBQ0RVO0FBQ1Y7Ozs7Ozs7Ozs7Ozs7OztBQ0RBLGdCQUFnQixTQUFJLElBQUksU0FBSTtBQUM1QjtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGlFQUFlLElBQUksRUFBQztBQUNwQjs7Ozs7Ozs7Ozs7QUM3R1U7QUFDVjs7Ozs7Ozs7Ozs7QUNEVTtBQUNWOzs7Ozs7Ozs7Ozs7Ozs7O0FDREEsZ0JBQWdCLFNBQUksSUFBSSxTQUFJO0FBQzVCO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFJLElBQUksU0FBSTtBQUNqQyw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLDREQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCw0QkFBNEIsY0FBYztBQUN2RyxrQkFBa0IsdUNBQXVDO0FBQ3pELHVCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCw0QkFBNEIsY0FBYztBQUN2RyxrQkFBa0Isd0NBQXdDO0FBQzFELHVCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlFQUFlLE9BQU8sRUFBQztBQUN2Qjs7Ozs7Ozs7Ozs7QUN0TVU7QUFDVjs7Ozs7Ozs7Ozs7QUNEVTtBQUNWOzs7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pCa0M7QUFDc0I7QUFDRjtBQUNBO0FBQ0Q7QUFDQztBQUNOO0FBQ0U7QUFDTDtBQUNPO0FBQ0E7QUFDTjtBQUM5QztBQUNBLGlCQUFpQixtREFBTTtBQUN2QixJQUFJLGlFQUFjO0FBQ2xCLElBQUksK0RBQWE7QUFDakIsSUFBSSwrREFBYTtBQUNqQixJQUFJLDhEQUFhO0FBQ2pCLElBQUksK0RBQWE7QUFDakIsSUFBSSx5REFBVTtBQUNkLElBQUksMkRBQVc7QUFDZixJQUFJLHNEQUFRO0FBQ1osSUFBSSw2REFBWTtBQUNoQixJQUFJLDhEQUFZO0FBQ2hCLElBQUksd0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDOEQ7QUFDRjtBQUNBO0FBQ1I7QUFDTTtBQUNGO0FBQ0k7QUFDTjtBQUNJO0FBQ047QUFDTTtBQUMxRDtBQUM2QztBQUNEO0FBQ0E7QUFDSjtBQUNHO0FBQ0Q7QUFDRTtBQUNIO0FBQ0U7QUFDSDtBQUNHO0FBQzNDO0FBQ2lEO0FBQ0Q7QUFDQTtBQUNKO0FBQ0c7QUFDRDtBQUNFO0FBQ0g7QUFDRTtBQUNIO0FBQ0c7QUFDL0M7QUFDd0Q7QUFDRjtBQUNBO0FBQ1I7QUFDTztBQUNIO0FBQ0k7QUFDTjtBQUNJO0FBQ1A7QUFDTztBQUNwRDtBQUNrRDtBQUNsRDs7Ozs7Ozs7Ozs7OztBQzdFQSxpR0FBOEQ7QUFHOUQsSUFBTSx5QkFBeUIsR0FBRztJQUNoQyxJQUFNLHFCQUFxQixHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsMEJBQTBCLENBQXNCLENBQUM7SUFDdkcsSUFBTSwyQkFBMkIsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLDhCQUE4QixDQUFzQixDQUFDO0lBQ2pILElBQUcsQ0FBQyxxQkFBcUIsRUFBRTtRQUN6QixPQUFPLENBQUMsR0FBRyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7UUFDckQsT0FBTztLQUNSO0lBQ0QscUJBQXFCLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFO1FBQzlDLElBQU0scUJBQXFCLEdBQTRCLEVBQUU7UUFDekQsZ0NBQWdDO1FBQ2hDLElBQU0sMkJBQTJCLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFFcEYsMkJBQTJCLENBQUMsT0FBTyxDQUFDLFVBQUMsZ0JBQWdCOztZQUNuRCxxQ0FBcUM7WUFDckMsSUFBTSw2QkFBNkIsR0FBRyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsNkJBQTZCLENBQXFCLENBQUM7WUFDeEgsSUFBTSxtQ0FBbUMsR0FBRyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMscUNBQXFDLENBQXFCLENBQUM7WUFDdEksSUFBTSxpQ0FBaUMsR0FBRyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsbUNBQW1DLENBQXFCLENBQUM7WUFFbEksSUFBSSxTQUFTLENBQUM7WUFDZCxJQUFNLFVBQVUsR0FBRyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsdUNBQXVDLENBQXFCLENBQUM7WUFDL0csSUFBTSxjQUFjLEdBQUcsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLHVDQUErQixVQUFVLENBQUMsS0FBSyxRQUFJLENBQUMsQ0FBQztZQUUzRyxJQUFHLENBQUMsY0FBYyxFQUFFO2dCQUNsQixLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQ3ZCLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO2FBQ3REO1lBQ0QsU0FBUyxHQUFHLGNBQVEsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLENBQUMsbUNBQUksQ0FBQyxDQUFFO1lBQzNFLDZCQUE2QjtZQUM3QixJQUFNLHdCQUF3QixHQUFHLFFBQVEsQ0FBQyw2QkFBNkIsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMvRSxJQUFNLDhCQUE4QixHQUFHLG1DQUFtQyxDQUFDLEtBQUssQ0FBQztZQUNqRixJQUFNLDRCQUE0QixHQUFHLGlDQUFpQyxDQUFDLEtBQUssQ0FBQztZQUU3RSxxQkFBcUIsQ0FBQyxJQUFJLENBQUM7Z0JBQ3pCLEVBQUUsRUFBRSxTQUFTO2dCQUNiLFFBQVEsRUFBRSx3QkFBd0I7Z0JBQ2xDLGNBQWMsRUFBRSw4QkFBOEI7Z0JBQzlDLFlBQVksRUFBRSw0QkFBNEI7YUFDM0MsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBTSxhQUFhLEdBQXFCLFFBQVEsQ0FBQyxhQUFhLENBQUMsNkJBQTZCLENBQUM7UUFDN0YsYUFBYSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLHFCQUFxQixDQUFDO1FBQzNELDJCQUEyQixDQUFDLEtBQUssRUFBRTtJQUNyQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFTSxJQUFNLHdCQUF3QixHQUFHO0lBQ3RDLElBQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsaUNBQWlDLENBQUMsQ0FBQztJQUNqRixJQUFNLDJCQUEyQixHQUFnQixRQUFRLENBQUMsYUFBYSxDQUFDLDBCQUEwQixDQUFDO0lBQ25HLElBQU0sZUFBZSxHQUFpQjtRQUNwQyxTQUFTLEVBQUUsY0FBYztRQUN6QixRQUFRLEVBQUUsU0FBUztRQUNuQixlQUFlLEVBQUUsaUVBQWlFO1FBQ2xGLFFBQVEsRUFBRSxJQUFJO1FBQ2QsTUFBTSxFQUFFO1lBQ04sT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQztRQUNuQyxDQUFDO1FBQ0QsTUFBTSxFQUFFO1lBQ04sT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQztRQUNuQyxDQUFDO1FBQ0QsUUFBUSxFQUFFO1lBQ1IsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsQ0FBQztRQUN2QyxDQUFDO0tBQ0Y7SUFFRCxJQUFNLFFBQVEsR0FBbUIsSUFBSSxnQkFBSyxDQUFDLDJCQUEyQixFQUFFLGVBQWUsQ0FBQyxDQUFDO0lBQ3pGLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUU7UUFDdkMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2xCLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBTSxtQkFBbUIsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLHFCQUFxQixDQUFzQixDQUFDO0lBQy9GLG1CQUFtQixDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRTtRQUM1QyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDbEIsQ0FBQyxDQUFDO0lBRUYseUJBQXlCLEVBQUUsQ0FBQztBQUM5QixDQUFDO0FBOUJZLGdDQUF3Qiw0QkE4QnBDOzs7Ozs7Ozs7Ozs7OztBQy9FRCxpR0FBK0M7QUFFL0MsaUZBQWtEO0FBRWxELElBQU0sa0JBQWtCLEdBQUcsVUFBQyxzQkFBc0M7SUFDaEUsSUFBTSxrQkFBa0IsR0FBRyxzQkFBc0IsQ0FBQyxnQkFBZ0IsQ0FDaEUsa0NBQWtDLENBQ0gsQ0FBQztJQUNsQyxJQUFNLFlBQVksR0FBRyxzQkFBc0IsQ0FBQyxhQUFhLENBQUMsb0NBQW9DLENBQW1CLENBQUM7SUFDbEgsSUFBSSxpQkFBaUIsR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO0lBRTdFLElBQUksYUFBYSxHQUFHLENBQUMsQ0FBQztJQUV0QixrQkFBa0IsQ0FBQyxPQUFPLENBQUMsVUFBQyxnQkFBZ0I7UUFDMUMsSUFBSSxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUU7WUFDMUIsYUFBYSxJQUFJLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNuRDtJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsWUFBWSxDQUFDLFNBQVMsR0FBRyxDQUFDLGlCQUFpQixHQUFHLGFBQWEsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQzFFLENBQUMsQ0FBQztBQUVGLElBQU0sa0JBQWtCLEdBQUcsVUFBQyx5QkFBeUM7SUFDbkUsSUFBTSxpQkFBaUIsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLHNCQUFzQixDQUFtQixDQUFDO0lBQzNGLElBQU0sb0JBQW9CLEdBQUcsaUJBQWlCLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBbUIsQ0FBQztJQUNqRixvQkFBb0IsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBRW5ELG9CQUFvQixDQUFDLGFBQWEsQ0FBQywrQkFBK0IsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxVQUFDLENBQUM7UUFDL0YsSUFBTSxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsTUFBMEIsQ0FBQztRQUN0RCxJQUFNLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDLEtBQUssR0FBRyxJQUFJLENBQWdCLENBQUM7UUFDcEgsdUZBQXVGO1FBQ3ZGLDRFQUE0RTtRQUM1RSxJQUFJLE9BQU8sQ0FBQztRQUNaLElBQUksZ0JBQWdCLENBQUMsS0FBSyxFQUFFO1lBQzFCLE9BQU8sR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLGlDQUFpQyxDQUFDLENBQUM7U0FDbEU7YUFBTTtZQUNMLE9BQU8sR0FBRyxFQUFFLENBQUM7U0FDZDtRQUVELElBQU0sV0FBVyxHQUFHLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxzQ0FBc0MsQ0FBcUIsQ0FBQztRQUNuSCxXQUFXLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUN6QyxDQUFDLENBQUMsQ0FBQztJQUVILElBQU0seUJBQXlCLEdBQUcsb0JBQW9CLENBQUMsYUFBYSxDQUNsRSwrQkFBK0IsQ0FDWCxDQUFDO0lBRXZCLHlCQUF5QixDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDLENBQUM7UUFDcEQsb0JBQW9CLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDOUIsa0JBQWtCLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUNoRCxDQUFDLENBQUMsQ0FBQztJQUVILElBQU0sYUFBYSxHQUFHLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxrQ0FBa0MsQ0FBcUIsQ0FBQztJQUNqSCxJQUFNLFlBQVksR0FBRyx5QkFBeUIsQ0FBQyxhQUFhLENBQUMsb0NBQW9DLENBQUMsQ0FBQztJQUNuRyxJQUFNLHFCQUFxQixHQUFHLHlCQUF5QixDQUFDLGdCQUFnQixDQUN0RSxrQ0FBa0MsQ0FDSCxDQUFDO0lBRWxDLElBQUksWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7SUFDeEUscUJBQXFCLENBQUMsT0FBTyxDQUFDLFVBQUMsa0JBQWtCO1FBQy9DLElBQUksa0JBQWtCLENBQUMsS0FBSyxFQUFFO1lBQzVCLFlBQVksSUFBSSxRQUFRLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDcEQ7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUNILGFBQWEsQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzdDLHlCQUF5QixDQUFDLGFBQWEsQ0FBQyxzQ0FBc0MsQ0FBdUIsQ0FBQyxNQUFNLENBQzNHLG9CQUFvQixDQUNyQixDQUFDO0lBRUYsYUFBYSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDLENBQUM7UUFDeEMsa0JBQWtCLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUNoRCxDQUFDLENBQUMsQ0FBQztJQUNILGtCQUFrQixDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDOUMsT0FBTyxvQkFBb0IsQ0FBQztBQUM5QixDQUFDLENBQUM7QUFFSyxJQUFNLGtCQUFrQixHQUFHO0lBQ2hDLFFBQVE7SUFDUixJQUFNLG1DQUFtQyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQ2hFLHFDQUFxQyxDQUN2QixDQUFDO0lBQ2pCLElBQU0sa0JBQWtCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQywyQkFBMkIsQ0FBbUIsQ0FBQztJQUNqRyxJQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyw0QkFBNEIsQ0FBa0MsQ0FBQztJQUNsSCxJQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLHFCQUFxQixDQUFxQixDQUFDO0lBQ3pGLElBQU0saUJBQWlCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyw0QkFBNEIsQ0FBc0IsQ0FBQztJQUNwRyxJQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGdDQUFnQyxDQUFtQixDQUFDO0lBQ2xHLElBQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsaUNBQWlDLENBQXFCLENBQUM7SUFDdEcsSUFBTSxvQkFBb0IsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGlDQUFpQyxDQUFxQixDQUFDO0lBQzNHLElBQU0sb0JBQW9CLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxpQ0FBaUMsQ0FBcUIsQ0FBQztJQUMzRyxJQUFNLHNCQUFzQixHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsbUNBQW1DLENBQXFCLENBQUM7SUFDL0csSUFBTSxxQkFBcUIsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGlDQUFpQyxDQUFzQixDQUFDO0lBQzdHLElBQU0sc0JBQXNCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxrQ0FBa0MsQ0FBc0IsQ0FBQztJQUMvRyxJQUFNLCtCQUErQixHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsc0NBQXNDLENBQUMsQ0FBQztJQUN2RyxJQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGtDQUFrQyxDQUFzQixDQUFDO0lBRW5HLElBQU0sZ0JBQWdCLEdBQWlCO1FBQ3JDLFNBQVMsRUFBRSxjQUFjO1FBQ3pCLFFBQVEsRUFBRSxTQUFTO1FBQ25CLGVBQWUsRUFBRSxpRUFBaUU7UUFDbEYsUUFBUSxFQUFFLElBQUk7UUFDZCxNQUFNLEVBQUU7WUFDTixPQUFPLENBQUMsR0FBRyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7WUFDakQsT0FBTyxtQ0FBbUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDOUQsbUNBQW1DLENBQUMsV0FBVyxDQUFDLG1DQUFtQyxDQUFDLGdCQUFnQixDQUFDLENBQUM7YUFDdkc7WUFFRCxJQUFNLGNBQWMsR0FBRyxtQ0FBbUMsQ0FBQyxnQkFBZ0IsQ0FDekUsc0JBQXNCLENBQ08sQ0FBQztZQUNoQyxjQUFjLENBQUMsT0FBTyxDQUFDLFVBQUMsS0FBSyxJQUFLLFlBQUssQ0FBQyxNQUFNLEVBQUUsRUFBZCxDQUFjLENBQUMsQ0FBQztZQUVsRCxJQUFNLHVCQUF1QixHQUFHLG1DQUFtQyxDQUFDLGdCQUFnQixDQUNsRixzQ0FBc0MsQ0FDTixDQUFDO1lBQ25DLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxVQUFDLE1BQU0sSUFBSyxhQUFNLENBQUMsTUFBTSxFQUFFLEVBQWYsQ0FBZSxDQUFDLENBQUM7UUFDL0QsQ0FBQztLQUNGLENBQUM7SUFDRixJQUFNLGNBQWMsR0FBRyxJQUFJLGdCQUFLLENBQUMsa0JBQWtCLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUV2RSxJQUFNLG9CQUFvQixHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsc0JBQXNCLENBQXNCLENBQUM7SUFDakcsb0JBQW9CLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFO1FBQzdDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUN4QixDQUFDLENBQUMsQ0FBQztJQUVILGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxVQUFDLGVBQWU7UUFDdkMsSUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQXFCLENBQUM7UUFDckcsZUFBZSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRTtZQUN4Qyw4QkFBOEI7WUFDOUIsY0FBYyxDQUFDLEtBQUssR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7WUFDN0MsaUJBQWlCLENBQUMsS0FBSyxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztZQUNsRCxlQUFlLENBQUMsS0FBSyxHQUFHLGdCQUFnQixDQUFDLEtBQUssQ0FBQztZQUMvQyxvQkFBb0IsQ0FBQyxLQUFLLEdBQUcsbUNBQXVCLEVBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbEYsb0JBQW9CLENBQUMsS0FBSyxHQUFHLGdCQUFnQixDQUFDLFVBQVUsQ0FBQztZQUN6RCxzQkFBc0IsQ0FBQyxLQUFLLEdBQUcsbUNBQXVCLEVBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDdEYscUJBQXFCLENBQUMsS0FBSyxHQUFHLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDdEUsc0JBQXNCLENBQUMsS0FBSyxHQUFHLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7WUFFeEUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3RFLElBQU0sd0JBQXdCLEdBQUcsbUNBQW1DLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDakcsbUNBQW1DLENBQUMsV0FBVyxDQUFDLHdCQUF3QixDQUFDLENBQUM7YUFDM0U7WUFFRCxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsVUFBQyxnQkFBZ0IsRUFBRSxDQUFDO2dCQUM3RCxJQUFNLGdDQUFnQyxHQUFHLG1DQUFtQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekYsSUFBTSx1QkFBdUIsR0FBRyxnQ0FBZ0MsQ0FBQyxhQUFhLENBQzVFLHVCQUF1QixDQUNKLENBQUM7Z0JBQ3RCLElBQU0sdUJBQXVCLEdBQUcsZ0NBQWdDLENBQUMsYUFBYSxDQUM1RSxtQ0FBbUMsQ0FDbEIsQ0FBQztnQkFDcEIsSUFBTSxzQkFBc0IsR0FBRyxnQ0FBZ0MsQ0FBQyxhQUFhLENBQzNFLHVDQUF1QyxDQUN0QixDQUFDO2dCQUNwQixJQUFNLDJCQUEyQixHQUFHLGdDQUFnQyxDQUFDLGFBQWEsQ0FDaEYsb0NBQW9DLENBQ25CLENBQUM7Z0JBQ3BCLElBQU0sZ0NBQWdDLEdBQUcsZ0NBQWdDLENBQUMsYUFBYSxDQUNyRixxQ0FBcUMsQ0FDcEIsQ0FBQztnQkFDcEIsSUFBTSw4QkFBOEIsR0FBRyxnQ0FBZ0MsQ0FBQyxhQUFhLENBQ25GLG1DQUFtQyxDQUNsQixDQUFDO2dCQUNwQixJQUFNLGdDQUFnQyxHQUFHLGdDQUFnQyxDQUFDLGFBQWEsQ0FDckYsb0NBQW9DLENBQ25CLENBQUM7Z0JBRXBCLHVCQUF1QixDQUFDLEtBQUssR0FBRyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBRS9ELHVCQUF1QixDQUFDLFNBQVMsR0FBRyxvQkFBYSxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxvQ0FBMEIsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLElBQUksU0FBTSxDQUFDO2dCQUM1SSxzQkFBc0IsQ0FBQyxTQUFTLEdBQUcsb0JBQWEsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLEdBQUcsZUFBSyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxTQUFNLENBQUM7Z0JBQ3BILDJCQUEyQixDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQzdFLDJCQUEyQixDQUFDLFlBQVksQ0FBQyxlQUFlLEVBQUUsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7Z0JBQ2hHLGdDQUFnQyxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ2xGLGdDQUFnQyxDQUFDLFNBQVMsR0FBRyxtQ0FBdUIsRUFBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDdEcsOEJBQThCLENBQUMsU0FBUyxHQUFHLG1DQUF1QixFQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUVsRyxJQUFNLGlCQUFpQixHQUFHLCtCQUErQixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQXNCLENBQUM7Z0JBQy9GLGdCQUFnQjtnQkFDaEIsaUJBQWlCLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFO29CQUMxQyx5QkFBa0IsQ0FBQyxnQ0FBa0QsQ0FBQztnQkFBdEUsQ0FBc0UsQ0FDdkUsQ0FBQztnQkFFRCw4QkFBOEIsQ0FBQyxVQUFVLENBQUMsVUFBNkIsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztnQkFDbEcsaUJBQWlCLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFFaEQsZ0JBQWdCLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLFVBQUMsYUFBYTtvQkFDM0QsSUFBTSxzQkFBc0IsR0FBRyxrQkFBa0IsQ0FBQyxnQ0FBa0QsQ0FBQyxDQUFDO29CQUN0RyxJQUFNLFdBQVcsR0FBRyxzQkFBc0IsQ0FBQyxhQUFhLENBQUMsK0JBQStCLENBQXFCLENBQUM7b0JBQzlHLElBQU0saUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsYUFBYSxDQUM1RCxzQ0FBc0MsQ0FDbkIsQ0FBQztvQkFDdEIsSUFBTSxrQkFBa0IsR0FBRyxzQkFBc0IsQ0FBQyxhQUFhLENBQzdELGtDQUFrQyxDQUNmLENBQUM7b0JBRXRCLFdBQVcsQ0FBQyxLQUFLLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7b0JBQ3hELGlCQUFpQixDQUFDLEtBQUssR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDOUQsa0JBQWtCLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQy9ELENBQUMsQ0FBQyxDQUFDO2dCQUVILElBQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxzQkFBc0IsQ0FBK0IsQ0FBQztnQkFFcEcsSUFBSSxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDMUIsaUJBQWlCLENBQUMsS0FBSyxFQUFFLENBQUM7aUJBQzNCO2dCQUVELGtCQUFrQixDQUFDLGdDQUFrRCxDQUFDLENBQUM7WUFDekUsQ0FBQyxDQUFDLENBQUM7WUFFSCxJQUFJLGdCQUFnQixDQUFDLE1BQU0sS0FBSyxvQkFBb0IsSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEtBQUssT0FBTyxFQUFFO2dCQUMzRixVQUFVLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDbkMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQzFDLGNBQWMsQ0FBQyxTQUFTLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxDQUFDO2dCQUNuRCxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQzNDO2lCQUFNO2dCQUNMLFVBQVUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUN0QyxjQUFjLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDdkMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM5QztZQUNELGNBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN4QixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsc0JBQXNCO0lBQ3RCLElBQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsa0NBQWtDLENBQXNCLENBQUM7SUFDbkcsVUFBVSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRTtRQUNuQyxJQUFNLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsNEJBQTRCLENBQXNCLENBQUM7UUFFcEcsSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLEtBQUssb0JBQW9CLEVBQUU7WUFDcEQsSUFBTSxPQUFPLEdBQUcsNEJBQTRCLEVBQUUsQ0FBQztZQUMvQyxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNaLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO2dCQUN6QyxPQUFPO2FBQ1I7U0FDRjtRQUVELElBQU0sZ0NBQWdDLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUNoRSxxQ0FBcUMsQ0FDUixDQUFDO1FBQ2hDLElBQU0sYUFBYSxHQUEwQixFQUFFLENBQUM7UUFFaEQsZ0NBQWdDLENBQUMsT0FBTyxDQUFDLFVBQUMscUJBQXFCO1lBQzdELElBQU0sdUJBQXVCLEdBQUcscUJBQXFCLENBQUMsYUFBYSxDQUFDLHVCQUF1QixDQUFxQixDQUFDO1lBRWpILElBQU0sa0JBQWtCLEdBQXdCO2dCQUM5QyxrQkFBa0IsRUFBRSxRQUFRLENBQUMsdUJBQXVCLENBQUMsS0FBSyxDQUFDO2dCQUMzRCxzQkFBc0IsRUFBRSxFQUFFO2FBQzNCLENBQUM7WUFFRixJQUFNLGtCQUFrQixHQUFHLHFCQUFxQixDQUFDLGdCQUFnQixDQUMvRCxzQkFBc0IsQ0FDTyxDQUFDO1lBQ2hDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxVQUFDLFlBQVk7Z0JBQ3RDLElBQU0sYUFBYSxHQUFHLFlBQVksQ0FBQyxhQUFhLENBQUMsK0JBQStCLENBQXNCLENBQUM7Z0JBQ3ZHLElBQU0sbUJBQW1CLEdBQUcsWUFBWSxDQUFDLGFBQWEsQ0FDcEQsc0NBQXNDLENBQ2xCLENBQUM7Z0JBQ3ZCLElBQU0sa0JBQWtCLEdBQUcsWUFBWSxDQUFDLGFBQWEsQ0FBQyxrQ0FBa0MsQ0FBcUIsQ0FBQztnQkFFOUcsSUFBSSxtQkFBbUIsQ0FBQyxLQUFLLElBQUksa0JBQWtCLENBQUMsS0FBSyxFQUFFO29CQUN6RCxJQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ3BELElBQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFFekQsa0JBQWtCLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDO3dCQUM3QyxPQUFPLEVBQUUsT0FBTzt3QkFDaEIsUUFBUSxFQUFFLGFBQWE7cUJBQ3hCLENBQUMsQ0FBQztpQkFDSjtZQUNILENBQUMsQ0FBQyxDQUFDO1lBQ0gsYUFBYSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3pDLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBTSw0QkFBNEIsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUN6RCx3Q0FBd0MsQ0FDckIsQ0FBQztRQUN0Qiw0QkFBNEIsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUVuRSxJQUFNLFlBQVksR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLDJCQUEyQixDQUFzQixDQUFDO1FBQzlGLFlBQVksQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQztBQTVNVywwQkFBa0Isc0JBNE03QjtBQUVGLElBQU0sNEJBQTRCLEdBQUc7SUFDbkMsSUFBTSx3QkFBd0IsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsb0NBQW9DLENBQUMsQ0FBQztJQUVqRyxJQUFNLGlCQUFpQixHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBQyxZQUFZO1FBQ2hGLElBQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbEQsT0FBTyxRQUFRLEtBQUssQ0FBQyxDQUFDO0lBQ3hCLENBQUMsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxpQkFBaUIsQ0FBQztBQUMzQixDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsU0YsdUhBQXdEO0FBRXhELDJFQUFpRDtBQUNqRCw4RUFBbUQ7QUFDbkQsOEVBQTRDO0FBQzVDLGdIQUE0QztBQUM1QyxvSUFBd0Q7QUFFeEQsaUNBQWlDO0FBQ2pDLElBQU0sV0FBVyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7QUFDL0IsSUFBTSxRQUFRLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQztBQUV6Qyx3QkFBTSxFQUFDLEVBQUUsS0FBSyx1QkFBRSxVQUFVLDRCQUFFLENBQUMsQ0FBQztBQUU5QixJQUFNLGVBQWUsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsNEJBQTRCLENBQUMsQ0FBQztBQUNoRixlQUFlLENBQUMsT0FBTyxDQUFDLFVBQUMsQ0FBQztJQUN4QixRQUFDLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFO1FBQzFCLElBQU0sWUFBWSxHQUFzQixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztJQUNwRixDQUFDLENBQUM7QUFGRixDQUVFLENBQ0gsQ0FBQztBQUVGLElBQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUNyRSxJQUFNLGdCQUFnQixHQUFHLElBQUksd0JBQVUsQ0FBQyxZQUFZLEVBQUU7SUFDcEQsUUFBUSxFQUFFLElBQUk7SUFDZCxNQUFNLEVBQUUsSUFBSTtDQUNiLENBQUMsQ0FBQztBQUVILGNBQWM7QUFDZCxJQUFNLFdBQVcsR0FBcUIsUUFBUSxDQUFDLGFBQWEsQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO0FBQzdGLElBQU0saUJBQWlCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO0FBQ3ZGLElBQUksaUJBQWlCLElBQUksV0FBVyxFQUFFO0lBQ3BDLGlCQUFpQixDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRTtRQUMxQyxJQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0MsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEdBQUcsVUFBRyxHQUFHLENBQUMsSUFBSSxDQUFFLENBQUM7SUFDdkMsQ0FBQyxDQUFDLENBQUM7Q0FDSjtBQUNELElBQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0FBRTdFLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDO0lBQ3RCLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUU7Ozs7O3lCQUN0QixPQUFPLENBQUMsV0FBVyxDQUFDLEVBQXBCLHdCQUFvQjtvQkFDbEIsRUFBRSxHQUFHLENBQUMsQ0FBQyxZQUFZLENBQUMsdUJBQXVCLENBQUMsQ0FBQztvQkFDaEMscUJBQU0sS0FBSyxDQUFDLGdDQUF5QixFQUFFLENBQUUsRUFBRTs0QkFDMUQsTUFBTSxFQUFFLFFBQVE7eUJBQ2pCLENBQUM7O29CQUZJLFFBQVEsR0FBRyxTQUVmO29CQUNGLElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxHQUFHLEVBQUU7d0JBQzFCLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztxQkFDbkI7Ozs7O1NBRUosQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFNLGdCQUFnQixHQUFHO0lBQ3ZCLElBQU0sU0FBUyxHQUFHLElBQUksZUFBZSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUQsSUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0lBQ3RELE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdkIsSUFBSSxDQUFDLFNBQVMsRUFBRTtRQUNkLE9BQU87S0FDUjtJQUVELElBQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMseUJBQWtCLFNBQVMsQ0FBRSxDQUFDLENBQUM7SUFFMUUsSUFBSSxDQUFDLFdBQVcsRUFBRTtRQUNoQixPQUFPO0tBQ1I7SUFFRCxJQUFNLGVBQWUsR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFDLDRCQUE0QixDQUFzQixDQUFDO0lBQ3JHLGVBQWUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUMxQixDQUFDLENBQUM7QUFFRixJQUFNLHNCQUFzQixHQUFHLFVBQUMsQ0FBYTtJQUMzQyxJQUFNLHlCQUF5QixHQUFJLENBQUMsQ0FBQyxhQUFpQyxDQUFDLFVBQTRCLENBQUM7SUFDcEcsSUFBTSwwQkFBMEIsR0FBRyx5QkFBeUIsQ0FBQyxVQUE0QixDQUFDO0lBRTFGLHlCQUF5QixDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ25DLE9BQU8sQ0FBQyxHQUFHLENBQUMsMEJBQTBCLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hELElBQUksMEJBQTBCLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDbkQsSUFBTSw0QkFBNEIsR0FBRywwQkFBMEIsQ0FBQyxhQUFhLENBQUMsa0NBQWtDLENBQUMsQ0FBQztRQUNsSCxPQUFPLENBQUMsR0FBRyxDQUFDLDRCQUE0QixDQUFDLENBQUM7UUFDMUMsNEJBQTRCLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztLQUN6RDtBQUNILENBQUMsQ0FBQztBQUVGLElBQU0sZ0NBQWdDLEdBQUcsVUFBQyxDQUFhO0lBQ3JELElBQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxhQUFrQyxDQUFDO0lBQ2pELElBQU0seUJBQXlCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLFVBQTRCLENBQUM7SUFFNUcsSUFBSSx5QkFBeUIsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDN0QsSUFBTSw0QkFBNEIsR0FBRyx5QkFBeUIsQ0FBQyxhQUFhLENBQUMsa0NBQWtDLENBQUMsQ0FBQztRQUNqSCw0QkFBNEIsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0tBQzVEO0lBRUQsSUFBTSxtQkFBbUIsR0FBRyx5QkFBeUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFtQixDQUFDO0lBQ3hGLGVBQWU7SUFDZixtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxLQUFLO1FBQzFELEtBQUssQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBQ25CLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBTSw0QkFBNEIsR0FBRyxtQkFBbUIsQ0FBQyxhQUFhLENBQUMsa0NBQWtDLENBQUMsQ0FBQztJQUMzRyw0QkFBNEIsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztJQUUvRSxJQUFNLDBCQUEwQixHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsVUFBNEIsQ0FBQztJQUUvRSwwQkFBMEIsQ0FBQyxZQUFZLENBQUMsbUJBQW1CLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzdFLGtCQUFrQixFQUFFLENBQUM7QUFDdkIsQ0FBQyxDQUFDO0FBRUYsd0VBQXdFO0FBQ3hFLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsRUFBRTtJQUM1QyxhQUFhO0lBQ2Isb0NBQXlCLEdBQUUsQ0FBQztJQUM1QixnQ0FBZ0M7SUFDaEMsa0NBQXdCLEdBQUUsQ0FBQztJQUMzQixpQ0FBaUM7SUFDakMsNkJBQWtCLEdBQUUsQ0FBQztJQUVyQixJQUFNLHFCQUFxQixHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsb0NBQW9DLENBQXNCLENBQUM7SUFDakgscUJBQXFCLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLGdDQUFnQyxDQUFDLENBQUM7SUFFbEYsSUFBTSw0QkFBNEIsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGtDQUFrQyxDQUFDLENBQUM7SUFDaEcsNEJBQTRCLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLHNCQUFzQixDQUFDLENBQUM7SUFFL0UscUJBQXFCO0lBQ3JCLGdCQUFnQixFQUFFLENBQUM7QUFDckIsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFNLGtCQUFrQixHQUFHO0lBQ3pCLElBQU0sc0JBQXNCLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUFDLDJCQUEyQixDQUFDLENBQUM7SUFDdEYsSUFBTSxvQkFBb0IsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUNsRixJQUFNLHFCQUFxQixHQUFHLHNCQUFzQixDQUFDLHNCQUFzQixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQXFCLENBQUM7SUFDNUcsSUFBTSxtQkFBbUIsR0FBRyxvQkFBb0IsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFxQixDQUFDO0lBRXRHLElBQU0sZUFBZSxHQUFHLElBQUksb0JBQVUsQ0FBQyxxQkFBcUIsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNsRSxJQUFNLGFBQWEsR0FBRyxJQUFJLG9CQUFVLENBQUMsbUJBQW1CLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDaEUsQ0FBQyxDQUFDO0FBRUYsY0FBYztBQUNkLElBQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsOEJBQThCLENBQXNCLENBQUM7QUFDakcsSUFBTSxpQkFBaUIsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsNkJBQTZCLENBQUMsQ0FBQztBQUNuRixJQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBcUIsQ0FBQztBQUUzRSxZQUFZLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFO0lBQ3JDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxVQUFDLEtBQXVCO1FBQ2hELElBQUksS0FBSyxDQUFDLE9BQU8sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLGVBQWUsRUFBRTtZQUNuRixXQUFXLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDakU7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBTSxhQUFhLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUMvQyxJQUFNLGVBQWUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGdDQUFnQyxDQUFxQixDQUFDO0FBRXJHLElBQU0sV0FBVyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztBQUNwRCxJQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xELElBQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEQsSUFBTSxNQUFNLEdBQUcsS0FBSyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDekMsSUFBTSxjQUFjLEdBQUcsS0FBSyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUMxRCxJQUFNLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQzdELGVBQWUsQ0FBQyxLQUFLLEdBQUcsVUFBRyxjQUFjLGNBQUksZ0JBQWdCLGNBQUksTUFBTSxDQUFFLENBQUM7QUFFMUUsSUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUFDLDJCQUEyQixDQUFDLENBQUM7QUFDM0UsV0FBVyxDQUFDLE9BQU8sQ0FBQyxVQUFDLFVBQTRCO0lBQy9DLFVBQVUsQ0FBQyxLQUFLLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvQyxJQUFNLE1BQU0sR0FBRyxJQUFJLGlCQUFRLENBQUMsTUFBTSxDQUFDO1FBQ2pDLE9BQU8sRUFBRSxVQUFVO1FBQ25CLEdBQUcsRUFBRTtZQUNILG9FQUFvRTtZQUNwRSw0Q0FBNEM7U0FDN0M7UUFDRCxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUM7UUFDdkIsVUFBVSxFQUFFO1lBQ1YsT0FBTyxFQUFFLElBQUksSUFBSSxFQUFFO1lBQ25CLE9BQU8sRUFBRSxDQUFDO1lBQ1YsV0FBVyxFQUFFLElBQUk7U0FDbEI7UUFDRCxNQUFNLEVBQUUsQ0FBQztLQUNWLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7OztBQ2xMSSxJQUFNLHVCQUF1QixHQUFHLFVBQUMsVUFBa0I7SUFDeEQsSUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFFbEMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUMzRixJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDeEUsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBRWhDLE9BQU8sSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUN4QyxDQUFDLENBQUM7QUFSVywrQkFBdUIsMkJBUWxDOzs7Ozs7Ozs7Ozs7OztBQ1JGLGlHQUFnQztBQUdoQyxpRkFBa0Q7QUFFM0MsSUFBTSx5QkFBeUIsR0FBRztJQUNyQyxjQUFjO0lBQ2QsSUFBTSw0QkFBNEIsR0FBbUIsUUFBUSxDQUFDLGFBQWEsQ0FBQywyQkFBMkIsQ0FBbUIsQ0FBQztJQUMzSCxJQUFNLFdBQVcsR0FBRyw0QkFBNEIsQ0FBQyxhQUFhLENBQUMsOEJBQThCLENBQW1CLENBQUM7SUFDakgsSUFBTSxXQUFXLEdBQUcsNEJBQTRCLENBQUMsYUFBYSxDQUFDLDRCQUE0QixDQUFtQixDQUFDO0lBQy9HLElBQU0sZUFBZSxHQUFHLDRCQUE0QixDQUFDLGFBQWEsQ0FBQyxpQ0FBaUMsQ0FBbUIsQ0FBQztJQUN4SCxJQUFNLGVBQWUsR0FBRyw0QkFBNEIsQ0FBQyxhQUFhLENBQUMsaUNBQWlDLENBQW1CLENBQUM7SUFDeEgsSUFBTSxVQUFVLEdBQUcsNEJBQTRCLENBQUMsYUFBYSxDQUFDLGlDQUFpQyxDQUFtQixDQUFDO0lBQ25ILElBQU0saUJBQWlCLEdBQUcsNEJBQTRCLENBQUMsYUFBYSxDQUFDLG1DQUFtQyxDQUFtQixDQUFDO0lBQzVILElBQU0sa0JBQWtCLEdBQUcsNEJBQTRCLENBQUMsYUFBYSxDQUFDLG9DQUFvQyxDQUFtQixDQUFDO0lBQzlILElBQU0saUJBQWlCLEdBQUcsNEJBQTRCLENBQUMsYUFBYSxDQUFDLG1DQUFtQyxDQUFDO0lBQ3pHLElBQU0sb0JBQW9CLEdBQUcsNEJBQTRCLENBQUMsYUFBYSxDQUFDLHNDQUFzQyxDQUFDO0lBRS9HLElBQU0sYUFBYSxHQUFHLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxpQkFBaUIsRUFBRSxrQkFBa0IsRUFBRSxpQkFBaUIsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO0lBQy9LLGVBQWU7SUFDZixJQUFNLGdCQUFnQixHQUFpQjtRQUNuQyxTQUFTLEVBQUUsY0FBYztRQUN6QixRQUFRLEVBQUUsU0FBUztRQUNuQixlQUFlLEVBQUUsaUVBQWlFO1FBQ2xGLFFBQVEsRUFBRSxJQUFJO1FBQ2QsTUFBTSxFQUFFO1lBQ0osYUFBYSxDQUFDLE9BQU8sQ0FBQyxrQkFBUTtnQkFDNUIsUUFBUSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7WUFDMUIsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDO0tBQ0o7SUFFRCxJQUFNLFNBQVMsR0FBRyxJQUFJLGdCQUFLLENBQUMsNEJBQTRCLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUM1RSxJQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO0lBQ2pGLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxVQUFDLFVBQVU7UUFDbEMsSUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQXFCLENBQUM7UUFDaEcsUUFBUTtRQUNSLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUU7WUFDbkMsNkJBQTZCO1lBQzdCLFdBQVcsQ0FBQyxTQUFTLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO1lBQ2pELFdBQVcsQ0FBQyxTQUFTLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxDQUFDO1lBQ2hELGVBQWUsQ0FBQyxTQUFTLEdBQUcsbUNBQXVCLEVBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDakYsZUFBZSxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUM7WUFDeEQsVUFBVSxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUM7WUFDOUMsaUJBQWlCLENBQUMsU0FBUyxHQUFHLG1DQUF1QixFQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ3JGLGtCQUFrQixDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO1lBQy9ELGlCQUFpQixDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO1lBQzdELG9CQUFvQixDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDO1lBRW5FLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNuQixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBTSxvQkFBb0IsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLHNCQUFzQixDQUFzQixDQUFDO0lBQ2pHLG9CQUFvQixDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRTtRQUM3QyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDbkIsQ0FBQyxDQUFDO0lBR0YsSUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBc0IsQ0FBQztJQUMzRixjQUFjLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFO1FBQ3ZDLGVBQWUsRUFBRTtJQUNuQixDQUFDLENBQUMsQ0FBQztBQUNQLENBQUM7QUExRFksaUNBQXlCLDZCQTBEckM7QUFFRCxJQUFNLGVBQWUsR0FBRztJQUN0QixJQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztJQUN4QyxJQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2xELFNBQVMsQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDO0lBQzdCLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3JDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUNuQixRQUFRLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzdCLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBRXJDLElBQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUNyRSxlQUFlLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUM5QyxJQUFNLGdCQUFnQixHQUFHLFVBQVUsQ0FBQztRQUNsQyxlQUFlLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMzQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUNqQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDWCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hGRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVFQUF1RSxFQUFFLE1BQU07QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFFBQVEsNENBQTRDO0FBQ3BEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixZQUFZLEVBQUUsbUJBQW1CLEVBQUUsdUJBQXVCLEVBQUU7QUFDdkY7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRCxVQUFVLFlBQVk7QUFDdEI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixFQUFFLElBQUksS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZLEtBQUssaUJBQWlCO0FBQ2pELDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtB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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBCQUEwQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLDBHQUEwRyxjQUFjO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPLFdBQVcsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdDQUF3QztBQUMzQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx3TUFBd007QUFDM007QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDLEdBQUc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ2xCLGlCQUFpQixHQUFHO0FBQ3BCLHVCQUF1QixHQUFHO0FBQzFCLGlCQUFpQixHQUFHO0FBQ3BCLHFCQUFxQixHQUFHO0FBQ3hCLHVCQUF1QixHQUFHO0FBQzFCLDJCQUEyQixHQUFHO0FBQzlCLDJCQUEyQixHQUFHO0FBQzlCLENBQUMsbUdBQW1HLEdBQUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0QkFBNEIsR0FBRyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtEQUFrRCxHQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELGVBQWUsR0FBRztBQUNsQixtQkFBbUIsR0FBRztBQUN0QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEIsdUJBQXVCLEdBQUc7QUFDMUIsaUJBQWlCLEdBQUc7QUFDcEIscUJBQXFCLEdBQUc7QUFDeEIsdUJBQXVCLEdBQUc7QUFDMUIsMkJBQTJCLEdBQUc7QUFDOUIsMkJBQTJCLEdBQUc7QUFDOUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0RBQXNELEdBQUc7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLEVBQUUsR0FBRyxpUEFBaVAsR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHO0FBQ25VO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEVBQUUsbUJBQW1CLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHLElBQUksR0FBRztBQUN2QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwQ0FBMEMsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLDZKQUE2SixHQUFHLGFBQWEsR0FBRztBQUN4UztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhDQUE4QyxHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUc7QUFDcE47QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNEZBQTRGLCtCQUErQiwyRkFBMkYsZ0NBQWdDLDRCQUE0Qiw2QkFBNkI7QUFDL1M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxlQUFlO0FBQ2pFLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCLGNBQWM7QUFDcEQ7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixtRUFBbUUsZ0RBQWdEO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsR0FBRztBQUNIO0FBQ0EsK0RBQStELDJCQUEyQjtBQUMxRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMkNBQTJDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUlBQXlJLDJDQUEyQztBQUNwTDtBQUNBLGVBQWUsK0JBQStCO0FBQzlDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0QsdVpBQXVaLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUc7QUFDemY7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRyxJQUFJLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxHQUFHLElBQUksZ0JBQWdCO0FBQ2pFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNEJBQTRCLEVBQUUsRUFBRTtBQUN6QztBQUNBO0FBQ0EsU0FBUywyQkFBMkIsRUFBRSxFQUFFO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTLDZCQUE2QixFQUFFLEVBQUU7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQix5Q0FBeUMsMEJBQTBCLGdFQUFnRSxzQkFBc0I7QUFDak47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EscURBQXFELHdCQUF3QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FB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c0MsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUcsSUFBSSxxQkFBcUI7QUFDdEM7QUFDQSxVQUFVLEdBQUcsSUFBSSxxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLHNDQUFzQyx3QkFBd0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLLElBQUksTUFBTSxFQUFFLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQ0FBZ0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2Q0FBNkM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsdUJBQXVCLG1DQUFtQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwQ0FBMEM7QUFDdEY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUErQixTQUFTLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDbEQ7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SkFBdUosd0NBQXdDLEVBQUUsd0NBQXdDO0FBQ3pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBa0gsa0JBQWtCLG1DQUFtQyxpQkFBaUI7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVSxFQUFFLEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUIsSUFBSSxJQUFJLGlCQUFpQixnQ0FBZ0MsTUFBTSxnQ0FBZ0M7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQyxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFD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TSxxQkFBcUI7V0FDM0I7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBOztXQUVBO1dBQ0E7V0FDQTs7Ozs7VUVyRkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQGVhc2VwaWNrL2J1bmRsZS9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZVNjcm9sbC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzTGF5b3V0Vmlld3BvcnQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXItbGl0ZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZm9ybWF0LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdW5pcXVlQnkuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy91c2VyQWdlbnQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9EYXRlcGlja2VyLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL2V2ZW50cy9mdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvZXZlbnRzL2lucHV0RmllbGRMaXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvZXZlbnRzL290aGVyTGlzdGVuZXJzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL2V2ZW50cy9waWNrZXJMaXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvaTE4bi9iYXNlLWxvY2FsZXMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvbGliL2RhdGUtZm9ybWF0LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL2xpYi9kYXRlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL2xpYi9kb20uanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvbGliL2V2ZW50LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9vcHRpb25zL2RlZmF1bHRPcHRpb25zLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL29wdGlvbnMvcHJvY2Vzc09wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlLWRhdGVwaWNrZXIvanMvcGlja2VyL1BpY2tlci5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9waWNrZXIvdGVtcGxhdGVzL2NhbGVuZGFyV2Vla3NUZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9waWNrZXIvdGVtcGxhdGVzL2RheXNUZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9waWNrZXIvdGVtcGxhdGVzL3BpY2tlclRlbXBsYXRlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS1kYXRlcGlja2VyL2pzL3BpY2tlci92aWV3cy9EYXlzVmlldy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9waWNrZXIvdmlld3MvTW9udGhzVmlldy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9waWNrZXIvdmlld3MvVmlldy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9qcy9waWNrZXIvdmlld3MvWWVhcnNWaWV3LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvYWNjb3JkaW9uL2luZGV4LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvYWNjb3JkaW9uL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2FjY29yZGlvbi90eXBlcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2Nhcm91c2VsL2luZGV4LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvY2Fyb3VzZWwvaW50ZXJmYWNlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvY2Fyb3VzZWwvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9jb2xsYXBzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2NvbGxhcHNlL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2NvbGxhcHNlL3R5cGVzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvZGlhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2RpYWwvaW50ZXJmYWNlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvZGlhbC90eXBlcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2Rpc21pc3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kaXNtaXNzL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2Rpc21pc3MvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kcmF3ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kcmF3ZXIvaW50ZXJmYWNlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvZHJhd2VyL3R5cGVzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvZHJvcGRvd24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kcm9wZG93bi9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kcm9wZG93bi90eXBlcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2luZGV4LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvbW9kYWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9tb2RhbC9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9tb2RhbC90eXBlcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL3BvcG92ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9wb3BvdmVyL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL3BvcG92ZXIvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy90YWJzL2luZGV4LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvdGFicy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy90YWJzL3R5cGVzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvdG9vbHRpcC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL3Rvb2x0aXAvaW50ZXJmYWNlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvdG9vbHRpcC90eXBlcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9kb20vZXZlbnRzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2luZGV4LmpzIiwid2VicGFjazovL3N0YXRpYy8uL3NyYy9pbmJvdW5kX29yZGVyL2FkZC50cyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9zcmMvaW5ib3VuZF9vcmRlci9lZGl0LnRzIiwid2VicGFjazovL3N0YXRpYy8uL3NyYy9pbmJvdW5kX29yZGVyL2luYm91bmRfb3JkZXIudHMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vc3JjL2luYm91bmRfb3JkZXIvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vc3JjL2luYm91bmRfb3JkZXIvdmlldy50cyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvdHctZWxlbWVudHMvZGlzdC9qcy90dy1lbGVtZW50cy5lcy5taW4uanMiLCJ3ZWJwYWNrOi8vc3RhdGljL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3N0YXRpYy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vc3RhdGljL3dlYnBhY2svcnVudGltZS9lbnN1cmUgY2h1bmsiLCJ3ZWJwYWNrOi8vc3RhdGljL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9zdGF0aWMvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9zdGF0aWMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9zdGF0aWMvd2VicGFjay9ydW50aW1lL2xvYWQgc2NyaXB0Iiwid2VicGFjazovL3N0YXRpYy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3N0YXRpYy93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9zdGF0aWMvd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vc3RhdGljL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vc3RhdGljL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9zdGF0aWMvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIHQgZXh0ZW5kcyBEYXRle3N0YXRpYyBwYXJzZURhdGVUaW1lKGUsaT1cIllZWVktTU0tRERcIixuPVwiZW4tVVNcIil7aWYoIWUpcmV0dXJuIG5ldyBEYXRlKChuZXcgRGF0ZSkuc2V0SG91cnMoMCwwLDAsMCkpO2lmKGUgaW5zdGFuY2VvZiB0KXJldHVybiBlLnRvSlNEYXRlKCk7aWYoZSBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIGU7aWYoL14tP1xcZHsxMCx9JC8udGVzdChTdHJpbmcoZSkpKXJldHVybiBuZXcgRGF0ZShOdW1iZXIoZSkpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXtjb25zdCBzPVtdO2xldCBvPW51bGw7Zm9yKDtudWxsIT0obz10LnJlZ2V4LmV4ZWMoaSkpOylcIlxcXFxcIiE9PW9bMV0mJnMucHVzaChvKTtpZihzLmxlbmd0aCl7Y29uc3QgaT17eWVhcjpudWxsLG1vbnRoOm51bGwsc2hvcnRNb250aDpudWxsLGxvbmdNb250aDpudWxsLGRheTpudWxsLGhvdXI6MCxtaW51dGU6MCxzZWNvbmQ6MCxhbXBtOm51bGwsdmFsdWU6XCJcIn07c1swXS5pbmRleD4wJiYoaS52YWx1ZSs9XCIuKj9cIik7Zm9yKGNvbnN0W2Usb11vZiBPYmplY3QuZW50cmllcyhzKSl7Y29uc3Qgcz1OdW1iZXIoZSkse2dyb3VwOmEscGF0dGVybjpyfT10LmZvcm1hdFBhdHRlcm5zKG9bMF0sbik7aVthXT1zKzEsaS52YWx1ZSs9cixpLnZhbHVlKz1cIi4qP1wifWNvbnN0IG89bmV3IFJlZ0V4cChgXiR7aS52YWx1ZX0kYCk7aWYoby50ZXN0KGUpKXtjb25zdCBzPW8uZXhlYyhlKSxhPU51bWJlcihzW2kueWVhcl0pO2xldCByPW51bGw7aS5tb250aD9yPU51bWJlcihzW2kubW9udGhdKS0xOmkuc2hvcnRNb250aD9yPXQuc2hvcnRNb250aHMobikuaW5kZXhPZihzW2kuc2hvcnRNb250aF0pOmkubG9uZ01vbnRoJiYocj10LmxvbmdNb250aHMobikuaW5kZXhPZihzW2kubG9uZ01vbnRoXSkpO2NvbnN0IGM9TnVtYmVyKHNbaS5kYXldKXx8MSxsPU51bWJlcihzW2kuaG91cl0pO2xldCBoPU51bWJlci5pc05hTihsKT8wOmw7Y29uc3QgZD1OdW1iZXIoc1tpLm1pbnV0ZV0pLHA9TnVtYmVyLmlzTmFOKGQpPzA6ZCx1PU51bWJlcihzW2kuc2Vjb25kXSksZz1OdW1iZXIuaXNOYU4odSk/MDp1LG09c1tpLmFtcG1dO3JldHVybiBtJiZcIlBNXCI9PT1tJiYoaCs9MTIsMjQ9PT1oJiYoaD0wKSksbmV3IERhdGUoYSxyLGMsaCxwLGcsMCl9fX1yZXR1cm4gbmV3IERhdGUoKG5ldyBEYXRlKS5zZXRIb3VycygwLDAsMCwwKSl9c3RhdGljIHJlZ2V4PS8oXFxcXCk/KFl7Miw0fXxNezEsNH18RHsxLDJ9fEh7MSwyfXxoezEsMn18bXsxLDJ9fHN7MSwyfXxBfGEpL2c7c3RhdGljIE1PTlRIX0pTPVswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExXTtzdGF0aWMgc2hvcnRNb250aHMoZSl7cmV0dXJuIHQuTU9OVEhfSlMubWFwKCh0PT5uZXcgRGF0ZSgyMDE5LHQpLnRvTG9jYWxlU3RyaW5nKGUse21vbnRoOlwic2hvcnRcIn0pKSl9c3RhdGljIGxvbmdNb250aHMoZSl7cmV0dXJuIHQuTU9OVEhfSlMubWFwKCh0PT5uZXcgRGF0ZSgyMDE5LHQpLnRvTG9jYWxlU3RyaW5nKGUse21vbnRoOlwibG9uZ1wifSkpKX1zdGF0aWMgZm9ybWF0UGF0dGVybnMoZSxpKXtzd2l0Y2goZSl7Y2FzZVwiWVlcIjpjYXNlXCJZWVlZXCI6cmV0dXJue2dyb3VwOlwieWVhclwiLHBhdHRlcm46YChcXFxcZHske2UubGVuZ3RofX0pYH07Y2FzZVwiTVwiOnJldHVybntncm91cDpcIm1vbnRoXCIscGF0dGVybjpcIihcXFxcZHsxLDJ9KVwifTtjYXNlXCJNTVwiOnJldHVybntncm91cDpcIm1vbnRoXCIscGF0dGVybjpcIihcXFxcZHsyfSlcIn07Y2FzZVwiTU1NXCI6cmV0dXJue2dyb3VwOlwic2hvcnRNb250aFwiLHBhdHRlcm46YCgke3Quc2hvcnRNb250aHMoaSkuam9pbihcInxcIil9KWB9O2Nhc2VcIk1NTU1cIjpyZXR1cm57Z3JvdXA6XCJsb25nTW9udGhcIixwYXR0ZXJuOmAoJHt0LmxvbmdNb250aHMoaSkuam9pbihcInxcIil9KWB9O2Nhc2VcIkRcIjpyZXR1cm57Z3JvdXA6XCJkYXlcIixwYXR0ZXJuOlwiKFxcXFxkezEsMn0pXCJ9O2Nhc2VcIkREXCI6cmV0dXJue2dyb3VwOlwiZGF5XCIscGF0dGVybjpcIihcXFxcZHsyfSlcIn07Y2FzZVwiaFwiOmNhc2VcIkhcIjpyZXR1cm57Z3JvdXA6XCJob3VyXCIscGF0dGVybjpcIihcXFxcZHsxLDJ9KVwifTtjYXNlXCJoaFwiOmNhc2VcIkhIXCI6cmV0dXJue2dyb3VwOlwiaG91clwiLHBhdHRlcm46XCIoXFxcXGR7Mn0pXCJ9O2Nhc2VcIm1cIjpyZXR1cm57Z3JvdXA6XCJtaW51dGVcIixwYXR0ZXJuOlwiKFxcXFxkezEsMn0pXCJ9O2Nhc2VcIm1tXCI6cmV0dXJue2dyb3VwOlwibWludXRlXCIscGF0dGVybjpcIihcXFxcZHsyfSlcIn07Y2FzZVwic1wiOnJldHVybntncm91cDpcInNlY29uZFwiLHBhdHRlcm46XCIoXFxcXGR7MSwyfSlcIn07Y2FzZVwic3NcIjpyZXR1cm57Z3JvdXA6XCJzZWNvbmRcIixwYXR0ZXJuOlwiKFxcXFxkezJ9KVwifTtjYXNlXCJhXCI6Y2FzZVwiQVwiOnJldHVybntncm91cDpcImFtcG1cIixwYXR0ZXJuOlwiKEFNfFBNfGFtfHBtKVwifX19bGFuZztjb25zdHJ1Y3RvcihlPW51bGwsaT1cIllZWVktTU0tRERcIixuPVwiZW4tVVNcIil7c3VwZXIodC5wYXJzZURhdGVUaW1lKGUsaSxuKSksdGhpcy5sYW5nPW59Z2V0V2Vlayh0KXtjb25zdCBlPW5ldyBEYXRlKHRoaXMubWlkbmlnaHRfdHModGhpcykpLGk9KHRoaXMuZ2V0RGF5KCkrKDctdCkpJTc7ZS5zZXREYXRlKGUuZ2V0RGF0ZSgpLWkpO2NvbnN0IG49ZS5nZXRUaW1lKCk7cmV0dXJuIGUuc2V0TW9udGgoMCwxKSxlLmdldERheSgpIT09dCYmZS5zZXRNb250aCgwLDErKDQtZS5nZXREYXkoKSs3KSU3KSwxK01hdGguY2VpbCgobi1lLmdldFRpbWUoKSkvNjA0OGU1KX1jbG9uZSgpe3JldHVybiBuZXcgdCh0aGlzKX10b0pTRGF0ZSgpe3JldHVybiBuZXcgRGF0ZSh0aGlzKX1pbkFycmF5KHQsZT1cIltdXCIpe3JldHVybiB0LnNvbWUoKHQ9PnQgaW5zdGFuY2VvZiBBcnJheT90aGlzLmlzQmV0d2Vlbih0WzBdLHRbMV0sZSk6dGhpcy5pc1NhbWUodCxcImRheVwiKSkpfWlzQmV0d2Vlbih0LGUsaT1cIigpXCIpe3N3aXRjaChpKXtkZWZhdWx0OmNhc2VcIigpXCI6cmV0dXJuIHRoaXMubWlkbmlnaHRfdHModGhpcyk+dGhpcy5taWRuaWdodF90cyh0KSYmdGhpcy5taWRuaWdodF90cyh0aGlzKTx0aGlzLm1pZG5pZ2h0X3RzKGUpO2Nhc2VcIlspXCI6cmV0dXJuIHRoaXMubWlkbmlnaHRfdHModGhpcyk+PXRoaXMubWlkbmlnaHRfdHModCkmJnRoaXMubWlkbmlnaHRfdHModGhpcyk8dGhpcy5taWRuaWdodF90cyhlKTtjYXNlXCIoXVwiOnJldHVybiB0aGlzLm1pZG5pZ2h0X3RzKHRoaXMpPnRoaXMubWlkbmlnaHRfdHModCkmJnRoaXMubWlkbmlnaHRfdHModGhpcyk8PXRoaXMubWlkbmlnaHRfdHMoZSk7Y2FzZVwiW11cIjpyZXR1cm4gdGhpcy5taWRuaWdodF90cygpPj10aGlzLm1pZG5pZ2h0X3RzKHQpJiZ0aGlzLm1pZG5pZ2h0X3RzKCk8PXRoaXMubWlkbmlnaHRfdHMoZSl9fWlzQmVmb3JlKHQsZT1cImRheXNcIil7c3dpdGNoKGUpe2Nhc2VcImRheVwiOmNhc2VcImRheXNcIjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSx0LmdldERhdGUoKSkuZ2V0VGltZSgpPm5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksdGhpcy5nZXREYXRlKCkpLmdldFRpbWUoKTtjYXNlXCJtb250aFwiOmNhc2VcIm1vbnRoc1wiOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksdC5nZXRNb250aCgpLDEpLmdldFRpbWUoKT5uZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLDEpLmdldFRpbWUoKTtjYXNlXCJ5ZWFyXCI6Y2FzZVwieWVhcnNcIjpyZXR1cm4gdC5nZXRGdWxsWWVhcigpPnRoaXMuZ2V0RnVsbFllYXIoKX10aHJvdyBuZXcgRXJyb3IoXCJpc0JlZm9yZTogSW52YWxpZCB1bml0IVwiKX1pc1NhbWVPckJlZm9yZSh0LGU9XCJkYXlzXCIpe3N3aXRjaChlKXtjYXNlXCJkYXlcIjpjYXNlXCJkYXlzXCI6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksdC5nZXREYXRlKCkpLmdldFRpbWUoKT49bmV3IERhdGUodGhpcy5nZXRGdWxsWWVhcigpLHRoaXMuZ2V0TW9udGgoKSx0aGlzLmdldERhdGUoKSkuZ2V0VGltZSgpO2Nhc2VcIm1vbnRoXCI6Y2FzZVwibW9udGhzXCI6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksMSkuZ2V0VGltZSgpPj1uZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLDEpLmdldFRpbWUoKX10aHJvdyBuZXcgRXJyb3IoXCJpc1NhbWVPckJlZm9yZTogSW52YWxpZCB1bml0IVwiKX1pc0FmdGVyKHQsZT1cImRheXNcIil7c3dpdGNoKGUpe2Nhc2VcImRheVwiOmNhc2VcImRheXNcIjpyZXR1cm4gbmV3IERhdGUodGhpcy5nZXRGdWxsWWVhcigpLHRoaXMuZ2V0TW9udGgoKSx0aGlzLmdldERhdGUoKSkuZ2V0VGltZSgpPm5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksdC5nZXREYXRlKCkpLmdldFRpbWUoKTtjYXNlXCJtb250aFwiOmNhc2VcIm1vbnRoc1wiOnJldHVybiBuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLDEpLmdldFRpbWUoKT5uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksdC5nZXRNb250aCgpLDEpLmdldFRpbWUoKTtjYXNlXCJ5ZWFyXCI6Y2FzZVwieWVhcnNcIjpyZXR1cm4gdGhpcy5nZXRGdWxsWWVhcigpPnQuZ2V0RnVsbFllYXIoKX10aHJvdyBuZXcgRXJyb3IoXCJpc0FmdGVyOiBJbnZhbGlkIHVuaXQhXCIpfWlzU2FtZU9yQWZ0ZXIodCxlPVwiZGF5c1wiKXtzd2l0Y2goZSl7Y2FzZVwiZGF5XCI6Y2FzZVwiZGF5c1wiOnJldHVybiBuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLHRoaXMuZ2V0RGF0ZSgpKS5nZXRUaW1lKCk+PW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksdC5nZXREYXRlKCkpLmdldFRpbWUoKTtjYXNlXCJtb250aFwiOmNhc2VcIm1vbnRoc1wiOnJldHVybiBuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLDEpLmdldFRpbWUoKT49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSwxKS5nZXRUaW1lKCl9dGhyb3cgbmV3IEVycm9yKFwiaXNTYW1lT3JBZnRlcjogSW52YWxpZCB1bml0IVwiKX1pc1NhbWUodCxlPVwiZGF5c1wiKXtzd2l0Y2goZSl7Y2FzZVwiZGF5XCI6Y2FzZVwiZGF5c1wiOnJldHVybiBuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLHRoaXMuZ2V0RGF0ZSgpKS5nZXRUaW1lKCk9PT1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksdC5nZXRNb250aCgpLHQuZ2V0RGF0ZSgpKS5nZXRUaW1lKCk7Y2FzZVwibW9udGhcIjpjYXNlXCJtb250aHNcIjpyZXR1cm4gbmV3IERhdGUodGhpcy5nZXRGdWxsWWVhcigpLHRoaXMuZ2V0TW9udGgoKSwxKS5nZXRUaW1lKCk9PT1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksdC5nZXRNb250aCgpLDEpLmdldFRpbWUoKX10aHJvdyBuZXcgRXJyb3IoXCJpc1NhbWU6IEludmFsaWQgdW5pdCFcIil9YWRkKHQsZT1cImRheXNcIil7c3dpdGNoKGUpe2Nhc2VcImRheVwiOmNhc2VcImRheXNcIjp0aGlzLnNldERhdGUodGhpcy5nZXREYXRlKCkrdCk7YnJlYWs7Y2FzZVwibW9udGhcIjpjYXNlXCJtb250aHNcIjp0aGlzLnNldE1vbnRoKHRoaXMuZ2V0TW9udGgoKSt0KX1yZXR1cm4gdGhpc31zdWJ0cmFjdCh0LGU9XCJkYXlzXCIpe3N3aXRjaChlKXtjYXNlXCJkYXlcIjpjYXNlXCJkYXlzXCI6dGhpcy5zZXREYXRlKHRoaXMuZ2V0RGF0ZSgpLXQpO2JyZWFrO2Nhc2VcIm1vbnRoXCI6Y2FzZVwibW9udGhzXCI6dGhpcy5zZXRNb250aCh0aGlzLmdldE1vbnRoKCktdCl9cmV0dXJuIHRoaXN9ZGlmZih0LGU9XCJkYXlzXCIpe3N3aXRjaChlKXtkZWZhdWx0OmNhc2VcImRheVwiOmNhc2VcImRheXNcIjpyZXR1cm4gTWF0aC5yb3VuZCgodGhpcy5taWRuaWdodF90cygpLXRoaXMubWlkbmlnaHRfdHModCkpLzg2NGU1KTtjYXNlXCJtb250aFwiOmNhc2VcIm1vbnRoc1wiOmxldCBlPTEyKih0LmdldEZ1bGxZZWFyKCktdGhpcy5nZXRGdWxsWWVhcigpKTtyZXR1cm4gZS09dC5nZXRNb250aCgpLGUrPXRoaXMuZ2V0TW9udGgoKSxlfX1mb3JtYXQoZSxpPVwiZW4tVVNcIil7bGV0IG49XCJcIjtjb25zdCBzPVtdO2xldCBvPW51bGw7Zm9yKDtudWxsIT0obz10LnJlZ2V4LmV4ZWMoZSkpOylcIlxcXFxcIiE9PW9bMV0mJnMucHVzaChvKTtpZihzLmxlbmd0aCl7c1swXS5pbmRleD4wJiYobis9ZS5zdWJzdHJpbmcoMCxzWzBdLmluZGV4KSk7Zm9yKGNvbnN0W3Qsb11vZiBPYmplY3QuZW50cmllcyhzKSl7Y29uc3QgYT1OdW1iZXIodCk7bis9dGhpcy5mb3JtYXRUb2tlbnMob1swXSxpKSxzW2ErMV0mJihuKz1lLnN1YnN0cmluZyhvLmluZGV4K29bMF0ubGVuZ3RoLHNbYSsxXS5pbmRleCkpLGE9PT1zLmxlbmd0aC0xJiYobis9ZS5zdWJzdHJpbmcoby5pbmRleCtvWzBdLmxlbmd0aCkpfX1yZXR1cm4gbi5yZXBsYWNlKC9cXFxcL2csXCJcIil9bWlkbmlnaHRfdHModCl7cmV0dXJuIHQ/bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSx0LmdldERhdGUoKSwwLDAsMCwwKS5nZXRUaW1lKCk6bmV3IERhdGUodGhpcy5nZXRGdWxsWWVhcigpLHRoaXMuZ2V0TW9udGgoKSx0aGlzLmdldERhdGUoKSwwLDAsMCwwKS5nZXRUaW1lKCl9Zm9ybWF0VG9rZW5zKGUsaSl7c3dpdGNoKGUpe2Nhc2VcIllZXCI6cmV0dXJuIFN0cmluZyh0aGlzLmdldEZ1bGxZZWFyKCkpLnNsaWNlKC0yKTtjYXNlXCJZWVlZXCI6cmV0dXJuIFN0cmluZyh0aGlzLmdldEZ1bGxZZWFyKCkpO2Nhc2VcIk1cIjpyZXR1cm4gU3RyaW5nKHRoaXMuZ2V0TW9udGgoKSsxKTtjYXNlXCJNTVwiOnJldHVybmAwJHt0aGlzLmdldE1vbnRoKCkrMX1gLnNsaWNlKC0yKTtjYXNlXCJNTU1cIjpyZXR1cm4gdC5zaG9ydE1vbnRocyhpKVt0aGlzLmdldE1vbnRoKCldO2Nhc2VcIk1NTU1cIjpyZXR1cm4gdC5sb25nTW9udGhzKGkpW3RoaXMuZ2V0TW9udGgoKV07Y2FzZVwiRFwiOnJldHVybiBTdHJpbmcodGhpcy5nZXREYXRlKCkpO2Nhc2VcIkREXCI6cmV0dXJuYDAke3RoaXMuZ2V0RGF0ZSgpfWAuc2xpY2UoLTIpO2Nhc2VcIkhcIjpyZXR1cm4gU3RyaW5nKHRoaXMuZ2V0SG91cnMoKSk7Y2FzZVwiSEhcIjpyZXR1cm5gMCR7dGhpcy5nZXRIb3VycygpfWAuc2xpY2UoLTIpO2Nhc2VcImhcIjpyZXR1cm4gU3RyaW5nKHRoaXMuZ2V0SG91cnMoKSUxMnx8MTIpO2Nhc2VcImhoXCI6cmV0dXJuYDAke3RoaXMuZ2V0SG91cnMoKSUxMnx8MTJ9YC5zbGljZSgtMik7Y2FzZVwibVwiOnJldHVybiBTdHJpbmcodGhpcy5nZXRNaW51dGVzKCkpO2Nhc2VcIm1tXCI6cmV0dXJuYDAke3RoaXMuZ2V0TWludXRlcygpfWAuc2xpY2UoLTIpO2Nhc2VcInNcIjpyZXR1cm4gU3RyaW5nKHRoaXMuZ2V0U2Vjb25kcygpKTtjYXNlXCJzc1wiOnJldHVybmAwJHt0aGlzLmdldFNlY29uZHMoKX1gLnNsaWNlKC0yKTtjYXNlXCJhXCI6cmV0dXJuIHRoaXMuZ2V0SG91cnMoKTwxMnx8MjQ9PT10aGlzLmdldEhvdXJzKCk/XCJhbVwiOlwicG1cIjtjYXNlXCJBXCI6cmV0dXJuIHRoaXMuZ2V0SG91cnMoKTwxMnx8MjQ9PT10aGlzLmdldEhvdXJzKCk/XCJBTVwiOlwiUE1cIjtkZWZhdWx0OnJldHVyblwiXCJ9fX1jbGFzcyBle3BpY2tlcjtjb25zdHJ1Y3Rvcih0KXt0aGlzLnBpY2tlcj10fXJlbmRlcihlLGkpe2V8fChlPW5ldyB0KSxlLnNldERhdGUoMSksZS5zZXRIb3VycygwLDAsMCwwKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzW2BnZXQke2l9Vmlld2BdJiZ0aGlzW2BnZXQke2l9Vmlld2BdKGUpfWdldENvbnRhaW5lclZpZXcodCl7dGhpcy5waWNrZXIudWkuY29udGFpbmVyLmlubmVySFRNTD1cIlwiLHRoaXMucGlja2VyLm9wdGlvbnMuaGVhZGVyJiZ0aGlzLnBpY2tlci50cmlnZ2VyKFwicmVuZGVyXCIse2RhdGU6dC5jbG9uZSgpLHZpZXc6XCJIZWFkZXJcIn0pLHRoaXMucGlja2VyLnRyaWdnZXIoXCJyZW5kZXJcIix7ZGF0ZTp0LmNsb25lKCksdmlldzpcIk1haW5cIn0pLHRoaXMucGlja2VyLm9wdGlvbnMuYXV0b0FwcGx5fHx0aGlzLnBpY2tlci50cmlnZ2VyKFwicmVuZGVyXCIse2RhdGU6dC5jbG9uZSgpLHZpZXc6XCJGb290ZXJcIn0pfWdldEhlYWRlclZpZXcodCl7Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaGVhZGVyXCIpO3RoaXMucGlja2VyLm9wdGlvbnMuaGVhZGVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJmUuYXBwZW5kQ2hpbGQodGhpcy5waWNrZXIub3B0aW9ucy5oZWFkZXIpLFwic3RyaW5nXCI9PXR5cGVvZiB0aGlzLnBpY2tlci5vcHRpb25zLmhlYWRlciYmKGUuaW5uZXJIVE1MPXRoaXMucGlja2VyLm9wdGlvbnMuaGVhZGVyKSx0aGlzLnBpY2tlci51aS5jb250YWluZXIuYXBwZW5kQ2hpbGQoZSksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7dGFyZ2V0OmUsZGF0ZTp0LmNsb25lKCksdmlldzpcIkhlYWRlclwifSl9Z2V0TWFpblZpZXcodCl7Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWFpblwiKTt0aGlzLnBpY2tlci51aS5jb250YWluZXIuYXBwZW5kQ2hpbGQoZSk7Y29uc3QgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2kuY2xhc3NOYW1lPWBjYWxlbmRhcnMgZ3JpZC0ke3RoaXMucGlja2VyLm9wdGlvbnMuZ3JpZH1gO2ZvcihsZXQgZT0wO2U8dGhpcy5waWNrZXIub3B0aW9ucy5jYWxlbmRhcnM7ZSsrKXtjb25zdCBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7bi5jbGFzc05hbWU9XCJjYWxlbmRhclwiLGkuYXBwZW5kQ2hpbGQobik7Y29uc3Qgcz10aGlzLmdldENhbGVuZGFySGVhZGVyVmlldyh0LmNsb25lKCkpO24uYXBwZW5kQ2hpbGQocyksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7ZGF0ZTp0LmNsb25lKCksdmlldzpcIkNhbGVuZGFySGVhZGVyXCIsaW5kZXg6ZSx0YXJnZXQ6c30pO2NvbnN0IG89dGhpcy5nZXRDYWxlbmRhckRheU5hbWVzVmlldygpO24uYXBwZW5kQ2hpbGQobyksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7ZGF0ZTp0LmNsb25lKCksdmlldzpcIkNhbGVuZGFyRGF5TmFtZXNcIixpbmRleDplLHRhcmdldDpvfSk7Y29uc3QgYT10aGlzLmdldENhbGVuZGFyRGF5c1ZpZXcodC5jbG9uZSgpKTtuLmFwcGVuZENoaWxkKGEpLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse2RhdGU6dC5jbG9uZSgpLHZpZXc6XCJDYWxlbmRhckRheXNcIixpbmRleDplLHRhcmdldDphfSk7Y29uc3Qgcj10aGlzLmdldENhbGVuZGFyRm9vdGVyVmlldyh0aGlzLnBpY2tlci5vcHRpb25zLmxhbmcsdC5jbG9uZSgpKTtuLmFwcGVuZENoaWxkKHIpLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse2RhdGU6dC5jbG9uZSgpLHZpZXc6XCJDYWxlbmRhckZvb3RlclwiLGluZGV4OmUsdGFyZ2V0OnJ9KSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHtkYXRlOnQuY2xvbmUoKSx2aWV3OlwiQ2FsZW5kYXJJdGVtXCIsaW5kZXg6ZSx0YXJnZXQ6bn0pLHQuYWRkKDEsXCJtb250aFwiKX1lLmFwcGVuZENoaWxkKGkpLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse2RhdGU6dC5jbG9uZSgpLHZpZXc6XCJDYWxlbmRhcnNcIix0YXJnZXQ6aX0pLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse2RhdGU6dC5jbG9uZSgpLHZpZXc6XCJNYWluXCIsdGFyZ2V0OmV9KX1nZXRGb290ZXJWaWV3KHQpe2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvb3RlclwiKSxpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aS5jbGFzc05hbWU9XCJmb290ZXItYnV0dG9uc1wiO2NvbnN0IG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtuLmNsYXNzTmFtZT1cImNhbmNlbC1idXR0b24gdW5pdFwiLG4uaW5uZXJIVE1MPXRoaXMucGlja2VyLm9wdGlvbnMubG9jYWxlLmNhbmNlbCxpLmFwcGVuZENoaWxkKG4pO2NvbnN0IHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtzLmNsYXNzTmFtZT1cImFwcGx5LWJ1dHRvbiB1bml0XCIscy5pbm5lckhUTUw9dGhpcy5waWNrZXIub3B0aW9ucy5sb2NhbGUuYXBwbHkscy5kaXNhYmxlZD0hMCxpLmFwcGVuZENoaWxkKHMpLGUuYXBwZW5kQ2hpbGQoaSksdGhpcy5waWNrZXIudWkuY29udGFpbmVyLmFwcGVuZENoaWxkKGUpLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse2RhdGU6dCx0YXJnZXQ6ZSx2aWV3OlwiRm9vdGVyXCJ9KX1nZXRDYWxlbmRhckhlYWRlclZpZXcodCl7Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2UuY2xhc3NOYW1lPVwiaGVhZGVyXCI7Y29uc3QgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2kuY2xhc3NOYW1lPVwibW9udGgtbmFtZVwiLGkuaW5uZXJIVE1MPWA8c3Bhbj4ke3QudG9Mb2NhbGVTdHJpbmcodGhpcy5waWNrZXIub3B0aW9ucy5sYW5nLHttb250aDpcImxvbmdcIn0pfTwvc3Bhbj4gJHt0LmZvcm1hdChcIllZWVlcIil9YCxlLmFwcGVuZENoaWxkKGkpO2NvbnN0IG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtuLmNsYXNzTmFtZT1cInByZXZpb3VzLWJ1dHRvbiB1bml0XCIsbi5pbm5lckhUTUw9dGhpcy5waWNrZXIub3B0aW9ucy5sb2NhbGUucHJldmlvdXNNb250aCxlLmFwcGVuZENoaWxkKG4pO2NvbnN0IHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtyZXR1cm4gcy5jbGFzc05hbWU9XCJuZXh0LWJ1dHRvbiB1bml0XCIscy5pbm5lckhUTUw9dGhpcy5waWNrZXIub3B0aW9ucy5sb2NhbGUubmV4dE1vbnRoLGUuYXBwZW5kQ2hpbGQocyksZX1nZXRDYWxlbmRhckRheU5hbWVzVmlldygpe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0LmNsYXNzTmFtZT1cImRheW5hbWVzLXJvd1wiO2ZvcihsZXQgZT0xO2U8PTc7ZSsrKXtjb25zdCBpPTMrdGhpcy5waWNrZXIub3B0aW9ucy5maXJzdERheStlLG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtuLmNsYXNzTmFtZT1cImRheW5hbWVcIixuLmlubmVySFRNTD1uZXcgRGF0ZSgxOTcwLDAsaSwxMiwwLDAsMCkudG9Mb2NhbGVTdHJpbmcodGhpcy5waWNrZXIub3B0aW9ucy5sYW5nLHt3ZWVrZGF5Olwic2hvcnRcIn0pLG4udGl0bGU9bmV3IERhdGUoMTk3MCwwLGksMTIsMCwwLDApLnRvTG9jYWxlU3RyaW5nKHRoaXMucGlja2VyLm9wdGlvbnMubGFuZyx7d2Vla2RheTpcImxvbmdcIn0pLHQuYXBwZW5kQ2hpbGQobiksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7ZGF5SWR4OmksdmlldzpcIkNhbGVuZGFyRGF5TmFtZVwiLHRhcmdldDpufSl9cmV0dXJuIHR9Z2V0Q2FsZW5kYXJEYXlzVmlldyh0KXtjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7ZS5jbGFzc05hbWU9XCJkYXlzLWdyaWRcIjtjb25zdCBpPXRoaXMuY2FsY09mZnNldERheXModCx0aGlzLnBpY2tlci5vcHRpb25zLmZpcnN0RGF5KSxuPTMyLW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksMzIpLmdldERhdGUoKTtmb3IobGV0IHQ9MDt0PGk7dCsrKXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dC5jbGFzc05hbWU9XCJvZmZzZXRcIixlLmFwcGVuZENoaWxkKHQpfWZvcihsZXQgaT0xO2k8PW47aSsrKXt0LnNldERhdGUoaSk7Y29uc3Qgbj10aGlzLmdldENhbGVuZGFyRGF5Vmlldyh0KTtlLmFwcGVuZENoaWxkKG4pLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse2RhdGU6dCx2aWV3OlwiQ2FsZW5kYXJEYXlcIix0YXJnZXQ6bn0pfXJldHVybiBlfWdldENhbGVuZGFyRGF5VmlldyhlKXtjb25zdCBpPXRoaXMucGlja2VyLm9wdGlvbnMuZGF0ZT9uZXcgdCh0aGlzLnBpY2tlci5vcHRpb25zLmRhdGUpOm51bGwsbj1uZXcgdCxzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIHMuY2xhc3NOYW1lPVwiZGF5IHVuaXRcIixzLmlubmVySFRNTD1lLmZvcm1hdChcIkRcIikscy5kYXRhc2V0LnRpbWU9U3RyaW5nKGUuZ2V0VGltZSgpKSxlLmlzU2FtZShuLFwiZGF5XCIpJiZzLmNsYXNzTGlzdC5hZGQoXCJ0b2RheVwiKSxbMCw2XS5pbmNsdWRlcyhlLmdldERheSgpKSYmcy5jbGFzc0xpc3QuYWRkKFwid2Vla2VuZFwiKSx0aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aD90aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdLmlzU2FtZShlLFwiZGF5XCIpJiZzLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTppJiZlLmlzU2FtZShpLFwiZGF5XCIpJiZzLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHtkYXRlOmUsdmlldzpcIkNhbGVuZGFyRGF5XCIsdGFyZ2V0OnN9KSxzfWdldENhbGVuZGFyRm9vdGVyVmlldyh0LGUpe2NvbnN0IGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gaS5jbGFzc05hbWU9XCJmb290ZXJcIixpfWNhbGNPZmZzZXREYXlzKHQsZSl7bGV0IGk9dC5nZXREYXkoKS1lO3JldHVybiBpPDAmJihpKz03KSxpfX1jbGFzcyBpe3BpY2tlcjtpbnN0YW5jZXM9e307Y29uc3RydWN0b3IodCl7dGhpcy5waWNrZXI9dH1pbml0aWFsaXplKCl7Y29uc3QgdD1bXTt0aGlzLnBpY2tlci5vcHRpb25zLnBsdWdpbnMuZm9yRWFjaCgoZT0+e1wiZnVuY3Rpb25cIj09dHlwZW9mIGU/dC5wdXNoKG5ldyBlKTpcInN0cmluZ1wiPT10eXBlb2YgZSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGVhc2VwaWNrJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWFzZXBpY2ssZSk/dC5wdXNoKG5ldyBlYXNlcGlja1tlXSk6Y29uc29sZS53YXJuKGBlYXNlcGljazogJHtlfSBub3QgZm91bmQuYCl9KSksdC5zb3J0KCgodCxlKT0+dC5wcmlvcml0eT5lLnByaW9yaXR5Py0xOnQucHJpb3JpdHk8ZS5wcmlvcml0eXx8dC5kZXBlbmRlbmNpZXMubGVuZ3RoPmUuZGVwZW5kZW5jaWVzLmxlbmd0aD8xOnQuZGVwZW5kZW5jaWVzLmxlbmd0aDxlLmRlcGVuZGVuY2llcy5sZW5ndGg/LTE6MCkpLHQuZm9yRWFjaCgodD0+e3QuYXR0YWNoKHRoaXMucGlja2VyKSx0aGlzLmluc3RhbmNlc1t0LmdldE5hbWUoKV09dH0pKX1nZXRJbnN0YW5jZSh0KXtyZXR1cm4gdGhpcy5pbnN0YW5jZXNbdF19YWRkSW5zdGFuY2UodCl7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaW5zdGFuY2VzLHQpKWNvbnNvbGUud2FybihgZWFzZXBpY2s6ICR7dH0gYWxyZWFkeSBhZGRlZC5gKTtlbHNle2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBlYXNlcGljayYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVhc2VwaWNrLHQpKXtjb25zdCBlPW5ldyBlYXNlcGlja1t0XTtyZXR1cm4gZS5hdHRhY2godGhpcy5waWNrZXIpLHRoaXMuaW5zdGFuY2VzW2UuZ2V0TmFtZSgpXT1lLGV9aWYoXCJ1bmRlZmluZWRcIiE9PXRoaXMuZ2V0UGx1Z2luRm4odCkpe2NvbnN0IGU9bmV3KHRoaXMuZ2V0UGx1Z2luRm4odCkpO3JldHVybiBlLmF0dGFjaCh0aGlzLnBpY2tlciksdGhpcy5pbnN0YW5jZXNbZS5nZXROYW1lKCldPWUsZX1jb25zb2xlLndhcm4oYGVhc2VwaWNrOiAke3R9IG5vdCBmb3VuZC5gKX1yZXR1cm4gbnVsbH1yZW1vdmVJbnN0YW5jZSh0KXtyZXR1cm4gdCBpbiB0aGlzLmluc3RhbmNlcyYmdGhpcy5pbnN0YW5jZXNbdF0uZGV0YWNoKCksZGVsZXRlIHRoaXMuaW5zdGFuY2VzW3RdfXJlbG9hZEluc3RhbmNlKHQpe3JldHVybiB0aGlzLnJlbW92ZUluc3RhbmNlKHQpLHRoaXMuYWRkSW5zdGFuY2UodCl9Z2V0UGx1Z2luRm4odCl7cmV0dXJuWy4uLnRoaXMucGlja2VyLm9wdGlvbnMucGx1Z2luc10uZmlsdGVyKChlPT5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYobmV3IGUpLmdldE5hbWUoKT09PXQpKS5zaGlmdCgpfX1jbGFzcyBue0NhbGVuZGFyPW5ldyBlKHRoaXMpO1BsdWdpbk1hbmFnZXI9bmV3IGkodGhpcyk7Y2FsZW5kYXJzPVtdO2RhdGVQaWNrZWQ9W107Y3NzTG9hZGVkPTA7YmluZHM9e2hpZGVQaWNrZXI6dGhpcy5oaWRlUGlja2VyLmJpbmQodGhpcyksc2hvdzp0aGlzLnNob3cuYmluZCh0aGlzKX07b3B0aW9ucz17ZG9jOmRvY3VtZW50LGNzczpbXSxlbGVtZW50Om51bGwsZmlyc3REYXk6MSxncmlkOjEsY2FsZW5kYXJzOjEsbGFuZzpcImVuLVVTXCIsZGF0ZTpudWxsLGZvcm1hdDpcIllZWVktTU0tRERcIixyZWFkb25seTohMCxhdXRvQXBwbHk6ITAsaGVhZGVyOiExLGlubGluZTohMSxzY3JvbGxUb0RhdGU6ITAsbG9jYWxlOntuZXh0TW9udGg6Jzxzdmcgd2lkdGg9XCIxMVwiIGhlaWdodD1cIjE2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMi43NDggMTZMMCAxMy4zMzMgNS4zMzMgOCAwIDIuNjY3IDIuNzQ4IDBsNy45MTkgOHpcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicscHJldmlvdXNNb250aDonPHN2ZyB3aWR0aD1cIjExXCIgaGVpZ2h0PVwiMTZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk03LjkxOSAwbDIuNzQ4IDIuNjY3TDUuMzMzIDhsNS4zMzQgNS4zMzNMNy45MTkgMTYgMCA4elwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxjYW5jZWw6XCJDYW5jZWxcIixhcHBseTpcIkFwcGx5XCJ9LGRvY3VtZW50Q2xpY2s6dGhpcy5iaW5kcy5oaWRlUGlja2VyLHBsdWdpbnM6W119O3VpPXtjb250YWluZXI6bnVsbCxzaGFkb3dSb290Om51bGwsd3JhcHBlcjpudWxsfTt2ZXJzaW9uPVwiMS4yLjFcIjtjb25zdHJ1Y3Rvcih0KXtjb25zdCBlPXsuLi50aGlzLm9wdGlvbnMubG9jYWxlLC4uLnQubG9jYWxlfTt0aGlzLm9wdGlvbnM9ey4uLnRoaXMub3B0aW9ucywuLi50fSx0aGlzLm9wdGlvbnMubG9jYWxlPWUsdGhpcy5oYW5kbGVPcHRpb25zKCksdGhpcy51aS53cmFwcGVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLHRoaXMudWkud3JhcHBlci5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLHRoaXMudWkud3JhcHBlci5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsdGhpcy51aS53cmFwcGVyLnN0eWxlLnBvaW50ZXJFdmVudHM9XCJub25lXCIsdGhpcy51aS53cmFwcGVyLmNsYXNzTmFtZT1cImVhc2VwaWNrLXdyYXBwZXJcIix0aGlzLnVpLndyYXBwZXIuYXR0YWNoU2hhZG93KHttb2RlOlwib3BlblwifSksdGhpcy51aS5zaGFkb3dSb290PXRoaXMudWkud3JhcHBlci5zaGFkb3dSb290LHRoaXMudWkuY29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy51aS5jb250YWluZXIuY2xhc3NOYW1lPVwiY29udGFpbmVyXCIsdGhpcy5vcHRpb25zLnpJbmRleCYmKHRoaXMudWkuY29udGFpbmVyLnN0eWxlLnpJbmRleD1TdHJpbmcodGhpcy5vcHRpb25zLnpJbmRleCkpLHRoaXMub3B0aW9ucy5pbmxpbmUmJih0aGlzLnVpLndyYXBwZXIuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiLHRoaXMudWkuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJpbmxpbmVcIikpLHRoaXMudWkuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLnVpLmNvbnRhaW5lciksdGhpcy5vcHRpb25zLmVsZW1lbnQuYWZ0ZXIodGhpcy51aS53cmFwcGVyKSx0aGlzLmhhbmRsZUNTUygpLHRoaXMub3B0aW9ucy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuYmluZHMuc2hvdyksdGhpcy5vbihcInZpZXdcIix0aGlzLm9uVmlldy5iaW5kKHRoaXMpKSx0aGlzLm9uKFwicmVuZGVyXCIsdGhpcy5vblJlbmRlci5iaW5kKHRoaXMpKSx0aGlzLlBsdWdpbk1hbmFnZXIuaW5pdGlhbGl6ZSgpLHRoaXMucGFyc2VWYWx1ZXMoKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuc2V0dXAmJnRoaXMub3B0aW9ucy5zZXR1cCh0aGlzKSx0aGlzLm9uKFwiY2xpY2tcIix0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSk7Y29uc3QgaT10aGlzLm9wdGlvbnMuc2Nyb2xsVG9EYXRlP3RoaXMuZ2V0RGF0ZSgpOm51bGw7dGhpcy5yZW5kZXJBbGwoaSl9b24odCxlLGk9e30pe3RoaXMudWkuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIodCxlLGkpfW9mZih0LGUsaT17fSl7dGhpcy51aS5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LGUsaSl9dHJpZ2dlcih0LGU9e30pe3JldHVybiB0aGlzLnVpLmNvbnRhaW5lci5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCh0LHtkZXRhaWw6ZX0pKX1kZXN0cm95KCl7dGhpcy5vcHRpb25zLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5iaW5kcy5zaG93KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuZG9jdW1lbnRDbGljayYmZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5vcHRpb25zLmRvY3VtZW50Q2xpY2ssITApLE9iamVjdC5rZXlzKHRoaXMuUGx1Z2luTWFuYWdlci5pbnN0YW5jZXMpLmZvckVhY2goKHQ9Pnt0aGlzLlBsdWdpbk1hbmFnZXIucmVtb3ZlSW5zdGFuY2UodCl9KSksdGhpcy51aS53cmFwcGVyLnJlbW92ZSgpfW9uUmVuZGVyKHQpe2NvbnN0e3ZpZXc6ZSxkYXRlOml9PXQuZGV0YWlsO3RoaXMuQ2FsZW5kYXIucmVuZGVyKGksZSl9b25WaWV3KHQpe2NvbnN0e3ZpZXc6ZSx0YXJnZXQ6aX09dC5kZXRhaWw7XCJGb290ZXJcIj09PWUmJnRoaXMuZGF0ZVBpY2tlZC5sZW5ndGgmJihpLnF1ZXJ5U2VsZWN0b3IoXCIuYXBwbHktYnV0dG9uXCIpLmRpc2FibGVkPSExKX1vbkNsaWNrSGVhZGVyQnV0dG9uKHQpe3RoaXMuaXNDYWxlbmRhckhlYWRlckJ1dHRvbih0KSYmKHQuY2xhc3NMaXN0LmNvbnRhaW5zKFwibmV4dC1idXR0b25cIik/dGhpcy5jYWxlbmRhcnNbMF0uYWRkKDEsXCJtb250aFwiKTp0aGlzLmNhbGVuZGFyc1swXS5zdWJ0cmFjdCgxLFwibW9udGhcIiksdGhpcy5yZW5kZXJBbGwodGhpcy5jYWxlbmRhcnNbMF0pKX1vbkNsaWNrQ2FsZW5kYXJEYXkoZSl7aWYodGhpcy5pc0NhbGVuZGFyRGF5KGUpKXtjb25zdCBpPW5ldyB0KGUuZGF0YXNldC50aW1lKTt0aGlzLm9wdGlvbnMuYXV0b0FwcGx5Pyh0aGlzLnNldERhdGUoaSksdGhpcy50cmlnZ2VyKFwic2VsZWN0XCIse2RhdGU6dGhpcy5nZXREYXRlKCl9KSx0aGlzLmhpZGUoKSk6KHRoaXMuZGF0ZVBpY2tlZFswXT1pLHRoaXMudHJpZ2dlcihcInByZXNlbGVjdFwiLHtkYXRlOnRoaXMuZ2V0RGF0ZSgpfSksdGhpcy5yZW5kZXJBbGwoKSl9fW9uQ2xpY2tBcHBseUJ1dHRvbih0KXtpZih0aGlzLmlzQXBwbHlCdXR0b24odCkpe2lmKHRoaXMuZGF0ZVBpY2tlZFswXWluc3RhbmNlb2YgRGF0ZSl7Y29uc3QgdD10aGlzLmRhdGVQaWNrZWRbMF0uY2xvbmUoKTt0aGlzLnNldERhdGUodCl9dGhpcy5oaWRlKCksdGhpcy50cmlnZ2VyKFwic2VsZWN0XCIse2RhdGU6dGhpcy5nZXREYXRlKCl9KX19b25DbGlja0NhbmNlbEJ1dHRvbih0KXt0aGlzLmlzQ2FuY2VsQnV0dG9uKHQpJiZ0aGlzLmhpZGUoKX1vbkNsaWNrKHQpe2NvbnN0IGU9dC50YXJnZXQ7aWYoZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KXtjb25zdCB0PWUuY2xvc2VzdChcIi51bml0XCIpO2lmKCEodCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlyZXR1cm47dGhpcy5vbkNsaWNrSGVhZGVyQnV0dG9uKHQpLHRoaXMub25DbGlja0NhbGVuZGFyRGF5KHQpLHRoaXMub25DbGlja0FwcGx5QnV0dG9uKHQpLHRoaXMub25DbGlja0NhbmNlbEJ1dHRvbih0KX19aXNTaG93bigpe3JldHVybiB0aGlzLnVpLmNvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoXCJpbmxpbmVcIil8fHRoaXMudWkuY29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcInNob3dcIil9c2hvdyh0KXtpZih0aGlzLmlzU2hvd24oKSlyZXR1cm47Y29uc3QgZT10JiZcInRhcmdldFwiaW4gdD90LnRhcmdldDp0aGlzLm9wdGlvbnMuZWxlbWVudCx7dG9wOmksbGVmdDpufT10aGlzLmFkanVzdFBvc2l0aW9uKGUpO3RoaXMudWkuY29udGFpbmVyLnN0eWxlLnRvcD1gJHtpfXB4YCx0aGlzLnVpLmNvbnRhaW5lci5zdHlsZS5sZWZ0PWAke259cHhgLHRoaXMudWkuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzaG93XCIpLHRoaXMudHJpZ2dlcihcInNob3dcIix7dGFyZ2V0OmV9KX1oaWRlKCl7dGhpcy51aS5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIiksdGhpcy5kYXRlUGlja2VkLmxlbmd0aD0wLHRoaXMucmVuZGVyQWxsKCksdGhpcy50cmlnZ2VyKFwiaGlkZVwiKX1zZXREYXRlKGUpe2NvbnN0IGk9bmV3IHQoZSx0aGlzLm9wdGlvbnMuZm9ybWF0KTt0aGlzLm9wdGlvbnMuZGF0ZT1pLmNsb25lKCksdGhpcy51cGRhdGVWYWx1ZXMoKSx0aGlzLmNhbGVuZGFycy5sZW5ndGgmJnRoaXMucmVuZGVyQWxsKCl9Z2V0RGF0ZSgpe3JldHVybiB0aGlzLm9wdGlvbnMuZGF0ZSBpbnN0YW5jZW9mIHQ/dGhpcy5vcHRpb25zLmRhdGUuY2xvbmUoKTpudWxsfXBhcnNlVmFsdWVzKCl7dGhpcy5vcHRpb25zLmRhdGU/dGhpcy5zZXREYXRlKHRoaXMub3B0aW9ucy5kYXRlKTp0aGlzLm9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJnRoaXMub3B0aW9ucy5lbGVtZW50LnZhbHVlLmxlbmd0aCYmdGhpcy5zZXREYXRlKHRoaXMub3B0aW9ucy5lbGVtZW50LnZhbHVlKSx0aGlzLm9wdGlvbnMuZGF0ZSBpbnN0YW5jZW9mIERhdGV8fCh0aGlzLm9wdGlvbnMuZGF0ZT1udWxsKX11cGRhdGVWYWx1ZXMoKXtjb25zdCB0PXRoaXMuZ2V0RGF0ZSgpLGU9dCBpbnN0YW5jZW9mIERhdGU/dC5mb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCx0aGlzLm9wdGlvbnMubGFuZyk6XCJcIixpPXRoaXMub3B0aW9ucy5lbGVtZW50O2kgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50P2kudmFsdWU9ZTppIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJihpLmlubmVyVGV4dD1lKX1oaWRlUGlja2VyKHQpe2xldCBlPXQudGFyZ2V0LGk9bnVsbDtlLnNoYWRvd1Jvb3QmJihlPXQuY29tcG9zZWRQYXRoKClbMF0saT1lLmdldFJvb3ROb2RlKCkuaG9zdCksdGhpcy5pc1Nob3duKCkmJmkhPT10aGlzLnVpLndyYXBwZXImJmUhPT10aGlzLm9wdGlvbnMuZWxlbWVudCYmdGhpcy5oaWRlKCl9cmVuZGVyQWxsKHQpe3RoaXMudHJpZ2dlcihcInJlbmRlclwiLHt2aWV3OlwiQ29udGFpbmVyXCIsZGF0ZToodHx8dGhpcy5jYWxlbmRhcnNbMF0pLmNsb25lKCl9KX1pc0NhbGVuZGFySGVhZGVyQnV0dG9uKHQpe3JldHVybltcInByZXZpb3VzLWJ1dHRvblwiLFwibmV4dC1idXR0b25cIl0uc29tZSgoZT0+dC5jbGFzc0xpc3QuY29udGFpbnMoZSkpKX1pc0NhbGVuZGFyRGF5KHQpe3JldHVybiB0LmNsYXNzTGlzdC5jb250YWlucyhcImRheVwiKX1pc0FwcGx5QnV0dG9uKHQpe3JldHVybiB0LmNsYXNzTGlzdC5jb250YWlucyhcImFwcGx5LWJ1dHRvblwiKX1pc0NhbmNlbEJ1dHRvbih0KXtyZXR1cm4gdC5jbGFzc0xpc3QuY29udGFpbnMoXCJjYW5jZWwtYnV0dG9uXCIpfWdvdG9EYXRlKGUpe2NvbnN0IGk9bmV3IHQoZSx0aGlzLm9wdGlvbnMuZm9ybWF0KTtpLnNldERhdGUoMSksdGhpcy5jYWxlbmRhcnNbMF09aS5jbG9uZSgpLHRoaXMucmVuZGVyQWxsKCl9Y2xlYXIoKXt0aGlzLm9wdGlvbnMuZGF0ZT1udWxsLHRoaXMuZGF0ZVBpY2tlZC5sZW5ndGg9MCx0aGlzLnVwZGF0ZVZhbHVlcygpLHRoaXMucmVuZGVyQWxsKCksdGhpcy50cmlnZ2VyKFwiY2xlYXJcIil9aGFuZGxlT3B0aW9ucygpe3RoaXMub3B0aW9ucy5lbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnR8fCh0aGlzLm9wdGlvbnMuZWxlbWVudD10aGlzLm9wdGlvbnMuZG9jLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLmVsZW1lbnQpKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuZG9jdW1lbnRDbGljayYmZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5vcHRpb25zLmRvY3VtZW50Q2xpY2ssITApLHRoaXMub3B0aW9ucy5lbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmKHRoaXMub3B0aW9ucy5lbGVtZW50LnJlYWRPbmx5PXRoaXMub3B0aW9ucy5yZWFkb25seSksdGhpcy5vcHRpb25zLmRhdGU/dGhpcy5jYWxlbmRhcnNbMF09bmV3IHQodGhpcy5vcHRpb25zLmRhdGUsdGhpcy5vcHRpb25zLmZvcm1hdCk6dGhpcy5jYWxlbmRhcnNbMF09bmV3IHR9aGFuZGxlQ1NTKCl7aWYoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuY3NzKSl0aGlzLm9wdGlvbnMuY3NzLmZvckVhY2goKHQ9Pntjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO2UuaHJlZj10LGUucmVsPVwic3R5bGVzaGVldFwiO2NvbnN0IGk9KCk9Pnt0aGlzLmNzc0xvYWRlZCsrLHRoaXMuY3NzTG9hZGVkPT09dGhpcy5vcHRpb25zLmNzcy5sZW5ndGgmJih0aGlzLnVpLndyYXBwZXIuc3R5bGUuZGlzcGxheT1cIlwiKX07ZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGkpLGUuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsaSksdGhpcy51aS5zaGFkb3dSb290LmFwcGVuZChlKX0pKTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuY3NzKXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSxlPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMub3B0aW9ucy5jc3MpO3QuYXBwZW5kQ2hpbGQoZSksdGhpcy51aS5zaGFkb3dSb290LmFwcGVuZCh0KSx0aGlzLnVpLndyYXBwZXIuc3R5bGUuZGlzcGxheT1cIlwifWVsc2VcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuY3NzJiYodGhpcy5vcHRpb25zLmNzcy5jYWxsKHRoaXMsdGhpcyksdGhpcy51aS53cmFwcGVyLnN0eWxlLmRpc3BsYXk9XCJcIil9YWRqdXN0UG9zaXRpb24odCl7Y29uc3QgZT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGk9dGhpcy51aS53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3RoaXMudWkuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjYWxjXCIpO2NvbnN0IG49dGhpcy51aS5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dGhpcy51aS5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcImNhbGNcIik7bGV0IHM9ZS5ib3R0b20taS5ib3R0b20sbz1lLmxlZnQtaS5sZWZ0O3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJih3aW5kb3cuaW5uZXJIZWlnaHQ8cytuLmhlaWdodCYmcy1uLmhlaWdodD49MCYmKHM9ZS50b3AtaS50b3Atbi5oZWlnaHQpLHdpbmRvdy5pbm5lcldpZHRoPG8rbi53aWR0aCYmZS5yaWdodC1uLndpZHRoPj0wJiYobz1lLnJpZ2h0LWkucmlnaHQtbi53aWR0aCkpLHtsZWZ0Om8sdG9wOnN9fX12YXIgcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxDb3JlOm4sY3JlYXRlOm59KTtjbGFzcyBve3BpY2tlcjtvcHRpb25zO3ByaW9yaXR5PTA7ZGVwZW5kZW5jaWVzPVtdO2F0dGFjaCh0KXtjb25zdCBlPXRoaXMuZ2V0TmFtZSgpLGk9ey4uLnRoaXMub3B0aW9uc307dGhpcy5vcHRpb25zPXsuLi50aGlzLm9wdGlvbnMsLi4udC5vcHRpb25zW2VdfHx7fX07Zm9yKGNvbnN0IG4gb2YgT2JqZWN0LmtleXMoaSkpaWYobnVsbCE9PWlbbl0mJlwib2JqZWN0XCI9PXR5cGVvZiBpW25dJiZPYmplY3Qua2V5cyhpW25dKS5sZW5ndGgmJmUgaW4gdC5vcHRpb25zJiZuIGluIHQub3B0aW9uc1tlXSl7Y29uc3Qgcz17Li4udC5vcHRpb25zW2VdW25dfTtudWxsIT09cyYmXCJvYmplY3RcIj09dHlwZW9mIHMmJk9iamVjdC5rZXlzKHMpLmxlbmd0aCYmT2JqZWN0LmtleXMocykuZXZlcnkoKHQ9Pk9iamVjdC5rZXlzKGlbbl0pLmluY2x1ZGVzKHQpKSkmJih0aGlzLm9wdGlvbnNbbl09ey4uLmlbbl0sLi4uc30pfWlmKHRoaXMucGlja2VyPXQsdGhpcy5kZXBlbmRlbmNpZXNOb3RGb3VuZCgpKXtjb25zdCB0PXRoaXMuZGVwZW5kZW5jaWVzLmZpbHRlcigodD0+IXRoaXMucGx1Z2luc0FzU3RyaW5nQXJyYXkoKS5pbmNsdWRlcyh0KSkpO3JldHVybiB2b2lkIGNvbnNvbGUud2FybihgJHt0aGlzLmdldE5hbWUoKX06IHJlcXVpcmVkIGRlcGVuZGVuY2llcyAoJHt0LmpvaW4oXCIsIFwiKX0pLmApfWNvbnN0IG49dGhpcy5jYW1lbENhc2VUb0tlYmFiKHRoaXMuZ2V0TmFtZSgpKTt0aGlzLnBpY2tlci51aS5jb250YWluZXIuY2xhc3NMaXN0LmFkZChuKSx0aGlzLm9uQXR0YWNoKCl9ZGV0YWNoKCl7Y29uc3QgdD10aGlzLmNhbWVsQ2FzZVRvS2ViYWIodGhpcy5nZXROYW1lKCkpO3RoaXMucGlja2VyLnVpLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub25EZXRhY2gmJnRoaXMub25EZXRhY2goKX1kZXBlbmRlbmNpZXNOb3RGb3VuZCgpe3JldHVybiB0aGlzLmRlcGVuZGVuY2llcy5sZW5ndGgmJiF0aGlzLmRlcGVuZGVuY2llcy5ldmVyeSgodD0+dGhpcy5wbHVnaW5zQXNTdHJpbmdBcnJheSgpLmluY2x1ZGVzKHQpKSl9cGx1Z2luc0FzU3RyaW5nQXJyYXkoKXtyZXR1cm4gdGhpcy5waWNrZXIub3B0aW9ucy5wbHVnaW5zLm1hcCgodD0+XCJmdW5jdGlvblwiPT10eXBlb2YgdD8obmV3IHQpLmdldE5hbWUoKTp0KSl9Y2FtZWxDYXNlVG9LZWJhYih0KXtyZXR1cm4gdC5yZXBsYWNlKC8oW2EtekEtWl0pKD89W0EtWl0pL2csXCIkMS1cIikudG9Mb3dlckNhc2UoKX19Y2xhc3MgYSBleHRlbmRzIG97cHJpb3JpdHk9MTtiaW5kcz17b25WaWV3OnRoaXMub25WaWV3LmJpbmQodGhpcyl9O29wdGlvbnM9e21pbkRhdGU6bnVsbCxtYXhEYXRlOm51bGwsbWluRGF5czpudWxsLG1heERheXM6bnVsbCxzZWxlY3RGb3J3YXJkOm51bGwsc2VsZWN0QmFja3dhcmQ6bnVsbCxwcmVzZXRzOiEwLGluc2VwYXJhYmxlOiExLGZpbHRlcjpudWxsfTtnZXROYW1lKCl7cmV0dXJuXCJMb2NrUGx1Z2luXCJ9b25BdHRhY2goKXtpZih0aGlzLm9wdGlvbnMubWluRGF0ZSYmKHRoaXMub3B0aW9ucy5taW5EYXRlPW5ldyB0KHRoaXMub3B0aW9ucy5taW5EYXRlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0LHRoaXMucGlja2VyLm9wdGlvbnMubGFuZykpLHRoaXMub3B0aW9ucy5tYXhEYXRlJiYodGhpcy5vcHRpb25zLm1heERhdGU9bmV3IHQodGhpcy5vcHRpb25zLm1heERhdGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQsdGhpcy5waWNrZXIub3B0aW9ucy5sYW5nKSx0aGlzLm9wdGlvbnMubWF4RGF0ZSBpbnN0YW5jZW9mIHQmJnRoaXMucGlja2VyLm9wdGlvbnMuY2FsZW5kYXJzPjEmJnRoaXMucGlja2VyLmNhbGVuZGFyc1swXS5pc1NhbWUodGhpcy5vcHRpb25zLm1heERhdGUsXCJtb250aFwiKSkpe2NvbnN0IHQ9dGhpcy5waWNrZXIuY2FsZW5kYXJzWzBdLmNsb25lKCkuc3VidHJhY3QoMSxcIm1vbnRoXCIpO3RoaXMucGlja2VyLmdvdG9EYXRlKHQpfWlmKCh0aGlzLm9wdGlvbnMubWluRGF5c3x8dGhpcy5vcHRpb25zLm1heERheXN8fHRoaXMub3B0aW9ucy5zZWxlY3RGb3J3YXJkfHx0aGlzLm9wdGlvbnMuc2VsZWN0QmFja3dhcmQpJiYhdGhpcy5waWNrZXIub3B0aW9ucy5wbHVnaW5zLmluY2x1ZGVzKFwiUmFuZ2VQbHVnaW5cIikpe2NvbnN0IHQ9W1wibWluRGF5c1wiLFwibWF4RGF5c1wiLFwic2VsZWN0Rm9yd2FyZFwiLFwic2VsZWN0QmFja3dhcmRcIl07Y29uc29sZS53YXJuKGAke3RoaXMuZ2V0TmFtZSgpfTogb3B0aW9ucyAke3Quam9pbihcIiwgXCIpfSByZXF1aXJlZCBSYW5nZVBsdWdpbi5gKX10aGlzLnBpY2tlci5vbihcInZpZXdcIix0aGlzLmJpbmRzLm9uVmlldyl9b25EZXRhY2goKXt0aGlzLnBpY2tlci5vZmYoXCJ2aWV3XCIsdGhpcy5iaW5kcy5vblZpZXcpfW9uVmlldyhlKXtjb25zdHt2aWV3OmksdGFyZ2V0Om4sZGF0ZTpzfT1lLmRldGFpbDtpZihcIkNhbGVuZGFySGVhZGVyXCI9PT1pJiYodGhpcy5vcHRpb25zLm1pbkRhdGUgaW5zdGFuY2VvZiB0JiZzLmlzU2FtZU9yQmVmb3JlKHRoaXMub3B0aW9ucy5taW5EYXRlLFwibW9udGhcIikmJm4uY2xhc3NMaXN0LmFkZChcIm5vLXByZXZpb3VzLW1vbnRoXCIpLHRoaXMub3B0aW9ucy5tYXhEYXRlIGluc3RhbmNlb2YgdCYmcy5pc1NhbWVPckFmdGVyKHRoaXMub3B0aW9ucy5tYXhEYXRlLFwibW9udGhcIikmJm4uY2xhc3NMaXN0LmFkZChcIm5vLW5leHQtbW9udGhcIikpLFwiQ2FsZW5kYXJEYXlcIj09PWkpe2NvbnN0IHQ9dGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGg/dGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXTpudWxsO2lmKHRoaXMudGVzdEZpbHRlcihzKSlyZXR1cm4gdm9pZCBuLmNsYXNzTGlzdC5hZGQoXCJsb2NrZWRcIik7aWYodGhpcy5vcHRpb25zLmluc2VwYXJhYmxlKXtpZih0aGlzLm9wdGlvbnMubWluRGF5cyl7Y29uc3QgdD1zLmNsb25lKCkuc3VidHJhY3QodGhpcy5vcHRpb25zLm1pbkRheXMtMSxcImRheVwiKSxlPXMuY2xvbmUoKS5hZGQodGhpcy5vcHRpb25zLm1pbkRheXMtMSxcImRheVwiKTtsZXQgaT0hMSxvPSExO2Zvcig7dC5pc0JlZm9yZShzLFwiZGF5XCIpOyl7aWYodGhpcy50ZXN0RmlsdGVyKHQpKXtpPSEwO2JyZWFrfXQuYWRkKDEsXCJkYXlcIil9Zm9yKDtlLmlzQWZ0ZXIocyxcImRheVwiKTspe2lmKHRoaXMudGVzdEZpbHRlcihlKSl7bz0hMDticmVha31lLnN1YnRyYWN0KDEsXCJkYXlcIil9aSYmbyYmbi5jbGFzc0xpc3QuYWRkKFwibm90LWF2YWlsYWJsZVwiKX10aGlzLnJhbmdlSXNOb3RBdmFpbGFibGUocyx0KSYmbi5jbGFzc0xpc3QuYWRkKFwibm90LWF2YWlsYWJsZVwiKX10aGlzLmRhdGVJc05vdEF2YWlsYWJsZShzLHQpJiZuLmNsYXNzTGlzdC5hZGQoXCJub3QtYXZhaWxhYmxlXCIpfWlmKHRoaXMub3B0aW9ucy5wcmVzZXRzJiZcIlByZXNldFBsdWdpbkJ1dHRvblwiPT09aSl7Y29uc3QgZT1uZXcgdChOdW1iZXIobi5kYXRhc2V0LnN0YXJ0KSksaT1uZXcgdChOdW1iZXIobi5kYXRhc2V0LmVuZCkpLHM9aS5kaWZmKGUsXCJkYXlcIiksbz10aGlzLm9wdGlvbnMubWluRGF5cyYmczx0aGlzLm9wdGlvbnMubWluRGF5cyxhPXRoaXMub3B0aW9ucy5tYXhEYXlzJiZzPnRoaXMub3B0aW9ucy5tYXhEYXlzOyhvfHxhfHx0aGlzLmxvY2tNaW5EYXRlKGUpfHx0aGlzLmxvY2tNYXhEYXRlKGUpfHx0aGlzLmxvY2tNaW5EYXRlKGkpfHx0aGlzLmxvY2tNYXhEYXRlKGkpfHx0aGlzLnJhbmdlSXNOb3RBdmFpbGFibGUoZSxpKSkmJm4uc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIixcImRpc2FibGVkXCIpfX1kYXRlSXNOb3RBdmFpbGFibGUodCxlKXtyZXR1cm4gdGhpcy5sb2NrTWluRGF0ZSh0KXx8dGhpcy5sb2NrTWF4RGF0ZSh0KXx8dGhpcy5sb2NrTWluRGF5cyh0LGUpfHx0aGlzLmxvY2tNYXhEYXlzKHQsZSl8fHRoaXMubG9ja1NlbGVjdEZvcndhcmQodCl8fHRoaXMubG9ja1NlbGVjdEJhY2t3YXJkKHQpfXJhbmdlSXNOb3RBdmFpbGFibGUodCxlKXtpZighdHx8IWUpcmV0dXJuITE7Y29uc3QgaT0odC5pc1NhbWVPckJlZm9yZShlLFwiZGF5XCIpP3Q6ZSkuY2xvbmUoKSxuPShlLmlzU2FtZU9yQWZ0ZXIodCxcImRheVwiKT9lOnQpLmNsb25lKCk7Zm9yKDtpLmlzU2FtZU9yQmVmb3JlKG4sXCJkYXlcIik7KXtpZih0aGlzLnRlc3RGaWx0ZXIoaSkpcmV0dXJuITA7aS5hZGQoMSxcImRheVwiKX1yZXR1cm4hMX1sb2NrTWluRGF0ZShlKXtyZXR1cm4gdGhpcy5vcHRpb25zLm1pbkRhdGUgaW5zdGFuY2VvZiB0JiZlLmlzQmVmb3JlKHRoaXMub3B0aW9ucy5taW5EYXRlLFwiZGF5XCIpfWxvY2tNYXhEYXRlKGUpe3JldHVybiB0aGlzLm9wdGlvbnMubWF4RGF0ZSBpbnN0YW5jZW9mIHQmJmUuaXNBZnRlcih0aGlzLm9wdGlvbnMubWF4RGF0ZSxcImRheVwiKX1sb2NrTWluRGF5cyh0LGUpe2lmKHRoaXMub3B0aW9ucy5taW5EYXlzJiZlKXtjb25zdCBpPWUuY2xvbmUoKS5zdWJ0cmFjdCh0aGlzLm9wdGlvbnMubWluRGF5cy0xLFwiZGF5XCIpLG49ZS5jbG9uZSgpLmFkZCh0aGlzLm9wdGlvbnMubWluRGF5cy0xLFwiZGF5XCIpO3JldHVybiB0LmlzQmV0d2VlbihpLG4pfXJldHVybiExfWxvY2tNYXhEYXlzKHQsZSl7aWYodGhpcy5vcHRpb25zLm1heERheXMmJmUpe2NvbnN0IGk9ZS5jbG9uZSgpLnN1YnRyYWN0KHRoaXMub3B0aW9ucy5tYXhEYXlzLFwiZGF5XCIpLG49ZS5jbG9uZSgpLmFkZCh0aGlzLm9wdGlvbnMubWF4RGF5cyxcImRheVwiKTtyZXR1cm4hdC5pc0JldHdlZW4oaSxuKX1yZXR1cm4hMX1sb2NrU2VsZWN0Rm9yd2FyZCh0KXtpZigxPT09dGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGgmJnRoaXMub3B0aW9ucy5zZWxlY3RGb3J3YXJkKXtjb25zdCBlPXRoaXMucGlja2VyLmRhdGVQaWNrZWRbMF0uY2xvbmUoKTtyZXR1cm4gdC5pc0JlZm9yZShlLFwiZGF5XCIpfXJldHVybiExfWxvY2tTZWxlY3RCYWNrd2FyZCh0KXtpZigxPT09dGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGgmJnRoaXMub3B0aW9ucy5zZWxlY3RCYWNrd2FyZCl7Y29uc3QgZT10aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdLmNsb25lKCk7cmV0dXJuIHQuaXNBZnRlcihlLFwiZGF5XCIpfXJldHVybiExfXRlc3RGaWx0ZXIodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vcHRpb25zLmZpbHRlciYmdGhpcy5vcHRpb25zLmZpbHRlcih0LHRoaXMucGlja2VyLmRhdGVQaWNrZWQpfX1jbGFzcyByIGV4dGVuZHMgb3tkZXBlbmRlbmNpZXM9W1wiUmFuZ2VQbHVnaW5cIl07YmluZHM9e29uVmlldzp0aGlzLm9uVmlldy5iaW5kKHRoaXMpLG9uQ2xpY2s6dGhpcy5vbkNsaWNrLmJpbmQodGhpcyl9O29wdGlvbnM9e2N1c3RvbUxhYmVsczpbXCJUb2RheVwiLFwiWWVzdGVyZGF5XCIsXCJMYXN0IDcgRGF5c1wiLFwiTGFzdCAzMCBEYXlzXCIsXCJUaGlzIE1vbnRoXCIsXCJMYXN0IE1vbnRoXCJdLGN1c3RvbVByZXNldDp7fSxwb3NpdGlvbjpcImxlZnRcIn07Z2V0TmFtZSgpe3JldHVyblwiUHJlc2V0UGx1Z2luXCJ9b25BdHRhY2goKXtpZighT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmN1c3RvbVByZXNldCkubGVuZ3RoKXtjb25zdCBlPW5ldyB0LGk9KCk9Pntjb25zdCBpPWUuY2xvbmUoKTtpLnNldERhdGUoMSk7Y29uc3Qgbj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksZS5nZXRNb250aCgpKzEsMCk7cmV0dXJuW25ldyB0KGkpLG5ldyB0KG4pXX0sbj0oKT0+e2NvbnN0IGk9ZS5jbG9uZSgpO2kuc2V0TW9udGgoaS5nZXRNb250aCgpLTEpLGkuc2V0RGF0ZSgxKTtjb25zdCBuPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSxlLmdldE1vbnRoKCksMCk7cmV0dXJuW25ldyB0KGkpLG5ldyB0KG4pXX0scz1bW2UuY2xvbmUoKSxlLmNsb25lKCldLFtlLmNsb25lKCkuc3VidHJhY3QoMSxcImRheVwiKSxlLmNsb25lKCkuc3VidHJhY3QoMSxcImRheVwiKV0sW2UuY2xvbmUoKS5zdWJ0cmFjdCg2LFwiZGF5XCIpLGUuY2xvbmUoKV0sW2UuY2xvbmUoKS5zdWJ0cmFjdCgyOSxcImRheVwiKSxlLmNsb25lKCldLGkoKSxuKCldO09iamVjdC52YWx1ZXModGhpcy5vcHRpb25zLmN1c3RvbUxhYmVscykuZm9yRWFjaCgoKHQsZSk9Pnt0aGlzLm9wdGlvbnMuY3VzdG9tUHJlc2V0W3RdPXNbZV19KSl9dGhpcy5waWNrZXIub24oXCJ2aWV3XCIsdGhpcy5iaW5kcy5vblZpZXcpLHRoaXMucGlja2VyLm9uKFwiY2xpY2tcIix0aGlzLmJpbmRzLm9uQ2xpY2spfW9uRGV0YWNoKCl7dGhpcy5waWNrZXIub2ZmKFwidmlld1wiLHRoaXMuYmluZHMub25WaWV3KSx0aGlzLnBpY2tlci5vZmYoXCJjbGlja1wiLHRoaXMuYmluZHMub25DbGljayl9b25WaWV3KHQpe2NvbnN0e3ZpZXc6ZSx0YXJnZXQ6aX09dC5kZXRhaWw7aWYoXCJNYWluXCI9PT1lKXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dC5jbGFzc05hbWU9XCJwcmVzZXQtcGx1Z2luLWNvbnRhaW5lclwiLE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5jdXN0b21QcmVzZXQpLmZvckVhY2goKGU9PntpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcHRpb25zLmN1c3RvbVByZXNldCxlKSl7Y29uc3QgaT10aGlzLm9wdGlvbnMuY3VzdG9tUHJlc2V0W2VdLG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtuLmNsYXNzTmFtZT1cInByZXNldC1idXR0b24gdW5pdFwiLG4uaW5uZXJIVE1MPWUsbi5kYXRhc2V0LnN0YXJ0PWlbMF0uZ2V0VGltZSgpLG4uZGF0YXNldC5lbmQ9aVsxXS5nZXRUaW1lKCksdC5hcHBlbmRDaGlsZChuKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHt2aWV3OlwiUHJlc2V0UGx1Z2luQnV0dG9uXCIsdGFyZ2V0Om59KX19KSksaS5hcHBlbmRDaGlsZCh0KSxpLmNsYXNzTGlzdC5hZGQoYHByZXNldC0ke3RoaXMub3B0aW9ucy5wb3NpdGlvbn1gKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHt2aWV3OlwiUHJlc2V0UGx1Z2luQ29udGFpbmVyXCIsdGFyZ2V0OnR9KX19b25DbGljayhlKXtjb25zdCBpPWUudGFyZ2V0O2lmKGkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCl7Y29uc3QgZT1pLmNsb3Nlc3QoXCIudW5pdFwiKTtpZighKGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpcmV0dXJuO2lmKHRoaXMuaXNQcmVzZXRCdXR0b24oZSkpe2NvbnN0IGk9bmV3IHQoTnVtYmVyKGUuZGF0YXNldC5zdGFydCkpLG49bmV3IHQoTnVtYmVyKGUuZGF0YXNldC5lbmQpKTt0aGlzLnBpY2tlci5vcHRpb25zLmF1dG9BcHBseT8odGhpcy5waWNrZXIuc2V0RGF0ZVJhbmdlKGksbiksdGhpcy5waWNrZXIudHJpZ2dlcihcInNlbGVjdFwiLHtzdGFydDp0aGlzLnBpY2tlci5nZXRTdGFydERhdGUoKSxlbmQ6dGhpcy5waWNrZXIuZ2V0RW5kRGF0ZSgpfSksdGhpcy5waWNrZXIuaGlkZSgpKToodGhpcy5waWNrZXIuZGF0ZVBpY2tlZD1baSxuXSx0aGlzLnBpY2tlci5yZW5kZXJBbGwoKSl9fX1pc1ByZXNldEJ1dHRvbih0KXtyZXR1cm4gdC5jbGFzc0xpc3QuY29udGFpbnMoXCJwcmVzZXQtYnV0dG9uXCIpfX1jbGFzcyBjIGV4dGVuZHMgb3t0b29sdGlwRWxlbWVudDt0cmlnZ2VyRWxlbWVudDtiaW5kcz17c2V0U3RhcnREYXRlOnRoaXMuc2V0U3RhcnREYXRlLmJpbmQodGhpcyksc2V0RW5kRGF0ZTp0aGlzLnNldEVuZERhdGUuYmluZCh0aGlzKSxzZXREYXRlUmFuZ2U6dGhpcy5zZXREYXRlUmFuZ2UuYmluZCh0aGlzKSxnZXRTdGFydERhdGU6dGhpcy5nZXRTdGFydERhdGUuYmluZCh0aGlzKSxnZXRFbmREYXRlOnRoaXMuZ2V0RW5kRGF0ZS5iaW5kKHRoaXMpLG9uVmlldzp0aGlzLm9uVmlldy5iaW5kKHRoaXMpLG9uU2hvdzp0aGlzLm9uU2hvdy5iaW5kKHRoaXMpLG9uTW91c2VFbnRlcjp0aGlzLm9uTW91c2VFbnRlci5iaW5kKHRoaXMpLG9uTW91c2VMZWF2ZTp0aGlzLm9uTW91c2VMZWF2ZS5iaW5kKHRoaXMpLG9uQ2xpY2tDYWxlbmRhckRheTp0aGlzLm9uQ2xpY2tDYWxlbmRhckRheS5iaW5kKHRoaXMpLG9uQ2xpY2tBcHBseUJ1dHRvbjp0aGlzLm9uQ2xpY2tBcHBseUJ1dHRvbi5iaW5kKHRoaXMpLHBhcnNlVmFsdWVzOnRoaXMucGFyc2VWYWx1ZXMuYmluZCh0aGlzKSx1cGRhdGVWYWx1ZXM6dGhpcy51cGRhdGVWYWx1ZXMuYmluZCh0aGlzKSxjbGVhcjp0aGlzLmNsZWFyLmJpbmQodGhpcyl9O29wdGlvbnM9e2VsZW1lbnRFbmQ6bnVsbCxzdGFydERhdGU6bnVsbCxlbmREYXRlOm51bGwscmVwaWNrOiExLHN0cmljdDohMCxkZWxpbWl0ZXI6XCIgLSBcIix0b29sdGlwOiEwLHRvb2x0aXBOdW1iZXI6dD0+dCxsb2NhbGU6e3plcm86XCJcIixvbmU6XCJkYXlcIix0d286XCJcIixmZXc6XCJcIixtYW55OlwiXCIsb3RoZXI6XCJkYXlzXCJ9LGRvY3VtZW50Q2xpY2s6dGhpcy5oaWRlUGlja2VyLmJpbmQodGhpcyl9O2dldE5hbWUoKXtyZXR1cm5cIlJhbmdlUGx1Z2luXCJ9b25BdHRhY2goKXt0aGlzLmJpbmRzLl9zZXRTdGFydERhdGU9dGhpcy5waWNrZXIuc2V0U3RhcnREYXRlLHRoaXMuYmluZHMuX3NldEVuZERhdGU9dGhpcy5waWNrZXIuc2V0RW5kRGF0ZSx0aGlzLmJpbmRzLl9zZXREYXRlUmFuZ2U9dGhpcy5waWNrZXIuc2V0RGF0ZVJhbmdlLHRoaXMuYmluZHMuX2dldFN0YXJ0RGF0ZT10aGlzLnBpY2tlci5nZXRTdGFydERhdGUsdGhpcy5iaW5kcy5fZ2V0RW5kRGF0ZT10aGlzLnBpY2tlci5nZXRFbmREYXRlLHRoaXMuYmluZHMuX3BhcnNlVmFsdWVzPXRoaXMucGlja2VyLnBhcnNlVmFsdWVzLHRoaXMuYmluZHMuX3VwZGF0ZVZhbHVlcz10aGlzLnBpY2tlci51cGRhdGVWYWx1ZXMsdGhpcy5iaW5kcy5fY2xlYXI9dGhpcy5waWNrZXIuY2xlYXIsdGhpcy5iaW5kcy5fb25DbGlja0NhbGVuZGFyRGF5PXRoaXMucGlja2VyLm9uQ2xpY2tDYWxlbmRhckRheSx0aGlzLmJpbmRzLl9vbkNsaWNrQXBwbHlCdXR0b249dGhpcy5waWNrZXIub25DbGlja0FwcGx5QnV0dG9uLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMucGlja2VyLHtzZXRTdGFydERhdGU6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLnNldFN0YXJ0RGF0ZX0sc2V0RW5kRGF0ZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuc2V0RW5kRGF0ZX0sc2V0RGF0ZVJhbmdlOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5zZXREYXRlUmFuZ2V9LGdldFN0YXJ0RGF0ZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuZ2V0U3RhcnREYXRlfSxnZXRFbmREYXRlOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5nZXRFbmREYXRlfSxwYXJzZVZhbHVlczp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMucGFyc2VWYWx1ZXN9LHVwZGF0ZVZhbHVlczp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMudXBkYXRlVmFsdWVzfSxjbGVhcjp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuY2xlYXJ9LG9uQ2xpY2tDYWxlbmRhckRheTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMub25DbGlja0NhbGVuZGFyRGF5fSxvbkNsaWNrQXBwbHlCdXR0b246e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLm9uQ2xpY2tBcHBseUJ1dHRvbn19KSx0aGlzLm9wdGlvbnMuZWxlbWVudEVuZCYmKHRoaXMub3B0aW9ucy5lbGVtZW50RW5kIGluc3RhbmNlb2YgSFRNTEVsZW1lbnR8fCh0aGlzLm9wdGlvbnMuZWxlbWVudEVuZD10aGlzLnBpY2tlci5vcHRpb25zLmRvYy5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5lbGVtZW50RW5kKSksdGhpcy5vcHRpb25zLmVsZW1lbnRFbmQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50JiYodGhpcy5vcHRpb25zLmVsZW1lbnRFbmQucmVhZE9ubHk9dGhpcy5waWNrZXIub3B0aW9ucy5yZWFkb25seSksXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5waWNrZXIub3B0aW9ucy5kb2N1bWVudENsaWNrJiYoZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5waWNrZXIub3B0aW9ucy5kb2N1bWVudENsaWNrLCEwKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuZG9jdW1lbnRDbGljayYmZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5vcHRpb25zLmRvY3VtZW50Q2xpY2ssITApKSx0aGlzLm9wdGlvbnMuZWxlbWVudEVuZC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLnBpY2tlci5zaG93LmJpbmQodGhpcy5waWNrZXIpKSksdGhpcy5vcHRpb25zLnJlcGljaz10aGlzLm9wdGlvbnMucmVwaWNrJiZ0aGlzLm9wdGlvbnMuZWxlbWVudEVuZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50LHRoaXMucGlja2VyLm9wdGlvbnMuZGF0ZT1udWxsLHRoaXMucGlja2VyLm9uKFwidmlld1wiLHRoaXMuYmluZHMub25WaWV3KSx0aGlzLnBpY2tlci5vbihcInNob3dcIix0aGlzLmJpbmRzLm9uU2hvdyksdGhpcy5waWNrZXIub24oXCJtb3VzZWVudGVyXCIsdGhpcy5iaW5kcy5vbk1vdXNlRW50ZXIsITApLHRoaXMucGlja2VyLm9uKFwibW91c2VsZWF2ZVwiLHRoaXMuYmluZHMub25Nb3VzZUxlYXZlLCEwKSx0aGlzLmNoZWNrSW50bFBsdXJhbExvY2FsZXMoKX1vbkRldGFjaCgpe09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMucGlja2VyLHtzZXRTdGFydERhdGU6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLl9zZXRTdGFydERhdGV9LHNldEVuZERhdGU6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLl9zZXRFbmREYXRlfSxzZXREYXRlUmFuZ2U6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLl9zZXREYXRlUmFuZ2V9LGdldFN0YXJ0RGF0ZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuX2dldFN0YXJ0RGF0ZX0sZ2V0RW5kRGF0ZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuX2dldEVuZERhdGV9LHBhcnNlVmFsdWVzOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5fcGFyc2VWYWx1ZXN9LHVwZGF0ZVZhbHVlczp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuX3VwZGF0ZVZhbHVlc30sY2xlYXI6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLl9jbGVhcn0sb25DbGlja0NhbGVuZGFyRGF5Ontjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5fb25DbGlja0NhbGVuZGFyRGF5fSxvbkNsaWNrQXBwbHlCdXR0b246e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLl9vbkNsaWNrQXBwbHlCdXR0b259fSksdGhpcy5waWNrZXIub2ZmKFwidmlld1wiLHRoaXMuYmluZHMub25WaWV3KSx0aGlzLnBpY2tlci5vZmYoXCJzaG93XCIsdGhpcy5iaW5kcy5vblNob3cpLHRoaXMucGlja2VyLm9mZihcIm1vdXNlZW50ZXJcIix0aGlzLmJpbmRzLm9uTW91c2VFbnRlciwhMCksdGhpcy5waWNrZXIub2ZmKFwibW91c2VsZWF2ZVwiLHRoaXMuYmluZHMub25Nb3VzZUxlYXZlLCEwKX1wYXJzZVZhbHVlcygpe2lmKHRoaXMub3B0aW9ucy5zdGFydERhdGV8fHRoaXMub3B0aW9ucy5lbmREYXRlKXRoaXMub3B0aW9ucy5zdHJpY3Q/dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZSYmdGhpcy5vcHRpb25zLmVuZERhdGU/dGhpcy5zZXREYXRlUmFuZ2UodGhpcy5vcHRpb25zLnN0YXJ0RGF0ZSx0aGlzLm9wdGlvbnMuZW5kRGF0ZSk6KHRoaXMub3B0aW9ucy5zdGFydERhdGU9bnVsbCx0aGlzLm9wdGlvbnMuZW5kRGF0ZT1udWxsKToodGhpcy5vcHRpb25zLnN0YXJ0RGF0ZSYmdGhpcy5zZXRTdGFydERhdGUodGhpcy5vcHRpb25zLnN0YXJ0RGF0ZSksdGhpcy5vcHRpb25zLmVuZERhdGUmJnRoaXMuc2V0RW5kRGF0ZSh0aGlzLm9wdGlvbnMuZW5kRGF0ZSkpO2Vsc2UgaWYodGhpcy5vcHRpb25zLmVsZW1lbnRFbmQpdGhpcy5vcHRpb25zLnN0cmljdD90aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50JiZ0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQudmFsdWUubGVuZ3RoJiZ0aGlzLm9wdGlvbnMuZWxlbWVudEVuZCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJnRoaXMub3B0aW9ucy5lbGVtZW50RW5kLnZhbHVlLmxlbmd0aCYmdGhpcy5zZXREYXRlUmFuZ2UodGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LnZhbHVlLHRoaXMub3B0aW9ucy5lbGVtZW50RW5kLnZhbHVlKToodGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmdGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LnZhbHVlLmxlbmd0aCYmdGhpcy5zZXRTdGFydERhdGUodGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LnZhbHVlKSx0aGlzLm9wdGlvbnMuZWxlbWVudEVuZCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJnRoaXMub3B0aW9ucy5lbGVtZW50RW5kLnZhbHVlLmxlbmd0aCYmdGhpcy5zZXRFbmREYXRlKHRoaXMub3B0aW9ucy5lbGVtZW50RW5kLnZhbHVlKSk7ZWxzZSBpZih0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50JiZ0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQudmFsdWUubGVuZ3RoKXtjb25zdFt0LGVdPXRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC52YWx1ZS5zcGxpdCh0aGlzLm9wdGlvbnMuZGVsaW1pdGVyKTt0aGlzLm9wdGlvbnMuc3RyaWN0P3QmJmUmJnRoaXMuc2V0RGF0ZVJhbmdlKHQsZSk6KHQmJnRoaXMuc2V0U3RhcnREYXRlKHQpLGUmJnRoaXMuc2V0RW5kRGF0ZShlKSl9fXVwZGF0ZVZhbHVlcygpe2NvbnN0IHQ9dGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LGU9dGhpcy5vcHRpb25zLmVsZW1lbnRFbmQsaT10aGlzLnBpY2tlci5nZXRTdGFydERhdGUoKSxuPXRoaXMucGlja2VyLmdldEVuZERhdGUoKSxzPWkgaW5zdGFuY2VvZiBEYXRlP2kuZm9ybWF0KHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0LHRoaXMucGlja2VyLm9wdGlvbnMubGFuZyk6XCJcIixvPW4gaW5zdGFuY2VvZiBEYXRlP24uZm9ybWF0KHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0LHRoaXMucGlja2VyLm9wdGlvbnMubGFuZyk6XCJcIjtpZihlKXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50P3QudmFsdWU9czp0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJih0LmlubmVyVGV4dD1zKSxlIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudD9lLnZhbHVlPW86ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiYoZS5pbm5lclRleHQ9byk7ZWxzZXtjb25zdCBlPWAke3N9JHtzfHxvP3RoaXMub3B0aW9ucy5kZWxpbWl0ZXI6XCJcIn0ke299YDt0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudD90LnZhbHVlPWU6dCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiYodC5pbm5lclRleHQ9ZSl9fWNsZWFyKCl7dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZT1udWxsLHRoaXMub3B0aW9ucy5lbmREYXRlPW51bGwsdGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGg9MCx0aGlzLnVwZGF0ZVZhbHVlcygpLHRoaXMucGlja2VyLnJlbmRlckFsbCgpLHRoaXMucGlja2VyLnRyaWdnZXIoXCJjbGVhclwiKX1vblNob3codCl7Y29uc3R7dGFyZ2V0OmV9PXQuZGV0YWlsO3RoaXMudHJpZ2dlckVsZW1lbnQ9ZSx0aGlzLnBpY2tlci5vcHRpb25zLnNjcm9sbFRvRGF0ZSYmdGhpcy5nZXRTdGFydERhdGUoKWluc3RhbmNlb2YgRGF0ZSYmdGhpcy5waWNrZXIuZ290b0RhdGUodGhpcy5nZXRTdGFydERhdGUoKSksdGhpcy5pbml0aWFsaXplUmVwaWNrKCl9b25WaWV3KGUpe2NvbnN0e3ZpZXc6aSx0YXJnZXQ6bn09ZS5kZXRhaWw7aWYoXCJNYWluXCI9PT1pJiYodGhpcy50b29sdGlwRWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSx0aGlzLnRvb2x0aXBFbGVtZW50LmNsYXNzTmFtZT1cInJhbmdlLXBsdWdpbi10b29sdGlwXCIsbi5hcHBlbmRDaGlsZCh0aGlzLnRvb2x0aXBFbGVtZW50KSksXCJDYWxlbmRhckRheVwiPT09aSl7Y29uc3QgZT1uZXcgdChuLmRhdGFzZXQudGltZSksaT10aGlzLnBpY2tlci5kYXRlUGlja2VkLHM9aS5sZW5ndGg/dGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXTp0aGlzLmdldFN0YXJ0RGF0ZSgpLG89aS5sZW5ndGg/dGhpcy5waWNrZXIuZGF0ZVBpY2tlZFsxXTp0aGlzLmdldEVuZERhdGUoKTtzJiZzLmlzU2FtZShlLFwiZGF5XCIpJiZuLmNsYXNzTGlzdC5hZGQoXCJzdGFydFwiKSxzJiZvJiYoby5pc1NhbWUoZSxcImRheVwiKSYmbi5jbGFzc0xpc3QuYWRkKFwiZW5kXCIpLGUuaXNCZXR3ZWVuKHMsbykmJm4uY2xhc3NMaXN0LmFkZChcImluLXJhbmdlXCIpKX1pZihcIkZvb3RlclwiPT09aSl7Y29uc3QgdD0xPT09dGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGgmJiF0aGlzLm9wdGlvbnMuc3RyaWN0fHwyPT09dGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGg7bi5xdWVyeVNlbGVjdG9yKFwiLmFwcGx5LWJ1dHRvblwiKS5kaXNhYmxlZD0hdH19aGlkZVBpY2tlcih0KXtsZXQgZT10LnRhcmdldCxpPW51bGw7ZS5zaGFkb3dSb290JiYoZT10LmNvbXBvc2VkUGF0aCgpWzBdLGk9ZS5nZXRSb290Tm9kZSgpLmhvc3QpLHRoaXMucGlja2VyLmlzU2hvd24oKSYmaSE9PXRoaXMucGlja2VyLnVpLndyYXBwZXImJmUhPT10aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQmJmUhPT10aGlzLm9wdGlvbnMuZWxlbWVudEVuZCYmdGhpcy5waWNrZXIuaGlkZSgpfXNldFN0YXJ0RGF0ZShlKXtjb25zdCBpPW5ldyB0KGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpO3RoaXMub3B0aW9ucy5zdGFydERhdGU9aT9pLmNsb25lKCk6bnVsbCx0aGlzLnVwZGF0ZVZhbHVlcygpLHRoaXMucGlja2VyLnJlbmRlckFsbCgpfXNldEVuZERhdGUoZSl7Y29uc3QgaT1uZXcgdChlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTt0aGlzLm9wdGlvbnMuZW5kRGF0ZT1pP2kuY2xvbmUoKTpudWxsLHRoaXMudXBkYXRlVmFsdWVzKCksdGhpcy5waWNrZXIucmVuZGVyQWxsKCl9c2V0RGF0ZVJhbmdlKGUsaSl7Y29uc3Qgbj1uZXcgdChlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KSxzPW5ldyB0KGksdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpO3RoaXMub3B0aW9ucy5zdGFydERhdGU9bj9uLmNsb25lKCk6bnVsbCx0aGlzLm9wdGlvbnMuZW5kRGF0ZT1zP3MuY2xvbmUoKTpudWxsLHRoaXMudXBkYXRlVmFsdWVzKCksdGhpcy5waWNrZXIucmVuZGVyQWxsKCl9Z2V0U3RhcnREYXRlKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5zdGFydERhdGUgaW5zdGFuY2VvZiBEYXRlP3RoaXMub3B0aW9ucy5zdGFydERhdGUuY2xvbmUoKTpudWxsfWdldEVuZERhdGUoKXtyZXR1cm4gdGhpcy5vcHRpb25zLmVuZERhdGUgaW5zdGFuY2VvZiBEYXRlP3RoaXMub3B0aW9ucy5lbmREYXRlLmNsb25lKCk6bnVsbH1vbk1vdXNlRW50ZXIoZSl7Y29uc3QgaT1lLnRhcmdldDtpZihpIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpe3RoaXMuaXNDb250YWluZXIoaSkmJnRoaXMuaW5pdGlhbGl6ZVJlcGljaygpO2NvbnN0IGU9aS5jbG9zZXN0KFwiLnVuaXRcIik7aWYoIShlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKXJldHVybjtpZih0aGlzLnBpY2tlci5pc0NhbGVuZGFyRGF5KGUpKXtpZigxIT09dGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGgpcmV0dXJuO2xldCBpPXRoaXMucGlja2VyLmRhdGVQaWNrZWRbMF0uY2xvbmUoKSxuPW5ldyB0KGUuZGF0YXNldC50aW1lKSxzPSExO2lmKGkuaXNBZnRlcihuLFwiZGF5XCIpKXtjb25zdCB0PWkuY2xvbmUoKTtpPW4uY2xvbmUoKSxuPXQuY2xvbmUoKSxzPSEwfWlmKFsuLi50aGlzLnBpY2tlci51aS5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5kYXlcIildLmZvckVhY2goKG89Pntjb25zdCBhPW5ldyB0KG8uZGF0YXNldC50aW1lKSxyPXRoaXMucGlja2VyLkNhbGVuZGFyLmdldENhbGVuZGFyRGF5VmlldyhhKTthLmlzQmV0d2VlbihpLG4pJiZyLmNsYXNzTGlzdC5hZGQoXCJpbi1yYW5nZVwiKSxhLmlzU2FtZSh0aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdLFwiZGF5XCIpJiYoci5jbGFzc0xpc3QuYWRkKFwic3RhcnRcIiksci5jbGFzc0xpc3QudG9nZ2xlKFwiZmxpcHBlZFwiLHMpKSxvPT09ZSYmKHIuY2xhc3NMaXN0LmFkZChcImVuZFwiKSxyLmNsYXNzTGlzdC50b2dnbGUoXCJmbGlwcGVkXCIscykpLG8uY2xhc3NOYW1lPXIuY2xhc3NOYW1lfSkpLHRoaXMub3B0aW9ucy50b29sdGlwKXtjb25zdCB0PXRoaXMub3B0aW9ucy50b29sdGlwTnVtYmVyKG4uZGlmZihpLFwiZGF5XCIpKzEpO2lmKHQ+MCl7Y29uc3QgaT1uZXcgSW50bC5QbHVyYWxSdWxlcyh0aGlzLnBpY2tlci5vcHRpb25zLmxhbmcpLnNlbGVjdCh0KSxuPWAke3R9ICR7dGhpcy5vcHRpb25zLmxvY2FsZVtpXX1gO3RoaXMuc2hvd1Rvb2x0aXAoZSxuKX1lbHNlIHRoaXMuaGlkZVRvb2x0aXAoKX19fX1vbk1vdXNlTGVhdmUodCl7aWYodGhpcy5pc0NvbnRhaW5lcih0LnRhcmdldCkmJnRoaXMub3B0aW9ucy5yZXBpY2spe2NvbnN0IHQ9dGhpcy5nZXRTdGFydERhdGUoKSxlPXRoaXMuZ2V0RW5kRGF0ZSgpO3QmJmUmJih0aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aD0wLHRoaXMucGlja2VyLnJlbmRlckFsbCgpKX19b25DbGlja0NhbGVuZGFyRGF5KGUpe2lmKHRoaXMucGlja2VyLmlzQ2FsZW5kYXJEYXkoZSkpezI9PT10aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aCYmKHRoaXMucGlja2VyLmRhdGVQaWNrZWQubGVuZ3RoPTApO2NvbnN0IGk9bmV3IHQoZS5kYXRhc2V0LnRpbWUpO2lmKHRoaXMucGlja2VyLmRhdGVQaWNrZWRbdGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGhdPWksMj09PXRoaXMucGlja2VyLmRhdGVQaWNrZWQubGVuZ3RoJiZ0aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdLmlzQWZ0ZXIodGhpcy5waWNrZXIuZGF0ZVBpY2tlZFsxXSkpe2NvbnN0IHQ9dGhpcy5waWNrZXIuZGF0ZVBpY2tlZFsxXS5jbG9uZSgpO3RoaXMucGlja2VyLmRhdGVQaWNrZWRbMV09dGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXS5jbG9uZSgpLHRoaXMucGlja2VyLmRhdGVQaWNrZWRbMF09dC5jbG9uZSgpfTEhPT10aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aCYmdGhpcy5waWNrZXIub3B0aW9ucy5hdXRvQXBwbHl8fHRoaXMucGlja2VyLnRyaWdnZXIoXCJwcmVzZWxlY3RcIix7c3RhcnQ6dGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXWluc3RhbmNlb2YgRGF0ZT90aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdLmNsb25lKCk6bnVsbCxlbmQ6dGhpcy5waWNrZXIuZGF0ZVBpY2tlZFsxXWluc3RhbmNlb2YgRGF0ZT90aGlzLnBpY2tlci5kYXRlUGlja2VkWzFdLmNsb25lKCk6bnVsbH0pLDE9PT10aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aCYmKCF0aGlzLm9wdGlvbnMuc3RyaWN0JiZ0aGlzLnBpY2tlci5vcHRpb25zLmF1dG9BcHBseSYmKHRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudD09PXRoaXMudHJpZ2dlckVsZW1lbnQmJnRoaXMuc2V0U3RhcnREYXRlKHRoaXMucGlja2VyLmRhdGVQaWNrZWRbMF0pLHRoaXMub3B0aW9ucy5lbGVtZW50RW5kPT09dGhpcy50cmlnZ2VyRWxlbWVudCYmdGhpcy5zZXRFbmREYXRlKHRoaXMucGlja2VyLmRhdGVQaWNrZWRbMF0pLHRoaXMucGlja2VyLnRyaWdnZXIoXCJzZWxlY3RcIix7c3RhcnQ6dGhpcy5waWNrZXIuZ2V0U3RhcnREYXRlKCksZW5kOnRoaXMucGlja2VyLmdldEVuZERhdGUoKX0pKSx0aGlzLnBpY2tlci5yZW5kZXJBbGwoKSksMj09PXRoaXMucGlja2VyLmRhdGVQaWNrZWQubGVuZ3RoJiYodGhpcy5waWNrZXIub3B0aW9ucy5hdXRvQXBwbHk/KHRoaXMuc2V0RGF0ZVJhbmdlKHRoaXMucGlja2VyLmRhdGVQaWNrZWRbMF0sdGhpcy5waWNrZXIuZGF0ZVBpY2tlZFsxXSksdGhpcy5waWNrZXIudHJpZ2dlcihcInNlbGVjdFwiLHtzdGFydDp0aGlzLnBpY2tlci5nZXRTdGFydERhdGUoKSxlbmQ6dGhpcy5waWNrZXIuZ2V0RW5kRGF0ZSgpfSksdGhpcy5waWNrZXIuaGlkZSgpKToodGhpcy5oaWRlVG9vbHRpcCgpLHRoaXMucGlja2VyLnJlbmRlckFsbCgpKSl9fW9uQ2xpY2tBcHBseUJ1dHRvbih0KXt0aGlzLnBpY2tlci5pc0FwcGx5QnV0dG9uKHQpJiYoMSE9PXRoaXMucGlja2VyLmRhdGVQaWNrZWQubGVuZ3RofHx0aGlzLm9wdGlvbnMuc3RyaWN0fHwodGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50PT09dGhpcy50cmlnZ2VyRWxlbWVudCYmKHRoaXMub3B0aW9ucy5lbmREYXRlPW51bGwsdGhpcy5zZXRTdGFydERhdGUodGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXSkpLHRoaXMub3B0aW9ucy5lbGVtZW50RW5kPT09dGhpcy50cmlnZ2VyRWxlbWVudCYmKHRoaXMub3B0aW9ucy5zdGFydERhdGU9bnVsbCx0aGlzLnNldEVuZERhdGUodGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXSkpKSwyPT09dGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGgmJnRoaXMuc2V0RGF0ZVJhbmdlKHRoaXMucGlja2VyLmRhdGVQaWNrZWRbMF0sdGhpcy5waWNrZXIuZGF0ZVBpY2tlZFsxXSksdGhpcy5waWNrZXIudHJpZ2dlcihcInNlbGVjdFwiLHtzdGFydDp0aGlzLnBpY2tlci5nZXRTdGFydERhdGUoKSxlbmQ6dGhpcy5waWNrZXIuZ2V0RW5kRGF0ZSgpfSksdGhpcy5waWNrZXIuaGlkZSgpKX1zaG93VG9vbHRpcCh0LGUpe3RoaXMudG9vbHRpcEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eT1cInZpc2libGVcIix0aGlzLnRvb2x0aXBFbGVtZW50LmlubmVySFRNTD1lO2NvbnN0IGk9dGhpcy5waWNrZXIudWkuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG49dGhpcy50b29sdGlwRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxzPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7bGV0IG89cy50b3AsYT1zLmxlZnQ7by09aS50b3AsYS09aS5sZWZ0LG8tPW4uaGVpZ2h0LGEtPW4ud2lkdGgvMixhKz1zLndpZHRoLzIsdGhpcy50b29sdGlwRWxlbWVudC5zdHlsZS50b3A9YCR7b31weGAsdGhpcy50b29sdGlwRWxlbWVudC5zdHlsZS5sZWZ0PWAke2F9cHhgfWhpZGVUb29sdGlwKCl7dGhpcy50b29sdGlwRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCJ9Y2hlY2tJbnRsUGx1cmFsTG9jYWxlcygpe2lmKCF0aGlzLm9wdGlvbnMudG9vbHRpcClyZXR1cm47Y29uc3QgdD1bLi4ubmV3IFNldChbbmV3IEludGwuUGx1cmFsUnVsZXModGhpcy5waWNrZXIub3B0aW9ucy5sYW5nKS5zZWxlY3QoMCksbmV3IEludGwuUGx1cmFsUnVsZXModGhpcy5waWNrZXIub3B0aW9ucy5sYW5nKS5zZWxlY3QoMSksbmV3IEludGwuUGx1cmFsUnVsZXModGhpcy5waWNrZXIub3B0aW9ucy5sYW5nKS5zZWxlY3QoMiksbmV3IEludGwuUGx1cmFsUnVsZXModGhpcy5waWNrZXIub3B0aW9ucy5sYW5nKS5zZWxlY3QoNiksbmV3IEludGwuUGx1cmFsUnVsZXModGhpcy5waWNrZXIub3B0aW9ucy5sYW5nKS5zZWxlY3QoMTgpXSldLGU9T2JqZWN0LmtleXModGhpcy5vcHRpb25zLmxvY2FsZSk7dC5ldmVyeSgodD0+ZS5pbmNsdWRlcyh0KSkpfHxjb25zb2xlLndhcm4oYCR7dGhpcy5nZXROYW1lKCl9OiBwcm92aWRlIGxvY2FsZXMgKCR7dC5qb2luKFwiLCBcIil9KSBmb3IgY29ycmVjdCB0b29sdGlwIHRleHQuYCl9aW5pdGlhbGl6ZVJlcGljaygpe2lmKCF0aGlzLm9wdGlvbnMucmVwaWNrKXJldHVybjtjb25zdCB0PXRoaXMuZ2V0U3RhcnREYXRlKCksZT10aGlzLmdldEVuZERhdGUoKTtlJiZ0aGlzLnRyaWdnZXJFbGVtZW50PT09dGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50JiYodGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXT1lKSx0JiZ0aGlzLnRyaWdnZXJFbGVtZW50PT09dGhpcy5vcHRpb25zLmVsZW1lbnRFbmQmJih0aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdPXQpfWlzQ29udGFpbmVyKHQpe3JldHVybiB0PT09dGhpcy5waWNrZXIudWkuY29udGFpbmVyfX1jbGFzcyBsIGV4dGVuZHMgb3tvcHRpb25zPXtuYXRpdmU6ITEsc2Vjb25kczohMSxzdGVwSG91cnM6MSxzdGVwTWludXRlczo1LHN0ZXBTZWNvbmRzOjUsZm9ybWF0MTI6ITF9O3JhbmdlUGx1Z2luO3RpbWVQaWNrZWQ9e2lucHV0Om51bGwsc3RhcnQ6bnVsbCxlbmQ6bnVsbH07dGltZVByZVBpY2tlZD17aW5wdXQ6bnVsbCxzdGFydDpudWxsLGVuZDpudWxsfTtiaW5kcz17Z2V0RGF0ZTp0aGlzLmdldERhdGUuYmluZCh0aGlzKSxnZXRTdGFydERhdGU6dGhpcy5nZXRTdGFydERhdGUuYmluZCh0aGlzKSxnZXRFbmREYXRlOnRoaXMuZ2V0RW5kRGF0ZS5iaW5kKHRoaXMpLG9uVmlldzp0aGlzLm9uVmlldy5iaW5kKHRoaXMpLG9uSW5wdXQ6dGhpcy5vbklucHV0LmJpbmQodGhpcyksb25DaGFuZ2U6dGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpLG9uQ2xpY2s6dGhpcy5vbkNsaWNrLmJpbmQodGhpcyksc2V0VGltZTp0aGlzLnNldFRpbWUuYmluZCh0aGlzKSxzZXRTdGFydFRpbWU6dGhpcy5zZXRTdGFydFRpbWUuYmluZCh0aGlzKSxzZXRFbmRUaW1lOnRoaXMuc2V0RW5kVGltZS5iaW5kKHRoaXMpfTtnZXROYW1lKCl7cmV0dXJuXCJUaW1lUGx1Z2luXCJ9b25BdHRhY2goKXt0aGlzLmJpbmRzLl9nZXREYXRlPXRoaXMucGlja2VyLmdldERhdGUsdGhpcy5iaW5kcy5fZ2V0U3RhcnREYXRlPXRoaXMucGlja2VyLmdldFN0YXJ0RGF0ZSx0aGlzLmJpbmRzLl9nZXRFbmREYXRlPXRoaXMucGlja2VyLmdldEVuZERhdGUsT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5waWNrZXIse2dldERhdGU6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLmdldERhdGV9LGdldFN0YXJ0RGF0ZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuZ2V0U3RhcnREYXRlfSxnZXRFbmREYXRlOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5nZXRFbmREYXRlfSxzZXRUaW1lOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5zZXRUaW1lfSxzZXRTdGFydFRpbWU6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLnNldFN0YXJ0VGltZX0sc2V0RW5kVGltZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuc2V0RW5kVGltZX19KSx0aGlzLnJhbmdlUGx1Z2luPXRoaXMucGlja2VyLlBsdWdpbk1hbmFnZXIuZ2V0SW5zdGFuY2UoXCJSYW5nZVBsdWdpblwiKSx0aGlzLnBhcnNlVmFsdWVzKCksdGhpcy5waWNrZXIub24oXCJ2aWV3XCIsdGhpcy5iaW5kcy5vblZpZXcpLHRoaXMucGlja2VyLm9uKFwiaW5wdXRcIix0aGlzLmJpbmRzLm9uSW5wdXQpLHRoaXMucGlja2VyLm9uKFwiY2hhbmdlXCIsdGhpcy5iaW5kcy5vbkNoYW5nZSksdGhpcy5waWNrZXIub24oXCJjbGlja1wiLHRoaXMuYmluZHMub25DbGljayl9b25EZXRhY2goKXtkZWxldGUgdGhpcy5waWNrZXIuc2V0VGltZSxkZWxldGUgdGhpcy5waWNrZXIuc2V0U3RhcnRUaW1lLGRlbGV0ZSB0aGlzLnBpY2tlci5zZXRFbmRUaW1lLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMucGlja2VyLHtnZXREYXRlOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5fZ2V0RGF0ZX0sZ2V0U3RhcnREYXRlOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5fZ2V0U3RhcnREYXRlfSxnZXRFbmREYXRlOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5fZ2V0RW5kRGF0ZX19KSx0aGlzLnBpY2tlci5vZmYoXCJ2aWV3XCIsdGhpcy5iaW5kcy5vblZpZXcpLHRoaXMucGlja2VyLm9mZihcImlucHV0XCIsdGhpcy5iaW5kcy5vbklucHV0KSx0aGlzLnBpY2tlci5vZmYoXCJjaGFuZ2VcIix0aGlzLmJpbmRzLm9uQ2hhbmdlKSx0aGlzLnBpY2tlci5vZmYoXCJjbGlja1wiLHRoaXMuYmluZHMub25DbGljayl9b25WaWV3KHQpe2NvbnN0e3ZpZXc6ZSx0YXJnZXQ6aX09dC5kZXRhaWw7aWYoXCJNYWluXCI9PT1lKXt0aGlzLnJhbmdlUGx1Z2luPXRoaXMucGlja2VyLlBsdWdpbk1hbmFnZXIuZ2V0SW5zdGFuY2UoXCJSYW5nZVBsdWdpblwiKTtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aWYodC5jbGFzc05hbWU9XCJ0aW1lLXBsdWdpbi1jb250YWluZXJcIix0aGlzLnJhbmdlUGx1Z2luKXtjb25zdCBlPXRoaXMuZ2V0U3RhcnRJbnB1dCgpO3QuYXBwZW5kQ2hpbGQoZSksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7dmlldzpcIlRpbWVQbHVnaW5JbnB1dFwiLHRhcmdldDplfSk7Y29uc3QgaT10aGlzLmdldEVuZElucHV0KCk7dC5hcHBlbmRDaGlsZChpKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHt2aWV3OlwiVGltZVBsdWdpbklucHV0XCIsdGFyZ2V0Oml9KX1lbHNle2NvbnN0IGU9dGhpcy5nZXRTaW5nbGVJbnB1dCgpO3QuYXBwZW5kQ2hpbGQoZSksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7dmlldzpcIlRpbWVQbHVnaW5JbnB1dFwiLHRhcmdldDplfSl9aS5hcHBlbmRDaGlsZCh0KSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHt2aWV3OlwiVGltZVBsdWdpbkNvbnRhaW5lclwiLHRhcmdldDp0fSl9fW9uSW5wdXQoZSl7Y29uc3QgaT1lLnRhcmdldDtpZihpIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmaS5jbGFzc0xpc3QuY29udGFpbnMoXCJ0aW1lLXBsdWdpbi1pbnB1dFwiKSl7Y29uc3QgZT10aGlzLnRpbWVQaWNrZWRbaS5uYW1lXXx8bmV3IHQsW24sc109aS52YWx1ZS5zcGxpdChcIjpcIik7ZS5zZXRIb3VycyhOdW1iZXIobil8fDAsTnVtYmVyKHMpfHwwLDAsMCksdGhpcy5waWNrZXIub3B0aW9ucy5hdXRvQXBwbHk/KHRoaXMudGltZVBpY2tlZFtpLm5hbWVdPWUsdGhpcy5waWNrZXIudXBkYXRlVmFsdWVzKCkpOnRoaXMudGltZVByZVBpY2tlZFtpLm5hbWVdPWV9fW9uQ2hhbmdlKGUpe2NvbnN0IGk9ZS50YXJnZXQ7aWYoaSBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50JiZpLmNsYXNzTGlzdC5jb250YWlucyhcInRpbWUtcGx1Z2luLWN1c3RvbS1pbnB1dFwiKSl7Y29uc3QgZT0vKFxcdyspXFxbKFxcdyspXFxdLyxbLG4sc109aS5uYW1lLm1hdGNoKGUpLG89TnVtYmVyKGkudmFsdWUpO2xldCBhPW5ldyB0O3N3aXRjaCghdGhpcy5waWNrZXIub3B0aW9ucy5hdXRvQXBwbHkmJnRoaXMudGltZVByZVBpY2tlZFtuXWluc3RhbmNlb2YgRGF0ZT9hPXRoaXMudGltZVByZVBpY2tlZFtuXS5jbG9uZSgpOnRoaXMudGltZVBpY2tlZFtuXWluc3RhbmNlb2YgRGF0ZSYmKGE9dGhpcy50aW1lUGlja2VkW25dLmNsb25lKCkpLHMpe2Nhc2VcIkhIXCI6aWYodGhpcy5vcHRpb25zLmZvcm1hdDEyKXtjb25zdCB0PWkuY2xvc2VzdChcIi50aW1lLXBsdWdpbi1jdXN0b20tYmxvY2tcIikucXVlcnlTZWxlY3Rvcihgc2VsZWN0W25hbWU9XCIke259W3BlcmlvZF1cIl1gKS52YWx1ZSxlPXRoaXMuaGFuZGxlRm9ybWF0MTIodCxhLG8pO2Euc2V0SG91cnMoZS5nZXRIb3VycygpLGUuZ2V0TWludXRlcygpLGUuZ2V0U2Vjb25kcygpLDApfWVsc2UgYS5zZXRIb3VycyhvLGEuZ2V0TWludXRlcygpLGEuZ2V0U2Vjb25kcygpLDApO2JyZWFrO2Nhc2VcIm1tXCI6YS5zZXRIb3VycyhhLmdldEhvdXJzKCksbyxhLmdldFNlY29uZHMoKSwwKTticmVhaztjYXNlXCJzc1wiOmEuc2V0SG91cnMoYS5nZXRIb3VycygpLGEuZ2V0TWludXRlcygpLG8sMCk7YnJlYWs7Y2FzZVwicGVyaW9kXCI6aWYodGhpcy5vcHRpb25zLmZvcm1hdDEyKXtjb25zdCB0PWkuY2xvc2VzdChcIi50aW1lLXBsdWdpbi1jdXN0b20tYmxvY2tcIikucXVlcnlTZWxlY3Rvcihgc2VsZWN0W25hbWU9XCIke259W0hIXVwiXWApLnZhbHVlLGU9dGhpcy5oYW5kbGVGb3JtYXQxMihpLnZhbHVlLGEsTnVtYmVyKHQpKTthLnNldEhvdXJzKGUuZ2V0SG91cnMoKSxlLmdldE1pbnV0ZXMoKSxlLmdldFNlY29uZHMoKSwwKX19aWYodGhpcy5waWNrZXIub3B0aW9ucy5hdXRvQXBwbHkpdGhpcy50aW1lUGlja2VkW25dPWEsdGhpcy5waWNrZXIudXBkYXRlVmFsdWVzKCk7ZWxzZXt0aGlzLnRpbWVQcmVQaWNrZWRbbl09YTtjb25zdCB0PXRoaXMucGlja2VyLnVpLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLmFwcGx5LWJ1dHRvblwiKTtpZih0aGlzLnJhbmdlUGx1Z2luKXtjb25zdCBlPXRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucyxpPXRoaXMucGlja2VyLmRhdGVQaWNrZWQsbj1lLnN0cmljdCYmMj09PWkubGVuZ3RofHwhZS5zdHJpY3QmJmkubGVuZ3RoPjB8fCFpLmxlbmd0aCYmZS5zdHJpY3QmJmUuc3RhcnREYXRlIGluc3RhbmNlb2YgRGF0ZSYmZS5lbmREYXRlIGluc3RhbmNlb2YgRGF0ZXx8IWkubGVuZ3RoJiYhZS5zdHJpY3QmJihlLnN0YXJ0RGF0ZSBpbnN0YW5jZW9mIERhdGV8fGUuZW5kRGF0ZSBpbnN0YW5jZW9mIERhdGUpO3QuZGlzYWJsZWQ9IW59ZWxzZSB0aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aCYmKHQuZGlzYWJsZWQ9ITEpfX19b25DbGljayh0KXtjb25zdCBlPXQudGFyZ2V0O2lmKGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCl7Y29uc3QgdD1lLmNsb3Nlc3QoXCIudW5pdFwiKTtpZighKHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpcmV0dXJuO3RoaXMucGlja2VyLmlzQXBwbHlCdXR0b24odCkmJihPYmplY3Qua2V5cyh0aGlzLnRpbWVQaWNrZWQpLmZvckVhY2goKHQ9Pnt0aGlzLnRpbWVQcmVQaWNrZWRbdF1pbnN0YW5jZW9mIERhdGUmJih0aGlzLnRpbWVQaWNrZWRbdF09dGhpcy50aW1lUHJlUGlja2VkW3RdLmNsb25lKCkpfSkpLHRoaXMucGlja2VyLnVwZGF0ZVZhbHVlcygpLHRoaXMudGltZVByZVBpY2tlZD17aW5wdXQ6bnVsbCxzdGFydDpudWxsLGVuZDpudWxsfSksdGhpcy5waWNrZXIuaXNDYW5jZWxCdXR0b24odCkmJih0aGlzLnRpbWVQcmVQaWNrZWQ9e2lucHV0Om51bGwsc3RhcnQ6bnVsbCxlbmQ6bnVsbH0sdGhpcy5waWNrZXIucmVuZGVyQWxsKCkpfX1zZXRUaW1lKHQpe2NvbnN0IGU9dGhpcy5oYW5kbGVUaW1lU3RyaW5nKHQpO3RoaXMudGltZVBpY2tlZC5pbnB1dD1lLmNsb25lKCksdGhpcy5waWNrZXIucmVuZGVyQWxsKCksdGhpcy5waWNrZXIudXBkYXRlVmFsdWVzKCl9c2V0U3RhcnRUaW1lKHQpe2NvbnN0IGU9dGhpcy5oYW5kbGVUaW1lU3RyaW5nKHQpO3RoaXMudGltZVBpY2tlZC5zdGFydD1lLmNsb25lKCksdGhpcy5waWNrZXIucmVuZGVyQWxsKCksdGhpcy5waWNrZXIudXBkYXRlVmFsdWVzKCl9c2V0RW5kVGltZSh0KXtjb25zdCBlPXRoaXMuaGFuZGxlVGltZVN0cmluZyh0KTt0aGlzLnRpbWVQaWNrZWQuZW5kPWUuY2xvbmUoKSx0aGlzLnBpY2tlci5yZW5kZXJBbGwoKSx0aGlzLnBpY2tlci51cGRhdGVWYWx1ZXMoKX1oYW5kbGVUaW1lU3RyaW5nKGUpe2NvbnN0IGk9bmV3IHQsW24scyxvXT1lLnNwbGl0KFwiOlwiKS5tYXAoKHQ9Pk51bWJlcih0KSkpLGE9biYmIU51bWJlci5pc05hTihuKT9uOjAscj1zJiYhTnVtYmVyLmlzTmFOKHMpP3M6MCxjPW8mJiFOdW1iZXIuaXNOYU4obyk/bzowO3JldHVybiBpLnNldEhvdXJzKGEscixjLDApLGl9Z2V0RGF0ZSgpe2lmKHRoaXMucGlja2VyLm9wdGlvbnMuZGF0ZSBpbnN0YW5jZW9mIERhdGUpe2NvbnN0IGU9bmV3IHQodGhpcy5waWNrZXIub3B0aW9ucy5kYXRlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTtpZih0aGlzLnRpbWVQaWNrZWQuaW5wdXQgaW5zdGFuY2VvZiBEYXRlKXtjb25zdCB0PXRoaXMudGltZVBpY2tlZC5pbnB1dDtlLnNldEhvdXJzKHQuZ2V0SG91cnMoKSx0LmdldE1pbnV0ZXMoKSx0LmdldFNlY29uZHMoKSwwKX1yZXR1cm4gZX1yZXR1cm4gbnVsbH1nZXRTdGFydERhdGUoKXtpZih0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuc3RhcnREYXRlIGluc3RhbmNlb2YgRGF0ZSl7Y29uc3QgZT1uZXcgdCh0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuc3RhcnREYXRlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTtpZih0aGlzLnRpbWVQaWNrZWQuc3RhcnQgaW5zdGFuY2VvZiBEYXRlKXtjb25zdCB0PXRoaXMudGltZVBpY2tlZC5zdGFydDtlLnNldEhvdXJzKHQuZ2V0SG91cnMoKSx0LmdldE1pbnV0ZXMoKSx0LmdldFNlY29uZHMoKSwwKX1yZXR1cm4gZX1yZXR1cm4gbnVsbH1nZXRFbmREYXRlKCl7aWYodGhpcy5yYW5nZVBsdWdpbi5vcHRpb25zLmVuZERhdGUgaW5zdGFuY2VvZiBEYXRlKXtjb25zdCBlPW5ldyB0KHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5lbmREYXRlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTtpZih0aGlzLnRpbWVQaWNrZWQuZW5kIGluc3RhbmNlb2YgRGF0ZSl7Y29uc3QgdD10aGlzLnRpbWVQaWNrZWQuZW5kO2Uuc2V0SG91cnModC5nZXRIb3VycygpLHQuZ2V0TWludXRlcygpLHQuZ2V0U2Vjb25kcygpLDApfXJldHVybiBlfXJldHVybiBudWxsfWdldFNpbmdsZUlucHV0KCl7cmV0dXJuIHRoaXMub3B0aW9ucy5uYXRpdmU/dGhpcy5nZXROYXRpdmVJbnB1dChcImlucHV0XCIpOnRoaXMuZ2V0Q3VzdG9tSW5wdXQoXCJpbnB1dFwiKX1nZXRTdGFydElucHV0KCl7cmV0dXJuIHRoaXMub3B0aW9ucy5uYXRpdmU/dGhpcy5nZXROYXRpdmVJbnB1dChcInN0YXJ0XCIpOnRoaXMuZ2V0Q3VzdG9tSW5wdXQoXCJzdGFydFwiKX1nZXRFbmRJbnB1dCgpe3JldHVybiB0aGlzLm9wdGlvbnMubmF0aXZlP3RoaXMuZ2V0TmF0aXZlSW5wdXQoXCJlbmRcIik6dGhpcy5nZXRDdXN0b21JbnB1dChcImVuZFwiKX1nZXROYXRpdmVJbnB1dCh0KXtjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtlLnR5cGU9XCJ0aW1lXCIsZS5uYW1lPXQsZS5jbGFzc05hbWU9XCJ0aW1lLXBsdWdpbi1pbnB1dCB1bml0XCI7Y29uc3QgaT10aGlzLnRpbWVQaWNrZWRbdF07aWYoaSl7Y29uc3QgdD1gMCR7aS5nZXRIb3VycygpfWAuc2xpY2UoLTIpLG49YDAke2kuZ2V0TWludXRlcygpfWAuc2xpY2UoLTIpO2UudmFsdWU9YCR7dH06JHtufWB9cmV0dXJuIGV9Z2V0Q3VzdG9tSW5wdXQodCl7Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2UuY2xhc3NOYW1lPVwidGltZS1wbHVnaW4tY3VzdG9tLWJsb2NrXCI7Y29uc3QgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO2kuY2xhc3NOYW1lPVwidGltZS1wbHVnaW4tY3VzdG9tLWlucHV0IHVuaXRcIixpLm5hbWU9YCR7dH1bSEhdYDtjb25zdCBuPXRoaXMub3B0aW9ucy5mb3JtYXQxMj8xOjAscz10aGlzLm9wdGlvbnMuZm9ybWF0MTI/MTM6MjQ7bGV0IG89bnVsbDshdGhpcy5waWNrZXIub3B0aW9ucy5hdXRvQXBwbHkmJnRoaXMudGltZVByZVBpY2tlZFt0XWluc3RhbmNlb2YgRGF0ZT9vPXRoaXMudGltZVByZVBpY2tlZFt0XS5jbG9uZSgpOnRoaXMudGltZVBpY2tlZFt0XWluc3RhbmNlb2YgRGF0ZSYmKG89dGhpcy50aW1lUGlja2VkW3RdLmNsb25lKCkpO2ZvcihsZXQgdD1uO3Q8czt0Kz10aGlzLm9wdGlvbnMuc3RlcEhvdXJzKXtjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7ZS52YWx1ZT1TdHJpbmcodCksZS50ZXh0PVN0cmluZyh0KSxvJiYodGhpcy5vcHRpb25zLmZvcm1hdDEyPyhvLmdldEhvdXJzKCklMTI/by5nZXRIb3VycygpJTEyOjEyKT09PXQmJihlLnNlbGVjdGVkPSEwKTpvLmdldEhvdXJzKCk9PT10JiYoZS5zZWxlY3RlZD0hMCkpLGkuYXBwZW5kQ2hpbGQoZSl9ZS5hcHBlbmRDaGlsZChpKTtjb25zdCBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7YS5jbGFzc05hbWU9XCJ0aW1lLXBsdWdpbi1jdXN0b20taW5wdXQgdW5pdFwiLGEubmFtZT1gJHt0fVttbV1gO2ZvcihsZXQgdD0wO3Q8NjA7dCs9dGhpcy5vcHRpb25zLnN0ZXBNaW51dGVzKXtjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7ZS52YWx1ZT1gMCR7U3RyaW5nKHQpfWAuc2xpY2UoLTIpLGUudGV4dD1gMCR7U3RyaW5nKHQpfWAuc2xpY2UoLTIpLG8mJm8uZ2V0TWludXRlcygpPT09dCYmKGUuc2VsZWN0ZWQ9ITApLGEuYXBwZW5kQ2hpbGQoZSl9aWYoZS5hcHBlbmRDaGlsZChhKSx0aGlzLm9wdGlvbnMuc2Vjb25kcyl7Y29uc3QgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO2kuY2xhc3NOYW1lPVwidGltZS1wbHVnaW4tY3VzdG9tLWlucHV0IHVuaXRcIixpLm5hbWU9YCR7dH1bc3NdYDtjb25zdCBuPTYwO2ZvcihsZXQgdD0wO3Q8bjt0Kz10aGlzLm9wdGlvbnMuc3RlcFNlY29uZHMpe2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtlLnZhbHVlPWAwJHtTdHJpbmcodCl9YC5zbGljZSgtMiksZS50ZXh0PWAwJHtTdHJpbmcodCl9YC5zbGljZSgtMiksbyYmby5nZXRTZWNvbmRzKCk9PT10JiYoZS5zZWxlY3RlZD0hMCksaS5hcHBlbmRDaGlsZChlKX1lLmFwcGVuZENoaWxkKGkpfWlmKHRoaXMub3B0aW9ucy5mb3JtYXQxMil7Y29uc3QgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO2kuY2xhc3NOYW1lPVwidGltZS1wbHVnaW4tY3VzdG9tLWlucHV0IHVuaXRcIixpLm5hbWU9YCR7dH1bcGVyaW9kXWAsW1wiQU1cIixcIlBNXCJdLmZvckVhY2goKHQ9Pntjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7ZS52YWx1ZT10LGUudGV4dD10LG8mJlwiUE1cIj09PXQmJm8uZ2V0SG91cnMoKT49MTImJihlLnNlbGVjdGVkPSEwKSxpLmFwcGVuZENoaWxkKGUpfSkpLGUuYXBwZW5kQ2hpbGQoaSl9cmV0dXJuIGV9aGFuZGxlRm9ybWF0MTIodCxlLGkpe2NvbnN0IG49ZS5jbG9uZSgpO3N3aXRjaCh0KXtjYXNlXCJBTVwiOjEyPT09aT9uLnNldEhvdXJzKDAsbi5nZXRNaW51dGVzKCksbi5nZXRTZWNvbmRzKCksMCk6bi5zZXRIb3VycyhpLG4uZ2V0TWludXRlcygpLG4uZ2V0U2Vjb25kcygpLDApO2JyZWFrO2Nhc2VcIlBNXCI6MTIhPT1pP24uc2V0SG91cnMoaSsxMixuLmdldE1pbnV0ZXMoKSxuLmdldFNlY29uZHMoKSwwKTpuLnNldEhvdXJzKGksbi5nZXRNaW51dGVzKCksbi5nZXRTZWNvbmRzKCksMCl9cmV0dXJuIG59cGFyc2VWYWx1ZXMoKXtpZih0aGlzLnJhbmdlUGx1Z2luKXtpZih0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuc3RyaWN0KXtpZih0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuc3RhcnREYXRlJiZ0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuZW5kRGF0ZSl7Y29uc3QgZT1uZXcgdCh0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuc3RhcnREYXRlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KSxpPW5ldyB0KHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5lbmREYXRlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTt0aGlzLnRpbWVQaWNrZWQuc3RhcnQ9ZS5jbG9uZSgpLHRoaXMudGltZVBpY2tlZC5lbmQ9aS5jbG9uZSgpfX1lbHNle2lmKHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5zdGFydERhdGUpe2NvbnN0IGU9bmV3IHQodGhpcy5yYW5nZVBsdWdpbi5vcHRpb25zLnN0YXJ0RGF0ZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCk7dGhpcy50aW1lUGlja2VkLnN0YXJ0PWUuY2xvbmUoKX1pZih0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuZW5kRGF0ZSl7Y29uc3QgZT1uZXcgdCh0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuZW5kRGF0ZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCk7dGhpcy50aW1lUGlja2VkLmVuZD1lLmNsb25lKCl9fWlmKHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5lbGVtZW50RW5kKWlmKHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5zdHJpY3Qpe2lmKHRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJnRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC52YWx1ZS5sZW5ndGgmJnRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5lbGVtZW50RW5kIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmdGhpcy5yYW5nZVBsdWdpbi5vcHRpb25zLmVsZW1lbnRFbmQudmFsdWUubGVuZ3RoKXtjb25zdCBlPW5ldyB0KHRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC52YWx1ZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCksaT1uZXcgdCh0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuZWxlbWVudEVuZC52YWx1ZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCk7dGhpcy50aW1lUGlja2VkLnN0YXJ0PWUuY2xvbmUoKSx0aGlzLnRpbWVQaWNrZWQuZW5kPWkuY2xvbmUoKX19ZWxzZXtpZih0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50JiZ0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQudmFsdWUubGVuZ3RoKXtjb25zdCBlPW5ldyB0KHRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC52YWx1ZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCk7dGhpcy50aW1lUGlja2VkLnN0YXJ0PWUuY2xvbmUoKX1pZih0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuZWxlbWVudEVuZCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJnRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5lbGVtZW50RW5kLnZhbHVlLmxlbmd0aCl7Y29uc3QgZT1uZXcgdCh0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuZWxlbWVudEVuZC52YWx1ZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCk7dGhpcy50aW1lUGlja2VkLnN0YXJ0PWUuY2xvbmUoKX19ZWxzZSBpZih0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50JiZ0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQudmFsdWUubGVuZ3RoKXtjb25zdFtlLGldPXRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC52YWx1ZS5zcGxpdCh0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuZGVsaW1pdGVyKTtpZih0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuc3RyaWN0KXtpZihlJiZpKXtjb25zdCBuPW5ldyB0KGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpLHM9bmV3IHQoaSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCk7dGhpcy50aW1lUGlja2VkLnN0YXJ0PW4uY2xvbmUoKSx0aGlzLnRpbWVQaWNrZWQuZW5kPXMuY2xvbmUoKX19ZWxzZXtpZihlKXtjb25zdCBpPW5ldyB0KGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpO3RoaXMudGltZVBpY2tlZC5zdGFydD1pLmNsb25lKCl9aWYoaSl7Y29uc3QgZT1uZXcgdChpLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTt0aGlzLnRpbWVQaWNrZWQuc3RhcnQ9ZS5jbG9uZSgpfX19fWVsc2V7aWYodGhpcy5waWNrZXIub3B0aW9ucy5kYXRlKXtjb25zdCBlPW5ldyB0KHRoaXMucGlja2VyLm9wdGlvbnMuZGF0ZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCk7dGhpcy50aW1lUGlja2VkLmlucHV0PWUuY2xvbmUoKX1pZih0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50JiZ0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQudmFsdWUubGVuZ3RoKXtjb25zdCBlPW5ldyB0KHRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC52YWx1ZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCk7dGhpcy50aW1lUGlja2VkLmlucHV0PWUuY2xvbmUoKX19fX1jbGFzcyBoIGV4dGVuZHMgb3tkb2NFbGVtZW50PW51bGw7cmFuZ2VQbHVnaW47YmluZHM9e29uVmlldzp0aGlzLm9uVmlldy5iaW5kKHRoaXMpLG9uS2V5ZG93bjp0aGlzLm9uS2V5ZG93bi5iaW5kKHRoaXMpfTtvcHRpb25zPXt1bml0SW5kZXg6MSxkYXlJbmRleDoyfTtnZXROYW1lKCl7cmV0dXJuXCJLYmRQbHVnaW5cIn1vbkF0dGFjaCgpe2NvbnN0IHQ9dGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LGU9dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZih0aGlzLmRvY0VsZW1lbnQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIiksdGhpcy5kb2NFbGVtZW50LnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIix0aGlzLmRvY0VsZW1lbnQuc3R5bGUudG9wPWAke3Qub2Zmc2V0VG9wfXB4YCx0aGlzLmRvY0VsZW1lbnQuc3R5bGUubGVmdD10Lm9mZnNldExlZnQrZS53aWR0aC0yNStcInB4XCIsdGhpcy5kb2NFbGVtZW50LmF0dGFjaFNoYWRvdyh7bW9kZTpcIm9wZW5cIn0pLHRoaXMub3B0aW9ucy5odG1sKXRoaXMuZG9jRWxlbWVudC5zaGFkb3dSb290LmlubmVySFRNTD10aGlzLm9wdGlvbnMuaHRtbDtlbHNle2NvbnN0IHQ9YFxcbiAgICAgIDxzdHlsZT5cXG4gICAgICBidXR0b24ge1xcbiAgICAgICAgYm9yZGVyOiBub25lO1xcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICAgICAgICBmb250LXNpemU6ICR7d2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50KS5mb250U2l6ZX07XFxuICAgICAgfVxcbiAgICAgIDwvc3R5bGU+XFxuXFxuICAgICAgPGJ1dHRvbj4mIzEyODE5Nzs8L2J1dHRvbj5cXG4gICAgICBgO3RoaXMuZG9jRWxlbWVudC5zaGFkb3dSb290LmlubmVySFRNTD10fWNvbnN0IGk9dGhpcy5kb2NFbGVtZW50LnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImJ1dHRvblwiKTtpJiYoaS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwodD0+e3QucHJldmVudERlZmF1bHQoKSx0aGlzLnBpY2tlci5zaG93KHt0YXJnZXQ6dGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50fSl9KSx7Y2FwdHVyZTohMH0pLGkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwodD0+e1wiRXNjYXBlXCI9PT10LmNvZGUmJnRoaXMucGlja2VyLmhpZGUoKX0pLHtjYXB0dXJlOiEwfSkpLHRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC5hZnRlcih0aGlzLmRvY0VsZW1lbnQpLHRoaXMucGlja2VyLm9uKFwidmlld1wiLHRoaXMuYmluZHMub25WaWV3KSx0aGlzLnBpY2tlci5vbihcImtleWRvd25cIix0aGlzLmJpbmRzLm9uS2V5ZG93bil9b25EZXRhY2goKXt0aGlzLmRvY0VsZW1lbnQmJnRoaXMuZG9jRWxlbWVudC5pc0Nvbm5lY3RlZCYmdGhpcy5kb2NFbGVtZW50LnJlbW92ZSgpLHRoaXMucGlja2VyLm9mZihcInZpZXdcIix0aGlzLmJpbmRzLm9uVmlldyksdGhpcy5waWNrZXIub2ZmKFwia2V5ZG93blwiLHRoaXMuYmluZHMub25LZXlkb3duKX1vblZpZXcodCl7Y29uc3R7dmlldzplLHRhcmdldDppfT10LmRldGFpbDtpJiZcInF1ZXJ5U2VsZWN0b3JcImluIGkmJihcIkNhbGVuZGFyRGF5XCIhPT1lfHxbXCJsb2NrZWRcIixcIm5vdC1hdmFpbGFibGVcIl0uc29tZSgodD0+aS5jbGFzc0xpc3QuY29udGFpbnModCkpKT9bLi4uaS5xdWVyeVNlbGVjdG9yQWxsKFwiLnVuaXQ6bm90KC5kYXkpXCIpXS5mb3JFYWNoKCh0PT50LnRhYkluZGV4PXRoaXMub3B0aW9ucy51bml0SW5kZXgpKTppLnRhYkluZGV4PXRoaXMub3B0aW9ucy5kYXlJbmRleCl9b25LZXlkb3duKHQpe3N3aXRjaCh0aGlzLm9uTW91c2VFbnRlcih0KSx0LmNvZGUpe2Nhc2VcIkFycm93VXBcIjpjYXNlXCJBcnJvd0Rvd25cIjp0aGlzLnZlcnRpY2FsTW92ZSh0KTticmVhaztjYXNlXCJBcnJvd0xlZnRcIjpjYXNlXCJBcnJvd1JpZ2h0XCI6dGhpcy5ob3Jpem9udGFsTW92ZSh0KTticmVhaztjYXNlXCJFbnRlclwiOmNhc2VcIlNwYWNlXCI6dGhpcy5oYW5kbGVFbnRlcih0KTticmVhaztjYXNlXCJFc2NhcGVcIjp0aGlzLnBpY2tlci5oaWRlKCl9fWZpbmRBbGxvd2FibGVEYXlTaWJsaW5nKHQsZSxpKXtjb25zdCBuPUFycmF5LmZyb20odC5xdWVyeVNlbGVjdG9yQWxsKGAuZGF5W3RhYmluZGV4PVwiJHt0aGlzLm9wdGlvbnMuZGF5SW5kZXh9XCJdYCkpLHM9bi5pbmRleE9mKGUpO3JldHVybiBuLmZpbHRlcigoKHQsZSk9PmkoZSxzKSYmdC50YWJJbmRleD09PXRoaXMub3B0aW9ucy5kYXlJbmRleCkpWzBdfWNoYW5nZU1vbnRoKHQpe2NvbnN0IGU9e0Fycm93TGVmdDpcInByZXZpb3VzXCIsQXJyb3dSaWdodDpcIm5leHRcIn0saT10aGlzLnBpY2tlci51aS5jb250YWluZXIucXVlcnlTZWxlY3RvcihgLiR7ZVt0LmNvZGVdfS1idXR0b25bdGFiaW5kZXg9XCIke3RoaXMub3B0aW9ucy51bml0SW5kZXh9XCJdYCk7aSYmIWkucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoYG5vLSR7ZVt0LmNvZGVdfS1tb250aGApJiYoaS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImNsaWNrXCIse2J1YmJsZXM6ITB9KSksc2V0VGltZW91dCgoKCk9PntsZXQgZT1udWxsO3N3aXRjaCh0LmNvZGUpe2Nhc2VcIkFycm93TGVmdFwiOmNvbnN0IHQ9dGhpcy5waWNrZXIudWkuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoYC5kYXlbdGFiaW5kZXg9XCIke3RoaXMub3B0aW9ucy5kYXlJbmRleH1cIl1gKTtlPXRbdC5sZW5ndGgtMV07YnJlYWs7Y2FzZVwiQXJyb3dSaWdodFwiOmU9dGhpcy5waWNrZXIudWkuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYC5kYXlbdGFiaW5kZXg9XCIke3RoaXMub3B0aW9ucy5kYXlJbmRleH1cIl1gKX1lJiZlLmZvY3VzKCl9KSkpfXZlcnRpY2FsTW92ZSh0KXtjb25zdCBlPXQudGFyZ2V0O2lmKGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGF5XCIpKXt0LnByZXZlbnREZWZhdWx0KCk7Y29uc3QgaT10aGlzLmZpbmRBbGxvd2FibGVEYXlTaWJsaW5nKHRoaXMucGlja2VyLnVpLmNvbnRhaW5lcixlLCgoZSxpKT0+ZT09PShcIkFycm93VXBcIj09PXQuY29kZT9pLTc6aSs3KSkpO2kmJmkuZm9jdXMoKX19aG9yaXpvbnRhbE1vdmUodCl7Y29uc3QgZT10LnRhcmdldDtpZihlLmNsYXNzTGlzdC5jb250YWlucyhcImRheVwiKSl7dC5wcmV2ZW50RGVmYXVsdCgpO2NvbnN0IGk9dGhpcy5maW5kQWxsb3dhYmxlRGF5U2libGluZyh0aGlzLnBpY2tlci51aS5jb250YWluZXIsZSwoKGUsaSk9PmU9PT0oXCJBcnJvd0xlZnRcIj09PXQuY29kZT9pLTE6aSsxKSkpO2k/aS5mb2N1cygpOnRoaXMuY2hhbmdlTW9udGgodCl9fWhhbmRsZUVudGVyKHQpe2NvbnN0IGU9dC50YXJnZXQ7ZS5jbGFzc0xpc3QuY29udGFpbnMoXCJkYXlcIikmJih0LnByZXZlbnREZWZhdWx0KCksZS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImNsaWNrXCIse2J1YmJsZXM6ITB9KSksc2V0VGltZW91dCgoKCk9PntpZih0aGlzLnJhbmdlUGx1Z2luPXRoaXMucGlja2VyLlBsdWdpbk1hbmFnZXIuZ2V0SW5zdGFuY2UoXCJSYW5nZVBsdWdpblwiKSx0aGlzLnJhbmdlUGx1Z2lufHwhdGhpcy5waWNrZXIub3B0aW9ucy5hdXRvQXBwbHkpe2NvbnN0IHQ9dGhpcy5waWNrZXIudWkuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuZGF5LnNlbGVjdGVkXCIpO3QmJnNldFRpbWVvdXQoKCgpPT57dC5mb2N1cygpfSkpfX0pKSl9b25Nb3VzZUVudGVyKHQpe3QudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImRheVwiKSYmc2V0VGltZW91dCgoKCk9Pntjb25zdCB0PXRoaXMucGlja2VyLnVpLnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDt0JiZ0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwibW91c2VlbnRlclwiLHtidWJibGVzOiEwfSkpfSkpfX1jbGFzcyBkIGV4dGVuZHMgb3tyYW5nZVBsdWdpbjtsb2NrUGx1Z2luO3ByaW9yaXR5PTEwO2JpbmRzPXtvblZpZXc6dGhpcy5vblZpZXcuYmluZCh0aGlzKSxvbkNvbG9yU2NoZW1lOnRoaXMub25Db2xvclNjaGVtZS5iaW5kKHRoaXMpfTtvcHRpb25zPXtkcm9wZG93bjp7bW9udGhzOiExLHllYXJzOiExLG1pblllYXI6MTk1MCxtYXhZZWFyOm51bGx9LGRhcmtNb2RlOiEwLGxvY2FsZTp7cmVzZXRCdXR0b246JzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGhlaWdodD1cIjI0XCIgd2lkdGg9XCIyNFwiPjxwYXRoIGQ9XCJNMTMgM2MtNC45NyAwLTkgNC4wMy05IDlIMWwzLjg5IDMuODkuMDcuMTRMOSAxMkg2YzAtMy44NyAzLjEzLTcgNy03czcgMy4xMyA3IDctMy4xMyA3LTcgN2MtMS45MyAwLTMuNjgtLjc5LTQuOTQtMi4wNmwtMS40MiAxLjQyQzguMjcgMTkuOTkgMTAuNTEgMjEgMTMgMjFjNC45NyAwIDktNC4wMyA5LTlzLTQuMDMtOS05LTl6bS0xIDV2NWw0LjI4IDIuNTQuNzItMS4yMS0zLjUtMi4wOFY4SDEyelwiLz48L3N2Zz4nfX07bWF0Y2hNZWRpYTtnZXROYW1lKCl7cmV0dXJuXCJBbXBQbHVnaW5cIn1vbkF0dGFjaCgpe3RoaXMub3B0aW9ucy5kYXJrTW9kZSYmd2luZG93JiZcIm1hdGNoTWVkaWFcImluIHdpbmRvdyYmKHRoaXMubWF0Y2hNZWRpYT13aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIiksdGhpcy5tYXRjaE1lZGlhLm1hdGNoZXMmJih0aGlzLnBpY2tlci51aS5jb250YWluZXIuZGF0YXNldC50aGVtZT1cImRhcmtcIiksdGhpcy5tYXRjaE1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIix0aGlzLmJpbmRzLm9uQ29sb3JTY2hlbWUpKSx0aGlzLm9wdGlvbnMud2Vla051bWJlcnMmJnRoaXMucGlja2VyLnVpLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwid2Vlay1udW1iZXJzXCIpLHRoaXMucGlja2VyLm9uKFwidmlld1wiLHRoaXMuYmluZHMub25WaWV3KX1vbkRldGFjaCgpe3RoaXMub3B0aW9ucy5kYXJrTW9kZSYmd2luZG93JiZcIm1hdGNoTWVkaWFcImluIHdpbmRvdyYmdGhpcy5tYXRjaE1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIix0aGlzLmJpbmRzLm9uQ29sb3JTY2hlbWUpLHRoaXMucGlja2VyLnVpLmNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRoZW1lXCIpLHRoaXMucGlja2VyLnVpLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwid2Vlay1udW1iZXJzXCIpLHRoaXMucGlja2VyLm9mZihcInZpZXdcIix0aGlzLmJpbmRzLm9uVmlldyl9b25WaWV3KHQpe3RoaXMubG9ja1BsdWdpbj10aGlzLnBpY2tlci5QbHVnaW5NYW5hZ2VyLmdldEluc3RhbmNlKFwiTG9ja1BsdWdpblwiKSx0aGlzLnJhbmdlUGx1Z2luPXRoaXMucGlja2VyLlBsdWdpbk1hbmFnZXIuZ2V0SW5zdGFuY2UoXCJSYW5nZVBsdWdpblwiKSx0aGlzLmhhbmRsZURyb3Bkb3duKHQpLHRoaXMuaGFuZGxlUmVzZXRCdXR0b24odCksdGhpcy5oYW5kbGVXZWVrTnVtYmVycyh0KX1vbkNvbG9yU2NoZW1lKHQpe2NvbnN0IGU9dC5tYXRjaGVzP1wiZGFya1wiOlwibGlnaHRcIjt0aGlzLnBpY2tlci51aS5jb250YWluZXIuZGF0YXNldC50aGVtZT1lfWhhbmRsZURyb3Bkb3duKGUpe2NvbnN0e3ZpZXc6aSx0YXJnZXQ6bixkYXRlOnMsaW5kZXg6b309ZS5kZXRhaWw7aWYoXCJDYWxlbmRhckhlYWRlclwiPT09aSl7Y29uc3QgZT1uLnF1ZXJ5U2VsZWN0b3IoXCIubW9udGgtbmFtZVwiKTtpZih0aGlzLm9wdGlvbnMuZHJvcGRvd24ubW9udGhzKXtlLmNoaWxkTm9kZXNbMF0ucmVtb3ZlKCk7Y29uc3QgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO2kuY2xhc3NOYW1lPVwibW9udGgtbmFtZS0tc2VsZWN0IG1vbnRoLW5hbWUtLWRyb3Bkb3duXCI7Zm9yKGxldCBlPTA7ZTwxMjtlKz0xKXtjb25zdCBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiksbz1uZXcgdChuZXcgRGF0ZShzLmdldEZ1bGxZZWFyKCksZSwyLDAsMCwwKSksYT1uZXcgdChuZXcgRGF0ZShzLmdldEZ1bGxZZWFyKCksZSwxLDAsMCwwKSk7bi52YWx1ZT1TdHJpbmcoZSksbi50ZXh0PW8udG9Mb2NhbGVTdHJpbmcodGhpcy5waWNrZXIub3B0aW9ucy5sYW5nLHttb250aDpcImxvbmdcIn0pLHRoaXMubG9ja1BsdWdpbiYmKG4uZGlzYWJsZWQ9dGhpcy5sb2NrUGx1Z2luLm9wdGlvbnMubWluRGF0ZSYmYS5pc0JlZm9yZShuZXcgdCh0aGlzLmxvY2tQbHVnaW4ub3B0aW9ucy5taW5EYXRlKSxcIm1vbnRoXCIpfHx0aGlzLmxvY2tQbHVnaW4ub3B0aW9ucy5tYXhEYXRlJiZhLmlzQWZ0ZXIobmV3IHQodGhpcy5sb2NrUGx1Z2luLm9wdGlvbnMubWF4RGF0ZSksXCJtb250aFwiKSksbi5zZWxlY3RlZD1hLmdldE1vbnRoKCk9PT1zLmdldE1vbnRoKCksaS5hcHBlbmRDaGlsZChuKX1pLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwodD0+e2NvbnN0IGU9dC50YXJnZXQ7dGhpcy5waWNrZXIuY2FsZW5kYXJzWzBdLnNldERhdGUoMSksdGhpcy5waWNrZXIuY2FsZW5kYXJzWzBdLnNldE1vbnRoKE51bWJlcihlLnZhbHVlKSksdGhpcy5waWNrZXIucmVuZGVyQWxsKCl9KSksZS5wcmVwZW5kKGkpfWlmKHRoaXMub3B0aW9ucy5kcm9wZG93bi55ZWFycyl7ZS5jaGlsZE5vZGVzWzFdLnJlbW92ZSgpO2NvbnN0IGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtpLmNsYXNzTmFtZT1cIm1vbnRoLW5hbWUtLXNlbGVjdFwiO2NvbnN0IG49dGhpcy5vcHRpb25zLmRyb3Bkb3duLm1pblllYXIsbz10aGlzLm9wdGlvbnMuZHJvcGRvd24ubWF4WWVhcj90aGlzLm9wdGlvbnMuZHJvcGRvd24ubWF4WWVhcjoobmV3IERhdGUpLmdldEZ1bGxZZWFyKCk7aWYocy5nZXRGdWxsWWVhcigpPm8pe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTt0LnZhbHVlPVN0cmluZyhzLmdldEZ1bGxZZWFyKCkpLHQudGV4dD1TdHJpbmcocy5nZXRGdWxsWWVhcigpKSx0LnNlbGVjdGVkPSEwLHQuZGlzYWJsZWQ9ITAsaS5hcHBlbmRDaGlsZCh0KX1mb3IobGV0IGU9bztlPj1uO2UtPTEpe2NvbnN0IG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSxvPW5ldyB0KG5ldyBEYXRlKGUsMCwxLDAsMCwwKSk7bi52YWx1ZT1TdHJpbmcoZSksbi50ZXh0PVN0cmluZyhlKSx0aGlzLmxvY2tQbHVnaW4mJihuLmRpc2FibGVkPXRoaXMubG9ja1BsdWdpbi5vcHRpb25zLm1pbkRhdGUmJm8uaXNCZWZvcmUobmV3IHQodGhpcy5sb2NrUGx1Z2luLm9wdGlvbnMubWluRGF0ZSksXCJ5ZWFyXCIpfHx0aGlzLmxvY2tQbHVnaW4ub3B0aW9ucy5tYXhEYXRlJiZvLmlzQWZ0ZXIobmV3IHQodGhpcy5sb2NrUGx1Z2luLm9wdGlvbnMubWF4RGF0ZSksXCJ5ZWFyXCIpKSxuLnNlbGVjdGVkPXMuZ2V0RnVsbFllYXIoKT09PWUsaS5hcHBlbmRDaGlsZChuKX1pZihzLmdldEZ1bGxZZWFyKCk8bil7Y29uc3QgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO3QudmFsdWU9U3RyaW5nKHMuZ2V0RnVsbFllYXIoKSksdC50ZXh0PVN0cmluZyhzLmdldEZ1bGxZZWFyKCkpLHQuc2VsZWN0ZWQ9ITAsdC5kaXNhYmxlZD0hMCxpLmFwcGVuZENoaWxkKHQpfWlmKFwiYXNjXCI9PT10aGlzLm9wdGlvbnMuZHJvcGRvd24ueWVhcnMpe2NvbnN0IHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaS5jaGlsZE5vZGVzKS5yZXZlcnNlKCk7aS5pbm5lckhUTUw9XCJcIix0LmZvckVhY2goKHQ9Pnt0LmlubmVySFRNTD10LnZhbHVlLGkuYXBwZW5kQ2hpbGQodCl9KSl9aS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsKHQ9Pntjb25zdCBlPXQudGFyZ2V0O3RoaXMucGlja2VyLmNhbGVuZGFyc1swXS5zZXRGdWxsWWVhcihOdW1iZXIoZS52YWx1ZSkpLHRoaXMucGlja2VyLnJlbmRlckFsbCgpfSkpLGUuYXBwZW5kQ2hpbGQoaSl9fX1oYW5kbGVSZXNldEJ1dHRvbih0KXtjb25zdHt2aWV3OmUsdGFyZ2V0Oml9PXQuZGV0YWlsO2lmKFwiQ2FsZW5kYXJIZWFkZXJcIj09PWUmJnRoaXMub3B0aW9ucy5yZXNldEJ1dHRvbil7Y29uc3QgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO3QuY2xhc3NOYW1lPVwicmVzZXQtYnV0dG9uIHVuaXRcIix0LmlubmVySFRNTD10aGlzLm9wdGlvbnMubG9jYWxlLnJlc2V0QnV0dG9uLHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsKHQ9Pnt0LnByZXZlbnREZWZhdWx0KCk7bGV0IGU9ITA7XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vcHRpb25zLnJlc2V0QnV0dG9uJiYoZT10aGlzLm9wdGlvbnMucmVzZXRCdXR0b24uY2FsbCh0aGlzKSksZSYmdGhpcy5waWNrZXIuY2xlYXIoKX0pKSxpLmFwcGVuZENoaWxkKHQpfX1oYW5kbGVXZWVrTnVtYmVycyhlKXtpZih0aGlzLm9wdGlvbnMud2Vla051bWJlcnMpe2NvbnN0e3ZpZXc6aSx0YXJnZXQ6bn09ZS5kZXRhaWw7aWYoXCJDYWxlbmRhckRheU5hbWVzXCI9PT1pKXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dC5jbGFzc05hbWU9XCJ3bnVtLWhlYWRlclwiLHQuaW5uZXJIVE1MPVwiV2tcIixuLnByZXBlbmQodCl9XCJDYWxlbmRhckRheXNcIj09PWkmJlsuLi5uLmNoaWxkcmVuXS5mb3JFYWNoKCgoZSxpKT0+e2lmKDA9PT1pfHxpJTc9PTApe2xldCBpO2lmKGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGF5XCIpKWk9bmV3IHQoZS5kYXRhc2V0LnRpbWUpO2Vsc2V7Y29uc3QgZT1uLnF1ZXJ5U2VsZWN0b3IoXCIuZGF5XCIpO2k9bmV3IHQoZS5kYXRhc2V0LnRpbWUpfWxldCBzPWkuZ2V0V2Vlayh0aGlzLnBpY2tlci5vcHRpb25zLmZpcnN0RGF5KTs1Mz09PXMmJjA9PT1pLmdldE1vbnRoKCkmJihzPVwiNTMvMVwiKTtjb25zdCBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7by5jbGFzc05hbWU9XCJ3bnVtLWl0ZW1cIixvLmlubmVySFRNTD1TdHJpbmcocyksbi5pbnNlcnRCZWZvcmUobyxlKX19KSl9fX1leHBvcnR7ZCBhcyBBbXBQbHVnaW4sdCBhcyBEYXRlVGltZSxoIGFzIEtiZFBsdWdpbixhIGFzIExvY2tQbHVnaW4sciBhcyBQcmVzZXRQbHVnaW4sYyBhcyBSYW5nZVBsdWdpbixsIGFzIFRpbWVQbHVnaW4sbiBhcyBjcmVhdGUscyBhcyBlYXNlcGlja307XG4iLCJpbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgdmFsaWRhdGVNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvdmFsaWRhdGVNb2RpZmllcnMuanNcIjtcbmltcG9ydCB1bmlxdWVCeSBmcm9tIFwiLi91dGlscy91bmlxdWVCeS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IG1lcmdlQnlOYW1lIGZyb20gXCIuL3V0aWxzL21lcmdlQnlOYW1lLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4vZW51bXMuanNcIjtcbnZhciBJTlZBTElEX0VMRU1FTlRfRVJST1IgPSAnUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuJztcbnZhciBJTkZJTklURV9MT09QX0VSUk9SID0gJ1BvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guJztcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTsgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIG1vZGlmaWVycyBzbyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGdldCB3YXJuZWRcbiAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtb2RpZmllcnMgaXMgaW52YWxpZCBmb3IgYW55IHJlYXNvblxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgbW9kaWZpZXJzID0gdW5pcXVlQnkoW10uY29uY2F0KG9yZGVyZWRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKTtcblxuICAgICAgICAgIGlmIChnZXRCYXNlUGxhY2VtZW50KHN0YXRlLm9wdGlvbnMucGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgICAgICAgICAgdmFyIGZsaXBNb2RpZmllciA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZmluZChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lO1xuICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2ZsaXAnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZmxpcE1vZGlmaWVyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXV0b1wiIHBsYWNlbWVudHMgcmVxdWlyZSB0aGUgXCJmbGlwXCIgbW9kaWZpZXIgYmUnLCAncHJlc2VudCBhbmQgZW5hYmxlZCB0byB3b3JrLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShwb3BwZXIpLFxuICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luUmlnaHQsXG4gICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkJvdHRvbSxcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkxlZnQ7IC8vIFdlIG5vIGxvbmdlciB0YWtlIGludG8gYWNjb3VudCBgbWFyZ2luc2Agb24gdGhlIHBvcHBlciwgYW5kIGl0IGNhblxuICAgICAgICAgIC8vIGNhdXNlIGJ1Z3Mgd2l0aCBwb3NpdGlvbmluZywgc28gd2UnbGwgd2FybiB0aGUgY29uc3VtZXJcblxuXG4gICAgICAgICAgaWYgKFttYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnRdLnNvbWUoZnVuY3Rpb24gKG1hcmdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWFyZ2luKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBDU1MgXCJtYXJnaW5cIiBzdHlsZXMgY2Fubm90IGJlIHVzZWQgdG8gYXBwbHkgcGFkZGluZycsICdiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudCBvciBib3VuZGFyeS4nLCAnVG8gcmVwbGljYXRlIG1hcmdpbiwgdXNlIHRoZSBgb2Zmc2V0YCBtb2RpZmllciwgYXMgd2VsbCBhcycsICd0aGUgYHBhZGRpbmdgIG9wdGlvbiBpbiB0aGUgYHByZXZlbnRPdmVyZmxvd2AgYW5kIGBmbGlwYCcsICdtb2RpZmllcnMuJ10uam9pbignICcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfX2RlYnVnX2xvb3BzX18gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIF9fZGVidWdfbG9vcHNfXyArPSAxO1xuXG4gICAgICAgICAgICBpZiAoX19kZWJ1Z19sb29wc19fID4gMTAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5GSU5JVEVfTE9PUF9FUlJPUik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICAgICAgX3JlZjMkb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZjMkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZjMuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07IiwiaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJpbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSBcIi4vaXNMYXlvdXRWaWV3cG9ydC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSwgaXNGaXhlZFN0cmF0ZWd5KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gIH1cblxuICB2YXIgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSAxO1xuICB2YXIgc2NhbGVZID0gMTtcblxuICBpZiAoaW5jbHVkZVNjYWxlICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBzY2FsZVggPSBlbGVtZW50Lm9mZnNldFdpZHRoID4gMCA/IHJvdW5kKGNsaWVudFJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxIDogMTtcbiAgICBzY2FsZVkgPSBlbGVtZW50Lm9mZnNldEhlaWdodCA+IDAgPyByb3VuZChjbGllbnRSZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxIDogMTtcbiAgfVxuXG4gIHZhciBfcmVmID0gaXNFbGVtZW50KGVsZW1lbnQpID8gZ2V0V2luZG93KGVsZW1lbnQpIDogd2luZG93LFxuICAgICAgdmlzdWFsVmlld3BvcnQgPSBfcmVmLnZpc3VhbFZpZXdwb3J0O1xuXG4gIHZhciBhZGRWaXN1YWxPZmZzZXRzID0gIWlzTGF5b3V0Vmlld3BvcnQoKSAmJiBpc0ZpeGVkU3RyYXRlZ3k7XG4gIHZhciB4ID0gKGNsaWVudFJlY3QubGVmdCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCA6IDApKSAvIHNjYWxlWDtcbiAgdmFyIHkgPSAoY2xpZW50UmVjdC50b3AgKyAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcCA6IDApKSAvIHNjYWxlWTtcbiAgdmFyIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcbiAgdmFyIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGVZO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgbGVmdDogeCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn0iLCJpbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tIFwiLi9nZXRWaWV3cG9ydFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSBcIi4vZ2V0RG9jdW1lbnRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBmYWxzZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gXCIuL2dldE5vZGVTY3JvbGwuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59IiwiaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59IiwiaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgeyBtYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIHZhciBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xuICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5IHx8IGh0bWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCJpbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0SFRNTEVsZW1lbnRTY3JvbGwgZnJvbSBcIi4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgdmFyIGlzSUUgPSAvVHJpZGVudC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgfVxuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59IiwiaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBpc0xheW91dFZpZXdwb3J0IGZyb20gXCIuL2lzTGF5b3V0Vmlld3BvcnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIHZhciBsYXlvdXRWaWV3cG9ydCA9IGlzTGF5b3V0Vmlld3BvcnQoKTtcblxuICAgIGlmIChsYXlvdXRWaWV3cG9ydCB8fCAhbGF5b3V0Vmlld3BvcnQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSxcbiAgICB5OiB5XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTsiLCJpbXBvcnQgZ2V0VUFTdHJpbmcgZnJvbSBcIi4uL3V0aWxzL3VzZXJBZ2VudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xufSIsImltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4gfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1wiO1xuaW1wb3J0IHsgbGVmdCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB0b3AsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNIVE1MRWxlbWVudChhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50IChub3QgYW4gU1ZHRWxlbWVudCkuJywgJ1RvIHVzZSBhbiBTVkcgYXJyb3csIHdyYXAgaXQgaW4gYW4gSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMnLCAndGhlIGFycm93LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgbW9kaWZpZXJcXCdzIGBlbGVtZW50YCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIHBvcHBlcicsICdlbGVtZW50LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmLCB3aW4pIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuICB2YXIgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgIHk6IHJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cyxcbiAgICAgIGlzRml4ZWQgPSBfcmVmMi5pc0ZpeGVkO1xuICB2YXIgX29mZnNldHMkeCA9IG9mZnNldHMueCxcbiAgICAgIHggPSBfb2Zmc2V0cyR4ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeCxcbiAgICAgIF9vZmZzZXRzJHkgPSBvZmZzZXRzLnksXG4gICAgICB5ID0gX29mZnNldHMkeSA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHk7XG5cbiAgdmFyIF9yZWYzID0gdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmMy54O1xuICB5ID0gX3JlZjMueTtcbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuXG5cbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSB0b3AgfHwgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCBwbGFjZW1lbnQgPT09IHJpZ2h0KSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICB2YXIgb2Zmc2V0WSA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICB2YXIgb2Zmc2V0WCA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXTtcbiAgICAgIHggLT0gb2Zmc2V0WCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIHZhciBfcmVmNCA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSwgZ2V0V2luZG93KHBvcHBlcikpIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmNC54O1xuICB5ID0gX3JlZjQueTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xuICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNS5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XG5cbiAgICBpZiAoYWRhcHRpdmUgJiYgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMDtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcnLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgJ1xcblxcbicsICdEaXNhYmxlIHRoZSBcImNvbXB1dGVTdHlsZXNcIiBtb2RpZmllclxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJywgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsICdvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuJywgJ1xcblxcbicsICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLCAnZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gIH07XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGFkYXB0aXZlOiBmYWxzZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyIsImltcG9ydCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn07IiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBhcHBseVN0eWxlcyB9IGZyb20gXCIuL2FwcGx5U3R5bGVzLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFycm93IH0gZnJvbSBcIi4vYXJyb3cuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29tcHV0ZVN0eWxlcyB9IGZyb20gXCIuL2NvbXB1dGVTdHlsZXMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXZlbnRMaXN0ZW5lcnMgfSBmcm9tIFwiLi9ldmVudExpc3RlbmVycy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmbGlwIH0gZnJvbSBcIi4vZmxpcC5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBoaWRlIH0gZnJvbSBcIi4vaGlkZS5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBvZmZzZXQgfSBmcm9tIFwiLi9vZmZzZXQuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcG9wcGVyT2Zmc2V0cyB9IGZyb20gXCIuL3BvcHBlck9mZnNldHMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJldmVudE92ZXJmbG93IH0gZnJvbSBcIi4vcHJldmVudE92ZXJmbG93LmpzXCI7IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHsgd2l0aGluLCB3aXRoaW5NYXhDbGFtcCB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmltcG9ydCB7IG1pbiBhcyBtYXRoTWluLCBtYXggYXMgbWF0aE1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07IiwiaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gXCIuL2NyZWF0ZVBvcHBlci5qc1wiO1xuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1wiO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSBcIi4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjtcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXCI7XG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cywgY29tcHV0ZVN0eWxlcywgYXBwbHlTdHlsZXNdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyIsImltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyB2YXJpYXRpb25QbGFjZW1lbnRzLCBiYXNlUGxhY2VtZW50cywgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gYWxsUGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBUaGUgYGFsbG93ZWRBdXRvUGxhY2VtZW50c2Agb3B0aW9uIGRpZCBub3QgYWxsb3cgYW55JywgJ3BsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvbicsICdvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLicsICdGb3IgZXhhbXBsZSwgXCJhdXRvXCIgY2Fubm90IGJlIHVzZWQgdG8gYWxsb3cgXCJib3R0b20tc3RhcnRcIi4nLCAnVXNlIFwiYXV0by1zdGFydFwiIGluc3RlYWQuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Q2xpcHBpbmdSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4vY29tcHV0ZU9mZnNldHMuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IGNsaXBwaW5nUGFyZW50cywgcmVmZXJlbmNlLCBwb3BwZXIsIGJvdHRvbSwgdG9wLCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuL2V4cGFuZFRvSGFzaE1hcC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRzdHJhdGVneSA9IF9vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgc3RyYXRlZ3kgPSBfb3B0aW9ucyRzdHJhdGVneSA9PT0gdm9pZCAwID8gc3RhdGUuc3RyYXRlZ3kgOiBfb3B0aW9ucyRzdHJhdGVneSxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXQoc3RyKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBbXS5jb25jYXQoYXJncykucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgcmV0dXJuIHAucmVwbGFjZSgvJXMvLCBjKTtcbiAgfSwgc3RyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iLCJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufSIsInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsInZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iLCJleHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSIsImltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4vZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xufSIsImltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1bmlxdWVCeShhcnIsIGZuKSB7XG4gIHZhciBpZGVudGlmaWVycyA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgaWRlbnRpZmllciA9IGZuKGl0ZW0pO1xuXG4gICAgaWYgKCFpZGVudGlmaWVycy5oYXMoaWRlbnRpZmllcikpIHtcbiAgICAgIGlkZW50aWZpZXJzLmFkZChpZGVudGlmaWVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKSB7XG4gIHZhciB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcyAmJiBBcnJheS5pc0FycmF5KHVhRGF0YS5icmFuZHMpKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5icmFuZCArIFwiL1wiICsgaXRlbS52ZXJzaW9uO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufSIsImltcG9ydCBmb3JtYXQgZnJvbSBcIi4vZm9ybWF0LmpzXCI7XG5pbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xudmFyIElOVkFMSURfTU9ESUZJRVJfRVJST1IgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcHJvdmlkZWQgYW4gaW52YWxpZCAlcyBwcm9wZXJ0eSwgZXhwZWN0ZWQgJXMgYnV0IGdvdCAlcyc7XG52YXIgTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHJlcXVpcmVzIFwiJXNcIiwgYnV0IFwiJXNcIiBtb2RpZmllciBpcyBub3QgYXZhaWxhYmxlJztcbnZhciBWQUxJRF9QUk9QRVJUSUVTID0gWyduYW1lJywgJ2VuYWJsZWQnLCAncGhhc2UnLCAnZm4nLCAnZWZmZWN0JywgJ3JlcXVpcmVzJywgJ29wdGlvbnMnXTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBbXS5jb25jYXQoT2JqZWN0LmtleXMobW9kaWZpZXIpLCBWQUxJRF9QUk9QRVJUSUVTKSAvLyBJRTExLWNvbXBhdGlibGUgcmVwbGFjZW1lbnQgZm9yIGBuZXcgU2V0KGl0ZXJhYmxlKWBcbiAgICAuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIFN0cmluZyhtb2RpZmllci5uYW1lKSwgJ1wibmFtZVwiJywgJ1wic3RyaW5nXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5uYW1lKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZW5hYmxlZCc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5lbmFibGVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcImVuYWJsZWRcIicsICdcImJvb2xlYW5cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmVuYWJsZWQpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwaGFzZSc6XG4gICAgICAgICAgaWYgKG1vZGlmaWVyUGhhc2VzLmluZGV4T2YobW9kaWZpZXIucGhhc2UpIDwgMCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicGhhc2VcIicsIFwiZWl0aGVyIFwiICsgbW9kaWZpZXJQaGFzZXMuam9pbignLCAnKSwgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucGhhc2UpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmbic6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5mbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZm5cIicsICdcImZ1bmN0aW9uXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5mbikgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2VmZmVjdCc6XG4gICAgICAgICAgaWYgKG1vZGlmaWVyLmVmZmVjdCAhPSBudWxsICYmIHR5cGVvZiBtb2RpZmllci5lZmZlY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcImVmZmVjdFwiJywgJ1wiZnVuY3Rpb25cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmZuKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmVxdWlyZXMnOlxuICAgICAgICAgIGlmIChtb2RpZmllci5yZXF1aXJlcyAhPSBudWxsICYmICFBcnJheS5pc0FycmF5KG1vZGlmaWVyLnJlcXVpcmVzKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicmVxdWlyZXNcIicsICdcImFycmF5XCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5yZXF1aXJlcykgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JlcXVpcmVzSWZFeGlzdHMnOlxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicmVxdWlyZXNJZkV4aXN0c1wiJywgJ1wiYXJyYXlcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvcHRpb25zJzpcbiAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUG9wcGVySlM6IGFuIGludmFsaWQgcHJvcGVydHkgaGFzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIFxcXCJcIiArIG1vZGlmaWVyLm5hbWUgKyBcIlxcXCIgbW9kaWZpZXIsIHZhbGlkIHByb3BlcnRpZXMgYXJlIFwiICsgVkFMSURfUFJPUEVSVElFUy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXCJcIiArIHMgKyBcIlxcXCJcIjtcbiAgICAgICAgICB9KS5qb2luKCcsICcpICsgXCI7IGJ1dCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIHByb3ZpZGVkLlwiKTtcbiAgICAgIH1cblxuICAgICAgbW9kaWZpZXIucmVxdWlyZXMgJiYgbW9kaWZpZXIucmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWlyZW1lbnQpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICByZXR1cm4gbW9kLm5hbWUgPT09IHJlcXVpcmVtZW50O1xuICAgICAgICB9KSA9PSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SLCBTdHJpbmcobW9kaWZpZXIubmFtZSksIHJlcXVpcmVtZW50LCByZXF1aXJlbWVudCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59IiwiaW1wb3J0IHsgbWF4IGFzIG1hdGhNYXgsIG1pbiBhcyBtYXRoTWluIH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIG1hdGhNYXgobWluLCBtYXRoTWluKHZhbHVlLCBtYXgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5NYXhDbGFtcChtaW4sIHZhbHVlLCBtYXgpIHtcbiAgdmFyIHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcbiAgcmV0dXJuIHYgPiBtYXggPyBtYXggOiB2O1xufSIsImltcG9ydCB7bGFzdEl0ZW1PZiwgc3RyaW5nVG9BcnJheSwgaXNJblJhbmdlfSBmcm9tICcuL2xpYi91dGlscy5qcyc7XG5pbXBvcnQge3RvZGF5fSBmcm9tICcuL2xpYi9kYXRlLmpzJztcbmltcG9ydCB7cGFyc2VEYXRlLCBmb3JtYXREYXRlfSBmcm9tICcuL2xpYi9kYXRlLWZvcm1hdC5qcyc7XG5pbXBvcnQge3JlZ2lzdGVyTGlzdGVuZXJzLCB1bnJlZ2lzdGVyTGlzdGVuZXJzfSBmcm9tICcuL2xpYi9ldmVudC5qcyc7XG5pbXBvcnQge2xvY2FsZXN9IGZyb20gJy4vaTE4bi9iYXNlLWxvY2FsZXMuanMnO1xuaW1wb3J0IGRlZmF1bHRPcHRpb25zIGZyb20gJy4vb3B0aW9ucy9kZWZhdWx0T3B0aW9ucy5qcyc7XG5pbXBvcnQgcHJvY2Vzc09wdGlvbnMgZnJvbSAnLi9vcHRpb25zL3Byb2Nlc3NPcHRpb25zLmpzJztcbmltcG9ydCBQaWNrZXIgZnJvbSAnLi9waWNrZXIvUGlja2VyLmpzJztcbmltcG9ydCB7dHJpZ2dlckRhdGVwaWNrZXJFdmVudH0gZnJvbSAnLi9ldmVudHMvZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7b25LZXlkb3duLCBvbkZvY3VzLCBvbk1vdXNlZG93biwgb25DbGlja0lucHV0LCBvblBhc3RlfSBmcm9tICcuL2V2ZW50cy9pbnB1dEZpZWxkTGlzdGVuZXJzLmpzJztcbmltcG9ydCB7b25DbGlja091dHNpZGV9IGZyb20gJy4vZXZlbnRzL290aGVyTGlzdGVuZXJzLmpzJztcblxuZnVuY3Rpb24gc3RyaW5naWZ5RGF0ZXMoZGF0ZXMsIGNvbmZpZykge1xuICByZXR1cm4gZGF0ZXNcbiAgICAubWFwKGR0ID0+IGZvcm1hdERhdGUoZHQsIGNvbmZpZy5mb3JtYXQsIGNvbmZpZy5sb2NhbGUpKVxuICAgIC5qb2luKGNvbmZpZy5kYXRlRGVsaW1pdGVyKTtcbn1cblxuLy8gcGFyc2UgaW5wdXQgZGF0ZXMgYW5kIGNyZWF0ZSBhbiBhcnJheSBvZiB0aW1lIHZhbHVlcyBmb3Igc2VsZWN0aW9uXG4vLyByZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgZGF0ZXMgaW4gaW5wdXREYXRlc1xuLy8gd2hlbiBvcmlnRGF0ZXMgKGN1cnJlbnQgc2VsZWN0aW9uKSBpcyBwYXNzZWQsIHRoZSBmdW5jdGlvbiB3b3JrcyB0byBtaXhcbi8vIHRoZSBpbnB1dCBkYXRlcyBpbnRvIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuZnVuY3Rpb24gcHJvY2Vzc0lucHV0RGF0ZXMoZGF0ZXBpY2tlciwgaW5wdXREYXRlcywgY2xlYXIgPSBmYWxzZSkge1xuICBjb25zdCB7Y29uZmlnLCBkYXRlczogb3JpZ0RhdGVzLCByYW5nZXBpY2tlcn0gPSBkYXRlcGlja2VyO1xuICBpZiAoaW5wdXREYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBlbXB0eSBpbnB1dCBpcyBjb25zaWRlcmVkIHZhbGlkIHVubGVzcyBvcmlnaURhdGVzIGlzIHBhc3NlZFxuICAgIHJldHVybiBjbGVhciA/IFtdIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgcmFuZ2VFbmQgPSByYW5nZXBpY2tlciAmJiBkYXRlcGlja2VyID09PSByYW5nZXBpY2tlci5kYXRlcGlja2Vyc1sxXTtcbiAgbGV0IG5ld0RhdGVzID0gaW5wdXREYXRlcy5yZWR1Y2UoKGRhdGVzLCBkdCkgPT4ge1xuICAgIGxldCBkYXRlID0gcGFyc2VEYXRlKGR0LCBjb25maWcuZm9ybWF0LCBjb25maWcubG9jYWxlKTtcbiAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfVxuICAgIGlmIChjb25maWcucGlja0xldmVsID4gMCkge1xuICAgICAgLy8gYWRqdXN0IHRvIDFzdCBvZiB0aGUgbW9udGgvSmFuIDFzdCBvZiB0aGUgeWVhclxuICAgICAgLy8gb3IgdG8gdGhlIGxhc3QgZGF5IG9mIHRoZSBtb25oL0RlYyAzMXN0IG9mIHRoZSB5ZWFyIGlmIHRoZSBkYXRlcGlja2VyXG4gICAgICAvLyBpcyB0aGUgcmFuZ2UtZW5kIHBpY2tlciBvZiBhIHJhbmdlcGlja2VyXG4gICAgICBjb25zdCBkdCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgaWYgKGNvbmZpZy5waWNrTGV2ZWwgPT09IDEpIHtcbiAgICAgICAgZGF0ZSA9IHJhbmdlRW5kXG4gICAgICAgICAgPyBkdC5zZXRNb250aChkdC5nZXRNb250aCgpICsgMSwgMClcbiAgICAgICAgICA6IGR0LnNldERhdGUoMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlID0gcmFuZ2VFbmRcbiAgICAgICAgICA/IGR0LnNldEZ1bGxZZWFyKGR0LmdldEZ1bGxZZWFyKCkgKyAxLCAwLCAwKVxuICAgICAgICAgIDogZHQuc2V0TW9udGgoMCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGlzSW5SYW5nZShkYXRlLCBjb25maWcubWluRGF0ZSwgY29uZmlnLm1heERhdGUpXG4gICAgICAmJiAhZGF0ZXMuaW5jbHVkZXMoZGF0ZSlcbiAgICAgICYmICFjb25maWcuZGF0ZXNEaXNhYmxlZC5pbmNsdWRlcyhkYXRlKVxuICAgICAgJiYgIWNvbmZpZy5kYXlzT2ZXZWVrRGlzYWJsZWQuaW5jbHVkZXMobmV3IERhdGUoZGF0ZSkuZ2V0RGF5KCkpXG4gICAgKSB7XG4gICAgICBkYXRlcy5wdXNoKGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZXM7XG4gIH0sIFtdKTtcbiAgaWYgKG5ld0RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY29uZmlnLm11bHRpZGF0ZSAmJiAhY2xlYXIpIHtcbiAgICAvLyBnZXQgdGhlIHN5bm1ldHJpYyBkaWZmZXJlbmNlIGJldHdlZW4gb3JpZ0RhdGVzIGFuZCBuZXdEYXRlc1xuICAgIG5ld0RhdGVzID0gbmV3RGF0ZXMucmVkdWNlKChkYXRlcywgZGF0ZSkgPT4ge1xuICAgICAgaWYgKCFvcmlnRGF0ZXMuaW5jbHVkZXMoZGF0ZSkpIHtcbiAgICAgICAgZGF0ZXMucHVzaChkYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlcztcbiAgICB9LCBvcmlnRGF0ZXMuZmlsdGVyKGRhdGUgPT4gIW5ld0RhdGVzLmluY2x1ZGVzKGRhdGUpKSk7XG4gIH1cbiAgLy8gZG8gbGVuZ3RoIGNoZWNrIGFsd2F5cyBiZWNhdXNlIHVzZXIgY2FuIGlucHV0IG11bHRpcGxlIGRhdGVzIHJlZ2FyZGxlc3Mgb2YgdGhlIG1vZGVcbiAgcmV0dXJuIGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzICYmIG5ld0RhdGVzLmxlbmd0aCA+IGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzXG4gICAgPyBuZXdEYXRlcy5zbGljZShjb25maWcubWF4TnVtYmVyT2ZEYXRlcyAqIC0xKVxuICAgIDogbmV3RGF0ZXM7XG59XG5cbi8vIHJlZnJlc2ggdGhlIFVJIGVsZW1lbnRzXG4vLyBtb2RlczogMTogaW5wdXQgb25seSwgMiwgcGlja2VyIG9ubHksIDMgYm90aFxuZnVuY3Rpb24gcmVmcmVzaFVJKGRhdGVwaWNrZXIsIG1vZGUgPSAzLCBxdWlja1JlbmRlciA9IHRydWUpIHtcbiAgY29uc3Qge2NvbmZpZywgcGlja2VyLCBpbnB1dEZpZWxkfSA9IGRhdGVwaWNrZXI7XG4gIGlmIChtb2RlICYgMikge1xuICAgIGNvbnN0IG5ld1ZpZXcgPSBwaWNrZXIuYWN0aXZlID8gY29uZmlnLnBpY2tMZXZlbCA6IGNvbmZpZy5zdGFydFZpZXc7XG4gICAgcGlja2VyLnVwZGF0ZSgpLmNoYW5nZVZpZXcobmV3VmlldykucmVuZGVyKHF1aWNrUmVuZGVyKTtcbiAgfVxuICBpZiAobW9kZSAmIDEgJiYgaW5wdXRGaWVsZCkge1xuICAgIGlucHV0RmllbGQudmFsdWUgPSBzdHJpbmdpZnlEYXRlcyhkYXRlcGlja2VyLmRhdGVzLCBjb25maWcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldERhdGUoZGF0ZXBpY2tlciwgaW5wdXREYXRlcywgb3B0aW9ucykge1xuICBsZXQge2NsZWFyLCByZW5kZXIsIGF1dG9oaWRlfSA9IG9wdGlvbnM7XG4gIGlmIChyZW5kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlbmRlciA9IHRydWU7XG4gIH1cbiAgaWYgKCFyZW5kZXIpIHtcbiAgICBhdXRvaGlkZSA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGF1dG9oaWRlID09PSB1bmRlZmluZWQpIHtcbiAgICBhdXRvaGlkZSA9IGRhdGVwaWNrZXIuY29uZmlnLmF1dG9oaWRlO1xuICB9XG5cbiAgY29uc3QgbmV3RGF0ZXMgPSBwcm9jZXNzSW5wdXREYXRlcyhkYXRlcGlja2VyLCBpbnB1dERhdGVzLCBjbGVhcik7XG4gIGlmICghbmV3RGF0ZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG5ld0RhdGVzLnRvU3RyaW5nKCkgIT09IGRhdGVwaWNrZXIuZGF0ZXMudG9TdHJpbmcoKSkge1xuICAgIGRhdGVwaWNrZXIuZGF0ZXMgPSBuZXdEYXRlcztcbiAgICByZWZyZXNoVUkoZGF0ZXBpY2tlciwgcmVuZGVyID8gMyA6IDEpO1xuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQoZGF0ZXBpY2tlciwgJ2NoYW5nZURhdGUnKTtcbiAgfSBlbHNlIHtcbiAgICByZWZyZXNoVUkoZGF0ZXBpY2tlciwgMSk7XG4gIH1cbiAgaWYgKGF1dG9oaWRlKSB7XG4gICAgZGF0ZXBpY2tlci5oaWRlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBkYXRlIHBpY2tlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRlcGlja2VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRhdGUgcGlja2VyXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgYSBkYXRlIHBpY2tlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAtIGNvbmZpZyBvcHRpb25zXG4gICAqIEBwYXJhbSAge0RhdGVSYW5nZVBpY2tlcn0gW3JhbmdlcGlja2VyXSAtIERhdGVSYW5nZVBpY2tlciBpbnN0YW5jZSB0aGVcbiAgICogZGF0ZSBwaWNrZXIgYmVsb25ncyB0by4gVXNlIHRoaXMgb25seSB3aGVuIGNyZWF0aW5nIGRhdGUgcGlja2VyIGFzIGEgcGFydFxuICAgKiBvZiBkYXRlIHJhbmdlIHBpY2tlclxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9LCByYW5nZXBpY2tlciA9IHVuZGVmaW5lZCkge1xuICAgIGVsZW1lbnQuZGF0ZXBpY2tlciA9IHRoaXM7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblxuICAgIC8vIHNldCB1cCBjb25maWdcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYnV0dG9uQ2xhc3M6IChvcHRpb25zLmJ1dHRvbkNsYXNzICYmIFN0cmluZyhvcHRpb25zLmJ1dHRvbkNsYXNzKSkgfHwgJ2J1dHRvbicsXG4gICAgICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICBkZWZhdWx0Vmlld0RhdGU6IHRvZGF5KCksXG4gICAgICBtYXhEYXRlOiB1bmRlZmluZWQsXG4gICAgICBtaW5EYXRlOiB1bmRlZmluZWQsXG4gICAgfSwgcHJvY2Vzc09wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIHRoaXMpKTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgcHJvY2Vzc09wdGlvbnMob3B0aW9ucywgdGhpcykpO1xuXG4gICAgLy8gY29uZmlndXJlIGJ5IHR5cGVcbiAgICBjb25zdCBpbmxpbmUgPSB0aGlzLmlubGluZSA9IGVsZW1lbnQudGFnTmFtZSAhPT0gJ0lOUFVUJztcbiAgICBsZXQgaW5wdXRGaWVsZDtcbiAgICBsZXQgaW5pdGlhbERhdGVzO1xuXG4gICAgaWYgKGlubGluZSkge1xuICAgICAgY29uZmlnLmNvbnRhaW5lciA9IGVsZW1lbnQ7XG4gICAgICBpbml0aWFsRGF0ZXMgPSBzdHJpbmdUb0FycmF5KGVsZW1lbnQuZGF0YXNldC5kYXRlLCBjb25maWcuZGF0ZURlbGltaXRlcik7XG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LmRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25zLmNvbnRhaW5lcikgOiBudWxsO1xuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBjb25maWcuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgfVxuICAgICAgaW5wdXRGaWVsZCA9IHRoaXMuaW5wdXRGaWVsZCA9IGVsZW1lbnQ7XG4gICAgICBpbnB1dEZpZWxkLmNsYXNzTGlzdC5hZGQoJ2RhdGVwaWNrZXItaW5wdXQnKTtcbiAgICAgIGluaXRpYWxEYXRlcyA9IHN0cmluZ1RvQXJyYXkoaW5wdXRGaWVsZC52YWx1ZSwgY29uZmlnLmRhdGVEZWxpbWl0ZXIpO1xuICAgIH1cbiAgICBpZiAocmFuZ2VwaWNrZXIpIHtcbiAgICAgIC8vIGNoZWNrIHZhbGlkaXJ5XG4gICAgICBjb25zdCBpbmRleCA9IHJhbmdlcGlja2VyLmlucHV0cy5pbmRleE9mKGlucHV0RmllbGQpO1xuICAgICAgY29uc3QgZGF0ZXBpY2tlcnMgPSByYW5nZXBpY2tlci5kYXRlcGlja2VycztcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiAxIHx8ICFBcnJheS5pc0FycmF5KGRhdGVwaWNrZXJzKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByYW5nZXBpY2tlciBvYmplY3QuJyk7XG4gICAgICB9XG4gICAgICAvLyBhdHRhY2ggaXRhZWxmIHRvIHRoZSByYW5nZXBpY2tlciBoZXJlIHNvIHRoYXQgcHJvY2Vzc0lucHV0RGF0ZXMoKSBjYW5cbiAgICAgIC8vIGRldGVybWluZSBpZiB0aGlzIGlzIHRoZSByYW5nZS1lbmQgcGlja2VyIG9mIHRoZSByYW5nZXBpY2tlciB3aGlsZVxuICAgICAgLy8gc2V0dGluZyBpbml0YWwgdmFsdWVzIHdoZW4gcGlja0xldmVsID4gMFxuICAgICAgZGF0ZXBpY2tlcnNbaW5kZXhdID0gdGhpcztcbiAgICAgIC8vIGFkZCBnZXR0ZXIgZm9yIHJhbmdlcGlja2VyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JhbmdlcGlja2VyJywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlcGlja2VyO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGluaXRpYWwgZGF0ZXNcbiAgICB0aGlzLmRhdGVzID0gW107XG4gICAgLy8gcHJvY2VzcyBpbml0aWFsIHZhbHVlXG4gICAgY29uc3QgaW5wdXREYXRlVmFsdWVzID0gcHJvY2Vzc0lucHV0RGF0ZXModGhpcywgaW5pdGlhbERhdGVzKTtcbiAgICBpZiAoaW5wdXREYXRlVmFsdWVzICYmIGlucHV0RGF0ZVZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmRhdGVzID0gaW5wdXREYXRlVmFsdWVzO1xuICAgIH1cbiAgICBpZiAoaW5wdXRGaWVsZCkge1xuICAgICAgaW5wdXRGaWVsZC52YWx1ZSA9IHN0cmluZ2lmeURhdGVzKHRoaXMuZGF0ZXMsIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGlja2VyID0gdGhpcy5waWNrZXIgPSBuZXcgUGlja2VyKHRoaXMpO1xuXG4gICAgaWYgKGlubGluZSkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNldCB1cCBldmVudCBsaXN0ZW5lcnMgaW4gb3RoZXIgbW9kZXNcbiAgICAgIGNvbnN0IG9uTW91c2Vkb3duRG9jdW1lbnQgPSBvbkNsaWNrT3V0c2lkZS5iaW5kKG51bGwsIHRoaXMpO1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gW1xuICAgICAgICBbaW5wdXRGaWVsZCwgJ2tleWRvd24nLCBvbktleWRvd24uYmluZChudWxsLCB0aGlzKV0sXG4gICAgICAgIFtpbnB1dEZpZWxkLCAnZm9jdXMnLCBvbkZvY3VzLmJpbmQobnVsbCwgdGhpcyldLFxuICAgICAgICBbaW5wdXRGaWVsZCwgJ21vdXNlZG93bicsIG9uTW91c2Vkb3duLmJpbmQobnVsbCwgdGhpcyldLFxuICAgICAgICBbaW5wdXRGaWVsZCwgJ2NsaWNrJywgb25DbGlja0lucHV0LmJpbmQobnVsbCwgdGhpcyldLFxuICAgICAgICBbaW5wdXRGaWVsZCwgJ3Bhc3RlJywgb25QYXN0ZS5iaW5kKG51bGwsIHRoaXMpXSxcbiAgICAgICAgW2RvY3VtZW50LCAnbW91c2Vkb3duJywgb25Nb3VzZWRvd25Eb2N1bWVudF0sXG4gICAgICAgIFtkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBvbk1vdXNlZG93bkRvY3VtZW50XSxcbiAgICAgICAgW3dpbmRvdywgJ3Jlc2l6ZScsIHBpY2tlci5wbGFjZS5iaW5kKHBpY2tlcildXG4gICAgICBdO1xuICAgICAgcmVnaXN0ZXJMaXN0ZW5lcnModGhpcywgbGlzdGVuZXJzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0IERhdGUgb2JqZWN0IG9yIHRpbWUgdmFsdWUgaW4gZ2l2ZW4gZm9ybWF0IGFuZCBsYW5ndWFnZVxuICAgKiBAcGFyYW0gIHtEYXRlfE51bWJlcn0gZGF0ZSAtIGRhdGUgb3IgdGltZSB2YWx1ZSB0byBmb3JtYXRcbiAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gZm9ybWF0IC0gZm9ybWF0IHN0cmluZyBvciBvYmplY3QgdGhhdCBjb250YWluc1xuICAgKiB0b0Rpc3BsYXkoKSBjdXN0b20gZm9ybWF0dGVyLCB3aG9zZSBzaWduYXR1cmUgaXNcbiAgICogLSBhcmdzOlxuICAgKiAgIC0gZGF0ZToge0RhdGV9IC0gRGF0ZSBpbnN0YW5jZSBvZiB0aGUgZGF0ZSBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICAgKiAgIC0gZm9ybWF0OiB7T2JqZWN0fSAtIHRoZSBmb3JtYXQgb2JqZWN0IHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gICAqICAgLSBsb2NhbGU6IHtPYmplY3R9IC0gbG9jYWxlIGZvciB0aGUgbGFuZ3VhZ2Ugc3BlY2lmaWVkIGJ5IGBsYW5nYFxuICAgKiAtIHJldHVybjpcbiAgICogICAgIHtTdHJpbmd9IGZvcm1hdHRlZCBkYXRlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW2xhbmc9ZW5dIC0gbGFuZ3VhZ2UgY29kZSBmb3IgdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgZGF0ZVxuICAgKi9cbiAgc3RhdGljIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBsYW5nKSB7XG4gICAgcmV0dXJuIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBsYW5nICYmIGxvY2FsZXNbbGFuZ10gfHwgbG9jYWxlcy5lbik7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgZGF0ZSBzdHJpbmdcbiAgICogQHBhcmFtICB7U3RyaW5nfERhdGV8TnVtYmVyfSBkYXRlU3RyIC0gZGF0ZSBzdHJpbmcsIERhdGUgb2JqZWN0IG9yIHRpbWVcbiAgICogdmFsdWUgdG8gcGFyc2VcbiAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gZm9ybWF0IC0gZm9ybWF0IHN0cmluZyBvciBvYmplY3QgdGhhdCBjb250YWluc1xuICAgKiB0b1ZhbHVlKCkgY3VzdG9tIHBhcnNlciwgd2hvc2Ugc2lnbmF0dXJlIGlzXG4gICAqIC0gYXJnczpcbiAgICogICAtIGRhdGVTdHI6IHtTdHJpbmd8RGF0ZXxOdW1iZXJ9IC0gdGhlIGRhdGVTdHIgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICogICAtIGZvcm1hdDoge09iamVjdH0gLSB0aGUgZm9ybWF0IG9iamVjdCBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICAgKiAgIC0gbG9jYWxlOiB7T2JqZWN0fSAtIGxvY2FsZSBmb3IgdGhlIGxhbmd1YWdlIHNwZWNpZmllZCBieSBgbGFuZ2BcbiAgICogLSByZXR1cm46XG4gICAqICAgICB7RGF0ZXxOdW1iZXJ9IHBhcnNlZCBkYXRlIG9yIGl0cyB0aW1lIHZhbHVlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW2xhbmc9ZW5dIC0gbGFuZ3VhZ2UgY29kZSBmb3IgdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHJldHVybiB7TnVtYmVyfSB0aW1lIHZhbHVlIG9mIHBhcnNlZCBkYXRlXG4gICAqL1xuICBzdGF0aWMgcGFyc2VEYXRlKGRhdGVTdHIsIGZvcm1hdCwgbGFuZykge1xuICAgIHJldHVybiBwYXJzZURhdGUoZGF0ZVN0ciwgZm9ybWF0LCBsYW5nICYmIGxvY2FsZXNbbGFuZ10gfHwgbG9jYWxlcy5lbik7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge09iamVjdH0gLSBJbnN0YWxsZWQgbG9jYWxlcyBpbiBgW2xhbmd1YWdlQ29kZV06IGxvY2FsZU9iamVjdGAgZm9ybWF0XG4gICAqIGVuYDpfRW5nbGlzaCAoVVMpXyBpcyBwcmUtaW5zdGFsbGVkLlxuICAgKi9cbiAgc3RhdGljIGdldCBsb2NhbGVzKCkge1xuICAgIHJldHVybiBsb2NhbGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufSAtIFdoZXRoZXIgdGhlIHBpY2tlciBlbGVtZW50IGlzIHNob3duLiBgdHJ1ZWAgd2huZSBzaG93blxuICAgKi9cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gISEodGhpcy5waWNrZXIgJiYgdGhpcy5waWNrZXIuYWN0aXZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9IC0gRE9NIG9iamVjdCBvZiBwaWNrZXIgZWxlbWVudFxuICAgKi9cbiAgZ2V0IHBpY2tlckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGlja2VyID8gdGhpcy5waWNrZXIuZWxlbWVudCA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IHZhbHVlcyB0byB0aGUgY29uZmlnIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWcgb3B0aW9ucyB0byB1cGRhdGVcbiAgICovXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHBpY2tlciA9IHRoaXMucGlja2VyO1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucyhvcHRpb25zLCB0aGlzKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIG5ld09wdGlvbnMpO1xuICAgIHBpY2tlci5zZXRPcHRpb25zKG5ld09wdGlvbnMpO1xuXG4gICAgcmVmcmVzaFVJKHRoaXMsIDMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIHBpY2tlciBlbGVtZW50XG4gICAqL1xuICBzaG93KCkge1xuICAgIGlmICh0aGlzLmlucHV0RmllbGQpIHtcbiAgICAgIGlmICh0aGlzLmlucHV0RmllbGQuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaW5wdXRGaWVsZCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9zaG93aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmZvY3VzKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zaG93aW5nO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBpY2tlci5zaG93KCk7XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgcGlja2VyIGVsZW1lbnRcbiAgICogTm90IGF2YWlsYWJsZSBvbiBpbmxpbmUgcGlja2VyXG4gICAqL1xuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBpY2tlci5oaWRlKCk7XG4gICAgdGhpcy5waWNrZXIudXBkYXRlKCkuY2hhbmdlVmlldyh0aGlzLmNvbmZpZy5zdGFydFZpZXcpLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIERhdGVwaWNrZXIgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGV0ZXBpY2tlcn0gLSB0aGUgaW5zdGFuY2UgZGVzdHJveWVkXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuaGlkZSgpO1xuICAgIHVucmVnaXN0ZXJMaXN0ZW5lcnModGhpcyk7XG4gICAgdGhpcy5waWNrZXIuZGV0YWNoKCk7XG4gICAgaWYgKCF0aGlzLmlubGluZSkge1xuICAgICAgdGhpcy5pbnB1dEZpZWxkLmNsYXNzTGlzdC5yZW1vdmUoJ2RhdGVwaWNrZXItaW5wdXQnKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRlcGlja2VyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2VsZWN0ZWQgZGF0ZShzKVxuICAgKlxuICAgKiBUaGUgbWV0aG9kIHJldHVybnMgYSBEYXRlIG9iamVjdCBvZiBzZWxlY3RlZCBkYXRlIGJ5IGRlZmF1bHQsIGFuZCByZXR1cm5zXG4gICAqIGFuIGFycmF5IG9mIHNlbGVjdGVkIGRhdGVzIGluIG11bHRpZGF0ZSBtb2RlLiBJZiBmb3JtYXQgc3RyaW5nIGlzIHBhc3NlZCxcbiAgICogaXQgcmV0dXJucyBkYXRlIHN0cmluZyhzKSBmb3JtYXR0ZWQgaW4gZ2l2ZW4gZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtmb3JtYXRdIC0gRm9ybWF0IHN0cmluZyB0byBzdHJpbmdpZnkgdGhlIGRhdGUocylcbiAgICogQHJldHVybiB7RGF0ZXxTdHJpbmd8RGF0ZVtdfFN0cmluZ1tdfSAtIHNlbGVjdGVkIGRhdGUocyksIG9yIGlmIG5vbmUgaXNcbiAgICogc2VsZWN0ZWQsIGVtcHR5IGFycmF5IGluIG11bHRpZGF0ZSBtb2RlIGFuZCB1bnRpdGxlZCBpbiBzaWdsZWRhdGUgbW9kZVxuICAgKi9cbiAgZ2V0RGF0ZShmb3JtYXQgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IGZvcm1hdFxuICAgICAgPyBkYXRlID0+IGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLmNvbmZpZy5sb2NhbGUpXG4gICAgICA6IGRhdGUgPT4gbmV3IERhdGUoZGF0ZSk7XG5cbiAgICBpZiAodGhpcy5jb25maWcubXVsdGlkYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRlcy5tYXAoY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5kYXRlc1swXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RlZCBkYXRlKHMpXG4gICAqXG4gICAqIEluIG11bHRpZGF0ZSBtb2RlLCB5b3UgY2FuIHBhc3MgbXVsdGlwbGUgZGF0ZXMgYXMgYSBzZXJpZXMgb2YgYXJndW1lbnRzXG4gICAqIG9yIGFuIGFycmF5LiAoU2luY2UgZWFjaCBkYXRlIGlzIHBhcnNlZCBpbmRpdmlkdWFsbHksIHRoZSB0eXBlIG9mIHRoZVxuICAgKiBkYXRlcyBkb2Vzbid0IGhhdmUgdG8gYmUgdGhlIHNhbWUuKVxuICAgKiBUaGUgZ2l2ZW4gZGF0ZXMgYXJlIHVzZWQgdG8gdG9nZ2xlIHRoZSBzZWxlY3Qgc3RhdHVzIG9mIGVhY2ggZGF0ZS4gVGhlXG4gICAqIG51bWJlciBvZiBzZWxlY3RlZCBkYXRlcyBpcyBrZXB0IGZyb20gZXhjZWVkaW5nIHRoZSBsZW5ndGggc2V0IHRvXG4gICAqIG1heE51bWJlck9mRGF0ZXMuXG4gICAqXG4gICAqIFdpdGggY2xlYXI6IHRydWUgb3B0aW9uLCB0aGUgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGNsZWFyIHRoZSBzZWxlY3Rpb25cbiAgICogYW5kIHRvIHJlcGxhY2UgdGhlIHNlbGVjdGlvbiBpbnN0ZWFkIG9mIHRvZ2dsaW5nIGluIG11bHRpZGF0ZSBtb2RlLlxuICAgKiBJZiB0aGUgb3B0aW9uIGlzIHBhc3NlZCB3aXRoIG5vIGRhdGUgYXJndW1lbnRzIG9yIGFuIGVtcHR5IGRhdGVzIGFycmF5LFxuICAgKiBpdCB3b3JrcyBhcyBcImNsZWFyXCIgKGNsZWFyIHRoZSBzZWxlY3Rpb24gdGhlbiBzZXQgbm90aGluZyksIGFuZCBpZiB0aGVcbiAgICogb3B0aW9uIGlzIHBhc3NlZCB3aXRoIG5ldyBkYXRlcyB0byBzZWxlY3QsIGl0IHdvcmtzIGFzIFwicmVwbGFjZVwiIChjbGVhclxuICAgKiB0aGUgc2VsZWN0aW9uIHRoZW4gc2V0IHRoZSBnaXZlbiBkYXRlcylcbiAgICpcbiAgICogV2hlbiByZW5kZXI6IGZhbHNlIG9wdGlvbiBpcyB1c2VkLCB0aGUgbWV0aG9kIG9taXRzIHJlLXJlbmRlcmluZyB0aGVcbiAgICogcGlja2VyIGVsZW1lbnQuIEluIHRoaXMgY2FzZSwgeW91IG5lZWQgdG8gY2FsbCByZWZyZXNoKCkgbWV0aG9kIGxhdGVyIGluXG4gICAqIG9yZGVyIGZvciB0aGUgcGlja2VyIGVsZW1lbnQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlcy4gVGhlIGlucHV0IGZpZWxkIGlzXG4gICAqIHJlZnJlc2hlZCBhbHdheXMgcmVnYXJkbGVzcyBvZiB0aGlzIG9wdGlvbi5cbiAgICpcbiAgICogV2hlbiBpbnZhbGlkICh1bnBhcnNhYmxlLCByZXBlYXRlZCwgZGlzYWJsZWQgb3Igb3V0LW9mLXJhbmdlKSBkYXRlcyBhcmVcbiAgICogcGFzc2VkLCB0aGUgbWV0aG9kIGlnbm9yZXMgdGhlbSBhbmQgYXBwbGllcyBvbmx5IHZhbGlkIG9uZXMuIEluIHRoZSBjYXNlXG4gICAqIHRoYXQgYWxsIHRoZSBnaXZlbiBkYXRlcyBhcmUgaW52YWxpZCwgd2hpY2ggaXMgZGlzdGluZ3Vpc2hlZCBmcm9tIHBhc3NpbmdcbiAgICogbm8gZGF0ZXMsIHRoZSBtZXRob2QgY29uc2lkZXJzIGl0IGFzIGFuIGVycm9yIGFuZCBsZWF2ZXMgdGhlIHNlbGVjdGlvblxuICAgKiB1bnRvdWNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uKERhdGV8TnVtYmVyfFN0cmluZyl8QXJyYXl9IFtkYXRlc10gLSBEYXRlIHN0cmluZ3MsIERhdGVcbiAgICogb2JqZWN0cywgdGltZSB2YWx1ZXMgb3IgbWl4IG9mIHRob3NlIGZvciBuZXcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXG4gICAqIC0gY2xlYXI6IHtib29sZWFufSAtIFdoZXRoZXIgdG8gY2xlYXIgdGhlIGV4aXN0aW5nIHNlbGVjdGlvblxuICAgKiAgICAgZGVmdWFsdDogZmFsc2VcbiAgICogLSByZW5kZXI6IHtib29sZWFufSAtIFdoZXRoZXIgdG8gcmUtcmVuZGVyIHRoZSBwaWNrZXIgZWxlbWVudFxuICAgKiAgICAgZGVmYXVsdDogdHJ1ZVxuICAgKiAtIGF1dG9oaWRlOiB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRvIGhpZGUgdGhlIHBpY2tlciBlbGVtZW50IGFmdGVyIHJlLXJlbmRlclxuICAgKiAgICAgSWdub3JlZCB3aGVuIHVzZWQgd2l0aCByZW5kZXI6IGZhbHNlXG4gICAqICAgICBkZWZhdWx0OiBjb25maWcuYXV0b2hpZGVcbiAgICovXG4gIHNldERhdGUoLi4uYXJncykge1xuICAgIGNvbnN0IGRhdGVzID0gWy4uLmFyZ3NdO1xuICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICBjb25zdCBsYXN0QXJnID0gbGFzdEl0ZW1PZihhcmdzKTtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbGFzdEFyZyA9PT0gJ29iamVjdCdcbiAgICAgICYmICFBcnJheS5pc0FycmF5KGxhc3RBcmcpXG4gICAgICAmJiAhKGxhc3RBcmcgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgJiYgbGFzdEFyZ1xuICAgICkge1xuICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCBkYXRlcy5wb3AoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXREYXRlcyA9IEFycmF5LmlzQXJyYXkoZGF0ZXNbMF0pID8gZGF0ZXNbMF0gOiBkYXRlcztcbiAgICBzZXREYXRlKHRoaXMsIGlucHV0RGF0ZXMsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2VsZWN0ZWQgZGF0ZShzKSB3aXRoIGlucHV0IGZpZWxkJ3MgdmFsdWVcbiAgICogTm90IGF2YWlsYWJsZSBvbiBpbmxpbmUgcGlja2VyXG4gICAqXG4gICAqIFRoZSBpbnB1dCBmaWVsZCB3aWxsIGJlIHJlZnJlc2hlZCB3aXRoIHByb3Blcmx5IGZvcm1hdHRlZCBkYXRlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXG4gICAqIC0gYXV0b2hpZGU6IHtib29sZWFufSAtIHdoZXRoZXIgdG8gaGlkZSB0aGUgcGlja2VyIGVsZW1lbnQgYWZ0ZXIgcmVmcmVzaFxuICAgKiAgICAgZGVmYXVsdDogZmFsc2VcbiAgICovXG4gIHVwZGF0ZShvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHtjbGVhcjogdHJ1ZSwgYXV0b2hpZGU6ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5hdXRvaGlkZSl9O1xuICAgIGNvbnN0IGlucHV0RGF0ZXMgPSBzdHJpbmdUb0FycmF5KHRoaXMuaW5wdXRGaWVsZC52YWx1ZSwgdGhpcy5jb25maWcuZGF0ZURlbGltaXRlcik7XG4gICAgc2V0RGF0ZSh0aGlzLCBpbnB1dERhdGVzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBwaWNrZXIgZWxlbWVudCBhbmQgdGhlIGFzc29jaWF0ZWQgaW5wdXQgZmllbGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0YXJnZXRdIC0gdGFyZ2V0IGl0ZW0gd2hlbiByZWZyZXNoaW5nIG9uZSBpdGVtIG9ubHlcbiAgICogJ3BpY2tlcicgb3IgJ2lucHV0J1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZVJlbmRlcl0gLSB3aGV0aGVyIHRvIHJlLXJlbmRlciB0aGUgcGlja2VyIGVsZW1lbnRcbiAgICogcmVnYXJkbGVzcyBvZiBpdHMgc3RhdGUgaW5zdGVhZCBvZiBvcHRpbWl6ZWQgcmVmcmVzaFxuICAgKi9cbiAgcmVmcmVzaCh0YXJnZXQgPSB1bmRlZmluZWQsIGZvcmNlUmVuZGVyID0gZmFsc2UpIHtcbiAgICBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBmb3JjZVJlbmRlciA9IHRhcmdldDtcbiAgICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQgbW9kZTtcbiAgICBpZiAodGFyZ2V0ID09PSAncGlja2VyJykge1xuICAgICAgbW9kZSA9IDI7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgPT09ICdpbnB1dCcpIHtcbiAgICAgIG1vZGUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlID0gMztcbiAgICB9XG4gICAgcmVmcmVzaFVJKHRoaXMsIG1vZGUsICFmb3JjZVJlbmRlcik7XG4gIH1cblxuICAvKipcbiAgICogRW50ZXIgZWRpdCBtb2RlXG4gICAqIE5vdCBhdmFpbGFibGUgb24gaW5saW5lIHBpY2tlciBvciB3aGVuIHRoZSBwaWNrZXIgZWxlbWVudCBpcyBoaWRkZW5cbiAgICovXG4gIGVudGVyRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuaW5saW5lIHx8ICF0aGlzLnBpY2tlci5hY3RpdmUgfHwgdGhpcy5lZGl0TW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NMaXN0LmFkZCgnaW4tZWRpdCcsICdib3JkZXItYmx1ZS03MDAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGl0IGZyb20gZWRpdCBtb2RlXG4gICAqIE5vdCBhdmFpbGFibGUgb24gaW5saW5lIHBpY2tlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAtIGZ1bmN0aW9uIG9wdGlvbnNcbiAgICogLSB1cGRhdGU6IHtib29sZWFufSAtIHdoZXRoZXIgdG8gY2FsbCB1cGRhdGUoKSBhZnRlciBleGl0aW5nXG4gICAqICAgICBJZiBmYWxzZSwgaW5wdXQgZmllbGQgaXMgcmV2ZXJ0IHRvIHRoZSBleGlzdGluZyBzZWxlY3Rpb25cbiAgICogICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAqL1xuICBleGl0RWRpdE1vZGUob3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLmlubGluZSB8fCAhdGhpcy5lZGl0TW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7dXBkYXRlOiBmYWxzZX0sIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSB0aGlzLmVkaXRNb2RlO1xuICAgIHRoaXMuaW5wdXRGaWVsZC5jbGFzc0xpc3QucmVtb3ZlKCdpbi1lZGl0JywgJ2JvcmRlci1ibHVlLTcwMCcpO1xuICAgIGlmIChvcHRzLnVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGUob3B0cyk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge2xpbWl0VG9SYW5nZX0gZnJvbSAnLi4vbGliL3V0aWxzLmpzJztcbmltcG9ydCB7YWRkTW9udGhzLCBhZGRZZWFyc30gZnJvbSAnLi4vbGliL2RhdGUuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gdHJpZ2dlckRhdGVwaWNrZXJFdmVudChkYXRlcGlja2VyLCB0eXBlKSB7XG4gIGNvbnN0IGRldGFpbCA9IHtcbiAgICBkYXRlOiBkYXRlcGlja2VyLmdldERhdGUoKSxcbiAgICB2aWV3RGF0ZTogbmV3IERhdGUoZGF0ZXBpY2tlci5waWNrZXIudmlld0RhdGUpLFxuICAgIHZpZXdJZDogZGF0ZXBpY2tlci5waWNrZXIuY3VycmVudFZpZXcuaWQsXG4gICAgZGF0ZXBpY2tlcixcbiAgfTtcbiAgZGF0ZXBpY2tlci5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KHR5cGUsIHtkZXRhaWx9KSk7XG59XG5cbi8vIGRpcmVjdGlvbjogLTEgKHRvIHByZXZpb3VzKSwgMSAodG8gbmV4dClcbmV4cG9ydCBmdW5jdGlvbiBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCBkaXJlY3Rpb24pIHtcbiAgY29uc3Qge21pbkRhdGUsIG1heERhdGV9ID0gZGF0ZXBpY2tlci5jb25maWc7XG4gIGNvbnN0IHtjdXJyZW50Vmlldywgdmlld0RhdGV9ID0gZGF0ZXBpY2tlci5waWNrZXI7XG4gIGxldCBuZXdWaWV3RGF0ZTtcbiAgc3dpdGNoIChjdXJyZW50Vmlldy5pZCkge1xuICAgIGNhc2UgMDpcbiAgICAgIG5ld1ZpZXdEYXRlID0gYWRkTW9udGhzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgbmV3Vmlld0RhdGUgPSBhZGRZZWFycyh2aWV3RGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBuZXdWaWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiBjdXJyZW50Vmlldy5uYXZTdGVwKTtcbiAgfVxuICBuZXdWaWV3RGF0ZSA9IGxpbWl0VG9SYW5nZShuZXdWaWV3RGF0ZSwgbWluRGF0ZSwgbWF4RGF0ZSk7XG4gIGRhdGVwaWNrZXIucGlja2VyLmNoYW5nZUZvY3VzKG5ld1ZpZXdEYXRlKS5yZW5kZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN3aXRjaFZpZXcoZGF0ZXBpY2tlcikge1xuICBjb25zdCB2aWV3SWQgPSBkYXRlcGlja2VyLnBpY2tlci5jdXJyZW50Vmlldy5pZDtcbiAgaWYgKHZpZXdJZCA9PT0gZGF0ZXBpY2tlci5jb25maWcubWF4Vmlldykge1xuICAgIHJldHVybjtcbiAgfVxuICBkYXRlcGlja2VyLnBpY2tlci5jaGFuZ2VWaWV3KHZpZXdJZCArIDEpLnJlbmRlcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5mb2N1cyhkYXRlcGlja2VyKSB7XG4gIGlmIChkYXRlcGlja2VyLmNvbmZpZy51cGRhdGVPbkJsdXIpIHtcbiAgICBkYXRlcGlja2VyLnVwZGF0ZSh7YXV0b2hpZGU6IHRydWV9KTtcbiAgfSBlbHNlIHtcbiAgICBkYXRlcGlja2VyLnJlZnJlc2goJ2lucHV0Jyk7XG4gICAgZGF0ZXBpY2tlci5oaWRlKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7aXNJblJhbmdlfSBmcm9tICcuLi9saWIvdXRpbHMuanMnO1xuaW1wb3J0IHthZGREYXlzLCBhZGRNb250aHMsIGFkZFllYXJzLCBzdGFydE9mWWVhclBlcmlvZH0gZnJvbSAnLi4vbGliL2RhdGUuanMnO1xuaW1wb3J0IHtnb1RvUHJldk9yTmV4dCwgc3dpdGNoVmlldywgdW5mb2N1c30gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuXG4vLyBGaW5kIHRoZSBjbG9zZXN0IGRhdGUgdGhhdCBkb2Vzbid0IG1lZXQgdGhlIGNvbmRpdGlvbiBmb3IgdW5hdmFpbGFibGUgZGF0ZVxuLy8gUmV0dXJucyB1bmRlZmluZWQgaWYgbm8gYXZhaWxhYmxlIGRhdGUgaXMgZm91bmRcbi8vIGFkZEZuOiBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIG5leHQgZGF0ZVxuLy8gICAtIGFyZ3M6IHRpbWUgdmFsdWUsIGFtb3VudFxuLy8gaW5jcmVhc2U6IGFtb3VudCB0byBwYXNzIHRvIGFkZEZuXG4vLyB0ZXN0Rm46IGZ1bmN0aW9uIHRvIHRlc3QgdGhlIHVuYXZhaWxhYmxpdHkgb2YgdGhlIGRhdGVcbi8vICAgLSBhcmdzOiB0aW1lIHZhbHVlOyByZXR1bjogdHJ1ZSBpZiB1bmF2YWlsYWJsZVxuZnVuY3Rpb24gZmluZE5leHRBdmFpbGFibGVPbmUoZGF0ZSwgYWRkRm4sIGluY3JlYXNlLCB0ZXN0Rm4sIG1pbiwgbWF4KSB7XG4gIGlmICghaXNJblJhbmdlKGRhdGUsIG1pbiwgbWF4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodGVzdEZuKGRhdGUpKSB7XG4gICAgY29uc3QgbmV3RGF0ZSA9IGFkZEZuKGRhdGUsIGluY3JlYXNlKTtcbiAgICByZXR1cm4gZmluZE5leHRBdmFpbGFibGVPbmUobmV3RGF0ZSwgYWRkRm4sIGluY3JlYXNlLCB0ZXN0Rm4sIG1pbiwgbWF4KTtcbiAgfVxuICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gZGlyZWN0aW9uOiAtMSAobGVmdC91cCksIDEgKHJpZ2h0L2Rvd24pXG4vLyB2ZXJ0aWNhbDogdHJ1ZSBmb3IgdXAvZG93biwgZmFsc2UgZm9yIGxlZnQvcmlnaHRcbmZ1bmN0aW9uIG1vdmVCeUFycm93S2V5KGRhdGVwaWNrZXIsIGV2LCBkaXJlY3Rpb24sIHZlcnRpY2FsKSB7XG4gIGNvbnN0IHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyO1xuICBjb25zdCBjdXJyZW50VmlldyA9IHBpY2tlci5jdXJyZW50VmlldztcbiAgY29uc3Qgc3RlcCA9IGN1cnJlbnRWaWV3LnN0ZXAgfHwgMTtcbiAgbGV0IHZpZXdEYXRlID0gcGlja2VyLnZpZXdEYXRlO1xuICBsZXQgYWRkRm47XG4gIGxldCB0ZXN0Rm47XG4gIHN3aXRjaCAoY3VycmVudFZpZXcuaWQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgdmlld0RhdGUgPSBhZGREYXlzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiA3KTtcbiAgICAgIH0gZWxzZSBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgIHZpZXdEYXRlID0gYWRkWWVhcnModmlld0RhdGUsIGRpcmVjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3RGF0ZSA9IGFkZERheXModmlld0RhdGUsIGRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgICBhZGRGbiA9IGFkZERheXM7XG4gICAgICB0ZXN0Rm4gPSAoZGF0ZSkgPT4gY3VycmVudFZpZXcuZGlzYWJsZWQuaW5jbHVkZXMoZGF0ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICB2aWV3RGF0ZSA9IGFkZE1vbnRocyh2aWV3RGF0ZSwgdmVydGljYWwgPyBkaXJlY3Rpb24gKiA0IDogZGlyZWN0aW9uKTtcbiAgICAgIGFkZEZuID0gYWRkTW9udGhzO1xuICAgICAgdGVzdEZuID0gKGRhdGUpID0+IHtcbiAgICAgICAgY29uc3QgZHQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgY29uc3Qge3llYXIsIGRpc2FibGVkfSA9IGN1cnJlbnRWaWV3O1xuICAgICAgICByZXR1cm4gZHQuZ2V0RnVsbFllYXIoKSA9PT0geWVhciAmJiBkaXNhYmxlZC5pbmNsdWRlcyhkdC5nZXRNb250aCgpKTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmlld0RhdGUgPSBhZGRZZWFycyh2aWV3RGF0ZSwgZGlyZWN0aW9uICogKHZlcnRpY2FsID8gNCA6IDEpICogc3RlcCk7XG4gICAgICBhZGRGbiA9IGFkZFllYXJzO1xuICAgICAgdGVzdEZuID0gZGF0ZSA9PiBjdXJyZW50Vmlldy5kaXNhYmxlZC5pbmNsdWRlcyhzdGFydE9mWWVhclBlcmlvZChkYXRlLCBzdGVwKSk7XG4gIH1cbiAgdmlld0RhdGUgPSBmaW5kTmV4dEF2YWlsYWJsZU9uZShcbiAgICB2aWV3RGF0ZSxcbiAgICBhZGRGbixcbiAgICBkaXJlY3Rpb24gPCAwID8gLXN0ZXAgOiBzdGVwLFxuICAgIHRlc3RGbixcbiAgICBjdXJyZW50Vmlldy5taW5EYXRlLFxuICAgIGN1cnJlbnRWaWV3Lm1heERhdGVcbiAgKTtcbiAgaWYgKHZpZXdEYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwaWNrZXIuY2hhbmdlRm9jdXModmlld0RhdGUpLnJlbmRlcigpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbktleWRvd24oZGF0ZXBpY2tlciwgZXYpIHtcbiAgaWYgKGV2LmtleSA9PT0gJ1RhYicpIHtcbiAgICB1bmZvY3VzKGRhdGVwaWNrZXIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyO1xuICBjb25zdCB7aWQsIGlzTWluVmlld30gPSBwaWNrZXIuY3VycmVudFZpZXc7XG4gIGlmICghcGlja2VyLmFjdGl2ZSkge1xuICAgIHN3aXRjaCAoZXYua2V5KSB7XG4gICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgcGlja2VyLnNob3coKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgIGRhdGVwaWNrZXIudXBkYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRlcGlja2VyLmVkaXRNb2RlKSB7XG4gICAgc3dpdGNoIChldi5rZXkpIHtcbiAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgIHBpY2tlci5oaWRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICBkYXRlcGlja2VyLmV4aXRFZGl0TW9kZSh7dXBkYXRlOiB0cnVlLCBhdXRvaGlkZTogZGF0ZXBpY2tlci5jb25maWcuYXV0b2hpZGV9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAoZXYua2V5KSB7XG4gICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICBwaWNrZXIuaGlkZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgIGlmIChldi5jdHJsS2V5IHx8IGV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCAtMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYuc2hpZnRLZXkpIHtcbiAgICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW92ZUJ5QXJyb3dLZXkoZGF0ZXBpY2tlciwgZXYsIC0xLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICAgIGdvVG9QcmV2T3JOZXh0KGRhdGVwaWNrZXIsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vdmVCeUFycm93S2V5KGRhdGVwaWNrZXIsIGV2LCAxLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICAgIHN3aXRjaFZpZXcoZGF0ZXBpY2tlcik7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYuc2hpZnRLZXkpIHtcbiAgICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW92ZUJ5QXJyb3dLZXkoZGF0ZXBpY2tlciwgZXYsIC0xLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgIGlmIChldi5zaGlmdEtleSAmJiAhZXYuY3RybEtleSAmJiAhZXYubWV0YUtleSkge1xuICAgICAgICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgMSwgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICBpZiAoaXNNaW5WaWV3KSB7XG4gICAgICAgICAgZGF0ZXBpY2tlci5zZXREYXRlKHBpY2tlci52aWV3RGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGlja2VyLmNoYW5nZVZpZXcoaWQgLSAxKS5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0JhY2tzcGFjZSc6XG4gICAgICBjYXNlICdEZWxldGUnOlxuICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGV2LmtleS5sZW5ndGggPT09IDEgJiYgIWV2LmN0cmxLZXkgJiYgIWV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25Gb2N1cyhkYXRlcGlja2VyKSB7XG4gIGlmIChkYXRlcGlja2VyLmNvbmZpZy5zaG93T25Gb2N1cyAmJiAhZGF0ZXBpY2tlci5fc2hvd2luZykge1xuICAgIGRhdGVwaWNrZXIuc2hvdygpO1xuICB9XG59XG5cbi8vIGZvciB0aGUgcHJldmVudGlvbiBmb3IgZW50ZXJpbmcgZWRpdCBtb2RlIHdoaWxlIGdldHRpbmcgZm9jdXMgb24gY2xpY2tcbmV4cG9ydCBmdW5jdGlvbiBvbk1vdXNlZG93bihkYXRlcGlja2VyLCBldikge1xuICBjb25zdCBlbCA9IGV2LnRhcmdldDtcbiAgaWYgKGRhdGVwaWNrZXIucGlja2VyLmFjdGl2ZSB8fCBkYXRlcGlja2VyLmNvbmZpZy5zaG93T25DbGljaykge1xuICAgIGVsLl9hY3RpdmUgPSBlbCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBlbC5fY2xpY2tpbmcgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRlbGV0ZSBlbC5fYWN0aXZlO1xuICAgICAgZGVsZXRlIGVsLl9jbGlja2luZztcbiAgICB9LCAyMDAwKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25DbGlja0lucHV0KGRhdGVwaWNrZXIsIGV2KSB7XG4gIGNvbnN0IGVsID0gZXYudGFyZ2V0O1xuICBpZiAoIWVsLl9jbGlja2luZykge1xuICAgIHJldHVybjtcbiAgfVxuICBjbGVhclRpbWVvdXQoZWwuX2NsaWNraW5nKTtcbiAgZGVsZXRlIGVsLl9jbGlja2luZztcblxuICBpZiAoZWwuX2FjdGl2ZSkge1xuICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICB9XG4gIGRlbGV0ZSBlbC5fYWN0aXZlO1xuXG4gIGlmIChkYXRlcGlja2VyLmNvbmZpZy5zaG93T25DbGljaykge1xuICAgIGRhdGVwaWNrZXIuc2hvdygpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblBhc3RlKGRhdGVwaWNrZXIsIGV2KSB7XG4gIGlmIChldi5jbGlwYm9hcmREYXRhLnR5cGVzLmluY2x1ZGVzKCd0ZXh0L3BsYWluJykpIHtcbiAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtmaW5kRWxlbWVudEluRXZlbnRQYXRofSBmcm9tICcuLi9saWIvZXZlbnQuanMnO1xuaW1wb3J0IHt1bmZvY3VzfSBmcm9tICcuL2Z1bmN0aW9ucy5qcyc7XG5cbi8vIGZvciB0aGUgYGRvY3VtZW50YCB0byBkZWxlZ2F0ZSB0aGUgZXZlbnRzIGZyb20gb3V0c2lkZSB0aGUgcGlja2VyL2lucHV0IGZpZWxkXG5leHBvcnQgZnVuY3Rpb24gb25DbGlja091dHNpZGUoZGF0ZXBpY2tlciwgZXYpIHtcbiAgY29uc3QgZWxlbWVudCA9IGRhdGVwaWNrZXIuZWxlbWVudDtcbiAgaWYgKGVsZW1lbnQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGlja2VyRWxlbSA9IGRhdGVwaWNrZXIucGlja2VyLmVsZW1lbnQ7XG4gIGlmIChmaW5kRWxlbWVudEluRXZlbnRQYXRoKGV2LCBlbCA9PiBlbCA9PT0gZWxlbWVudCB8fCBlbCA9PT0gcGlja2VyRWxlbSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdW5mb2N1cyhkYXRlcGlja2VyKTtcbn1cbiIsImltcG9ydCB7dG9kYXksIGFkZE1vbnRocywgYWRkWWVhcnN9IGZyb20gJy4uL2xpYi9kYXRlLmpzJztcbmltcG9ydCB7ZmluZEVsZW1lbnRJbkV2ZW50UGF0aH0gZnJvbSAnLi4vbGliL2V2ZW50LmpzJztcbmltcG9ydCB7Z29Ub1ByZXZPck5leHQsIHN3aXRjaFZpZXd9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcblxuZnVuY3Rpb24gZ29Ub1NlbGVjdGVkTW9udGhPclllYXIoZGF0ZXBpY2tlciwgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyO1xuICBjb25zdCB2aWV3RGF0ZSA9IG5ldyBEYXRlKHBpY2tlci52aWV3RGF0ZSk7XG4gIGNvbnN0IHZpZXdJZCA9IHBpY2tlci5jdXJyZW50Vmlldy5pZDtcbiAgY29uc3QgbmV3RGF0ZSA9IHZpZXdJZCA9PT0gMVxuICAgID8gYWRkTW9udGhzKHZpZXdEYXRlLCBzZWxlY3Rpb24gLSB2aWV3RGF0ZS5nZXRNb250aCgpKVxuICAgIDogYWRkWWVhcnModmlld0RhdGUsIHNlbGVjdGlvbiAtIHZpZXdEYXRlLmdldEZ1bGxZZWFyKCkpO1xuXG4gIHBpY2tlci5jaGFuZ2VGb2N1cyhuZXdEYXRlKS5jaGFuZ2VWaWV3KHZpZXdJZCAtIDEpLnJlbmRlcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25DbGlja1RvZGF5QnRuKGRhdGVwaWNrZXIpIHtcbiAgY29uc3QgcGlja2VyID0gZGF0ZXBpY2tlci5waWNrZXI7XG4gIGNvbnN0IGN1cnJlbnREYXRlID0gdG9kYXkoKTtcbiAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLnRvZGF5QnRuTW9kZSA9PT0gMSkge1xuICAgIGlmIChkYXRlcGlja2VyLmNvbmZpZy5hdXRvaGlkZSkge1xuICAgICAgZGF0ZXBpY2tlci5zZXREYXRlKGN1cnJlbnREYXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0ZXBpY2tlci5zZXREYXRlKGN1cnJlbnREYXRlLCB7cmVuZGVyOiBmYWxzZX0pO1xuICAgIHBpY2tlci51cGRhdGUoKTtcbiAgfVxuICBpZiAocGlja2VyLnZpZXdEYXRlICE9PSBjdXJyZW50RGF0ZSkge1xuICAgIHBpY2tlci5jaGFuZ2VGb2N1cyhjdXJyZW50RGF0ZSk7XG4gIH1cbiAgcGlja2VyLmNoYW5nZVZpZXcoMCkucmVuZGVyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkNsaWNrQ2xlYXJCdG4oZGF0ZXBpY2tlcikge1xuICBkYXRlcGlja2VyLnNldERhdGUoe2NsZWFyOiB0cnVlfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkNsaWNrVmlld1N3aXRjaChkYXRlcGlja2VyKSB7XG4gIHN3aXRjaFZpZXcoZGF0ZXBpY2tlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkNsaWNrUHJldkJ0bihkYXRlcGlja2VyKSB7XG4gIGdvVG9QcmV2T3JOZXh0KGRhdGVwaWNrZXIsIC0xKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uQ2xpY2tOZXh0QnRuKGRhdGVwaWNrZXIpIHtcbiAgZ29Ub1ByZXZPck5leHQoZGF0ZXBpY2tlciwgMSk7XG59XG5cbi8vIEZvciB0aGUgcGlja2VyJ3MgbWFpbiBibG9jayB0byBkZWxlZ2V0ZSB0aGUgZXZlbnRzIGZyb20gYGRhdGVwaWNrZXItY2VsbGBzXG5leHBvcnQgZnVuY3Rpb24gb25DbGlja1ZpZXcoZGF0ZXBpY2tlciwgZXYpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZmluZEVsZW1lbnRJbkV2ZW50UGF0aChldiwgJy5kYXRlcGlja2VyLWNlbGwnKTtcbiAgaWYgKCF0YXJnZXQgfHwgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtpZCwgaXNNaW5WaWV3fSA9IGRhdGVwaWNrZXIucGlja2VyLmN1cnJlbnRWaWV3O1xuICBpZiAoaXNNaW5WaWV3KSB7XG4gICAgZGF0ZXBpY2tlci5zZXREYXRlKE51bWJlcih0YXJnZXQuZGF0YXNldC5kYXRlKSk7XG4gIH0gZWxzZSBpZiAoaWQgPT09IDEpIHtcbiAgICBnb1RvU2VsZWN0ZWRNb250aE9yWWVhcihkYXRlcGlja2VyLCBOdW1iZXIodGFyZ2V0LmRhdGFzZXQubW9udGgpKTtcbiAgfSBlbHNlIHtcbiAgICBnb1RvU2VsZWN0ZWRNb250aE9yWWVhcihkYXRlcGlja2VyLCBOdW1iZXIodGFyZ2V0LmRhdGFzZXQueWVhcikpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkNsaWNrUGlja2VyKGRhdGVwaWNrZXIpIHtcbiAgaWYgKCFkYXRlcGlja2VyLmlubGluZSAmJiAhZGF0ZXBpY2tlci5jb25maWcuZGlzYWJsZVRvdWNoS2V5Ym9hcmQpIHtcbiAgICBkYXRlcGlja2VyLmlucHV0RmllbGQuZm9jdXMoKTtcbiAgfVxufVxuIiwiLy8gZGVmYXVsdCBsb2NhbGVzXG5leHBvcnQgY29uc3QgbG9jYWxlcyA9IHtcbiAgZW46IHtcbiAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgICBkYXlzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICBkYXlzTWluOiBbXCJTdVwiLCBcIk1vXCIsIFwiVHVcIiwgXCJXZVwiLCBcIlRoXCIsIFwiRnJcIiwgXCJTYVwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICAgIG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG4gICAgdG9kYXk6IFwiVG9kYXlcIixcbiAgICBjbGVhcjogXCJDbGVhclwiLFxuICAgIHRpdGxlRm9ybWF0OiBcIk1NIHlcIlxuICB9XG59O1xuIiwiaW1wb3J0IHtzdHJpcFRpbWUsIHRvZGF5fSBmcm9tICcuL2RhdGUuanMnO1xuaW1wb3J0IHtsYXN0SXRlbU9mfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLy8gcGF0dGVybiBmb3IgZm9ybWF0IHBhcnRzXG5leHBvcnQgY29uc3QgcmVGb3JtYXRUb2tlbnMgPSAvZGQ/fEREP3xtbT98TU0/fHl5Pyg/Onl5KT8vO1xuLy8gcGF0dGVybiBmb3Igbm9uIGRhdGUgcGFydHNcbmV4cG9ydCBjb25zdCByZU5vbkRhdGVQYXJ0cyA9IC9bXFxzIS0vOi1AWy1gey1+5bm05pyI5pelXSsvO1xuLy8gY2FjaGUgZm9yIHBlcnNlZCBmb3JtYXRzXG5sZXQga25vd25Gb3JtYXRzID0ge307XG4vLyBwYXJzZSBmdW50aW9ucyBmb3IgZGF0ZSBwYXJ0c1xuY29uc3QgcGFyc2VGbnMgPSB7XG4gIHkoZGF0ZSwgeWVhcikge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKS5zZXRGdWxsWWVhcihwYXJzZUludCh5ZWFyLCAxMCkpO1xuICB9LFxuICBtKGRhdGUsIG1vbnRoLCBsb2NhbGUpIHtcbiAgICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgbGV0IG1vbnRoSW5kZXggPSBwYXJzZUludChtb250aCwgMTApIC0gMTtcblxuICAgIGlmIChpc05hTihtb250aEluZGV4KSkge1xuICAgICAgaWYgKCFtb250aCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtb250aE5hbWUgPSBtb250aC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgY29tcGFyZU5hbWVzID0gbmFtZSA9PiBuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChtb250aE5hbWUpO1xuICAgICAgLy8gY29tcGFyZSB3aXRoIGJvdGggc2hvcnQgYW5kIGZ1bGwgbmFtZXMgYmVjYXVzZSBzb21lIGxvY2FsZXMgaGF2ZSBwZXJpb2RzXG4gICAgICAvLyBpbiB0aGUgc2hvcnQgbmFtZXMgKG5vdCBlcXVhbCB0byB0aGUgZmlyc3QgWCBsZXR0ZXJzIG9mIHRoZSBmdWxsIG5hbWVzKVxuICAgICAgbW9udGhJbmRleCA9IGxvY2FsZS5tb250aHNTaG9ydC5maW5kSW5kZXgoY29tcGFyZU5hbWVzKTtcbiAgICAgIGlmIChtb250aEluZGV4IDwgMCkge1xuICAgICAgICBtb250aEluZGV4ID0gbG9jYWxlLm1vbnRocy5maW5kSW5kZXgoY29tcGFyZU5hbWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb250aEluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld0RhdGUuc2V0TW9udGgobW9udGhJbmRleCk7XG4gICAgcmV0dXJuIG5ld0RhdGUuZ2V0TW9udGgoKSAhPT0gbm9ybWFsaXplTW9udGgobW9udGhJbmRleClcbiAgICAgID8gbmV3RGF0ZS5zZXREYXRlKDApXG4gICAgICA6IG5ld0RhdGUuZ2V0VGltZSgpO1xuICB9LFxuICBkKGRhdGUsIGRheSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKS5zZXREYXRlKHBhcnNlSW50KGRheSwgMTApKTtcbiAgfSxcbn07XG4vLyBmb3JtYXQgZnVuY3Rpb25zIGZvciBkYXRlIHBhcnRzXG5jb25zdCBmb3JtYXRGbnMgPSB7XG4gIGQoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldERhdGUoKTtcbiAgfSxcbiAgZGQoZGF0ZSkge1xuICAgIHJldHVybiBwYWRaZXJvKGRhdGUuZ2V0RGF0ZSgpLCAyKTtcbiAgfSxcbiAgRChkYXRlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLmRheXNTaG9ydFtkYXRlLmdldERheSgpXTtcbiAgfSxcbiAgREQoZGF0ZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5kYXlzW2RhdGUuZ2V0RGF5KCldO1xuICB9LFxuICBtKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgfSxcbiAgbW0oZGF0ZSkge1xuICAgIHJldHVybiBwYWRaZXJvKGRhdGUuZ2V0TW9udGgoKSArIDEsIDIpO1xuICB9LFxuICBNKGRhdGUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRbZGF0ZS5nZXRNb250aCgpXTtcbiAgfSxcbiAgTU0oZGF0ZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgfSxcbiAgeShkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfSxcbiAgeXkoZGF0ZSkge1xuICAgIHJldHVybiBwYWRaZXJvKGRhdGUuZ2V0RnVsbFllYXIoKSwgMikuc2xpY2UoLTIpO1xuICB9LFxuICB5eXl5KGRhdGUpIHtcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldEZ1bGxZZWFyKCksIDQpO1xuICB9LFxufTtcblxuLy8gZ2V0IG1vbnRoIGluZGV4IGluIG5vcm1hbCByYW5nZSAoMCAtIDExKSBmcm9tIGFueSBudW1iZXJcbmZ1bmN0aW9uIG5vcm1hbGl6ZU1vbnRoKG1vbnRoSW5kZXgpIHtcbiAgcmV0dXJuIG1vbnRoSW5kZXggPiAtMSA/IG1vbnRoSW5kZXggJSAxMiA6IG5vcm1hbGl6ZU1vbnRoKG1vbnRoSW5kZXggKyAxMik7XG59XG5cbmZ1bmN0aW9uIHBhZFplcm8obnVtLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG51bS50b1N0cmluZygpLnBhZFN0YXJ0KGxlbmd0aCwgJzAnKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0KSB7XG4gIGlmICh0eXBlb2YgZm9ybWF0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuICB9XG4gIGlmIChmb3JtYXQgaW4ga25vd25Gb3JtYXRzKSB7XG4gICAgcmV0dXJuIGtub3duRm9ybWF0c1tmb3JtYXRdO1xuICB9XG5cbiAgLy8gc3ByaXQgdGhlIGZvcm1hdCBzdHJpbmcgaW50byBwYXJ0cyBhbmQgc2VwcmF0b3JzXG4gIGNvbnN0IHNlcGFyYXRvcnMgPSBmb3JtYXQuc3BsaXQocmVGb3JtYXRUb2tlbnMpO1xuICBjb25zdCBwYXJ0cyA9IGZvcm1hdC5tYXRjaChuZXcgUmVnRXhwKHJlRm9ybWF0VG9rZW5zLCAnZycpKTtcbiAgaWYgKHNlcGFyYXRvcnMubGVuZ3RoID09PSAwIHx8ICFwYXJ0cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuICB9XG5cbiAgLy8gY29sbGVjdCBmb3JtYXQgZnVuY3Rpb25zIHVzZWQgaW4gdGhlIGZvcm1hdFxuICBjb25zdCBwYXJ0Rm9ybWF0dGVycyA9IHBhcnRzLm1hcCh0b2tlbiA9PiBmb3JtYXRGbnNbdG9rZW5dKTtcblxuICAvLyBjb2xsZWN0IHBhcnNlIGZ1bmN0aW9uIGtleXMgdXNlZCBpbiB0aGUgZm9ybWF0XG4gIC8vIGl0ZXJhdGUgb3ZlciBwYXJzZUZucycga2V5cyBpbiBvcmRlciB0byBrZWVwIHRoZSBvcmRlciBvZiB0aGUga2V5cy5cbiAgY29uc3QgcGFydFBhcnNlcktleXMgPSBPYmplY3Qua2V5cyhwYXJzZUZucykucmVkdWNlKChrZXlzLCBrZXkpID0+IHtcbiAgICBjb25zdCB0b2tlbiA9IHBhcnRzLmZpbmQocGFydCA9PiBwYXJ0WzBdICE9PSAnRCcgJiYgcGFydFswXS50b0xvd2VyQ2FzZSgpID09PSBrZXkpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIGtub3duRm9ybWF0c1tmb3JtYXRdID0ge1xuICAgIHBhcnNlcihkYXRlU3RyLCBsb2NhbGUpIHtcbiAgICAgIGNvbnN0IGRhdGVQYXJ0cyA9IGRhdGVTdHIuc3BsaXQocmVOb25EYXRlUGFydHMpLnJlZHVjZSgoZHRQYXJ0cywgcGFydCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKHBhcnQubGVuZ3RoID4gMCAmJiBwYXJ0c1tpbmRleF0pIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnRzW2luZGV4XVswXTtcbiAgICAgICAgICBpZiAodG9rZW4gPT09ICdNJykge1xuICAgICAgICAgICAgZHRQYXJ0cy5tID0gcGFydDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuICE9PSAnRCcpIHtcbiAgICAgICAgICAgIGR0UGFydHNbdG9rZW5dID0gcGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR0UGFydHM7XG4gICAgICB9LCB7fSk7XG5cbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXJ0UGFyc2Vya2V5cyBzbyB0aGF0IHRoZSBwYXJzaW5nIGlzIG1hZGUgaW4gdGhlIG9kZXJcbiAgICAgIC8vIG9mIHllYXIsIG1vbnRoIGFuZCBkYXkgdG8gcHJldmVudCB0aGUgZGF5IHBhcnNlciBmcm9tIGNvcnJlY3RpbmcgbGFzdFxuICAgICAgLy8gZGF5IG9mIG1vbnRoIHdyb25nbHlcbiAgICAgIHJldHVybiBwYXJ0UGFyc2VyS2V5cy5yZWR1Y2UoKG9yaWdEYXRlLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbmV3RGF0ZSA9IHBhcnNlRm5zW2tleV0ob3JpZ0RhdGUsIGRhdGVQYXJ0c1trZXldLCBsb2NhbGUpO1xuICAgICAgICAvLyBpbmdub3JlIHRoZSBwYXJ0IGZhaWxlZCB0byBwYXJzZVxuICAgICAgICByZXR1cm4gaXNOYU4obmV3RGF0ZSkgPyBvcmlnRGF0ZSA6IG5ld0RhdGU7XG4gICAgICB9LCB0b2RheSgpKTtcbiAgICB9LFxuICAgIGZvcm1hdHRlcihkYXRlLCBsb2NhbGUpIHtcbiAgICAgIGxldCBkYXRlU3RyID0gcGFydEZvcm1hdHRlcnMucmVkdWNlKChzdHIsIGZuLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gc3RyICs9IGAke3NlcGFyYXRvcnNbaW5kZXhdfSR7Zm4oZGF0ZSwgbG9jYWxlKX1gO1xuICAgICAgfSwgJycpO1xuICAgICAgLy8gc2VwYXJhdG9ycycgbGVuZ3RoIGlzIGFsd2F5cyBwYXJ0cycgbGVuZ3RoICsgMSxcbiAgICAgIHJldHVybiBkYXRlU3RyICs9IGxhc3RJdGVtT2Yoc2VwYXJhdG9ycyk7XG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlU3RyLCBmb3JtYXQsIGxvY2FsZSkge1xuICBpZiAoZGF0ZVN0ciBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGRhdGVTdHIgPT09ICdudW1iZXInKSB7XG4gICAgY29uc3QgZGF0ZSA9IHN0cmlwVGltZShkYXRlU3RyKTtcbiAgICByZXR1cm4gaXNOYU4oZGF0ZSkgPyB1bmRlZmluZWQgOiBkYXRlO1xuICB9XG4gIGlmICghZGF0ZVN0cikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGRhdGVTdHIgPT09ICd0b2RheScpIHtcbiAgICByZXR1cm4gdG9kYXkoKTtcbiAgfVxuXG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LnRvVmFsdWUpIHtcbiAgICBjb25zdCBkYXRlID0gZm9ybWF0LnRvVmFsdWUoZGF0ZVN0ciwgZm9ybWF0LCBsb2NhbGUpO1xuICAgIHJldHVybiBpc05hTihkYXRlKSA/IHVuZGVmaW5lZCA6IHN0cmlwVGltZShkYXRlKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUZvcm1hdFN0cmluZyhmb3JtYXQpLnBhcnNlcihkYXRlU3RyLCBsb2NhbGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIGxvY2FsZSkge1xuICBpZiAoaXNOYU4oZGF0ZSkgfHwgKCFkYXRlICYmIGRhdGUgIT09IDApKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgY29uc3QgZGF0ZU9iaiA9IHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJyA/IG5ldyBEYXRlKGRhdGUpIDogZGF0ZTtcblxuICBpZiAoZm9ybWF0LnRvRGlzcGxheSkge1xuICAgIHJldHVybiBmb3JtYXQudG9EaXNwbGF5KGRhdGVPYmosIGZvcm1hdCwgbG9jYWxlKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUZvcm1hdFN0cmluZyhmb3JtYXQpLmZvcm1hdHRlcihkYXRlT2JqLCBsb2NhbGUpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHN0cmlwVGltZSh0aW1lVmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVWYWx1ZSkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2RheSgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59XG5cbi8vIEdldCB0aGUgdGltZSB2YWx1ZSBvZiB0aGUgc3RhcnQgb2YgZ2l2ZW4gZGF0ZSBvciB5ZWFyLCBtb250aCBhbmQgZGF5XG5leHBvcnQgZnVuY3Rpb24gZGF0ZVZhbHVlKC4uLmFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB0b2RheSgpO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBzdHJpcFRpbWUoYXJnc1swXSk7XG4gIH1cblxuICAvLyB1c2Ugc2V0RnVsbFllYXIoKSB0byBrZWVwIDItZGlnaXQgeWVhciBmcm9tIGJlaW5nIG1hcHBlZCB0byAxOTAwLTE5OTlcbiAgY29uc3QgbmV3RGF0ZSA9IG5ldyBEYXRlKDApO1xuICBuZXdEYXRlLnNldEZ1bGxZZWFyKC4uLmFyZ3MpO1xuICByZXR1cm4gbmV3RGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZERheXMoZGF0ZSwgYW1vdW50KSB7XG4gIGNvbnN0IG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgcmV0dXJuIG5ld0RhdGUuc2V0RGF0ZShuZXdEYXRlLmdldERhdGUoKSArIGFtb3VudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRXZWVrcyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuIGFkZERheXMoZGF0ZSwgYW1vdW50ICogNyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRNb250aHMoZGF0ZSwgYW1vdW50KSB7XG4gIC8vIElmIHRoZSBkYXkgb2YgdGhlIGRhdGUgaXMgbm90IGluIHRoZSBuZXcgbW9udGgsIHRoZSBsYXN0IGRheSBvZiB0aGUgbmV3XG4gIC8vIG1vbnRoIHdpbGwgYmUgcmV0dXJuZWQuIGUuZy4gSmFuIDMxICsgMSBtb250aCDihpIgRmViIDI4IChub3QgTWFyIDAzKVxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIGNvbnN0IG1vbnRoc1RvU2V0ID0gbmV3RGF0ZS5nZXRNb250aCgpICsgYW1vdW50O1xuICBsZXQgZXhwZWN0ZWRNb250aCA9IG1vbnRoc1RvU2V0ICUgMTI7XG4gIGlmIChleHBlY3RlZE1vbnRoIDwgMCkge1xuICAgIGV4cGVjdGVkTW9udGggKz0gMTI7XG4gIH1cblxuICBjb25zdCB0aW1lID0gbmV3RGF0ZS5zZXRNb250aChtb250aHNUb1NldCk7XG4gIHJldHVybiBuZXdEYXRlLmdldE1vbnRoKCkgIT09IGV4cGVjdGVkTW9udGggPyBuZXdEYXRlLnNldERhdGUoMCkgOiB0aW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkWWVhcnMoZGF0ZSwgYW1vdW50KSB7XG4gIC8vIElmIHRoZSBkYXRlIGlzIEZlYiAyOSBhbmQgdGhlIG5ldyB5ZWFyIGlzIG5vdCBhIGxlYXAgeWVhciwgRmViIDI4IG9mIHRoZVxuICAvLyBuZXcgeWVhciB3aWxsIGJlIHJldHVybmVkLlxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIGNvbnN0IGV4cGVjdGVkTW9udGggPSBuZXdEYXRlLmdldE1vbnRoKCk7XG4gIGNvbnN0IHRpbWUgPSBuZXdEYXRlLnNldEZ1bGxZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSArIGFtb3VudCk7XG4gIHJldHVybiBleHBlY3RlZE1vbnRoID09PSAxICYmIG5ld0RhdGUuZ2V0TW9udGgoKSA9PT0gMiA/IG5ld0RhdGUuc2V0RGF0ZSgwKSA6IHRpbWU7XG59XG5cbi8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0dHdlbiAyIGRheXMgb2YgdGhlIHdlZWtcbmZ1bmN0aW9uIGRheURpZmYoZGF5LCBmcm9tKSB7XG4gIHJldHVybiAoZGF5IC0gZnJvbSArIDcpICUgNztcbn1cblxuLy8gR2V0IHRoZSBkYXRlIG9mIHRoZSBzcGVjaWZpZWQgZGF5IG9mIHRoZSB3ZWVrIG9mIGdpdmVuIGJhc2UgZGF0ZVxuZXhwb3J0IGZ1bmN0aW9uIGRheU9mVGhlV2Vla09mKGJhc2VEYXRlLCBkYXlPZldlZWssIHdlZWtTdGFydCA9IDApIHtcbiAgY29uc3QgYmFzZURheSA9IG5ldyBEYXRlKGJhc2VEYXRlKS5nZXREYXkoKTtcbiAgcmV0dXJuIGFkZERheXMoYmFzZURhdGUsIGRheURpZmYoZGF5T2ZXZWVrLCB3ZWVrU3RhcnQpIC0gZGF5RGlmZihiYXNlRGF5LCB3ZWVrU3RhcnQpKTtcbn1cblxuLy8gR2V0IHRoZSBJU08gd2VlayBvZiBhIGRhdGVcbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWVrKGRhdGUpIHtcbiAgLy8gc3RhcnQgb2YgSVNPIHdlZWsgaXMgTW9uZGF5XG4gIGNvbnN0IHRodU9mVGhlV2VlayA9IGRheU9mVGhlV2Vla09mKGRhdGUsIDQsIDEpO1xuICAvLyAxc3Qgd2VlayA9PSB0aGUgd2VlayB3aGVyZSB0aGUgNHRoIG9mIEphbnVhcnkgaXMgaW5cbiAgY29uc3QgZmlyc3RUaHUgPSBkYXlPZlRoZVdlZWtPZihuZXcgRGF0ZSh0aHVPZlRoZVdlZWspLnNldE1vbnRoKDAsIDQpLCA0LCAxKTtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHRodU9mVGhlV2VlayAtIGZpcnN0VGh1KSAvIDYwNDgwMDAwMCkgKyAxO1xufVxuXG4vLyBHZXQgdGhlIHN0YXJ0IHllYXIgb2YgdGhlIHBlcmlvZCBvZiB5ZWFycyB0aGF0IGluY2x1ZGVzIGdpdmVuIGRhdGVcbi8vIHllYXJzOiBsZW5ndGggb2YgdGhlIHllYXIgcGVyaW9kXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRPZlllYXJQZXJpb2QoZGF0ZSwgeWVhcnMpIHtcbiAgLyogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9ZZWFyX3plcm8jSVNPXzg2MDEgKi9cbiAgY29uc3QgeWVhciA9IG5ldyBEYXRlKGRhdGUpLmdldEZ1bGxZZWFyKCk7XG4gIHJldHVybiBNYXRoLmZsb29yKHllYXIgLyB5ZWFycykgKiB5ZWFycztcbn1cbiIsImNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSFRNTChodG1sKSB7XG4gIHJldHVybiByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaHRtbCk7XG59XG5cbi8vIGVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgOnZpc2JsZVxuZXhwb3J0IGZ1bmN0aW9uIGlzVmlzaWJsZShlbCkge1xuICByZXR1cm4gISEoZWwub2Zmc2V0V2lkdGggfHwgZWwub2Zmc2V0SGVpZ2h0IHx8IGVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhpZGVFbGVtZW50KGVsKSB7XG4gIGlmIChlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gYmFjayB1cCB0aGUgZXhpc3RpbmcgZGlzcGxheSBzZXR0aW5nIGluIGRhdGEtc3R5bGUtZGlzcGxheVxuICBpZiAoZWwuc3R5bGUuZGlzcGxheSkge1xuICAgIGVsLmRhdGFzZXQuc3R5bGVEaXNwbGF5ID0gZWwuc3R5bGUuZGlzcGxheTtcbiAgfVxuICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvd0VsZW1lbnQoZWwpIHtcbiAgaWYgKGVsLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWwuZGF0YXNldC5zdHlsZURpc3BsYXkpIHtcbiAgICAvLyByZXN0b3JlIGJhY2tlZC11cCBkaXNwYXkgcHJvcGVydHlcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuZGF0YXNldC5zdHlsZURpc3BsYXk7XG4gICAgZGVsZXRlIGVsLmRhdGFzZXQuc3R5bGVEaXNwbGF5O1xuICB9IGVsc2Uge1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW1wdHlDaGlsZE5vZGVzKGVsKSB7XG4gIGlmIChlbC5maXJzdENoaWxkKSB7XG4gICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgZW1wdHlDaGlsZE5vZGVzKGVsKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUNoaWxkTm9kZXMoZWwsIG5ld0NoaWxkTm9kZXMpIHtcbiAgZW1wdHlDaGlsZE5vZGVzKGVsKTtcbiAgaWYgKG5ld0NoaWxkTm9kZXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgZWwuYXBwZW5kQ2hpbGQobmV3Q2hpbGROb2Rlcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkTm9kZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgZWwuYXBwZW5kQ2hpbGQocGFyc2VIVE1MKG5ld0NoaWxkTm9kZXMpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmV3Q2hpbGROb2Rlcy5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbmV3Q2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiY29uc3QgbGlzdGVuZXJSZWdpc3RyeSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB7YWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lcn0gPSBFdmVudFRhcmdldC5wcm90b3R5cGU7XG5cbi8vIFJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyB0byBhIGtleSBvYmplY3Rcbi8vIGxpc3RlbmVyczogYXJyYXkgb2YgbGlzdGVuZXIgZGVmaW5pdGlvbnM7XG4vLyAgIC0gZWFjaCBkZWZpbml0aW9uIG11c3QgYmUgYSBmbGF0IGFycmF5IG9mIGV2ZW50IHRhcmdldCBhbmQgdGhlIGFyZ3VtZW50c1xuLy8gICAgIHVzZWQgdG8gY2FsbCBhZGRFdmVudExpc3RlbmVyKCkgb24gdGhlIHRhcmdldFxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKGtleU9iaiwgbGlzdGVuZXJzKSB7XG4gIGxldCByZWdpc3RlcmVkID0gbGlzdGVuZXJSZWdpc3RyeS5nZXQoa2V5T2JqKTtcbiAgaWYgKCFyZWdpc3RlcmVkKSB7XG4gICAgcmVnaXN0ZXJlZCA9IFtdO1xuICAgIGxpc3RlbmVyUmVnaXN0cnkuc2V0KGtleU9iaiwgcmVnaXN0ZXJlZCk7XG4gIH1cbiAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lci5jYWxsKC4uLmxpc3RlbmVyKTtcbiAgICByZWdpc3RlcmVkLnB1c2gobGlzdGVuZXIpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoa2V5T2JqKSB7XG4gIGxldCBsaXN0ZW5lcnMgPSBsaXN0ZW5lclJlZ2lzdHJ5LmdldChrZXlPYmopO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyLmNhbGwoLi4ubGlzdGVuZXIpO1xuICB9KTtcbiAgbGlzdGVuZXJSZWdpc3RyeS5kZWxldGUoa2V5T2JqKTtcbn1cblxuLy8gRXZlbnQuY29tcG9zZWRQYXRoKCkgcG9seWZpbGwgZm9yIEVkZ2Vcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2tsZWluZnJldW5kL2U5Nzg3ZDczNzc2YzBlMzc1MGRjZmNkYzg5ZjEwMGVjXG5pZiAoIUV2ZW50LnByb3RvdHlwZS5jb21wb3NlZFBhdGgpIHtcbiAgY29uc3QgZ2V0Q29tcG9zZWRQYXRoID0gKG5vZGUsIHBhdGggPSBbXSkgPT4ge1xuICAgIHBhdGgucHVzaChub2RlKTtcblxuICAgIGxldCBwYXJlbnQ7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ob3N0KSB7IC8vIFNoYWRvd1Jvb3RcbiAgICAgIHBhcmVudCA9IG5vZGUuaG9zdDtcbiAgICB9IGVsc2UgaWYgKG5vZGUuZGVmYXVsdFZpZXcpIHsgIC8vIERvY3VtZW50XG4gICAgICBwYXJlbnQgPSBub2RlLmRlZmF1bHRWaWV3O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50ID8gZ2V0Q29tcG9zZWRQYXRoKHBhcmVudCwgcGF0aCkgOiBwYXRoO1xuICB9O1xuXG4gIEV2ZW50LnByb3RvdHlwZS5jb21wb3NlZFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldENvbXBvc2VkUGF0aCh0aGlzLnRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRGcm9tUGF0aChwYXRoLCBjcml0ZXJpYSwgY3VycmVudFRhcmdldCwgaW5kZXggPSAwKSB7XG4gIGNvbnN0IGVsID0gcGF0aFtpbmRleF07XG4gIGlmIChjcml0ZXJpYShlbCkpIHtcbiAgICByZXR1cm4gZWw7XG4gIH0gZWxzZSBpZiAoZWwgPT09IGN1cnJlbnRUYXJnZXQgfHwgIWVsLnBhcmVudEVsZW1lbnQpIHtcbiAgICAvLyBzdG9wIHdoZW4gcmVhY2hpbmcgY3VycmVudFRhcmdldCBvciA8aHRtbD5cbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIGZpbmRGcm9tUGF0aChwYXRoLCBjcml0ZXJpYSwgY3VycmVudFRhcmdldCwgaW5kZXggKyAxKTtcbn1cblxuLy8gU2VhcmNoIGZvciB0aGUgYWN0dWFsIHRhcmdldCBvZiBhIGRlbGVnYXRlZCBldmVudFxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFbGVtZW50SW5FdmVudFBhdGgoZXYsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IGNyaXRlcmlhID0gdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nID8gc2VsZWN0b3IgOiBlbCA9PiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgcmV0dXJuIGZpbmRGcm9tUGF0aChldi5jb21wb3NlZFBhdGgoKSwgY3JpdGVyaWEsIGV2LmN1cnJlbnRUYXJnZXQpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGhhc1Byb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXN0SXRlbU9mKGFycikge1xuICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cblxuLy8gcHVzaCBvbmx5IHRoZSBpdGVtcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5XG5leHBvcnQgZnVuY3Rpb24gcHVzaFVuaXF1ZShhcnIsIC4uLml0ZW1zKSB7XG4gIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpZiAoYXJyLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFyci5wdXNoKGl0ZW0pO1xuICB9KTtcbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyLCBzZXBhcmF0b3IpIHtcbiAgLy8gY29udmVydCBlbXB0eSBzdHJpbmcgdG8gYW4gZW1wdHkgYXJyYXlcbiAgcmV0dXJuIHN0ciA/IHN0ci5zcGxpdChzZXBhcmF0b3IpIDogW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luUmFuZ2UodGVzdFZhbCwgbWluLCBtYXgpIHtcbiAgY29uc3QgbWluT0sgPSBtaW4gPT09IHVuZGVmaW5lZCB8fCB0ZXN0VmFsID49IG1pbjtcbiAgY29uc3QgbWF4T0sgPSBtYXggPT09IHVuZGVmaW5lZCB8fCB0ZXN0VmFsIDw9IG1heDtcbiAgcmV0dXJuIG1pbk9LICYmIG1heE9LO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGltaXRUb1JhbmdlKHZhbCwgbWluLCBtYXgpIHtcbiAgaWYgKHZhbCA8IG1pbikge1xuICAgIHJldHVybiBtaW47XG4gIH1cbiAgaWYgKHZhbCA+IG1heCkge1xuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhZ1JlcGVhdCh0YWdOYW1lLCByZXBlYXQsIGF0dHJpYnV0ZXMgPSB7fSwgaW5kZXggPSAwLCBodG1sID0gJycpIHtcbiAgY29uc3Qgb3BlblRhZ1NyYyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnJlZHVjZSgoc3JjLCBhdHRyKSA9PiB7XG4gICAgbGV0IHZhbCA9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbCA9IHZhbChpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBgJHtzcmN9ICR7YXR0cn09XCIke3ZhbH1cImA7XG4gIH0sIHRhZ05hbWUpO1xuICBodG1sICs9IGA8JHtvcGVuVGFnU3JjfT48LyR7dGFnTmFtZX0+YDtcblxuICBjb25zdCBuZXh0ID0gaW5kZXggKyAxO1xuICByZXR1cm4gbmV4dCA8IHJlcGVhdFxuICAgID8gY3JlYXRlVGFnUmVwZWF0KHRhZ05hbWUsIHJlcGVhdCwgYXR0cmlidXRlcywgbmV4dCwgaHRtbClcbiAgICA6IGh0bWw7XG59XG5cbi8vIFJlbW92ZSB0aGUgc3BhY2luZyBzdXJyb3VuZGluZyB0YWdzIGZvciBIVE1MIHBhcnNlciBub3QgdG8gY3JlYXRlIHRleHQgbm9kZXNcbi8vIGJlZm9yZS9hZnRlciBlbGVtZW50c1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGltaXplVGVtcGxhdGVIVE1MKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSgvPlxccysvZywgJz4nKS5yZXBsYWNlKC9cXHMrPC8sICc8Jyk7XG59XG4iLCIvLyBjb25maWcgb3B0aW9ucyB1cGRhdGFibGUgYnkgc2V0T3B0aW9ucygpIGFuZCB0aGVpciBkZWZhdWx0IHZhbHVlc1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGF1dG9oaWRlOiBmYWxzZSxcbiAgYmVmb3JlU2hvd0RheTogbnVsbCxcbiAgYmVmb3JlU2hvd0RlY2FkZTogbnVsbCxcbiAgYmVmb3JlU2hvd01vbnRoOiBudWxsLFxuICBiZWZvcmVTaG93WWVhcjogbnVsbCxcbiAgY2FsZW5kYXJXZWVrczogZmFsc2UsXG4gIGNsZWFyQnRuOiBmYWxzZSxcbiAgZGF0ZURlbGltaXRlcjogJywnLFxuICBkYXRlc0Rpc2FibGVkOiBbXSxcbiAgZGF5c09mV2Vla0Rpc2FibGVkOiBbXSxcbiAgZGF5c09mV2Vla0hpZ2hsaWdodGVkOiBbXSxcbiAgZGVmYXVsdFZpZXdEYXRlOiB1bmRlZmluZWQsIC8vIHBsYWNlaG9sZGVyLCBkZWZhdWx0cyB0byB0b2RheSgpIGJ5IHRoZSBwcm9ncmFtXG4gIGRpc2FibGVUb3VjaEtleWJvYXJkOiBmYWxzZSxcbiAgZm9ybWF0OiAnbW0vZGQveXl5eScsXG4gIGxhbmd1YWdlOiAnZW4nLFxuICBtYXhEYXRlOiBudWxsLFxuICBtYXhOdW1iZXJPZkRhdGVzOiAxLFxuICBtYXhWaWV3OiAzLFxuICBtaW5EYXRlOiBudWxsLFxuICBuZXh0QXJyb3c6ICc8c3ZnIGNsYXNzPVwidy00IGgtNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTEyLjI5MyA1LjI5M2ExIDEgMCAwMTEuNDE0IDBsNCA0YTEgMSAwIDAxMCAxLjQxNGwtNCA0YTEgMSAwIDAxLTEuNDE0LTEuNDE0TDE0LjU4NiAxMUgzYTEgMSAwIDExMC0yaDExLjU4NmwtMi4yOTMtMi4yOTNhMSAxIDAgMDEwLTEuNDE0elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIj48L3BhdGg+PC9zdmc+JyxcbiAgb3JpZW50YXRpb246ICdhdXRvJyxcbiAgcGlja0xldmVsOiAwLFxuICBwcmV2QXJyb3c6ICc8c3ZnIGNsYXNzPVwidy00IGgtNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTkuNzA3IDE2LjcwN2ExIDEgMCAwMS0xLjQxNCAwbC02LTZhMSAxIDAgMDEwLTEuNDE0bDYtNmExIDEgMCAwMTEuNDE0IDEuNDE0TDUuNDE0IDlIMTdhMSAxIDAgMTEwIDJINS40MTRsNC4yOTMgNC4yOTNhMSAxIDAgMDEwIDEuNDE0elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIj48L3BhdGg+PC9zdmc+JyxcbiAgc2hvd0RheXNPZldlZWs6IHRydWUsXG4gIHNob3dPbkNsaWNrOiB0cnVlLFxuICBzaG93T25Gb2N1czogdHJ1ZSxcbiAgc3RhcnRWaWV3OiAwLFxuICB0aXRsZTogJycsXG4gIHRvZGF5QnRuOiBmYWxzZSxcbiAgdG9kYXlCdG5Nb2RlOiAwLFxuICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gIHVwZGF0ZU9uQmx1cjogdHJ1ZSxcbiAgd2Vla1N0YXJ0OiAwLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdE9wdGlvbnM7XG4iLCJpbXBvcnQge2hhc1Byb3BlcnR5LCBwdXNoVW5pcXVlfSBmcm9tICcuLi9saWIvdXRpbHMuanMnO1xuaW1wb3J0IHtkYXRlVmFsdWV9IGZyb20gJy4uL2xpYi9kYXRlLmpzJztcbmltcG9ydCB7cmVGb3JtYXRUb2tlbnMsIHBhcnNlRGF0ZX0gZnJvbSAnLi4vbGliL2RhdGUtZm9ybWF0LmpzJztcbmltcG9ydCB7cGFyc2VIVE1MfSBmcm9tICcuLi9saWIvZG9tLmpzJztcbmltcG9ydCBkZWZhdWx0T3B0aW9ucyBmcm9tICcuL2RlZmF1bHRPcHRpb25zLmpzJztcblxuY29uc3Qge1xuICBsYW5ndWFnZTogZGVmYXVsdExhbmcsXG4gIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcbiAgd2Vla1N0YXJ0OiBkZWZhdWx0V2Vla1N0YXJ0LFxufSA9IGRlZmF1bHRPcHRpb25zO1xuXG4vLyBSZWR1Y2VyIGZ1bmN0aW9uIHRvIGZpbHRlciBvdXQgaW52YWxpZCBkYXktb2Ytd2VlayBmcm9tIHRoZSBpbnB1dFxuZnVuY3Rpb24gc2FuaXRpemVET1coZG93LCBkYXkpIHtcbiAgcmV0dXJuIGRvdy5sZW5ndGggPCA2ICYmIGRheSA+PSAwICYmIGRheSA8IDdcbiAgICA/IHB1c2hVbmlxdWUoZG93LCBkYXkpXG4gICAgOiBkb3c7XG59XG5cbmZ1bmN0aW9uIGNhbGNFbmRPZldlZWsoc3RhcnRPZldlZWspIHtcbiAgcmV0dXJuIChzdGFydE9mV2VlayArIDYpICUgNztcbn1cblxuLy8gdmFsaWRhdGUgaW5wdXQgZGF0ZS4gaWYgaW52YWxpZCwgZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGUodmFsdWUsIGZvcm1hdCwgbG9jYWxlLCBvcmlnVmFsdWUpIHtcbiAgY29uc3QgZGF0ZSA9IHBhcnNlRGF0ZSh2YWx1ZSwgZm9ybWF0LCBsb2NhbGUpO1xuICByZXR1cm4gZGF0ZSAhPT0gdW5kZWZpbmVkID8gZGF0ZSA6IG9yaWdWYWx1ZTtcbn1cblxuLy8gVmFsaWRhdGUgdmlld0lkLiBpZiBpbnZhbGlkLCBmYWxsYmFjayB0byB0aGUgb3JpZ2luYWwgdmFsdWVcbmZ1bmN0aW9uIHZhbGlkYXRlVmlld0lkKHZhbHVlLCBvcmlnVmFsdWUsIG1heCA9IDMpIHtcbiAgY29uc3Qgdmlld0lkID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgcmV0dXJuIHZpZXdJZCA+PSAwICYmIHZpZXdJZCA8PSBtYXggPyB2aWV3SWQgOiBvcmlnVmFsdWU7XG59XG5cbi8vIENyZWF0ZSBEYXRlcGlja2VyIGNvbmZpZ3VyYXRpb24gdG8gc2V0XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcm9jZXNzT3B0aW9ucyhvcHRpb25zLCBkYXRlcGlja2VyKSB7XG4gIGNvbnN0IGluT3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICBjb25zdCBjb25maWcgPSB7fTtcbiAgY29uc3QgbG9jYWxlcyA9IGRhdGVwaWNrZXIuY29uc3RydWN0b3IubG9jYWxlcztcbiAgbGV0IHtcbiAgICBmb3JtYXQsXG4gICAgbGFuZ3VhZ2UsXG4gICAgbG9jYWxlLFxuICAgIG1heERhdGUsXG4gICAgbWF4VmlldyxcbiAgICBtaW5EYXRlLFxuICAgIHBpY2tMZXZlbCxcbiAgICBzdGFydFZpZXcsXG4gICAgd2Vla1N0YXJ0LFxuICB9ID0gZGF0ZXBpY2tlci5jb25maWcgfHwge307XG5cbiAgaWYgKGluT3B0cy5sYW5ndWFnZSkge1xuICAgIGxldCBsYW5nO1xuICAgIGlmIChpbk9wdHMubGFuZ3VhZ2UgIT09IGxhbmd1YWdlKSB7XG4gICAgICBpZiAobG9jYWxlc1tpbk9wdHMubGFuZ3VhZ2VdKSB7XG4gICAgICAgIGxhbmcgPSBpbk9wdHMubGFuZ3VhZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDaGVjayBpZiBsYW5nYXVnZSArIHJlZ2lvbiB0YWcgY2FuIGZhbGxiYWNrIHRvIHRoZSBvbmUgd2l0aG91dFxuICAgICAgICAvLyByZWdpb24gKGUuZy4gZnItQ0Eg4oaSIGZyKVxuICAgICAgICBsYW5nID0gaW5PcHRzLmxhbmd1YWdlLnNwbGl0KCctJylbMF07XG4gICAgICAgIGlmIChsb2NhbGVzW2xhbmddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy5sYW5ndWFnZTtcbiAgICBpZiAobGFuZykge1xuICAgICAgbGFuZ3VhZ2UgPSBjb25maWcubGFuZ3VhZ2UgPSBsYW5nO1xuXG4gICAgICAvLyB1cGRhdGUgbG9jYWxlIGFzIHdlbGwgd2hlbiB1cGRhdGluZyBsYW5ndWFnZVxuICAgICAgY29uc3Qgb3JpZ0xvY2FsZSA9IGxvY2FsZSB8fCBsb2NhbGVzW2RlZmF1bHRMYW5nXTtcbiAgICAgIC8vIHVzZSBkZWZhdWx0IGxhbmd1YWdlJ3MgcHJvcGVydGllcyBmb3IgdGhlIGZhbGxiYWNrXG4gICAgICBsb2NhbGUgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0LFxuICAgICAgICB3ZWVrU3RhcnQ6IGRlZmF1bHRXZWVrU3RhcnRcbiAgICAgIH0sIGxvY2FsZXNbZGVmYXVsdExhbmddKTtcbiAgICAgIGlmIChsYW5ndWFnZSAhPT0gZGVmYXVsdExhbmcpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihsb2NhbGUsIGxvY2FsZXNbbGFuZ3VhZ2VdKTtcbiAgICAgIH1cbiAgICAgIGNvbmZpZy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAvLyBpZiBmb3JtYXQgYW5kL29yIHdlZWtTdGFydCBhcmUgdGhlIHNhbWUgYXMgb2xkIGxvY2FsZSdzIGRlZmF1bHRzLFxuICAgICAgLy8gdXBkYXRlIHRoZW0gdG8gbmV3IGxvY2FsZSdzIGRlZmF1bHRzXG4gICAgICBpZiAoZm9ybWF0ID09PSBvcmlnTG9jYWxlLmZvcm1hdCkge1xuICAgICAgICBmb3JtYXQgPSBjb25maWcuZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgICAgIH1cbiAgICAgIGlmICh3ZWVrU3RhcnQgPT09IG9yaWdMb2NhbGUud2Vla1N0YXJ0KSB7XG4gICAgICAgIHdlZWtTdGFydCA9IGNvbmZpZy53ZWVrU3RhcnQgPSBsb2NhbGUud2Vla1N0YXJ0O1xuICAgICAgICBjb25maWcud2Vla0VuZCA9IGNhbGNFbmRPZldlZWsobG9jYWxlLndlZWtTdGFydCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluT3B0cy5mb3JtYXQpIHtcbiAgICBjb25zdCBoYXNUb0Rpc3BsYXkgPSB0eXBlb2YgaW5PcHRzLmZvcm1hdC50b0Rpc3BsYXkgPT09ICdmdW5jdGlvbic7XG4gICAgY29uc3QgaGFzVG9WYWx1ZSA9IHR5cGVvZiBpbk9wdHMuZm9ybWF0LnRvVmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgY29uc3QgdmFsaWRGb3JtYXRTdHJpbmcgPSByZUZvcm1hdFRva2Vucy50ZXN0KGluT3B0cy5mb3JtYXQpO1xuICAgIGlmICgoaGFzVG9EaXNwbGF5ICYmIGhhc1RvVmFsdWUpIHx8IHZhbGlkRm9ybWF0U3RyaW5nKSB7XG4gICAgICBmb3JtYXQgPSBjb25maWcuZm9ybWF0ID0gaW5PcHRzLmZvcm1hdDtcbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy5mb3JtYXQ7XG4gIH1cblxuICAvLyoqKiBkYXRlcyAqKiovL1xuICAvLyB3aGlsZSBtaW4gYW5kIG1heERhdGUgZm9yIFwibm8gbGltaXRcIiBpbiB0aGUgb3B0aW9ucyBhcmUgYmV0dGVyIHRvIGJlIG51bGxcbiAgLy8gKGVzcGVjaWFsbHkgd2hlbiB1cGRhdGluZyksIHRoZSBvbmVzIGluIHRoZSBjb25maWcgaGF2ZSB0byBiZSB1bmRlZmluZWRcbiAgLy8gYmVjYXVzZSBudWxsIGlzIHRyZWF0ZWQgYXMgMCAoPSB1bml4IGVwb2NoKSB3aGVuIGNvbXBhcmluZyB3aXRoIHRpbWUgdmFsdWVcbiAgbGV0IG1pbkR0ID0gbWluRGF0ZTtcbiAgbGV0IG1heER0ID0gbWF4RGF0ZTtcbiAgaWYgKGluT3B0cy5taW5EYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtaW5EdCA9IGluT3B0cy5taW5EYXRlID09PSBudWxsXG4gICAgICA/IGRhdGVWYWx1ZSgwLCAwLCAxKSAgLy8gc2V0IDAwMDAtMDEtMDEgdG8gcHJldmVudCBuZWdhdGl2ZSB2YWx1ZXMgZm9yIHllYXJcbiAgICAgIDogdmFsaWRhdGVEYXRlKGluT3B0cy5taW5EYXRlLCBmb3JtYXQsIGxvY2FsZSwgbWluRHQpO1xuICAgIGRlbGV0ZSBpbk9wdHMubWluRGF0ZTtcbiAgfVxuICBpZiAoaW5PcHRzLm1heERhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1heER0ID0gaW5PcHRzLm1heERhdGUgPT09IG51bGxcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHZhbGlkYXRlRGF0ZShpbk9wdHMubWF4RGF0ZSwgZm9ybWF0LCBsb2NhbGUsIG1heER0KTtcbiAgICBkZWxldGUgaW5PcHRzLm1heERhdGU7XG4gIH1cbiAgaWYgKG1heER0IDwgbWluRHQpIHtcbiAgICBtaW5EYXRlID0gY29uZmlnLm1pbkRhdGUgPSBtYXhEdDtcbiAgICBtYXhEYXRlID0gY29uZmlnLm1heERhdGUgPSBtaW5EdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAobWluRGF0ZSAhPT0gbWluRHQpIHtcbiAgICAgIG1pbkRhdGUgPSBjb25maWcubWluRGF0ZSA9IG1pbkR0O1xuICAgIH1cbiAgICBpZiAobWF4RGF0ZSAhPT0gbWF4RHQpIHtcbiAgICAgIG1heERhdGUgPSBjb25maWcubWF4RGF0ZSA9IG1heER0O1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbk9wdHMuZGF0ZXNEaXNhYmxlZCkge1xuICAgIGNvbmZpZy5kYXRlc0Rpc2FibGVkID0gaW5PcHRzLmRhdGVzRGlzYWJsZWQucmVkdWNlKChkYXRlcywgZHQpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBwYXJzZURhdGUoZHQsIGZvcm1hdCwgbG9jYWxlKTtcbiAgICAgIHJldHVybiBkYXRlICE9PSB1bmRlZmluZWQgPyBwdXNoVW5pcXVlKGRhdGVzLCBkYXRlKSA6IGRhdGVzO1xuICAgIH0sIFtdKTtcbiAgICBkZWxldGUgaW5PcHRzLmRhdGVzRGlzYWJsZWQ7XG4gIH1cbiAgaWYgKGluT3B0cy5kZWZhdWx0Vmlld0RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHZpZXdEYXRlID0gcGFyc2VEYXRlKGluT3B0cy5kZWZhdWx0Vmlld0RhdGUsIGZvcm1hdCwgbG9jYWxlKTtcbiAgICBpZiAodmlld0RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uZmlnLmRlZmF1bHRWaWV3RGF0ZSA9IHZpZXdEYXRlO1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLmRlZmF1bHRWaWV3RGF0ZTtcbiAgfVxuXG4gIC8vKioqIGRheXMgb2Ygd2VlayAqKiovL1xuICBpZiAoaW5PcHRzLndlZWtTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgd2tTdGFydCA9IE51bWJlcihpbk9wdHMud2Vla1N0YXJ0KSAlIDc7XG4gICAgaWYgKCFpc05hTih3a1N0YXJ0KSkge1xuICAgICAgd2Vla1N0YXJ0ID0gY29uZmlnLndlZWtTdGFydCA9IHdrU3RhcnQ7XG4gICAgICBjb25maWcud2Vla0VuZCA9IGNhbGNFbmRPZldlZWsod2tTdGFydCk7XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMud2Vla1N0YXJ0O1xuICB9XG4gIGlmIChpbk9wdHMuZGF5c09mV2Vla0Rpc2FibGVkKSB7XG4gICAgY29uZmlnLmRheXNPZldlZWtEaXNhYmxlZCA9IGluT3B0cy5kYXlzT2ZXZWVrRGlzYWJsZWQucmVkdWNlKHNhbml0aXplRE9XLCBbXSk7XG4gICAgZGVsZXRlIGluT3B0cy5kYXlzT2ZXZWVrRGlzYWJsZWQ7XG4gIH1cbiAgaWYgKGluT3B0cy5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25maWcuZGF5c09mV2Vla0hpZ2hsaWdodGVkID0gaW5PcHRzLmRheXNPZldlZWtIaWdobGlnaHRlZC5yZWR1Y2Uoc2FuaXRpemVET1csIFtdKTtcbiAgICBkZWxldGUgaW5PcHRzLmRheXNPZldlZWtIaWdobGlnaHRlZDtcbiAgfVxuXG4gIC8vKioqIG11bHRpIGRhdGUgKioqLy9cbiAgaWYgKGluT3B0cy5tYXhOdW1iZXJPZkRhdGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBtYXhOdW1iZXJPZkRhdGVzID0gcGFyc2VJbnQoaW5PcHRzLm1heE51bWJlck9mRGF0ZXMsIDEwKTtcbiAgICBpZiAobWF4TnVtYmVyT2ZEYXRlcyA+PSAwKSB7XG4gICAgICBjb25maWcubWF4TnVtYmVyT2ZEYXRlcyA9IG1heE51bWJlck9mRGF0ZXM7XG4gICAgICBjb25maWcubXVsdGlkYXRlID0gbWF4TnVtYmVyT2ZEYXRlcyAhPT0gMTtcbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy5tYXhOdW1iZXJPZkRhdGVzO1xuICB9XG4gIGlmIChpbk9wdHMuZGF0ZURlbGltaXRlcikge1xuICAgIGNvbmZpZy5kYXRlRGVsaW1pdGVyID0gU3RyaW5nKGluT3B0cy5kYXRlRGVsaW1pdGVyKTtcbiAgICBkZWxldGUgaW5PcHRzLmRhdGVEZWxpbWl0ZXI7XG4gIH1cblxuICAvLyoqKiBwaWNrIGxldmVsICYgdmlldyAqKiovL1xuICBsZXQgbmV3UGlja0xldmVsID0gcGlja0xldmVsO1xuICBpZiAoaW5PcHRzLnBpY2tMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbmV3UGlja0xldmVsID0gdmFsaWRhdGVWaWV3SWQoaW5PcHRzLnBpY2tMZXZlbCwgMik7XG4gICAgZGVsZXRlIGluT3B0cy5waWNrTGV2ZWw7XG4gIH1cbiAgaWYgKG5ld1BpY2tMZXZlbCAhPT0gcGlja0xldmVsKSB7XG4gICAgcGlja0xldmVsID0gY29uZmlnLnBpY2tMZXZlbCA9IG5ld1BpY2tMZXZlbDtcbiAgfVxuXG4gIGxldCBuZXdNYXhWaWV3ID0gbWF4VmlldztcbiAgaWYgKGluT3B0cy5tYXhWaWV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICBuZXdNYXhWaWV3ID0gdmFsaWRhdGVWaWV3SWQoaW5PcHRzLm1heFZpZXcsIG1heFZpZXcpO1xuICAgIGRlbGV0ZSBpbk9wdHMubWF4VmlldztcbiAgfVxuICAvLyBlbnN1cmUgbWF4IHZpZXcgPj0gcGljayBsZXZlbFxuICBuZXdNYXhWaWV3ID0gcGlja0xldmVsID4gbmV3TWF4VmlldyA/IHBpY2tMZXZlbCA6IG5ld01heFZpZXc7XG4gIGlmIChuZXdNYXhWaWV3ICE9PSBtYXhWaWV3KSB7XG4gICAgbWF4VmlldyA9IGNvbmZpZy5tYXhWaWV3ID0gbmV3TWF4VmlldztcbiAgfVxuXG4gIGxldCBuZXdTdGFydFZpZXcgPSBzdGFydFZpZXc7XG4gIGlmIChpbk9wdHMuc3RhcnRWaWV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICBuZXdTdGFydFZpZXcgPSB2YWxpZGF0ZVZpZXdJZChpbk9wdHMuc3RhcnRWaWV3LCBuZXdTdGFydFZpZXcpO1xuICAgIGRlbGV0ZSBpbk9wdHMuc3RhcnRWaWV3O1xuICB9XG4gIC8vIGVuc3VyZSBwaWNrIGxldmVsIDw9IHN0YXJ0IHZpZXcgPD0gbWF4IHZpZXdcbiAgaWYgKG5ld1N0YXJ0VmlldyA8IHBpY2tMZXZlbCkge1xuICAgIG5ld1N0YXJ0VmlldyA9IHBpY2tMZXZlbDtcbiAgfSBlbHNlIGlmIChuZXdTdGFydFZpZXcgPiBtYXhWaWV3KSB7XG4gICAgbmV3U3RhcnRWaWV3ID0gbWF4VmlldztcbiAgfVxuICBpZiAobmV3U3RhcnRWaWV3ICE9PSBzdGFydFZpZXcpIHtcbiAgICBjb25maWcuc3RhcnRWaWV3ID0gbmV3U3RhcnRWaWV3O1xuICB9XG5cbiAgLy8qKiogdGVtcGxhdGUgKioqLy9cbiAgaWYgKGluT3B0cy5wcmV2QXJyb3cpIHtcbiAgICBjb25zdCBwcmV2QXJyb3cgPSBwYXJzZUhUTUwoaW5PcHRzLnByZXZBcnJvdyk7XG4gICAgaWYgKHByZXZBcnJvdy5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbmZpZy5wcmV2QXJyb3cgPSBwcmV2QXJyb3cuY2hpbGROb2RlcztcbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy5wcmV2QXJyb3c7XG4gIH1cbiAgaWYgKGluT3B0cy5uZXh0QXJyb3cpIHtcbiAgICBjb25zdCBuZXh0QXJyb3cgPSBwYXJzZUhUTUwoaW5PcHRzLm5leHRBcnJvdyk7XG4gICAgaWYgKG5leHRBcnJvdy5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbmZpZy5uZXh0QXJyb3cgPSBuZXh0QXJyb3cuY2hpbGROb2RlcztcbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy5uZXh0QXJyb3c7XG4gIH1cblxuICAvLyoqKiBtaXNjICoqKi8vXG4gIGlmIChpbk9wdHMuZGlzYWJsZVRvdWNoS2V5Ym9hcmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbmZpZy5kaXNhYmxlVG91Y2hLZXlib2FyZCA9ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50ICYmICEhaW5PcHRzLmRpc2FibGVUb3VjaEtleWJvYXJkO1xuICAgIGRlbGV0ZSBpbk9wdHMuZGlzYWJsZVRvdWNoS2V5Ym9hcmQ7XG4gIH1cbiAgaWYgKGluT3B0cy5vcmllbnRhdGlvbikge1xuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gaW5PcHRzLm9yaWVudGF0aW9uLnRvTG93ZXJDYXNlKCkuc3BsaXQoL1xccysvZyk7XG4gICAgY29uZmlnLm9yaWVudGF0aW9uID0ge1xuICAgICAgeDogb3JpZW50YXRpb24uZmluZCh4ID0+ICh4ID09PSAnbGVmdCcgfHwgeCA9PT0gJ3JpZ2h0JykpIHx8ICdhdXRvJyxcbiAgICAgIHk6IG9yaWVudGF0aW9uLmZpbmQoeSA9PiAoeSA9PT0gJ3RvcCcgfHwgeSA9PT0gJ2JvdHRvbScpKSB8fCAnYXV0bycsXG4gICAgfTtcbiAgICBkZWxldGUgaW5PcHRzLm9yaWVudGF0aW9uO1xuICB9XG4gIGlmIChpbk9wdHMudG9kYXlCdG5Nb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBzd2l0Y2goaW5PcHRzLnRvZGF5QnRuTW9kZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxOlxuICAgICAgICBjb25maWcudG9kYXlCdG5Nb2RlID0gaW5PcHRzLnRvZGF5QnRuTW9kZTtcbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy50b2RheUJ0bk1vZGU7XG4gIH1cblxuICAvLyoqKiBjb3B5IHRoZSByZXN0ICoqKi8vXG4gIE9iamVjdC5rZXlzKGluT3B0cykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKGluT3B0c1trZXldICE9PSB1bmRlZmluZWQgJiYgaGFzUHJvcGVydHkoZGVmYXVsdE9wdGlvbnMsIGtleSkpIHtcbiAgICAgIGNvbmZpZ1trZXldID0gaW5PcHRzW2tleV07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuIiwiaW1wb3J0IHtoYXNQcm9wZXJ0eSwgbGFzdEl0ZW1PZiwgaXNJblJhbmdlLCBsaW1pdFRvUmFuZ2V9IGZyb20gJy4uL2xpYi91dGlscy5qcyc7XG5pbXBvcnQge3RvZGF5fSBmcm9tICcuLi9saWIvZGF0ZS5qcyc7XG5pbXBvcnQge3BhcnNlSFRNTCwgc2hvd0VsZW1lbnQsIGhpZGVFbGVtZW50LCBlbXB0eUNoaWxkTm9kZXN9IGZyb20gJy4uL2xpYi9kb20uanMnO1xuaW1wb3J0IHtyZWdpc3Rlckxpc3RlbmVyc30gZnJvbSAnLi4vbGliL2V2ZW50LmpzJztcbmltcG9ydCBwaWNrZXJUZW1wbGF0ZSBmcm9tICcuL3RlbXBsYXRlcy9waWNrZXJUZW1wbGF0ZS5qcyc7XG5pbXBvcnQgRGF5c1ZpZXcgZnJvbSAnLi92aWV3cy9EYXlzVmlldy5qcyc7XG5pbXBvcnQgTW9udGhzVmlldyBmcm9tICcuL3ZpZXdzL01vbnRoc1ZpZXcuanMnO1xuaW1wb3J0IFllYXJzVmlldyBmcm9tICcuL3ZpZXdzL1llYXJzVmlldy5qcyc7XG5pbXBvcnQge3RyaWdnZXJEYXRlcGlja2VyRXZlbnR9IGZyb20gJy4uL2V2ZW50cy9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgb25DbGlja1RvZGF5QnRuLFxuICBvbkNsaWNrQ2xlYXJCdG4sXG4gIG9uQ2xpY2tWaWV3U3dpdGNoLFxuICBvbkNsaWNrUHJldkJ0bixcbiAgb25DbGlja05leHRCdG4sXG4gIG9uQ2xpY2tWaWV3LFxuICBvbkNsaWNrUGlja2VyLFxufSBmcm9tICcuLi9ldmVudHMvcGlja2VyTGlzdGVuZXJzLmpzJztcblxuZnVuY3Rpb24gcHJvY2Vzc1BpY2tlck9wdGlvbnMocGlja2VyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy50aXRsZSkge1xuICAgICAgcGlja2VyLmNvbnRyb2xzLnRpdGxlLnRleHRDb250ZW50ID0gb3B0aW9ucy50aXRsZTtcbiAgICAgIHNob3dFbGVtZW50KHBpY2tlci5jb250cm9scy50aXRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpY2tlci5jb250cm9scy50aXRsZS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgaGlkZUVsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRpdGxlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJldkFycm93KSB7XG4gICAgY29uc3QgcHJldkJ0biA9IHBpY2tlci5jb250cm9scy5wcmV2QnRuO1xuICAgIGVtcHR5Q2hpbGROb2RlcyhwcmV2QnRuKTtcbiAgICBvcHRpb25zLnByZXZBcnJvdy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBwcmV2QnRuLmFwcGVuZENoaWxkKG5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9KTtcbiAgfVxuICBpZiAob3B0aW9ucy5uZXh0QXJyb3cpIHtcbiAgICBjb25zdCBuZXh0QnRuID0gcGlja2VyLmNvbnRyb2xzLm5leHRCdG47XG4gICAgZW1wdHlDaGlsZE5vZGVzKG5leHRCdG4pO1xuICAgIG9wdGlvbnMubmV4dEFycm93LmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5leHRCdG4uYXBwZW5kQ2hpbGQobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIH0pO1xuICB9XG4gIGlmIChvcHRpb25zLmxvY2FsZSkge1xuICAgIHBpY2tlci5jb250cm9scy50b2RheUJ0bi50ZXh0Q29udGVudCA9IG9wdGlvbnMubG9jYWxlLnRvZGF5O1xuICAgIHBpY2tlci5jb250cm9scy5jbGVhckJ0bi50ZXh0Q29udGVudCA9IG9wdGlvbnMubG9jYWxlLmNsZWFyO1xuICB9XG4gIGlmIChvcHRpb25zLnRvZGF5QnRuICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy50b2RheUJ0bikge1xuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRvZGF5QnRuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZUVsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRvZGF5QnRuKTtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtaW5EYXRlJykgfHwgaGFzUHJvcGVydHkob3B0aW9ucywgJ21heERhdGUnKSkge1xuICAgIGNvbnN0IHttaW5EYXRlLCBtYXhEYXRlfSA9IHBpY2tlci5kYXRlcGlja2VyLmNvbmZpZztcbiAgICBwaWNrZXIuY29udHJvbHMudG9kYXlCdG4uZGlzYWJsZWQgPSAhaXNJblJhbmdlKHRvZGF5KCksIG1pbkRhdGUsIG1heERhdGUpO1xuICB9XG4gIGlmIChvcHRpb25zLmNsZWFyQnRuICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5jbGVhckJ0bikge1xuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLmNsZWFyQnRuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZUVsZW1lbnQocGlja2VyLmNvbnRyb2xzLmNsZWFyQnRuKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQ29tcHV0ZSB2aWV3IGRhdGUgdG8gcmVzZXQsIHdoaWNoIHdpbGwgYmUuLi5cbi8vIC0gdGhlIGxhc3QgaXRlbSBvZiB0aGUgc2VsZWN0ZWQgZGF0ZXMgb3IgZGVmYXVsdFZpZXdEYXRlIGlmIG5vIHNlbGVjdGlvblxuLy8gLSBsaW1pdHRlZCB0byBtaW5EYXRlIG9yIG1heERhdGUgaWYgaXQgZXhjZWVkcyB0aGUgcmFuZ2VcbmZ1bmN0aW9uIGNvbXB1dGVSZXNldFZpZXdEYXRlKGRhdGVwaWNrZXIpIHtcbiAgY29uc3Qge2RhdGVzLCBjb25maWd9ID0gZGF0ZXBpY2tlcjtcbiAgY29uc3Qgdmlld0RhdGUgPSBkYXRlcy5sZW5ndGggPiAwID8gbGFzdEl0ZW1PZihkYXRlcykgOiBjb25maWcuZGVmYXVsdFZpZXdEYXRlO1xuICByZXR1cm4gbGltaXRUb1JhbmdlKHZpZXdEYXRlLCBjb25maWcubWluRGF0ZSwgY29uZmlnLm1heERhdGUpO1xufVxuXG4vLyBDaGFuZ2UgY3VycmVudCB2aWV3J3MgdmlldyBkYXRlXG5mdW5jdGlvbiBzZXRWaWV3RGF0ZShwaWNrZXIsIG5ld0RhdGUpIHtcbiAgY29uc3Qgb2xkVmlld0RhdGUgPSBuZXcgRGF0ZShwaWNrZXIudmlld0RhdGUpO1xuICBjb25zdCBuZXdWaWV3RGF0ZSA9IG5ldyBEYXRlKG5ld0RhdGUpO1xuICBjb25zdCB7aWQsIHllYXIsIGZpcnN0LCBsYXN0fSA9IHBpY2tlci5jdXJyZW50VmlldztcbiAgY29uc3Qgdmlld1llYXIgPSBuZXdWaWV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gIHBpY2tlci52aWV3RGF0ZSA9IG5ld0RhdGU7XG4gIGlmICh2aWV3WWVhciAhPT0gb2xkVmlld0RhdGUuZ2V0RnVsbFllYXIoKSkge1xuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQocGlja2VyLmRhdGVwaWNrZXIsICdjaGFuZ2VZZWFyJyk7XG4gIH1cbiAgaWYgKG5ld1ZpZXdEYXRlLmdldE1vbnRoKCkgIT09IG9sZFZpZXdEYXRlLmdldE1vbnRoKCkpIHtcbiAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHBpY2tlci5kYXRlcGlja2VyLCAnY2hhbmdlTW9udGgnKTtcbiAgfVxuXG4gIC8vIHJldHVybiB3aGV0aGVyIHRoZSBuZXcgZGF0ZSBpcyBpbiBkaWZmZXJlbnQgcGVyaW9kIG9uIHRpbWUgZnJvbSB0aGUgb25lXG4gIC8vIGRpc3BsYXllZCBpbiB0aGUgY3VycmVudCB2aWV3XG4gIC8vIHdoZW4gdHJ1ZSwgdGhlIHZpZXcgbmVlZHMgdG8gYmUgcmUtcmVuZGVyZWQgb24gdGhlIG5leHQgVUkgcmVmcmVzaC5cbiAgc3dpdGNoIChpZCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBuZXdEYXRlIDwgZmlyc3QgfHwgbmV3RGF0ZSA+IGxhc3Q7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHZpZXdZZWFyICE9PSB5ZWFyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmlld1llYXIgPCBmaXJzdCB8fCB2aWV3WWVhciA+IGxhc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGV4dERpcmVjdGlvbihlbCkge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpcmVjdGlvbjtcbn1cblxuLy8gQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBwaWNrZXIgVUlcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpY2tlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGVwaWNrZXIpIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIgPSBkYXRlcGlja2VyO1xuXG4gICAgY29uc3QgdGVtcGxhdGUgPSBwaWNrZXJUZW1wbGF0ZS5yZXBsYWNlKC8lYnV0dG9uQ2xhc3MlL2csIGRhdGVwaWNrZXIuY29uZmlnLmJ1dHRvbkNsYXNzKTtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50ID0gcGFyc2VIVE1MKHRlbXBsYXRlKS5maXJzdENoaWxkO1xuICAgIGNvbnN0IFtoZWFkZXIsIG1haW4sIGZvb3Rlcl0gPSBlbGVtZW50LmZpcnN0Q2hpbGQuY2hpbGRyZW47XG4gICAgY29uc3QgdGl0bGUgPSBoZWFkZXIuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgY29uc3QgW3ByZXZCdG4sIHZpZXdTd2l0Y2gsIG5leHRCdG5dID0gaGVhZGVyLmxhc3RFbGVtZW50Q2hpbGQuY2hpbGRyZW47XG4gICAgY29uc3QgW3RvZGF5QnRuLCBjbGVhckJ0bl0gPSBmb290ZXIuZmlyc3RDaGlsZC5jaGlsZHJlbjtcbiAgICBjb25zdCBjb250cm9scyA9IHtcbiAgICAgIHRpdGxlLFxuICAgICAgcHJldkJ0bixcbiAgICAgIHZpZXdTd2l0Y2gsXG4gICAgICBuZXh0QnRuLFxuICAgICAgdG9kYXlCdG4sXG4gICAgICBjbGVhckJ0bixcbiAgICB9O1xuICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xuXG4gICAgY29uc3QgZWxlbWVudENsYXNzID0gZGF0ZXBpY2tlci5pbmxpbmUgPyAnaW5saW5lJyA6ICdkcm9wZG93bic7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGBkYXRlcGlja2VyLSR7ZWxlbWVudENsYXNzfWApO1xuICAgIGVsZW1lbnRDbGFzcyA9PT0gJ2Ryb3Bkb3duJyA/IGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZHJvcGRvd24nLCAnYWJzb2x1dGUnLCAndG9wLTAnLCAnbGVmdC0wJywgJ3otNTAnLCAncHQtMicpIDogbnVsbDtcblxuICAgIHByb2Nlc3NQaWNrZXJPcHRpb25zKHRoaXMsIGRhdGVwaWNrZXIuY29uZmlnKTtcbiAgICB0aGlzLnZpZXdEYXRlID0gY29tcHV0ZVJlc2V0Vmlld0RhdGUoZGF0ZXBpY2tlcik7XG5cbiAgICAvLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgcmVnaXN0ZXJMaXN0ZW5lcnMoZGF0ZXBpY2tlciwgW1xuICAgICAgW2VsZW1lbnQsICdjbGljaycsIG9uQ2xpY2tQaWNrZXIuYmluZChudWxsLCBkYXRlcGlja2VyKSwge2NhcHR1cmU6IHRydWV9XSxcbiAgICAgIFttYWluLCAnY2xpY2snLCBvbkNsaWNrVmlldy5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcbiAgICAgIFtjb250cm9scy52aWV3U3dpdGNoLCAnY2xpY2snLCBvbkNsaWNrVmlld1N3aXRjaC5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcbiAgICAgIFtjb250cm9scy5wcmV2QnRuLCAnY2xpY2snLCBvbkNsaWNrUHJldkJ0bi5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcbiAgICAgIFtjb250cm9scy5uZXh0QnRuLCAnY2xpY2snLCBvbkNsaWNrTmV4dEJ0bi5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcbiAgICAgIFtjb250cm9scy50b2RheUJ0biwgJ2NsaWNrJywgb25DbGlja1RvZGF5QnRuLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLFxuICAgICAgW2NvbnRyb2xzLmNsZWFyQnRuLCAnY2xpY2snLCBvbkNsaWNrQ2xlYXJCdG4uYmluZChudWxsLCBkYXRlcGlja2VyKV0sXG4gICAgXSk7XG5cbiAgICAvLyBzZXQgdXAgdmlld3NcbiAgICB0aGlzLnZpZXdzID0gW1xuICAgICAgbmV3IERheXNWaWV3KHRoaXMpLFxuICAgICAgbmV3IE1vbnRoc1ZpZXcodGhpcyksXG4gICAgICBuZXcgWWVhcnNWaWV3KHRoaXMsIHtpZDogMiwgbmFtZTogJ3llYXJzJywgY2VsbENsYXNzOiAneWVhcicsIHN0ZXA6IDF9KSxcbiAgICAgIG5ldyBZZWFyc1ZpZXcodGhpcywge2lkOiAzLCBuYW1lOiAnZGVjYWRlcycsIGNlbGxDbGFzczogJ2RlY2FkZScsIHN0ZXA6IDEwfSksXG4gICAgXTtcbiAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdGhpcy52aWV3c1tkYXRlcGlja2VyLmNvbmZpZy5zdGFydFZpZXddO1xuXG4gICAgdGhpcy5jdXJyZW50Vmlldy5yZW5kZXIoKTtcbiAgICB0aGlzLm1haW4uYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50Vmlldy5lbGVtZW50KTtcbiAgICBkYXRlcGlja2VyLmNvbmZpZy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgfVxuXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHByb2Nlc3NQaWNrZXJPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMudmlld3MuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgdmlldy5pbml0KG9wdGlvbnMsIGZhbHNlKTtcbiAgICB9KTtcbiAgICB0aGlzLmN1cnJlbnRWaWV3LnJlbmRlcigpO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5jb25maWcuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJywgJ2Jsb2NrJyk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcblxuICAgIGNvbnN0IGRhdGVwaWNrZXIgPSB0aGlzLmRhdGVwaWNrZXI7XG4gICAgaWYgKCFkYXRlcGlja2VyLmlubGluZSkge1xuICAgICAgLy8gZW5zdXJlIHBpY2tlcidzIGRpcmVjdGlvbiBtYXRjaGVzIGlucHV0J3NcbiAgICAgIGNvbnN0IGlucHV0RGlyZWN0aW9uID0gZ2V0VGV4dERpcmVjdGlvbihkYXRlcGlja2VyLmlucHV0RmllbGQpO1xuICAgICAgaWYgKGlucHV0RGlyZWN0aW9uICE9PSBnZXRUZXh0RGlyZWN0aW9uKGRhdGVwaWNrZXIuY29uZmlnLmNvbnRhaW5lcikpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmRpciA9IGlucHV0RGlyZWN0aW9uO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVsZW1lbnQuZGlyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RpcicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsYWNlKCk7XG4gICAgICBpZiAoZGF0ZXBpY2tlci5jb25maWcuZGlzYWJsZVRvdWNoS2V5Ym9hcmQpIHtcbiAgICAgICAgZGF0ZXBpY2tlci5pbnB1dEZpZWxkLmJsdXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJpZ2dlckRhdGVwaWNrZXJFdmVudChkYXRlcGlja2VyLCAnc2hvdycpO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGF0ZXBpY2tlci5leGl0RWRpdE1vZGUoKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJywgJ2Jsb2NrJyk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScsICdibG9jaycsICdoaWRkZW4nKTtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQodGhpcy5kYXRlcGlja2VyLCAnaGlkZScpO1xuICB9XG5cbiAgcGxhY2UoKSB7XG4gICAgY29uc3Qge2NsYXNzTGlzdCwgc3R5bGV9ID0gdGhpcy5lbGVtZW50O1xuICAgIGNvbnN0IHtjb25maWcsIGlucHV0RmllbGR9ID0gdGhpcy5kYXRlcGlja2VyO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXI7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGNhbGVuZGFyV2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbGVuZGFySGVpZ2h0LFxuICAgIH0gPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdDogY29udGFpbmVyTGVmdCxcbiAgICAgIHRvcDogY29udGFpbmVyVG9wLFxuICAgICAgd2lkdGg6IGNvbnRhaW5lcldpZHRoLFxuICAgIH0gPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdDogaW5wdXRMZWZ0LFxuICAgICAgdG9wOiBpbnB1dFRvcCxcbiAgICAgIHdpZHRoOiBpbnB1dFdpZHRoLFxuICAgICAgaGVpZ2h0OiBpbnB1dEhlaWdodFxuICAgIH0gPSBpbnB1dEZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB7eDogb3JpZW50WCwgeTogb3JpZW50WX0gPSBjb25maWcub3JpZW50YXRpb247XG4gICAgbGV0IHNjcm9sbFRvcDtcbiAgICBsZXQgbGVmdDtcbiAgICBsZXQgdG9wO1xuXG4gICAgaWYgKGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgc2Nyb2xsVG9wID0gd2luZG93LnNjcm9sbFk7XG4gICAgICBsZWZ0ID0gaW5wdXRMZWZ0ICsgd2luZG93LnNjcm9sbFg7XG4gICAgICB0b3AgPSBpbnB1dFRvcCArIHNjcm9sbFRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Nyb2xsVG9wID0gY29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgIGxlZnQgPSBpbnB1dExlZnQgLSBjb250YWluZXJMZWZ0O1xuICAgICAgdG9wID0gaW5wdXRUb3AgLSBjb250YWluZXJUb3AgKyBzY3JvbGxUb3A7XG4gICAgfVxuXG4gICAgaWYgKG9yaWVudFggPT09ICdhdXRvJykge1xuICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgIC8vIGFsaWduIHRvIHRoZSBsZWZ0IGFuZCBtb3ZlIGludG8gdmlzaWJsZSBhcmVhIGlmIGlucHV0J3MgbGVmdCBlZGdlIDwgd2luZG93J3NcbiAgICAgICAgb3JpZW50WCA9ICdsZWZ0JztcbiAgICAgICAgbGVmdCA9IDEwO1xuICAgICAgfSBlbHNlIGlmIChsZWZ0ICsgY2FsZW5kYXJXaWR0aCA+IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgIC8vIGFsaWduIHRvIHRoZSByaWdodCBpZiBjYW5sZW5kYXIncyByaWdodCBlZGdlID4gY29udGFpbmVyJ3NcbiAgICAgICAgb3JpZW50WCA9ICdyaWdodCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcmllbnRYID0gZ2V0VGV4dERpcmVjdGlvbihpbnB1dEZpZWxkKSA9PT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3JpZW50WCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgbGVmdCAtPSBjYWxlbmRhcldpZHRoIC0gaW5wdXRXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAob3JpZW50WSA9PT0gJ2F1dG8nKSB7XG4gICAgICBvcmllbnRZID0gdG9wIC0gY2FsZW5kYXJIZWlnaHQgPCBzY3JvbGxUb3AgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgIH1cbiAgICBpZiAob3JpZW50WSA9PT0gJ3RvcCcpIHtcbiAgICAgIHRvcCAtPSBjYWxlbmRhckhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wICs9IGlucHV0SGVpZ2h0O1xuICAgIH1cblxuICAgIGNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAnZGF0ZXBpY2tlci1vcmllbnQtdG9wJyxcbiAgICAgICdkYXRlcGlja2VyLW9yaWVudC1ib3R0b20nLFxuICAgICAgJ2RhdGVwaWNrZXItb3JpZW50LXJpZ2h0JyxcbiAgICAgICdkYXRlcGlja2VyLW9yaWVudC1sZWZ0J1xuICAgICk7XG4gICAgY2xhc3NMaXN0LmFkZChgZGF0ZXBpY2tlci1vcmllbnQtJHtvcmllbnRZfWAsIGBkYXRlcGlja2VyLW9yaWVudC0ke29yaWVudFh9YCk7XG5cbiAgICBzdHlsZS50b3AgPSB0b3AgPyBgJHt0b3B9cHhgIDogdG9wO1xuICAgIHN0eWxlLmxlZnQgPSBsZWZ0ID8gYCR7bGVmdH1weGAgOiBsZWZ0O1xuICB9XG5cbiAgc2V0Vmlld1N3aXRjaExhYmVsKGxhYmVsVGV4dCkge1xuICAgIHRoaXMuY29udHJvbHMudmlld1N3aXRjaC50ZXh0Q29udGVudCA9IGxhYmVsVGV4dDtcbiAgfVxuXG4gIHNldFByZXZCdG5EaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIHRoaXMuY29udHJvbHMucHJldkJ0bi5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICB9XG5cbiAgc2V0TmV4dEJ0bkRpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgdGhpcy5jb250cm9scy5uZXh0QnRuLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gIH1cblxuICBjaGFuZ2VWaWV3KHZpZXdJZCkge1xuICAgIGNvbnN0IG9sZFZpZXcgPSB0aGlzLmN1cnJlbnRWaWV3O1xuICAgIGNvbnN0IG5ld1ZpZXcgPSAgdGhpcy52aWV3c1t2aWV3SWRdO1xuICAgIGlmIChuZXdWaWV3LmlkICE9PSBvbGRWaWV3LmlkKSB7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gbmV3VmlldztcbiAgICAgIHRoaXMuX3JlbmRlck1ldGhvZCA9ICdyZW5kZXInO1xuICAgICAgdHJpZ2dlckRhdGVwaWNrZXJFdmVudCh0aGlzLmRhdGVwaWNrZXIsICdjaGFuZ2VWaWV3Jyk7XG4gICAgICB0aGlzLm1haW4ucmVwbGFjZUNoaWxkKG5ld1ZpZXcuZWxlbWVudCwgb2xkVmlldy5lbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBDaGFuZ2UgdGhlIGZvY3VzZWQgZGF0ZSAodmlldyBkYXRlKVxuICBjaGFuZ2VGb2N1cyhuZXdWaWV3RGF0ZSkge1xuICAgIHRoaXMuX3JlbmRlck1ldGhvZCA9IHNldFZpZXdEYXRlKHRoaXMsIG5ld1ZpZXdEYXRlKSA/ICdyZW5kZXInIDogJ3JlZnJlc2hGb2N1cyc7XG4gICAgdGhpcy52aWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICB2aWV3LnVwZGF0ZUZvY3VzKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBBcHBseSB0aGUgY2hhbmdlIG9mIHRoZSBzZWxlY3RlZCBkYXRlc1xuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgbmV3Vmlld0RhdGUgPSBjb21wdXRlUmVzZXRWaWV3RGF0ZSh0aGlzLmRhdGVwaWNrZXIpO1xuICAgIHRoaXMuX3JlbmRlck1ldGhvZCA9IHNldFZpZXdEYXRlKHRoaXMsIG5ld1ZpZXdEYXRlKSA/ICdyZW5kZXInIDogJ3JlZnJlc2gnO1xuICAgIHRoaXMudmlld3MuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgdmlldy51cGRhdGVGb2N1cygpO1xuICAgICAgdmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFJlZnJlc2ggdGhlIHBpY2tlciBVSVxuICByZW5kZXIocXVpY2tSZW5kZXIgPSB0cnVlKSB7XG4gICAgY29uc3QgcmVuZGVyTWV0aG9kID0gKHF1aWNrUmVuZGVyICYmIHRoaXMuX3JlbmRlck1ldGhvZCkgfHwgJ3JlbmRlcic7XG4gICAgZGVsZXRlIHRoaXMuX3JlbmRlck1ldGhvZDtcblxuICAgIHRoaXMuY3VycmVudFZpZXdbcmVuZGVyTWV0aG9kXSgpO1xuICB9XG59XG4iLCJpbXBvcnQge2NyZWF0ZVRhZ1JlcGVhdCwgb3B0aW1pemVUZW1wbGF0ZUhUTUx9IGZyb20gJy4uLy4uL2xpYi91dGlscy5qcyc7XG5cbmNvbnN0IGNhbGVuZGFyV2Vla3NUZW1wbGF0ZSA9IG9wdGltaXplVGVtcGxhdGVIVE1MKGA8ZGl2IGNsYXNzPVwiY2FsZW5kYXItd2Vla3NcIj5cbiAgPGRpdiBjbGFzcz1cImRheXMtb2Ytd2VlayBmbGV4XCI+PHNwYW4gY2xhc3M9XCJkb3cgaC02IGxlYWRpbmctNiB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktNDAwXCI+PC9zcGFuPjwvZGl2PlxuICA8ZGl2IGNsYXNzPVwid2Vla3NcIj4ke2NyZWF0ZVRhZ1JlcGVhdCgnc3BhbicsIDYsIHtjbGFzczogJ3dlZWsgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1kZWZhdWx0IHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZm9udC1zZW1pYm9sZCB0ZXh0LXNtJ30pfTwvZGl2PlxuPC9kaXY+YCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNhbGVuZGFyV2Vla3NUZW1wbGF0ZTtcbiIsImltcG9ydCB7Y3JlYXRlVGFnUmVwZWF0LCBvcHRpbWl6ZVRlbXBsYXRlSFRNTH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzLmpzJztcblxuY29uc3QgZGF5c1RlbXBsYXRlID0gb3B0aW1pemVUZW1wbGF0ZUhUTUwoYDxkaXYgY2xhc3M9XCJkYXlzXCI+XG4gIDxkaXYgY2xhc3M9XCJkYXlzLW9mLXdlZWsgZ3JpZCBncmlkLWNvbHMtNyBtYi0xXCI+JHtjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA3LCB7Y2xhc3M6ICdkb3cgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1kZWZhdWx0IHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZm9udC1zZW1pYm9sZCB0ZXh0LXNtJ30pfTwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1ncmlkIHctNjQgZ3JpZCBncmlkLWNvbHMtN1wiPiR7Y3JlYXRlVGFnUmVwZWF0KCdzcGFuJywgNDIgLCB7Y2xhc3M6ICdibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLWRlZmF1bHQgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBmb250LXNlbWlib2xkIHRleHQtc20gaC02IGxlYWRpbmctNiB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktNDAwJ30pfTwvZGl2PlxuPC9kaXY+YCk7XG5cbmV4cG9ydCBkZWZhdWx0IGRheXNUZW1wbGF0ZTtcbiIsImltcG9ydCB7b3B0aW1pemVUZW1wbGF0ZUhUTUx9IGZyb20gJy4uLy4uL2xpYi91dGlscy5qcyc7XG5cbmNvbnN0IHBpY2tlclRlbXBsYXRlID0gb3B0aW1pemVUZW1wbGF0ZUhUTUwoYDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyIGhpZGRlblwiPlxuICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1waWNrZXIgaW5saW5lLWJsb2NrIHJvdW5kZWQtbGcgYmctd2hpdGUgZGFyazpiZy1ncmF5LTcwMCBzaGFkb3ctbGcgcC00XCI+XG4gICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItaGVhZGVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci10aXRsZSBiZy13aGl0ZSBkYXJrOmJnLWdyYXktNzAwIGRhcms6dGV4dC13aGl0ZSBweC0yIHB5LTMgdGV4dC1jZW50ZXIgZm9udC1zZW1pYm9sZFwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItY29udHJvbHMgZmxleCBqdXN0aWZ5LWJldHdlZW4gbWItMlwiPlxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgcm91bmRlZC1sZyB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC13aGl0ZSBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGhvdmVyOnRleHQtZ3JheS05MDAgZGFyazpob3Zlcjp0ZXh0LXdoaXRlIHRleHQtbGcgcC0yLjUgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktMjAwIHByZXYtYnRuXCI+PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwidGV4dC1zbSByb3VuZGVkLWxnIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgZm9udC1zZW1pYm9sZCBweS0yLjUgcHgtNSBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTIwMCB2aWV3LXN3aXRjaFwiPjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgcm91bmRlZC1sZyB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC13aGl0ZSBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGhvdmVyOnRleHQtZ3JheS05MDAgZGFyazpob3Zlcjp0ZXh0LXdoaXRlIHRleHQtbGcgcC0yLjUgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktMjAwIG5leHQtYnRuXCI+PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1tYWluIHAtMVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWZvb3RlclwiPlxuICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItY29udHJvbHMgZmxleCBzcGFjZS14LTIgbXQtMlwiPlxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiVidXR0b25DbGFzcyUgdG9kYXktYnRuIHRleHQtd2hpdGUgYmctYmx1ZS03MDAgZGFyazpiZy1ibHVlLTYwMCBob3ZlcjpiZy1ibHVlLTgwMCBkYXJrOmhvdmVyOmJnLWJsdWUtNzAwIGZvY3VzOnJpbmctNCBmb2N1czpyaW5nLWJsdWUtMzAwIGZvbnQtbWVkaXVtIHJvdW5kZWQtbGcgdGV4dC1zbSBweC01IHB5LTIgdGV4dC1jZW50ZXIgdy0xLzJcIj48L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIlYnV0dG9uQ2xhc3MlIGNsZWFyLWJ0biB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC13aGl0ZSBiZy13aGl0ZSBkYXJrOmJnLWdyYXktNzAwIGJvcmRlciBib3JkZXItZ3JheS0zMDAgZGFyazpib3JkZXItZ3JheS02MDAgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBmb2N1czpyaW5nLTQgZm9jdXM6cmluZy1ibHVlLTMwMCBmb250LW1lZGl1bSByb3VuZGVkLWxnIHRleHQtc20gcHgtNSBweS0yIHRleHQtY2VudGVyIHctMS8yXCI+PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5gKTtcblxuZXhwb3J0IGRlZmF1bHQgcGlja2VyVGVtcGxhdGU7XG4iLCJpbXBvcnQge2hhc1Byb3BlcnR5LCBwdXNoVW5pcXVlfSBmcm9tICcuLi8uLi9saWIvdXRpbHMuanMnO1xuaW1wb3J0IHt0b2RheSwgZGF0ZVZhbHVlLCBhZGREYXlzLCBhZGRXZWVrcywgZGF5T2ZUaGVXZWVrT2YsIGdldFdlZWt9IGZyb20gJy4uLy4uL2xpYi9kYXRlLmpzJztcbmltcG9ydCB7Zm9ybWF0RGF0ZX0gZnJvbSAnLi4vLi4vbGliL2RhdGUtZm9ybWF0LmpzJztcbmltcG9ydCB7cGFyc2VIVE1MLCBzaG93RWxlbWVudCwgaGlkZUVsZW1lbnR9IGZyb20gJy4uLy4uL2xpYi9kb20uanMnO1xuaW1wb3J0IGRheXNUZW1wbGF0ZSBmcm9tICcuLi90ZW1wbGF0ZXMvZGF5c1RlbXBsYXRlLmpzJztcbmltcG9ydCBjYWxlbmRhcldlZWtzVGVtcGxhdGUgZnJvbSAnLi4vdGVtcGxhdGVzL2NhbGVuZGFyV2Vla3NUZW1wbGF0ZS5qcyc7XG5pbXBvcnQgVmlldyBmcm9tICcuL1ZpZXcuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXlzVmlldyBleHRlbmRzIFZpZXcge1xuICBjb25zdHJ1Y3RvcihwaWNrZXIpIHtcbiAgICBzdXBlcihwaWNrZXIsIHtcbiAgICAgIGlkOiAwLFxuICAgICAgbmFtZTogJ2RheXMnLFxuICAgICAgY2VsbENsYXNzOiAnZGF5JyxcbiAgICB9KTtcbiAgfVxuXG4gIGluaXQob3B0aW9ucywgb25Db25zdHJ1Y3Rpb24gPSB0cnVlKSB7XG4gICAgaWYgKG9uQ29uc3RydWN0aW9uKSB7XG4gICAgICBjb25zdCBpbm5lciA9IHBhcnNlSFRNTChkYXlzVGVtcGxhdGUpLmZpcnN0Q2hpbGQ7XG4gICAgICB0aGlzLmRvdyA9IGlubmVyLmZpcnN0Q2hpbGQ7XG4gICAgICB0aGlzLmdyaWQgPSBpbm5lci5sYXN0Q2hpbGQ7XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgIH1cbiAgICBzdXBlci5pbml0KG9wdGlvbnMpO1xuICB9XG5cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgbGV0IHVwZGF0ZURPVztcblxuICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWluRGF0ZScpKSB7XG4gICAgICB0aGlzLm1pbkRhdGUgPSBvcHRpb25zLm1pbkRhdGU7XG4gICAgfVxuICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWF4RGF0ZScpKSB7XG4gICAgICB0aGlzLm1heERhdGUgPSBvcHRpb25zLm1heERhdGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRhdGVzRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGF0ZXNEaXNhYmxlZCA9IG9wdGlvbnMuZGF0ZXNEaXNhYmxlZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGF5c09mV2Vla0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmRheXNPZldlZWtEaXNhYmxlZCA9IG9wdGlvbnMuZGF5c09mV2Vla0Rpc2FibGVkO1xuICAgICAgdXBkYXRlRE9XID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGF5c09mV2Vla0hpZ2hsaWdodGVkKSB7XG4gICAgICB0aGlzLmRheXNPZldlZWtIaWdobGlnaHRlZCA9IG9wdGlvbnMuZGF5c09mV2Vla0hpZ2hsaWdodGVkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50b2RheUhpZ2hsaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRvZGF5SGlnaGxpZ2h0ID0gb3B0aW9ucy50b2RheUhpZ2hsaWdodDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud2Vla1N0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2Vla1N0YXJ0ID0gb3B0aW9ucy53ZWVrU3RhcnQ7XG4gICAgICB0aGlzLndlZWtFbmQgPSBvcHRpb25zLndlZWtFbmQ7XG4gICAgICB1cGRhdGVET1cgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sb2NhbGUpIHtcbiAgICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMubG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gICAgICB0aGlzLmRheU5hbWVzID0gbG9jYWxlLmRheXNNaW47XG4gICAgICB0aGlzLnN3aXRjaExhYmVsRm9ybWF0ID0gbG9jYWxlLnRpdGxlRm9ybWF0O1xuICAgICAgdXBkYXRlRE9XID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYmVmb3JlU2hvd0RheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmJlZm9yZVNob3cgPSB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTaG93RGF5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3B0aW9ucy5iZWZvcmVTaG93RGF5XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNhbGVuZGFyV2Vla3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdGlvbnMuY2FsZW5kYXJXZWVrcyAmJiAhdGhpcy5jYWxlbmRhcldlZWtzKSB7XG4gICAgICAgIGNvbnN0IHdlZWtzRWxlbSA9IHBhcnNlSFRNTChjYWxlbmRhcldlZWtzVGVtcGxhdGUpLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJXZWVrcyA9IHtcbiAgICAgICAgICBlbGVtZW50OiB3ZWVrc0VsZW0sXG4gICAgICAgICAgZG93OiB3ZWVrc0VsZW0uZmlyc3RDaGlsZCxcbiAgICAgICAgICB3ZWVrczogd2Vla3NFbGVtLmxhc3RDaGlsZCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZSh3ZWVrc0VsZW0sIHRoaXMuZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jYWxlbmRhcldlZWtzICYmICFvcHRpb25zLmNhbGVuZGFyV2Vla3MpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuY2FsZW5kYXJXZWVrcy5lbGVtZW50KTtcbiAgICAgICAgdGhpcy5jYWxlbmRhcldlZWtzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2hvd0RheXNPZldlZWsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdGlvbnMuc2hvd0RheXNPZldlZWspIHtcbiAgICAgICAgc2hvd0VsZW1lbnQodGhpcy5kb3cpO1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhcldlZWtzKSB7XG4gICAgICAgICAgc2hvd0VsZW1lbnQodGhpcy5jYWxlbmRhcldlZWtzLmRvdyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpZGVFbGVtZW50KHRoaXMuZG93KTtcbiAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXJXZWVrcykge1xuICAgICAgICAgIGhpZGVFbGVtZW50KHRoaXMuY2FsZW5kYXJXZWVrcy5kb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGRheXMtb2Ytd2VlayB3aGVuIGxvY2FsZSwgZGF5c09md2Vla0Rpc2FibGVkIG9yIHdlZWtTdGFydCBpcyBjaGFuZ2VkXG4gICAgaWYgKHVwZGF0ZURPVykge1xuICAgICAgQXJyYXkuZnJvbSh0aGlzLmRvdy5jaGlsZHJlbikuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGRvdyA9ICh0aGlzLndlZWtTdGFydCArIGluZGV4KSAlIDc7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGhpcy5kYXlOYW1lc1tkb3ddO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSB0aGlzLmRheXNPZldlZWtEaXNhYmxlZC5pbmNsdWRlcyhkb3cpID8gJ2RvdyBkaXNhYmxlZCB0ZXh0LWNlbnRlciBoLTYgbGVhZGluZy02IHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDAgY3Vyc29yLW5vdC1hbGxvd2VkJyA6ICdkb3cgdGV4dC1jZW50ZXIgaC02IGxlYWRpbmctNiB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktNDAwJztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFwcGx5IHVwZGF0ZSBvbiB0aGUgZm9jdXNlZCBkYXRlIHRvIHZpZXcncyBzZXR0aW5nc1xuICB1cGRhdGVGb2N1cygpIHtcbiAgICBjb25zdCB2aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMucGlja2VyLnZpZXdEYXRlKTtcbiAgICBjb25zdCB2aWV3WWVhciA9IHZpZXdEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgY29uc3Qgdmlld01vbnRoID0gdmlld0RhdGUuZ2V0TW9udGgoKTtcbiAgICBjb25zdCBmaXJzdE9mTW9udGggPSBkYXRlVmFsdWUodmlld1llYXIsIHZpZXdNb250aCwgMSk7XG4gICAgY29uc3Qgc3RhcnQgPSBkYXlPZlRoZVdlZWtPZihmaXJzdE9mTW9udGgsIHRoaXMud2Vla1N0YXJ0LCB0aGlzLndlZWtTdGFydCk7XG5cbiAgICB0aGlzLmZpcnN0ID0gZmlyc3RPZk1vbnRoO1xuICAgIHRoaXMubGFzdCA9IGRhdGVWYWx1ZSh2aWV3WWVhciwgdmlld01vbnRoICsgMSwgMCk7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZm9jdXNlZCA9IHRoaXMucGlja2VyLnZpZXdEYXRlO1xuICB9XG5cbiAgLy8gQXBwbHkgdXBkYXRlIG9uIHRoZSBzZWxlY3RlZCBkYXRlcyB0byB2aWV3J3Mgc2V0dGluZ3NcbiAgdXBkYXRlU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHtkYXRlcywgcmFuZ2VwaWNrZXJ9ID0gdGhpcy5waWNrZXIuZGF0ZXBpY2tlcjtcbiAgICB0aGlzLnNlbGVjdGVkID0gZGF0ZXM7XG4gICAgaWYgKHJhbmdlcGlja2VyKSB7XG4gICAgICB0aGlzLnJhbmdlID0gcmFuZ2VwaWNrZXIuZGF0ZXM7XG4gICAgfVxuICB9XG5cbiAgIC8vIFVwZGF0ZSB0aGUgZW50aXJlIHZpZXcgVUlcbiAgcmVuZGVyKCkge1xuICAgIC8vIHVwZGF0ZSB0b2RheSBtYXJrZXIgb24gZXZlciByZW5kZXJcbiAgICB0aGlzLnRvZGF5ID0gdGhpcy50b2RheUhpZ2hsaWdodCA/IHRvZGF5KCkgOiB1bmRlZmluZWQ7XG4gICAgLy8gcmVmcmVzaCBkaXNhYmxlZCBkYXRlcyBvbiBldmVyeSByZW5kZXIgaW4gb3JkZXIgdG8gY2xlYXIgdGhlIG9uZXMgYWRkZWRcbiAgICAvLyBieSBiZWZvcmVTaG93IGhvb2sgYXQgcHJldmlvdXMgcmVuZGVyXG4gICAgdGhpcy5kaXNhYmxlZCA9IFsuLi50aGlzLmRhdGVzRGlzYWJsZWRdO1xuXG4gICAgY29uc3Qgc3dpdGNoTGFiZWwgPSBmb3JtYXREYXRlKHRoaXMuZm9jdXNlZCwgdGhpcy5zd2l0Y2hMYWJlbEZvcm1hdCwgdGhpcy5sb2NhbGUpO1xuICAgIHRoaXMucGlja2VyLnNldFZpZXdTd2l0Y2hMYWJlbChzd2l0Y2hMYWJlbCk7XG4gICAgdGhpcy5waWNrZXIuc2V0UHJldkJ0bkRpc2FibGVkKHRoaXMuZmlyc3QgPD0gdGhpcy5taW5EYXRlKTtcbiAgICB0aGlzLnBpY2tlci5zZXROZXh0QnRuRGlzYWJsZWQodGhpcy5sYXN0ID49IHRoaXMubWF4RGF0ZSk7XG5cbiAgICBpZiAodGhpcy5jYWxlbmRhcldlZWtzKSB7XG4gICAgICAvLyBzdGFydCBvZiB0aGUgVVRDIHdlZWsgKE1vbmRheSkgb2YgdGhlIDFzdCBvZiB0aGUgbW9udGhcbiAgICAgIGNvbnN0IHN0YXJ0T2ZXZWVrID0gZGF5T2ZUaGVXZWVrT2YodGhpcy5maXJzdCwgMSwgMSk7XG4gICAgICBBcnJheS5mcm9tKHRoaXMuY2FsZW5kYXJXZWVrcy53ZWVrcy5jaGlsZHJlbikuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gZ2V0V2VlayhhZGRXZWVrcyhzdGFydE9mV2VlaywgaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICBjb25zdCBjdXJyZW50ID0gYWRkRGF5cyh0aGlzLnN0YXJ0LCBpbmRleCk7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoY3VycmVudCk7XG4gICAgICBjb25zdCBkYXkgPSBkYXRlLmdldERheSgpO1xuXG4gICAgICBlbC5jbGFzc05hbWUgPSBgZGF0ZXBpY2tlci1jZWxsIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1wb2ludGVyIHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSAke3RoaXMuY2VsbENsYXNzfWA7XG4gICAgICBlbC5kYXRhc2V0LmRhdGUgPSBjdXJyZW50O1xuICAgICAgZWwudGV4dENvbnRlbnQgPSBkYXRlLmdldERhdGUoKTtcblxuICAgICAgaWYgKGN1cnJlbnQgPCB0aGlzLmZpcnN0KSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3ByZXYnLCAndGV4dC1ncmF5LTUwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudCA+IHRoaXMubGFzdCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCduZXh0JywgJ3RleHQtZ3JheS01MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50b2RheSA9PT0gY3VycmVudCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCd0b2RheScsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA8IHRoaXMubWluRGF0ZSB8fCBjdXJyZW50ID4gdGhpcy5tYXhEYXRlIHx8IHRoaXMuZGlzYWJsZWQuaW5jbHVkZXMoY3VycmVudCkpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnLCAnY3Vyc29yLW5vdC1hbGxvd2VkJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXlzT2ZXZWVrRGlzYWJsZWQuaW5jbHVkZXMoZGF5KSkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcsICdjdXJzb3Itbm90LWFsbG93ZWQnKTtcbiAgICAgICAgcHVzaFVuaXF1ZSh0aGlzLmRpc2FibGVkLCBjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRheXNPZldlZWtIaWdobGlnaHRlZC5pbmNsdWRlcyhkYXkpKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2hpZ2hsaWdodGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yYW5nZSkge1xuICAgICAgICBjb25zdCBbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdID0gdGhpcy5yYW5nZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPiByYW5nZVN0YXJ0ICYmIGN1cnJlbnQgPCByYW5nZUVuZCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcbiAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdyb3VuZGVkLWxnJywgJ3JvdW5kZWQtbC1sZycsICdyb3VuZGVkLXItbGcnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnLCAnYmctZ3JheS0xMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcsICdyb3VuZGVkLWwtbGcnKTtcbiAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdyb3VuZGVkLWxnJywgJ3JvdW5kZWQtci1sZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZUVuZCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLWVuZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtci1sZycpO1xuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1sLWxnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICd0ZXh0LWdyYXktNTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJywgJ2Rhcms6YmctZ3JheS02MDAnLCAnYmctZ3JheS0xMDAnLCAnYmctZ3JheS0yMDAnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5iZWZvcmVTaG93KSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUJlZm9yZUhvb2soZWwsIGN1cnJlbnQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2VzIG9mIHNlbGVjdGVkIGFuZCBmb2N1c2VkIGl0ZW1zXG4gIHJlZnJlc2goKSB7XG4gICAgY29uc3QgW3JhbmdlU3RhcnQsIHJhbmdlRW5kXSA9IHRoaXMucmFuZ2UgfHwgW107XG4gICAgdGhpcy5ncmlkXG4gICAgICAucXVlcnlTZWxlY3RvckFsbCgnLnJhbmdlLCAucmFuZ2Utc3RhcnQsIC5yYW5nZS1lbmQsIC5zZWxlY3RlZCwgLmZvY3VzZWQnKVxuICAgICAgLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3JhbmdlJywgJ3JhbmdlLXN0YXJ0JywgJ3JhbmdlLWVuZCcsICdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ2ZvY3VzZWQnKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgndGV4dC1ncmF5LTkwMCcsICdyb3VuZGVkLWxnJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xuICAgICAgfSk7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmdyaWQuY2hpbGRyZW4pLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gTnVtYmVyKGVsLmRhdGFzZXQuZGF0ZSk7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKCdiZy1ncmF5LTIwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtbC1sZycsICdyb3VuZGVkLXItbGcnKVxuICAgICAgaWYgKGN1cnJlbnQgPiByYW5nZVN0YXJ0ICYmIGN1cnJlbnQgPCByYW5nZUVuZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZScsICdiZy1ncmF5LTIwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLXN0YXJ0JywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnLCAncm91bmRlZC1sLWxnJyk7XG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1yLWxnJyk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnLCAncm91bmRlZC1yLWxnJyk7XG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1sLWxnJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtZ3JheS05MDAnLCAnaG92ZXI6YmctZ3JheS0xMDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ2Rhcms6aG92ZXI6YmctZ3JheS02MDAnLCAnYmctZ3JheS0xMDAnLCAnYmctZ3JheS0yMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZm9jdXNlZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZSBvZiBmb2N1c2VkIGl0ZW1cbiAgcmVmcmVzaEZvY3VzKCkge1xuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5yb3VuZCgodGhpcy5mb2N1c2VkIC0gdGhpcy5zdGFydCkgLyA4NjQwMDAwMCk7XG4gICAgdGhpcy5ncmlkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb2N1c2VkJykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZvY3VzZWQnKTtcbiAgICB9KTtcbiAgICB0aGlzLmdyaWQuY2hpbGRyZW5baW5kZXhdLmNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtoYXNQcm9wZXJ0eSwgcHVzaFVuaXF1ZSwgY3JlYXRlVGFnUmVwZWF0fSBmcm9tICcuLi8uLi9saWIvdXRpbHMuanMnO1xuaW1wb3J0IHtkYXRlVmFsdWV9IGZyb20gJy4uLy4uL2xpYi9kYXRlLmpzJztcbmltcG9ydCB7cGFyc2VIVE1MfSBmcm9tICcuLi8uLi9saWIvZG9tLmpzJztcbmltcG9ydCBWaWV3IGZyb20gJy4vVmlldy5qcyc7XG5cbmZ1bmN0aW9uIGNvbXB1dGVNb250aFJhbmdlKHJhbmdlLCB0aGlzWWVhcikge1xuICBpZiAoIXJhbmdlIHx8ICFyYW5nZVswXSB8fCAhcmFuZ2VbMV0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBbW3N0YXJ0WSwgc3RhcnRNXSwgW2VuZFksIGVuZE1dXSA9IHJhbmdlO1xuICBpZiAoc3RhcnRZID4gdGhpc1llYXIgfHwgZW5kWSA8IHRoaXNZZWFyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBbXG4gICAgc3RhcnRZID09PSB0aGlzWWVhciA/IHN0YXJ0TSA6IC0xLFxuICAgIGVuZFkgPT09IHRoaXNZZWFyID8gZW5kTSA6IDEyLFxuICBdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb250aHNWaWV3IGV4dGVuZHMgVmlldyB7XG4gIGNvbnN0cnVjdG9yKHBpY2tlcikge1xuICAgIHN1cGVyKHBpY2tlciwge1xuICAgICAgaWQ6IDEsXG4gICAgICBuYW1lOiAnbW9udGhzJyxcbiAgICAgIGNlbGxDbGFzczogJ21vbnRoJyxcbiAgICB9KTtcbiAgfVxuXG4gIGluaXQob3B0aW9ucywgb25Db25zdHJ1Y3Rpb24gPSB0cnVlKSB7XG4gICAgaWYgKG9uQ29uc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmdyaWQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbW9udGhzJywgJ2RhdGVwaWNrZXItZ3JpZCcsICd3LTY0JywgJ2dyaWQnLCAnZ3JpZC1jb2xzLTQnKTtcbiAgICAgIHRoaXMuZ3JpZC5hcHBlbmRDaGlsZChwYXJzZUhUTUwoY3JlYXRlVGFnUmVwZWF0KCdzcGFuJywgMTIsIHsnZGF0YS1tb250aCc6IGl4ID0+IGl4fSkpKTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChvcHRpb25zKTtcbiAgfVxuXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmxvY2FsZSkge1xuICAgICAgdGhpcy5tb250aE5hbWVzID0gb3B0aW9ucy5sb2NhbGUubW9udGhzU2hvcnQ7XG4gICAgfVxuICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWluRGF0ZScpKSB7XG4gICAgICBpZiAob3B0aW9ucy5taW5EYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5taW5ZZWFyID0gdGhpcy5taW5Nb250aCA9IHRoaXMubWluRGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pbkRhdGVPYmogPSBuZXcgRGF0ZShvcHRpb25zLm1pbkRhdGUpO1xuICAgICAgICB0aGlzLm1pblllYXIgPSBtaW5EYXRlT2JqLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHRoaXMubWluTW9udGggPSBtaW5EYXRlT2JqLmdldE1vbnRoKCk7XG4gICAgICAgIHRoaXMubWluRGF0ZSA9IG1pbkRhdGVPYmouc2V0RGF0ZSgxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtYXhEYXRlJykpIHtcbiAgICAgIGlmIChvcHRpb25zLm1heERhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1heFllYXIgPSB0aGlzLm1heE1vbnRoID0gdGhpcy5tYXhEYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4RGF0ZU9iaiA9IG5ldyBEYXRlKG9wdGlvbnMubWF4RGF0ZSk7XG4gICAgICAgIHRoaXMubWF4WWVhciA9IG1heERhdGVPYmouZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgdGhpcy5tYXhNb250aCA9IG1heERhdGVPYmouZ2V0TW9udGgoKTtcbiAgICAgICAgdGhpcy5tYXhEYXRlID0gZGF0ZVZhbHVlKHRoaXMubWF4WWVhciwgdGhpcy5tYXhNb250aCArIDEsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5iZWZvcmVTaG93TW9udGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5iZWZvcmVTaG93ID0gdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2hvd01vbnRoID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3B0aW9ucy5iZWZvcmVTaG93TW9udGhcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIHZpZXcncyBzZXR0aW5ncyB0byByZWZsZWN0IHRoZSB2aWV3RGF0ZSBzZXQgb24gdGhlIHBpY2tlclxuICB1cGRhdGVGb2N1cygpIHtcbiAgICBjb25zdCB2aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMucGlja2VyLnZpZXdEYXRlKTtcbiAgICB0aGlzLnllYXIgPSB2aWV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIHRoaXMuZm9jdXNlZCA9IHZpZXdEYXRlLmdldE1vbnRoKCk7XG4gIH1cblxuICAvLyBVcGRhdGUgdmlldydzIHNldHRpbmdzIHRvIHJlZmxlY3QgdGhlIHNlbGVjdGVkIGRhdGVzXG4gIHVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7ZGF0ZXMsIHJhbmdlcGlja2VyfSA9IHRoaXMucGlja2VyLmRhdGVwaWNrZXI7XG4gICAgdGhpcy5zZWxlY3RlZCA9IGRhdGVzLnJlZHVjZSgoc2VsZWN0ZWQsIHRpbWVWYWx1ZSkgPT4ge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWVWYWx1ZSk7XG4gICAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgY29uc3QgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgICBpZiAoc2VsZWN0ZWRbeWVhcl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxlY3RlZFt5ZWFyXSA9IFttb250aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoVW5pcXVlKHNlbGVjdGVkW3llYXJdLCBtb250aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfSwge30pO1xuICAgIGlmIChyYW5nZXBpY2tlciAmJiByYW5nZXBpY2tlci5kYXRlcykge1xuICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlcGlja2VyLmRhdGVzLm1hcCh0aW1lVmFsdWUgPT4ge1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gdW5kZWZpbmVkIDogW2RhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgZW50aXJlIHZpZXcgVUlcbiAgcmVuZGVyKCkge1xuICAgIC8vIHJlZnJlc2ggZGlzYWJsZWQgbW9udGhzIG9uIGV2ZXJ5IHJlbmRlciBpbiBvcmRlciB0byBjbGVhciB0aGUgb25lcyBhZGRlZFxuICAgIC8vIGJ5IGJlZm9yZVNob3cgaG9vayBhdCBwcmV2aW91cyByZW5kZXJcbiAgICB0aGlzLmRpc2FibGVkID0gW107XG5cbiAgICB0aGlzLnBpY2tlci5zZXRWaWV3U3dpdGNoTGFiZWwodGhpcy55ZWFyKTtcbiAgICB0aGlzLnBpY2tlci5zZXRQcmV2QnRuRGlzYWJsZWQodGhpcy55ZWFyIDw9IHRoaXMubWluWWVhcik7XG4gICAgdGhpcy5waWNrZXIuc2V0TmV4dEJ0bkRpc2FibGVkKHRoaXMueWVhciA+PSB0aGlzLm1heFllYXIpO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkW3RoaXMueWVhcl0gfHwgW107XG4gICAgY29uc3QgeXJPdXRPZlJhbmdlID0gdGhpcy55ZWFyIDwgdGhpcy5taW5ZZWFyIHx8IHRoaXMueWVhciA+IHRoaXMubWF4WWVhcjtcbiAgICBjb25zdCBpc01pblllYXIgPSB0aGlzLnllYXIgPT09IHRoaXMubWluWWVhcjtcbiAgICBjb25zdCBpc01heFllYXIgPSB0aGlzLnllYXIgPT09IHRoaXMubWF4WWVhcjtcbiAgICBjb25zdCByYW5nZSA9IGNvbXB1dGVNb250aFJhbmdlKHRoaXMucmFuZ2UsIHRoaXMueWVhcik7XG5cbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICBjb25zdCBkYXRlID0gZGF0ZVZhbHVlKHRoaXMueWVhciwgaW5kZXgsIDEpO1xuXG4gICAgICBlbC5jbGFzc05hbWUgPSBgZGF0ZXBpY2tlci1jZWxsIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1wb2ludGVyIHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSAke3RoaXMuY2VsbENsYXNzfWA7XG4gICAgICBpZiAodGhpcy5pc01pblZpZXcpIHtcbiAgICAgICAgZWwuZGF0YXNldC5kYXRlID0gZGF0ZTtcbiAgICAgIH1cbiAgICAgIC8vIHJlc2V0IHRleHQgb24gZXZlcnkgcmVuZGVyIHRvIGNsZWFyIHRoZSBjdXN0b20gY29udGVudCBzZXRcbiAgICAgIC8vIGJ5IGJlZm9yZVNob3cgaG9vayBhdCBwcmV2aW91cyByZW5kZXJcbiAgICAgIGVsLnRleHRDb250ZW50ID0gdGhpcy5tb250aE5hbWVzW2luZGV4XTtcblxuICAgICAgaWYgKFxuICAgICAgICB5ck91dE9mUmFuZ2VcbiAgICAgICAgfHwgaXNNaW5ZZWFyICYmIGluZGV4IDwgdGhpcy5taW5Nb250aFxuICAgICAgICB8fCBpc01heFllYXIgJiYgaW5kZXggPiB0aGlzLm1heE1vbnRoXG4gICAgICApIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICBjb25zdCBbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdID0gcmFuZ2U7XG4gICAgICAgIGlmIChpbmRleCA+IHJhbmdlU3RhcnQgJiYgaW5kZXggPCByYW5nZUVuZCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IHJhbmdlRW5kKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZC5pbmNsdWRlcyhpbmRleCkpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyYXktOTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMuZm9jdXNlZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJlZm9yZVNob3cpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtQmVmb3JlSG9vayhlbCwgaW5kZXgsIGRhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2VzIG9mIHNlbGVjdGVkIGFuZCBmb2N1c2VkIGl0ZW1zXG4gIHJlZnJlc2goKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkW3RoaXMueWVhcl0gfHwgW107XG4gICAgY29uc3QgW3JhbmdlU3RhcnQsIHJhbmdlRW5kXSA9IGNvbXB1dGVNb250aFJhbmdlKHRoaXMucmFuZ2UsIHRoaXMueWVhcikgfHwgW107XG4gICAgdGhpcy5ncmlkXG4gICAgICAucXVlcnlTZWxlY3RvckFsbCgnLnJhbmdlLCAucmFuZ2Utc3RhcnQsIC5yYW5nZS1lbmQsIC5zZWxlY3RlZCwgLmZvY3VzZWQnKVxuICAgICAgLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3JhbmdlJywgJ3JhbmdlLXN0YXJ0JywgJ3JhbmdlLWVuZCcsICdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICd0ZXh0LXdoaXRlJywgJ2ZvY3VzZWQnKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xuICAgICAgfSk7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmdyaWQuY2hpbGRyZW4pLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xuICAgICAgaWYgKGluZGV4ID4gcmFuZ2VTdGFydCAmJiBpbmRleCA8IHJhbmdlRW5kKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPT09IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJyk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQuaW5jbHVkZXMoaW5kZXgpKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2Ugb2YgZm9jdXNlZCBpdGVtXG4gIHJlZnJlc2hGb2N1cygpIHtcbiAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmZvY3VzZWQnKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXNlZCcpO1xuICAgIH0pO1xuICAgIHRoaXMuZ3JpZC5jaGlsZHJlblt0aGlzLmZvY3VzZWRdLmNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgfVxufSIsImltcG9ydCB7cHVzaFVuaXF1ZX0gZnJvbSAnLi4vLi4vbGliL3V0aWxzLmpzJztcbmltcG9ydCB7cGFyc2VIVE1MLCByZXBsYWNlQ2hpbGROb2Rlc30gZnJvbSAnLi4vLi4vbGliL2RvbS5qcyc7XG5cbi8vIEJhc2UgY2xhc3Mgb2YgdGhlIHZpZXcgY2xhc3Nlc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlldyB7XG4gIGNvbnN0cnVjdG9yKHBpY2tlciwgY29uZmlnKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcsIHtcbiAgICAgIHBpY2tlcixcbiAgICAgIGVsZW1lbnQ6IHBhcnNlSFRNTChgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItdmlldyBmbGV4XCI+PC9kaXY+YCkuZmlyc3RDaGlsZCxcbiAgICAgIHNlbGVjdGVkOiBbXSxcbiAgICB9KTtcbiAgICB0aGlzLmluaXQodGhpcy5waWNrZXIuZGF0ZXBpY2tlci5jb25maWcpO1xuICB9XG5cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucGlja0xldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaXNNaW5WaWV3ID0gdGhpcy5pZCA9PT0gb3B0aW9ucy5waWNrTGV2ZWw7XG4gICAgfVxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZUZvY3VzKCk7XG4gICAgdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgfVxuXG4gIC8vIEV4ZWN1dGUgYmVmb3JlU2hvdygpIGNhbGxiYWNrIGFuZCBhcHBseSB0aGUgcmVzdWx0IHRvIHRoZSBlbGVtZW50XG4gIC8vIGFyZ3M6XG4gIC8vIC0gY3VycmVudCAtIGN1cnJlbnQgdmFsdWUgb24gdGhlIGl0ZXJhdGlvbiBvbiB2aWV3IHJlbmRlcmluZ1xuICAvLyAtIHRpbWVWYWx1ZSAtIHRpbWUgdmFsdWUgb2YgdGhlIGRhdGUgdG8gcGFzcyB0byBiZWZvcmVTaG93KClcbiAgcGVyZm9ybUJlZm9yZUhvb2soZWwsIGN1cnJlbnQsIHRpbWVWYWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmJlZm9yZVNob3cobmV3IERhdGUodGltZVZhbHVlKSk7XG4gICAgc3dpdGNoICh0eXBlb2YgcmVzdWx0KSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmVzdWx0ID0ge2VuYWJsZWQ6IHJlc3VsdH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmVzdWx0ID0ge2NsYXNzZXM6IHJlc3VsdH07XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKHJlc3VsdC5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgICBwdXNoVW5pcXVlKHRoaXMuZGlzYWJsZWQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5jbGFzc2VzKSB7XG4gICAgICAgIGNvbnN0IGV4dHJhQ2xhc3NlcyA9IHJlc3VsdC5jbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uZXh0cmFDbGFzc2VzKTtcbiAgICAgICAgaWYgKGV4dHJhQ2xhc3Nlcy5pbmNsdWRlcygnZGlzYWJsZWQnKSkge1xuICAgICAgICAgIHB1c2hVbmlxdWUodGhpcy5kaXNhYmxlZCwgY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuY29udGVudCkge1xuICAgICAgICByZXBsYWNlQ2hpbGROb2RlcyhlbCwgcmVzdWx0LmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtoYXNQcm9wZXJ0eSwgcHVzaFVuaXF1ZSwgY3JlYXRlVGFnUmVwZWF0fSBmcm9tICcuLi8uLi9saWIvdXRpbHMuanMnO1xuaW1wb3J0IHtkYXRlVmFsdWUsIHN0YXJ0T2ZZZWFyUGVyaW9kfSBmcm9tICcuLi8uLi9saWIvZGF0ZS5qcyc7XG5pbXBvcnQge3BhcnNlSFRNTH0gZnJvbSAnLi4vLi4vbGliL2RvbS5qcyc7XG5pbXBvcnQgVmlldyBmcm9tICcuL1ZpZXcuanMnO1xuXG5mdW5jdGlvbiB0b1RpdGxlQ2FzZSh3b3JkKSB7XG4gIHJldHVybiBbLi4ud29yZF0ucmVkdWNlKChzdHIsIGNoLCBpeCkgPT4gc3RyICs9IGl4ID8gY2ggOiBjaC50b1VwcGVyQ2FzZSgpLCAnJyk7XG59XG5cbi8vIENsYXNzIHJlcHJlc2VudGluZyB0aGUgeWVhcnMgYW5kIGRlY2FkZXMgdmlldyBlbGVtZW50c1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWWVhcnNWaWV3IGV4dGVuZHMgVmlldyB7XG4gIGNvbnN0cnVjdG9yKHBpY2tlciwgY29uZmlnKSB7XG4gICAgc3VwZXIocGlja2VyLCBjb25maWcpO1xuICB9XG5cbiAgaW5pdChvcHRpb25zLCBvbkNvbnN0cnVjdGlvbiA9IHRydWUpIHtcbiAgICBpZiAob25Db25zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMubmF2U3RlcCA9IHRoaXMuc3RlcCAqIDEwO1xuICAgICAgdGhpcy5iZWZvcmVTaG93T3B0aW9uID0gYGJlZm9yZVNob3cke3RvVGl0bGVDYXNlKHRoaXMuY2VsbENsYXNzKX1gO1xuICAgICAgdGhpcy5ncmlkID0gdGhpcy5lbGVtZW50O1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5uYW1lLCAnZGF0ZXBpY2tlci1ncmlkJywgJ3ctNjQnLCAnZ3JpZCcsICdncmlkLWNvbHMtNCcpO1xuICAgICAgdGhpcy5ncmlkLmFwcGVuZENoaWxkKHBhcnNlSFRNTChjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCAxMikpKTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChvcHRpb25zKTtcbiAgfVxuXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWluRGF0ZScpKSB7XG4gICAgICBpZiAob3B0aW9ucy5taW5EYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5taW5ZZWFyID0gdGhpcy5taW5EYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5taW5ZZWFyID0gc3RhcnRPZlllYXJQZXJpb2Qob3B0aW9ucy5taW5EYXRlLCB0aGlzLnN0ZXApO1xuICAgICAgICB0aGlzLm1pbkRhdGUgPSBkYXRlVmFsdWUodGhpcy5taW5ZZWFyLCAwLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtYXhEYXRlJykpIHtcbiAgICAgIGlmIChvcHRpb25zLm1heERhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1heFllYXIgPSB0aGlzLm1heERhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1heFllYXIgPSBzdGFydE9mWWVhclBlcmlvZChvcHRpb25zLm1heERhdGUsIHRoaXMuc3RlcCk7XG4gICAgICAgIHRoaXMubWF4RGF0ZSA9IGRhdGVWYWx1ZSh0aGlzLm1heFllYXIsIDExLCAzMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zW3RoaXMuYmVmb3JlU2hvd09wdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgYmVmb3JlU2hvdyA9IG9wdGlvbnNbdGhpcy5iZWZvcmVTaG93T3B0aW9uXTtcbiAgICAgIHRoaXMuYmVmb3JlU2hvdyA9IHR5cGVvZiBiZWZvcmVTaG93ID09PSAnZnVuY3Rpb24nID8gYmVmb3JlU2hvdyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgdmlldydzIHNldHRpbmdzIHRvIHJlZmxlY3QgdGhlIHZpZXdEYXRlIHNldCBvbiB0aGUgcGlja2VyXG4gIHVwZGF0ZUZvY3VzKCkge1xuICAgIGNvbnN0IHZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5waWNrZXIudmlld0RhdGUpO1xuICAgIGNvbnN0IGZpcnN0ID0gc3RhcnRPZlllYXJQZXJpb2Qodmlld0RhdGUsIHRoaXMubmF2U3RlcCk7XG4gICAgY29uc3QgbGFzdCA9IGZpcnN0ICsgOSAqIHRoaXMuc3RlcDtcblxuICAgIHRoaXMuZmlyc3QgPSBmaXJzdDtcbiAgICB0aGlzLmxhc3QgPSBsYXN0O1xuICAgIHRoaXMuc3RhcnQgPSBmaXJzdCAtIHRoaXMuc3RlcDtcbiAgICB0aGlzLmZvY3VzZWQgPSBzdGFydE9mWWVhclBlcmlvZCh2aWV3RGF0ZSwgdGhpcy5zdGVwKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB2aWV3J3Mgc2V0dGluZ3MgdG8gcmVmbGVjdCB0aGUgc2VsZWN0ZWQgZGF0ZXNcbiAgdXBkYXRlU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHtkYXRlcywgcmFuZ2VwaWNrZXJ9ID0gdGhpcy5waWNrZXIuZGF0ZXBpY2tlcjtcbiAgICB0aGlzLnNlbGVjdGVkID0gZGF0ZXMucmVkdWNlKCh5ZWFycywgdGltZVZhbHVlKSA9PiB7XG4gICAgICByZXR1cm4gcHVzaFVuaXF1ZSh5ZWFycywgc3RhcnRPZlllYXJQZXJpb2QodGltZVZhbHVlLCB0aGlzLnN0ZXApKTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKHJhbmdlcGlja2VyICYmIHJhbmdlcGlja2VyLmRhdGVzKSB7XG4gICAgICB0aGlzLnJhbmdlID0gcmFuZ2VwaWNrZXIuZGF0ZXMubWFwKHRpbWVWYWx1ZSA9PiB7XG4gICAgICAgIGlmICh0aW1lVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBzdGFydE9mWWVhclBlcmlvZCh0aW1lVmFsdWUsIHRoaXMuc3RlcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgZW50aXJlIHZpZXcgVUlcbiAgcmVuZGVyKCkge1xuICAgIC8vIHJlZnJlc2ggZGlzYWJsZWQgeWVhcnMgb24gZXZlcnkgcmVuZGVyIGluIG9yZGVyIHRvIGNsZWFyIHRoZSBvbmVzIGFkZGVkXG4gICAgLy8gYnkgYmVmb3JlU2hvdyBob29rIGF0IHByZXZpb3VzIHJlbmRlclxuICAgIHRoaXMuZGlzYWJsZWQgPSBbXTtcblxuICAgIHRoaXMucGlja2VyLnNldFZpZXdTd2l0Y2hMYWJlbChgJHt0aGlzLmZpcnN0fS0ke3RoaXMubGFzdH1gKTtcbiAgICB0aGlzLnBpY2tlci5zZXRQcmV2QnRuRGlzYWJsZWQodGhpcy5maXJzdCA8PSB0aGlzLm1pblllYXIpO1xuICAgIHRoaXMucGlja2VyLnNldE5leHRCdG5EaXNhYmxlZCh0aGlzLmxhc3QgPj0gdGhpcy5tYXhZZWFyKTtcblxuICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnN0YXJ0ICsgKGluZGV4ICogdGhpcy5zdGVwKTtcbiAgICAgIGNvbnN0IGRhdGUgPSBkYXRlVmFsdWUoY3VycmVudCwgMCwgMSk7XG5cbiAgICAgIGVsLmNsYXNzTmFtZSA9IGBkYXRlcGlja2VyLWNlbGwgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLXBvaW50ZXIgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBkYXJrOnRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCB0ZXh0LXNtICR7dGhpcy5jZWxsQ2xhc3N9YDtcbiAgICAgIGlmICh0aGlzLmlzTWluVmlldykge1xuICAgICAgICBlbC5kYXRhc2V0LmRhdGUgPSBkYXRlO1xuICAgICAgfVxuICAgICAgZWwudGV4dENvbnRlbnQgPSBlbC5kYXRhc2V0LnllYXIgPSBjdXJyZW50O1xuXG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncHJldicpO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMTEpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnbmV4dCcpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPCB0aGlzLm1pblllYXIgfHwgY3VycmVudCA+IHRoaXMubWF4WWVhcikge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmFuZ2UpIHtcbiAgICAgICAgY29uc3QgW3JhbmdlU3RhcnQsIHJhbmdlRW5kXSA9IHRoaXMucmFuZ2U7XG4gICAgICAgIGlmIChjdXJyZW50ID4gcmFuZ2VTdGFydCAmJiBjdXJyZW50IDwgcmFuZ2VFbmQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQuaW5jbHVkZXMoY3VycmVudCkpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyYXktOTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJyk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mb2N1c2VkKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmVmb3JlU2hvdykge1xuICAgICAgICB0aGlzLnBlcmZvcm1CZWZvcmVIb29rKGVsLCBjdXJyZW50LCBkYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlcyBvZiBzZWxlY3RlZCBhbmQgZm9jdXNlZCBpdGVtc1xuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IFtyYW5nZVN0YXJ0LCByYW5nZUVuZF0gPSB0aGlzLnJhbmdlIHx8IFtdO1xuICAgIHRoaXMuZ3JpZFxuICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5yYW5nZSwgLnJhbmdlLXN0YXJ0LCAucmFuZ2UtZW5kLCAuc2VsZWN0ZWQsIC5mb2N1c2VkJylcbiAgICAgIC5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdyYW5nZScsICdyYW5nZS1zdGFydCcsICdyYW5nZS1lbmQnLCAnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdmb2N1c2VkJyk7XG4gICAgICB9KTtcbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBOdW1iZXIoZWwudGV4dENvbnRlbnQpO1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xuICAgICAgaWYgKGN1cnJlbnQgPiByYW5nZVN0YXJ0ICYmIGN1cnJlbnQgPCByYW5nZUVuZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZScpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZUVuZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZm9jdXNlZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZSBvZiBmb2N1c2VkIGl0ZW1cbiAgcmVmcmVzaEZvY3VzKCkge1xuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5yb3VuZCgodGhpcy5mb2N1c2VkIC0gdGhpcy5zdGFydCkgLyB0aGlzLnN0ZXApO1xuICAgIHRoaXMuZ3JpZC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9jdXNlZCcpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmb2N1c2VkJyk7XG4gICAgfSk7XG4gICAgdGhpcy5ncmlkLmNoaWxkcmVuW2luZGV4XS5jbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gIH1cbn1cbiIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgRGVmYXVsdCA9IHtcbiAgICBhbHdheXNPcGVuOiBmYWxzZSxcbiAgICBhY3RpdmVDbGFzc2VzOiAnYmctZ3JheS0xMDAgZGFyazpiZy1ncmF5LTgwMCB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC13aGl0ZScsXG4gICAgaW5hY3RpdmVDbGFzc2VzOiAndGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDAnLFxuICAgIG9uT3BlbjogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uQ2xvc2U6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblRvZ2dsZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBBY2NvcmRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWNjb3JkaW9uKGl0ZW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChpdGVtcyA9PT0gdm9pZCAwKSB7IGl0ZW1zID0gW107IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzaG93IGFjY29yZGlvbiBpdGVtIGJhc2VkIG9uIGNsaWNrXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub3BlbihpdGVtLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS50cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRvZ2dsZShpdGVtLmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5pZCA9PT0gaWQ7IH0pWzBdO1xuICAgIH07XG4gICAgQWNjb3JkaW9uLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKGlkKTtcbiAgICAgICAgLy8gZG9uJ3QgaGlkZSBvdGhlciBhY2NvcmRpb25zIGlmIGFsd2F5cyBvcGVuXG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5hbHdheXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmIChpICE9PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGkudHJpZ2dlckVsLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9hLCBfdGhpcy5fb3B0aW9ucy5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSBpLnRyaWdnZXJFbC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYiwgX3RoaXMuX29wdGlvbnMuaW5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgICAgICAgICBpLnRhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICBpLnRyaWdnZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgaS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcm90YXRlIGljb24gaWYgc2V0XG4gICAgICAgICAgICAgICAgICAgIGlmIChpLmljb25FbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaS5pY29uRWwuY2xhc3NMaXN0LnJlbW92ZSgncm90YXRlLTE4MCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdyBhY3RpdmUgaXRlbVxuICAgICAgICAoX2EgPSBpdGVtLnRyaWdnZXJFbC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYSwgdGhpcy5fb3B0aW9ucy5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICAoX2IgPSBpdGVtLnRyaWdnZXJFbC5jbGFzc0xpc3QpLnJlbW92ZS5hcHBseShfYiwgdGhpcy5fb3B0aW9ucy5pbmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgIGl0ZW0udHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgICAgIGl0ZW0udGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgIGl0ZW0uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgLy8gcm90YXRlIGljb24gaWYgc2V0XG4gICAgICAgIGlmIChpdGVtLmljb25FbCkge1xuICAgICAgICAgICAgaXRlbS5pY29uRWwuY2xhc3NMaXN0LmFkZCgncm90YXRlLTE4MCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25PcGVuKHRoaXMsIGl0ZW0pO1xuICAgIH07XG4gICAgQWNjb3JkaW9uLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpO1xuICAgICAgICBpZiAoaXRlbS5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuKGlkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uVG9nZ2xlKHRoaXMsIGl0ZW0pO1xuICAgIH07XG4gICAgQWNjb3JkaW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShpZCk7XG4gICAgICAgIChfYSA9IGl0ZW0udHJpZ2dlckVsLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9hLCB0aGlzLl9vcHRpb25zLmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgIChfYiA9IGl0ZW0udHJpZ2dlckVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9iLCB0aGlzLl9vcHRpb25zLmluYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgaXRlbS50YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgaXRlbS50cmlnZ2VyRWwuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgIGl0ZW0uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8vIHJvdGF0ZSBpY29uIGlmIHNldFxuICAgICAgICBpZiAoaXRlbS5pY29uRWwpIHtcbiAgICAgICAgICAgIGl0ZW0uaWNvbkVsLmNsYXNzTGlzdC5yZW1vdmUoJ3JvdGF0ZS0xODAnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uQ2xvc2UodGhpcywgaXRlbSk7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3JkaW9uO1xufSgpKTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5BY2NvcmRpb24gPSBBY2NvcmRpb247XG59XG5leHBvcnQgZnVuY3Rpb24gaW5pdEFjY29yZGlvbnMoKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtYWNjb3JkaW9uXScpLmZvckVhY2goZnVuY3Rpb24gKCRhY2NvcmRpb25FbCkge1xuICAgICAgICB2YXIgYWx3YXlzT3BlbiA9ICRhY2NvcmRpb25FbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWNjb3JkaW9uJyk7XG4gICAgICAgIHZhciBhY3RpdmVDbGFzc2VzID0gJGFjY29yZGlvbkVsLmdldEF0dHJpYnV0ZSgnZGF0YS1hY3RpdmUtY2xhc3NlcycpO1xuICAgICAgICB2YXIgaW5hY3RpdmVDbGFzc2VzID0gJGFjY29yZGlvbkVsLmdldEF0dHJpYnV0ZSgnZGF0YS1pbmFjdGl2ZS1jbGFzc2VzJyk7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAkYWNjb3JkaW9uRWxcbiAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1hY2NvcmRpb24tdGFyZ2V0XScpXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWFjY29yZGlvbi10YXJnZXQnKSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWw6ICR0cmlnZ2VyRWwsXG4gICAgICAgICAgICAgICAgdGFyZ2V0RWw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWNjb3JkaW9uLXRhcmdldCcpKSxcbiAgICAgICAgICAgICAgICBpY29uRWw6ICR0cmlnZ2VyRWwucXVlcnlTZWxlY3RvcignW2RhdGEtYWNjb3JkaW9uLWljb25dJyksXG4gICAgICAgICAgICAgICAgYWN0aXZlOiAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpID09PSAndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5ldyBBY2NvcmRpb24oaXRlbXMsIHtcbiAgICAgICAgICAgIGFsd2F5c09wZW46IGFsd2F5c09wZW4gPT09ICdvcGVuJyA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgIGFjdGl2ZUNsYXNzZXM6IGFjdGl2ZUNsYXNzZXNcbiAgICAgICAgICAgICAgICA/IGFjdGl2ZUNsYXNzZXNcbiAgICAgICAgICAgICAgICA6IERlZmF1bHQuYWN0aXZlQ2xhc3NlcyxcbiAgICAgICAgICAgIGluYWN0aXZlQ2xhc3NlczogaW5hY3RpdmVDbGFzc2VzXG4gICAgICAgICAgICAgICAgPyBpbmFjdGl2ZUNsYXNzZXNcbiAgICAgICAgICAgICAgICA6IERlZmF1bHQuaW5hY3RpdmVDbGFzc2VzLFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IEFjY29yZGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIERlZmF1bHQgPSB7XG4gICAgZGVmYXVsdFBvc2l0aW9uOiAwLFxuICAgIGluZGljYXRvcnM6IHtcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBhY3RpdmVDbGFzc2VzOiAnYmctd2hpdGUgZGFyazpiZy1ncmF5LTgwMCcsXG4gICAgICAgIGluYWN0aXZlQ2xhc3NlczogJ2JnLXdoaXRlLzUwIGRhcms6YmctZ3JheS04MDAvNTAgaG92ZXI6Ymctd2hpdGUgZGFyazpob3ZlcjpiZy1ncmF5LTgwMCcsXG4gICAgfSxcbiAgICBpbnRlcnZhbDogMzAwMCxcbiAgICBvbk5leHQ6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblByZXY6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBDYXJvdXNlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXJvdXNlbChpdGVtcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXRlbXMgPT09IHZvaWQgMCkgeyBpdGVtcyA9IFtdOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBEZWZhdWx0KSwgb3B0aW9ucyksIHsgaW5kaWNhdG9yczogX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQuaW5kaWNhdG9ycyksIG9wdGlvbnMuaW5kaWNhdG9ycykgfSk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW0gPSB0aGlzLmdldEl0ZW0odGhpcy5fb3B0aW9ucy5kZWZhdWx0UG9zaXRpb24pO1xuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzID0gdGhpcy5fb3B0aW9ucy5pbmRpY2F0b3JzLml0ZW1zO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbER1cmF0aW9uID0gdGhpcy5fb3B0aW9ucy5pbnRlcnZhbDtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZSBjYXJvdXNlbCBhbmQgaXRlbXMgYmFzZWQgb24gYWN0aXZlIG9uZVxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5faXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmVsLmNsYXNzTGlzdC5hZGQoJ2Fic29sdXRlJywgJ2luc2V0LTAnLCAndHJhbnNpdGlvbi10cmFuc2Zvcm0nLCAndHJhbnNmb3JtJyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpZiBubyBhY3RpdmUgaXRlbSBpcyBzZXQgdGhlbiBmaXJzdCBwb3NpdGlvbiBpcyBkZWZhdWx0XG4gICAgICAgIGlmICh0aGlzLl9nZXRBY3RpdmVJdGVtKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVUbyh0aGlzLl9nZXRBY3RpdmVJdGVtKCkucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zbGlkZVRvKDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luZGljYXRvcnMubWFwKGZ1bmN0aW9uIChpbmRpY2F0b3IsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpbmRpY2F0b3IuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2xpZGVUbyhwb3NpdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbcG9zaXRpb25dO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2xpZGUgdG8gdGhlIGVsZW1lbnQgYmFzZWQgb24gaWRcbiAgICAgKiBAcGFyYW0geyp9IHBvc2l0aW9uXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnNsaWRlVG8gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIG5leHRJdGVtID0gdGhpcy5faXRlbXNbcG9zaXRpb25dO1xuICAgICAgICB2YXIgcm90YXRpb25JdGVtcyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IG5leHRJdGVtLnBvc2l0aW9uID09PSAwXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgIDogdGhpcy5faXRlbXNbbmV4dEl0ZW0ucG9zaXRpb24gLSAxXSxcbiAgICAgICAgICAgIG1pZGRsZTogbmV4dEl0ZW0sXG4gICAgICAgICAgICByaWdodDogbmV4dEl0ZW0ucG9zaXRpb24gPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2l0ZW1zWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9pdGVtc1tuZXh0SXRlbS5wb3NpdGlvbiArIDFdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9yb3RhdGUocm90YXRpb25JdGVtcyk7XG4gICAgICAgIHRoaXMuX3NldEFjdGl2ZUl0ZW0obmV4dEl0ZW0pO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25DaGFuZ2UodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtIGl0IHdpbGwgZ28gdG8gdGhlIG5leHQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUl0ZW0gPSB0aGlzLl9nZXRBY3RpdmVJdGVtKCk7XG4gICAgICAgIHZhciBuZXh0SXRlbSA9IG51bGw7XG4gICAgICAgIC8vIGNoZWNrIGlmIGxhc3QgaXRlbVxuICAgICAgICBpZiAoYWN0aXZlSXRlbS5wb3NpdGlvbiA9PT0gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgbmV4dEl0ZW0gPSB0aGlzLl9pdGVtc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHRJdGVtID0gdGhpcy5faXRlbXNbYWN0aXZlSXRlbS5wb3NpdGlvbiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVUbyhuZXh0SXRlbS5wb3NpdGlvbik7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25OZXh0KHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdGhlIGN1cnJlbnRseSBhY3RpdmUgaXRlbSBpdCB3aWxsIGdvIHRvIHRoZSBwcmV2aW91cyBwb3NpdGlvblxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aXZlSXRlbSA9IHRoaXMuX2dldEFjdGl2ZUl0ZW0oKTtcbiAgICAgICAgdmFyIHByZXZJdGVtID0gbnVsbDtcbiAgICAgICAgLy8gY2hlY2sgaWYgZmlyc3QgaXRlbVxuICAgICAgICBpZiAoYWN0aXZlSXRlbS5wb3NpdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgcHJldkl0ZW0gPSB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gdGhpcy5faXRlbXNbYWN0aXZlSXRlbS5wb3NpdGlvbiAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVUbyhwcmV2SXRlbS5wb3NpdGlvbik7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25QcmV2KHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYXBwbGllcyB0aGUgdHJhbnNmb3JtIGNsYXNzZXMgYmFzZWQgb24gdGhlIGxlZnQsIG1pZGRsZSwgYW5kIHJpZ2h0IHJvdGF0aW9uIGNhcm91c2VsIGl0ZW1zXG4gICAgICogQHBhcmFtIHsqfSByb3RhdGlvbkl0ZW1zXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9yb3RhdGUgPSBmdW5jdGlvbiAocm90YXRpb25JdGVtcykge1xuICAgICAgICAvLyByZXNldFxuICAgICAgICB0aGlzLl9pdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0uZWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBsZWZ0IGl0ZW0gKHByZXZpb3VzbHkgYWN0aXZlKVxuICAgICAgICByb3RhdGlvbkl0ZW1zLmxlZnQuZWwuY2xhc3NMaXN0LnJlbW92ZSgnLXRyYW5zbGF0ZS14LWZ1bGwnLCAndHJhbnNsYXRlLXgtZnVsbCcsICd0cmFuc2xhdGUteC0wJywgJ2hpZGRlbicsICd6LTIwJyk7XG4gICAgICAgIHJvdGF0aW9uSXRlbXMubGVmdC5lbC5jbGFzc0xpc3QuYWRkKCctdHJhbnNsYXRlLXgtZnVsbCcsICd6LTEwJyk7XG4gICAgICAgIC8vIGN1cnJlbnRseSBhY3RpdmUgaXRlbVxuICAgICAgICByb3RhdGlvbkl0ZW1zLm1pZGRsZS5lbC5jbGFzc0xpc3QucmVtb3ZlKCctdHJhbnNsYXRlLXgtZnVsbCcsICd0cmFuc2xhdGUteC1mdWxsJywgJ3RyYW5zbGF0ZS14LTAnLCAnaGlkZGVuJywgJ3otMTAnKTtcbiAgICAgICAgcm90YXRpb25JdGVtcy5taWRkbGUuZWwuY2xhc3NMaXN0LmFkZCgndHJhbnNsYXRlLXgtMCcsICd6LTIwJyk7XG4gICAgICAgIC8vIHJpZ2h0IGl0ZW0gKHVwY29taW5nIGFjdGl2ZSlcbiAgICAgICAgcm90YXRpb25JdGVtcy5yaWdodC5lbC5jbGFzc0xpc3QucmVtb3ZlKCctdHJhbnNsYXRlLXgtZnVsbCcsICd0cmFuc2xhdGUteC1mdWxsJywgJ3RyYW5zbGF0ZS14LTAnLCAnaGlkZGVuJywgJ3otMjAnKTtcbiAgICAgICAgcm90YXRpb25JdGVtcy5yaWdodC5lbC5jbGFzc0xpc3QuYWRkKCd0cmFuc2xhdGUteC1mdWxsJywgJ3otMTAnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhbiBpbnRlcnZhbCB0byBjeWNsZSB0aHJvdWdoIHRoZSBjYXJvdXNlbCBpdGVtc1xuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5jeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbEluc3RhbmNlID0gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9LCB0aGlzLl9pbnRlcnZhbER1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjeWNsaW5nIGludGVydmFsXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSW5zdGFuY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGl0ZW1cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2dldEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVJdGVtO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGl0ZW0gYW5kIGRhdGEgYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHsqfSBwb3NpdGlvblxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fc2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW0gPSBpdGVtO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGluZGljYXRvcnMgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9ycy5tYXAoZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yLmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50JywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICAgICAgKF9hID0gaW5kaWNhdG9yLmVsLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9hLCBfdGhpcy5fb3B0aW9ucy5pbmRpY2F0b3JzLmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICAgICAgKF9iID0gaW5kaWNhdG9yLmVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9iLCBfdGhpcy5fb3B0aW9ucy5pbmRpY2F0b3JzLmluYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5faW5kaWNhdG9yc1twb3NpdGlvbl0uZWwuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2EsIHRoaXMuX29wdGlvbnMuaW5kaWNhdG9ycy5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5faW5kaWNhdG9yc1twb3NpdGlvbl0uZWwuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2IsIHRoaXMuX29wdGlvbnMuaW5kaWNhdG9ycy5pbmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICB0aGlzLl9pbmRpY2F0b3JzW3Bvc2l0aW9uXS5lbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYXJvdXNlbDtcbn0oKSk7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuQ2Fyb3VzZWwgPSBDYXJvdXNlbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbml0Q2Fyb3VzZWxzKCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsXScpLmZvckVhY2goZnVuY3Rpb24gKCRjYXJvdXNlbEVsKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9ICRjYXJvdXNlbEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jYXJvdXNlbC1pbnRlcnZhbCcpO1xuICAgICAgICB2YXIgc2xpZGUgPSAkY2Fyb3VzZWxFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2Fyb3VzZWwnKSA9PT0gJ3NsaWRlJ1xuICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIGRlZmF1bHRQb3NpdGlvbiA9IDA7XG4gICAgICAgIGlmICgkY2Fyb3VzZWxFbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jYXJvdXNlbC1pdGVtXScpLmxlbmd0aCkge1xuICAgICAgICAgICAgQXJyYXkuZnJvbSgkY2Fyb3VzZWxFbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jYXJvdXNlbC1pdGVtXScpKS5tYXAoZnVuY3Rpb24gKCRjYXJvdXNlbEl0ZW1FbCwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBlbDogJGNhcm91c2VsSXRlbUVsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICgkY2Fyb3VzZWxJdGVtRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNhcm91c2VsLWl0ZW0nKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGljYXRvcnMgPSBbXTtcbiAgICAgICAgaWYgKCRjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsLXNsaWRlLXRvXScpLmxlbmd0aCkge1xuICAgICAgICAgICAgQXJyYXkuZnJvbSgkY2Fyb3VzZWxFbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jYXJvdXNlbC1zbGlkZS10b10nKSkubWFwKGZ1bmN0aW9uICgkaW5kaWNhdG9yRWwpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGFyc2VJbnQoJGluZGljYXRvckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jYXJvdXNlbC1zbGlkZS10bycpKSxcbiAgICAgICAgICAgICAgICAgICAgZWw6ICRpbmRpY2F0b3JFbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYXJvdXNlbCA9IG5ldyBDYXJvdXNlbChpdGVtcywge1xuICAgICAgICAgICAgZGVmYXVsdFBvc2l0aW9uOiBkZWZhdWx0UG9zaXRpb24sXG4gICAgICAgICAgICBpbmRpY2F0b3JzOiB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IGluZGljYXRvcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGludGVydmFsID8gaW50ZXJ2YWwgOiBEZWZhdWx0LmludGVydmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNsaWRlKSB7XG4gICAgICAgICAgICBjYXJvdXNlbC5jeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBjb250cm9sc1xuICAgICAgICB2YXIgY2Fyb3VzZWxOZXh0RWwgPSAkY2Fyb3VzZWxFbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jYXJvdXNlbC1uZXh0XScpO1xuICAgICAgICB2YXIgY2Fyb3VzZWxQcmV2RWwgPSAkY2Fyb3VzZWxFbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jYXJvdXNlbC1wcmV2XScpO1xuICAgICAgICBpZiAoY2Fyb3VzZWxOZXh0RWwpIHtcbiAgICAgICAgICAgIGNhcm91c2VsTmV4dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhcm91c2VsLm5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJvdXNlbFByZXZFbCkge1xuICAgICAgICAgICAgY2Fyb3VzZWxQcmV2RWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2Fyb3VzZWwucHJldigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IENhcm91c2VsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgRGVmYXVsdCA9IHtcbiAgICBvbkNvbGxhcHNlOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25FeHBhbmQ6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblRvZ2dsZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBDb2xsYXBzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2xsYXBzZSh0YXJnZXRFbCwgdHJpZ2dlckVsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0YXJnZXRFbCA9PT0gdm9pZCAwKSB7IHRhcmdldEVsID0gbnVsbDsgfVxuICAgICAgICBpZiAodHJpZ2dlckVsID09PSB2b2lkIDApIHsgdHJpZ2dlckVsID0gbnVsbDsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIHRoaXMuX3RhcmdldEVsID0gdGFyZ2V0RWw7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJFbCA9IHRyaWdnZXJFbDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBEZWZhdWx0KSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwuaGFzQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpID09PSAndHJ1ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmaXggdW50aWwgdjIgbm90IHRvIGJyZWFrIHByZXZpb3VzIHNpbmdsZSBjb2xsYXBzZXMgd2hpY2ggYmVjYW1lIGRpc21pc3NcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gIXRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5jb250YWlucygnaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sbGFwc2UucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkNvbGxhcHNlKHRoaXMpO1xuICAgIH07XG4gICAgQ29sbGFwc2UucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uRXhwYW5kKHRoaXMpO1xuICAgIH07XG4gICAgQ29sbGFwc2UucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblRvZ2dsZSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBDb2xsYXBzZTtcbn0oKSk7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuQ29sbGFwc2UgPSBDb2xsYXBzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbml0Q29sbGFwc2VzKCkge1xuICAgIGRvY3VtZW50XG4gICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jb2xsYXBzZS10b2dnbGVdJylcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgdmFyIHRhcmdldElkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sbGFwc2UtdG9nZ2xlJyk7XG4gICAgICAgIHZhciAkdGFyZ2V0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXRJZCk7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBleGlzdHNcbiAgICAgICAgaWYgKCR0YXJnZXRFbCkge1xuICAgICAgICAgICAgbmV3IENvbGxhcHNlKCR0YXJnZXRFbCwgJHRyaWdnZXJFbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIHRhcmdldCBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdCh0YXJnZXRJZCwgXCJcXFwiIGRvZXMgbm90IGV4aXN0LiBQbGVhc2UgY2hlY2sgdGhlIGRhdGEtY29sbGFwc2UtdG9nZ2xlIGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBDb2xsYXBzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIERlZmF1bHQgPSB7XG4gICAgdHJpZ2dlclR5cGU6ICdob3ZlcicsXG4gICAgb25TaG93OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25IaWRlOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25Ub2dnbGU6IGZ1bmN0aW9uICgpIHsgfSxcbn07XG52YXIgRGlhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaWFsKHBhcmVudEVsLCB0cmlnZ2VyRWwsIHRhcmdldEVsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChwYXJlbnRFbCA9PT0gdm9pZCAwKSB7IHBhcmVudEVsID0gbnVsbDsgfVxuICAgICAgICBpZiAodHJpZ2dlckVsID09PSB2b2lkIDApIHsgdHJpZ2dlckVsID0gbnVsbDsgfVxuICAgICAgICBpZiAodGFyZ2V0RWwgPT09IHZvaWQgMCkgeyB0YXJnZXRFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICB0aGlzLl9wYXJlbnRFbCA9IHBhcmVudEVsO1xuICAgICAgICB0aGlzLl90cmlnZ2VyRWwgPSB0cmlnZ2VyRWw7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsID0gdGFyZ2V0RWw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gICAgRGlhbC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyRXZlbnRUeXBlcyA9IHRoaXMuX2dldFRyaWdnZXJFdmVudFR5cGVzKHRoaXMuX29wdGlvbnMudHJpZ2dlclR5cGUpO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50VHlwZXMuc2hvd0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRUeXBlcy5oaWRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3BhcmVudEVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fcGFyZW50RWwubWF0Y2hlcygnOmhvdmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpYWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsKSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRWwuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uSGlkZSh0aGlzKTtcbiAgICB9O1xuICAgIERpYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsKSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRWwuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3codGhpcyk7XG4gICAgfTtcbiAgICBEaWFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWFsLnByb3RvdHlwZS5pc0hpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl92aXNpYmxlO1xuICAgIH07XG4gICAgRGlhbC5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9O1xuICAgIERpYWwucHJvdG90eXBlLl9nZXRUcmlnZ2VyRXZlbnRUeXBlcyA9IGZ1bmN0aW9uICh0cmlnZ2VyVHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHRyaWdnZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdob3Zlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydtb3VzZWVudGVyJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnbW91c2VsZWF2ZScsICdibHVyJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ2NsaWNrJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnZm9jdXNvdXQnLCAnYmx1ciddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydtb3VzZWVudGVyJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnbW91c2VsZWF2ZScsICdibHVyJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERpYWw7XG59KCkpO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LkRpYWwgPSBEaWFsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluaXREaWFscygpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1kaWFsLWluaXRdJykuZm9yRWFjaChmdW5jdGlvbiAoJHBhcmVudEVsKSB7XG4gICAgICAgIHZhciAkdHJpZ2dlckVsID0gJHBhcmVudEVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWRpYWwtdG9nZ2xlXScpO1xuICAgICAgICBpZiAoJHRyaWdnZXJFbCkge1xuICAgICAgICAgICAgdmFyIGRpYWxJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRpYWwtdG9nZ2xlJyk7XG4gICAgICAgICAgICB2YXIgJGRpYWxFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpYWxJZCk7XG4gICAgICAgICAgICBpZiAoJGRpYWxFbCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmlnZ2VyVHlwZSA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRpYWwtdHJpZ2dlcicpO1xuICAgICAgICAgICAgICAgIG5ldyBEaWFsKCRwYXJlbnRFbCwgJHRyaWdnZXJFbCwgJGRpYWxFbCwge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyVHlwZTogdHJpZ2dlclR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJpZ2dlclR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogRGVmYXVsdC50cmlnZ2VyVHlwZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEaWFsIHdpdGggaWQgXCIuY29uY2F0KGRpYWxJZCwgXCIgZG9lcyBub3QgZXhpc3QuIEFyZSB5b3Ugc3VyZSB0aGF0IHRoZSBkYXRhLWRpYWwtdG9nZ2xlIGF0dHJpYnV0ZSBwb2ludHMgdG8gdGhlIGNvcnJlY3QgbW9kYWwgaWQ/XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEaWFsIHdpdGggaWQgXCIuY29uY2F0KCRwYXJlbnRFbC5pZCwgXCIgZG9lcyBub3QgaGF2ZSBhIHRyaWdnZXIgZWxlbWVudC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtZGlhbC10b2dnbGUgYXR0cmlidXRlIGV4aXN0cz9cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBEaWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgRGVmYXVsdCA9IHtcbiAgICB0cmFuc2l0aW9uOiAndHJhbnNpdGlvbi1vcGFjaXR5JyxcbiAgICBkdXJhdGlvbjogMzAwLFxuICAgIHRpbWluZzogJ2Vhc2Utb3V0JyxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uICgpIHsgfSxcbn07XG52YXIgRGlzbWlzcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXNtaXNzKHRhcmdldEVsLCB0cmlnZ2VyRWwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRhcmdldEVsID09PSB2b2lkIDApIHsgdGFyZ2V0RWwgPSBudWxsOyB9XG4gICAgICAgIGlmICh0cmlnZ2VyRWwgPT09IHZvaWQgMCkgeyB0cmlnZ2VyRWwgPSBudWxsOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbDtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckVsID0gdHJpZ2dlckVsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICBEaXNtaXNzLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaXNtaXNzLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKHRoaXMuX29wdGlvbnMudHJhbnNpdGlvbiwgXCJkdXJhdGlvbi1cIi5jb25jYXQodGhpcy5fb3B0aW9ucy5kdXJhdGlvbiksIHRoaXMuX29wdGlvbnMudGltaW5nLCAnb3BhY2l0eS0wJyk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICB9LCB0aGlzLl9vcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUodGhpcywgdGhpcy5fdGFyZ2V0RWwpO1xuICAgIH07XG4gICAgcmV0dXJuIERpc21pc3M7XG59KCkpO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LkRpc21pc3MgPSBEaXNtaXNzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluaXREaXNtaXNzZXMoKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZGlzbWlzcy10YXJnZXRdJykuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgdGFyZ2V0SWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kaXNtaXNzLXRhcmdldCcpO1xuICAgICAgICB2YXIgJGRpc21pc3NFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0SWQpO1xuICAgICAgICBpZiAoJGRpc21pc3NFbCkge1xuICAgICAgICAgICAgbmV3IERpc21pc3MoJGRpc21pc3NFbCwgJHRyaWdnZXJFbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIGRpc21pc3MgZWxlbWVudCB3aXRoIGlkIFxcXCJcIi5jb25jYXQodGFyZ2V0SWQsIFwiXFxcIiBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIGNoZWNrIHRoZSBkYXRhLWRpc21pc3MtdGFyZ2V0IGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBEaXNtaXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgRGVmYXVsdCA9IHtcbiAgICBwbGFjZW1lbnQ6ICdsZWZ0JyxcbiAgICBib2R5U2Nyb2xsaW5nOiBmYWxzZSxcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBlZGdlOiBmYWxzZSxcbiAgICBlZGdlT2Zmc2V0OiAnYm90dG9tLVs2MHB4XScsXG4gICAgYmFja2Ryb3BDbGFzc2VzOiAnYmctZ3JheS05MDAgYmctb3BhY2l0eS01MCBkYXJrOmJnLW9wYWNpdHktODAgZml4ZWQgaW5zZXQtMCB6LTMwJyxcbiAgICBvblNob3c6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblRvZ2dsZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBEcmF3ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJhd2VyKHRhcmdldEVsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0YXJnZXRFbCA9PT0gdm9pZCAwKSB7IHRhcmdldEVsID0gbnVsbDsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIHRoaXMuX3RhcmdldEVsID0gdGFyZ2V0RWw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gICAgRHJhd2VyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzXG4gICAgICAgIGlmICh0aGlzLl90YXJnZXRFbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCd0cmFuc2l0aW9uLXRyYW5zZm9ybScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBiYXNlIHBsYWNlbWVudCBjbGFzc2VzXG4gICAgICAgIHRoaXMuX2dldFBsYWNlbWVudENsYXNzZXModGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQpLmJhc2UubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGFkZCBrZXlib2FyZCBldmVudCBsaXN0ZW5lciB0byBkb2N1bWVudFxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIC8vIGlmICdFc2NhcGUnIGtleSBpcyBwcmVzc2VkXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBEcmF3ZXIgaXMgdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7IC8vIGhpZGUgdGhlIERyYXdlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBlZGdlIG9wdGlvbiBzaG93IHBsYWNlbWVudCBjbGFzc2VzXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmVkZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFBsYWNlbWVudENsYXNzZXModGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQgKyAnLWVkZ2UnKS5hY3RpdmUubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2dldFBsYWNlbWVudENsYXNzZXModGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQgKyAnLWVkZ2UnKS5pbmFjdGl2ZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3Nlcyh0aGlzLl9vcHRpb25zLnBsYWNlbWVudCkuYWN0aXZlLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9nZXRQbGFjZW1lbnRDbGFzc2VzKHRoaXMuX29wdGlvbnMucGxhY2VtZW50KS5pbmFjdGl2ZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICAgICAgLy8gZW5hYmxlIGJvZHkgc2Nyb2xsXG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5ib2R5U2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ292ZXJmbG93LWhpZGRlbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlc3Ryb3kgYmFja2Ryb3BcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYmFja2Ryb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lCYWNrZHJvcEVsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uSGlkZSh0aGlzKTtcbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZWRnZSkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3Nlcyh0aGlzLl9vcHRpb25zLnBsYWNlbWVudCArICctZWRnZScpLmFjdGl2ZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3Nlcyh0aGlzLl9vcHRpb25zLnBsYWNlbWVudCArICctZWRnZScpLmluYWN0aXZlLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRQbGFjZW1lbnRDbGFzc2VzKHRoaXMuX29wdGlvbnMucGxhY2VtZW50KS5hY3RpdmUubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2dldFBsYWNlbWVudENsYXNzZXModGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQpLmluYWN0aXZlLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlc1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgLy8gZGlzYWJsZSBib2R5IHNjcm9sbFxuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuYm9keVNjcm9sbGluZykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdvdmVyZmxvdy1oaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaG93IGJhY2tkcm9wXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmJhY2tkcm9wKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVCYWNrZHJvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uU2hvdyh0aGlzKTtcbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS5fY3JlYXRlQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgICAgICB2YXIgYmFja2Ryb3BFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgYmFja2Ryb3BFbC5zZXRBdHRyaWJ1dGUoJ2RyYXdlci1iYWNrZHJvcCcsICcnKTtcbiAgICAgICAgICAgIChfYSA9IGJhY2tkcm9wRWwuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2EsIHRoaXMuX29wdGlvbnMuYmFja2Ryb3BDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZChiYWNrZHJvcEVsKTtcbiAgICAgICAgICAgIGJhY2tkcm9wRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUuX2Rlc3Ryb3lCYWNrZHJvcEVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RyYXdlci1iYWNrZHJvcF0nKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS5fZ2V0UGxhY2VtZW50Q2xhc3NlcyA9IGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgc3dpdGNoIChwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogWyd0b3AtMCcsICdsZWZ0LTAnLCAncmlnaHQtMCddLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IFsndHJhbnNmb3JtLW5vbmUnXSxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6IFsnLXRyYW5zbGF0ZS15LWZ1bGwnXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IFsncmlnaHQtMCcsICd0b3AtMCddLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IFsndHJhbnNmb3JtLW5vbmUnXSxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6IFsndHJhbnNsYXRlLXgtZnVsbCddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IFsnYm90dG9tLTAnLCAnbGVmdC0wJywgJ3JpZ2h0LTAnXSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBbJ3RyYW5zZm9ybS1ub25lJ10sXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlOiBbJ3RyYW5zbGF0ZS15LWZ1bGwnXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogWydsZWZ0LTAnLCAndG9wLTAnXSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBbJ3RyYW5zZm9ybS1ub25lJ10sXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlOiBbJy10cmFuc2xhdGUteC1mdWxsJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1lZGdlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYXNlOiBbJ2xlZnQtMCcsICd0b3AtMCddLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IFsndHJhbnNmb3JtLW5vbmUnXSxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6IFsndHJhbnNsYXRlLXktZnVsbCcsIHRoaXMuX29wdGlvbnMuZWRnZU9mZnNldF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogWydsZWZ0LTAnLCAndG9wLTAnXSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBbJ3RyYW5zZm9ybS1ub25lJ10sXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlOiBbJy10cmFuc2xhdGUteC1mdWxsJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS5pc0hpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl92aXNpYmxlO1xuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH07XG4gICAgcmV0dXJuIERyYXdlcjtcbn0oKSk7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuRHJhd2VyID0gRHJhd2VyO1xufVxudmFyIGdldERyYXdlckluc3RhbmNlID0gZnVuY3Rpb24gKGlkLCBpbnN0YW5jZXMpIHtcbiAgICBpZiAoaW5zdGFuY2VzLnNvbWUoZnVuY3Rpb24gKGRyYXdlckluc3RhbmNlKSB7IHJldHVybiBkcmF3ZXJJbnN0YW5jZS5pZCA9PT0gaWQ7IH0pKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXMuZmluZChmdW5jdGlvbiAoZHJhd2VySW5zdGFuY2UpIHsgcmV0dXJuIGRyYXdlckluc3RhbmNlLmlkID09PSBpZDsgfSk7XG4gICAgfVxufTtcbmV4cG9ydCBmdW5jdGlvbiBpbml0RHJhd2VycygpIHtcbiAgICB2YXIgZHJhd2VySW5zdGFuY2VzID0gW107XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZHJhd2VyLXRhcmdldF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIC8vIG1hbmRhdG9yeVxuICAgICAgICB2YXIgZHJhd2VySWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcmF3ZXItdGFyZ2V0Jyk7XG4gICAgICAgIHZhciAkZHJhd2VyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcmF3ZXJJZCk7XG4gICAgICAgIGlmICgkZHJhd2VyRWwpIHtcbiAgICAgICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhd2VyLXBsYWNlbWVudCcpO1xuICAgICAgICAgICAgdmFyIGJvZHlTY3JvbGxpbmcgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcmF3ZXItYm9keS1zY3JvbGxpbmcnKTtcbiAgICAgICAgICAgIHZhciBiYWNrZHJvcCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci1iYWNrZHJvcCcpO1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcmF3ZXItZWRnZScpO1xuICAgICAgICAgICAgdmFyIGVkZ2VPZmZzZXQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcmF3ZXItZWRnZS1vZmZzZXQnKTtcbiAgICAgICAgICAgIGlmICghZ2V0RHJhd2VySW5zdGFuY2UoZHJhd2VySWQsIGRyYXdlckluc3RhbmNlcykpIHtcbiAgICAgICAgICAgICAgICBkcmF3ZXJJbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBkcmF3ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBuZXcgRHJhd2VyKCRkcmF3ZXJFbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQgPyBwbGFjZW1lbnQgOiBEZWZhdWx0LnBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlTY3JvbGxpbmc6IGJvZHlTY3JvbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGJvZHlTY3JvbGxpbmcgPT09ICd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogRGVmYXVsdC5ib2R5U2Nyb2xsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2Ryb3A6IGJhY2tkcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBiYWNrZHJvcCA9PT0gJ3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LmJhY2tkcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZTogZWRnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZWRnZSA9PT0gJ3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LmVkZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlT2Zmc2V0OiBlZGdlT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlZGdlT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LmVkZ2VPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyYXdlciB3aXRoIGlkIFwiLmNvbmNhdChkcmF3ZXJJZCwgXCIgbm90IGZvdW5kLiBBcmUgeW91IHN1cmUgdGhhdCB0aGUgZGF0YS1kcmF3ZXItdGFyZ2V0IGF0dHJpYnV0ZSBwb2ludHMgdG8gdGhlIGNvcnJlY3QgZHJhd2VyIGlkP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1kcmF3ZXItdG9nZ2xlXScpLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgdmFyIGRyYXdlcklkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhd2VyLXRvZ2dsZScpO1xuICAgICAgICB2YXIgJGRyYXdlckVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHJhd2VySWQpO1xuICAgICAgICBpZiAoJGRyYXdlckVsKSB7XG4gICAgICAgICAgICB2YXIgZHJhd2VyXzEgPSBnZXREcmF3ZXJJbnN0YW5jZShkcmF3ZXJJZCwgZHJhd2VySW5zdGFuY2VzKTtcbiAgICAgICAgICAgIGlmIChkcmF3ZXJfMSkge1xuICAgICAgICAgICAgICAgICR0cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdlcl8xLm9iamVjdC50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEcmF3ZXIgd2l0aCBpZCBcIi5jb25jYXQoZHJhd2VySWQsIFwiIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4gUGxlYXNlIGluaXRpYWxpemUgaXQgdXNpbmcgdGhlIGRhdGEtZHJhd2VyLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEcmF3ZXIgd2l0aCBpZCBcIi5jb25jYXQoZHJhd2VySWQsIFwiIG5vdCBmb3VuZC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtZHJhd2VyLXRhcmdldCBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IGRyYXdlciBpZD9cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWRyYXdlci1kaXNtaXNzXSwgW2RhdGEtZHJhd2VyLWhpZGVdJylcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgdmFyIGRyYXdlcklkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhd2VyLWRpc21pc3MnKVxuICAgICAgICAgICAgPyAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcmF3ZXItZGlzbWlzcycpXG4gICAgICAgICAgICA6ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci1oaWRlJyk7XG4gICAgICAgIHZhciAkZHJhd2VyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcmF3ZXJJZCk7XG4gICAgICAgIGlmICgkZHJhd2VyRWwpIHtcbiAgICAgICAgICAgIHZhciBkcmF3ZXJfMiA9IGdldERyYXdlckluc3RhbmNlKGRyYXdlcklkLCBkcmF3ZXJJbnN0YW5jZXMpO1xuICAgICAgICAgICAgaWYgKGRyYXdlcl8yKSB7XG4gICAgICAgICAgICAgICAgJHRyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyXzIub2JqZWN0LmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEcmF3ZXIgd2l0aCBpZCBcIi5jb25jYXQoZHJhd2VySWQsIFwiIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4gUGxlYXNlIGluaXRpYWxpemUgaXQgdXNpbmcgdGhlIGRhdGEtZHJhd2VyLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEcmF3ZXIgd2l0aCBpZCBcIi5jb25jYXQoZHJhd2VySWQsIFwiIG5vdCBmb3VuZC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtZHJhd2VyLXRhcmdldCBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IGRyYXdlciBpZFwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1kcmF3ZXItc2hvd10nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciBkcmF3ZXJJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci1zaG93Jyk7XG4gICAgICAgIHZhciAkZHJhd2VyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcmF3ZXJJZCk7XG4gICAgICAgIGlmICgkZHJhd2VyRWwpIHtcbiAgICAgICAgICAgIHZhciBkcmF3ZXJfMyA9IGdldERyYXdlckluc3RhbmNlKGRyYXdlcklkLCBkcmF3ZXJJbnN0YW5jZXMpO1xuICAgICAgICAgICAgaWYgKGRyYXdlcl8zKSB7XG4gICAgICAgICAgICAgICAgJHRyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyXzMub2JqZWN0LnNob3coKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEcmF3ZXIgd2l0aCBpZCBcIi5jb25jYXQoZHJhd2VySWQsIFwiIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4gUGxlYXNlIGluaXRpYWxpemUgaXQgdXNpbmcgdGhlIGRhdGEtZHJhd2VyLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEcmF3ZXIgd2l0aCBpZCBcIi5jb25jYXQoZHJhd2VySWQsIFwiIG5vdCBmb3VuZC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtZHJhd2VyLXRhcmdldCBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IGRyYXdlciBpZD9cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBEcmF3ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbiAqL1xuaW1wb3J0IHsgY3JlYXRlUG9wcGVyIH0gZnJvbSAnQHBvcHBlcmpzL2NvcmUnO1xudmFyIERlZmF1bHQgPSB7XG4gICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICB0cmlnZ2VyVHlwZTogJ2NsaWNrJyxcbiAgICBvZmZzZXRTa2lkZGluZzogMCxcbiAgICBvZmZzZXREaXN0YW5jZTogMTAsXG4gICAgZGVsYXk6IDMwMCxcbiAgICBvblNob3c6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblRvZ2dsZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBEcm9wZG93biA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcm9wZG93bih0YXJnZXRFbGVtZW50LCB0cmlnZ2VyRWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCA9PT0gdm9pZCAwKSB7IHRhcmdldEVsZW1lbnQgPSBudWxsOyB9XG4gICAgICAgIGlmICh0cmlnZ2VyRWxlbWVudCA9PT0gdm9pZCAwKSB7IHRyaWdnZXJFbGVtZW50ID0gbnVsbDsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIHRoaXMuX3RhcmdldEVsID0gdGFyZ2V0RWxlbWVudDtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckVsID0gdHJpZ2dlckVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZSA9IHRoaXMuX2NyZWF0ZVBvcHBlckluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICBEcm9wZG93bi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9zZXR1cEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHJpZ2dlckV2ZW50cyA9IHRoaXMuX2dldFRyaWdnZXJFdmVudHMoKTtcbiAgICAgICAgLy8gY2xpY2sgZXZlbnQgaGFuZGxpbmcgZm9yIHRyaWdnZXIgZWxlbWVudFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy50cmlnZ2VyVHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cy5zaG93RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaG92ZXIgZXZlbnQgaGFuZGxpbmcgZm9yIHRyaWdnZXIgZWxlbWVudFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy50cmlnZ2VyVHlwZSA9PT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cy5zaG93RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldiA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5fb3B0aW9ucy5kZWxheSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMuaGlkZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3RhcmdldEVsLm1hdGNoZXMoJzpob3ZlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5fb3B0aW9ucy5kZWxheSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl90cmlnZ2VyRWwubWF0Y2hlcygnOmhvdmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF90aGlzLl9vcHRpb25zLmRlbGF5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuX2NyZWF0ZVBvcHBlckluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9wcGVyKHRoaXMuX3RyaWdnZXJFbCwgdGhpcy5fdGFyZ2V0RWwsIHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogdGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICAgICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9mZnNldFNraWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub2Zmc2V0RGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5fc2V0dXBDbGlja091dHNpZGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUNsaWNrT3V0c2lkZShldiwgX3RoaXMuX3RhcmdldEVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrT3V0c2lkZUV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9yZW1vdmVDbGlja091dHNpZGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrT3V0c2lkZUV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9oYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoZXYsIHRhcmdldEVsKSB7XG4gICAgICAgIHZhciBjbGlja2VkRWwgPSBldi50YXJnZXQ7XG4gICAgICAgIGlmIChjbGlja2VkRWwgIT09IHRhcmdldEVsICYmXG4gICAgICAgICAgICAhdGFyZ2V0RWwuY29udGFpbnMoY2xpY2tlZEVsKSAmJlxuICAgICAgICAgICAgIXRoaXMuX3RyaWdnZXJFbC5jb250YWlucyhjbGlja2VkRWwpICYmXG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9nZXRUcmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMudHJpZ2dlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hvdmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ21vdXNlZW50ZXInLCAnY2xpY2snXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogWydtb3VzZWxlYXZlJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ2NsaWNrJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydjbGljayddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uVG9nZ2xlKHRoaXMpO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2Jsb2NrJyk7XG4gICAgICAgIC8vIEVuYWJsZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnNldE9wdGlvbnMoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgbW9kaWZpZXJzOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG9wdGlvbnMubW9kaWZpZXJzLCB0cnVlKSwgW1xuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJywgZW5hYmxlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgXSwgZmFsc2UpIH0pKTsgfSk7XG4gICAgICAgIHRoaXMuX3NldHVwQ2xpY2tPdXRzaWRlTGlzdGVuZXIoKTtcbiAgICAgICAgLy8gVXBkYXRlIGl0cyBwb3NpdGlvblxuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25TaG93KHRoaXMpO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2Jsb2NrJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2Uuc2V0T3B0aW9ucyhmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtb2RpZmllcnM6IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb3B0aW9ucy5tb2RpZmllcnMsIHRydWUpLCBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLCBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgXSwgZmFsc2UpIH0pKTsgfSk7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQ2xpY2tPdXRzaWRlTGlzdGVuZXIoKTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gRHJvcGRvd247XG59KCkpO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LkRyb3Bkb3duID0gRHJvcGRvd247XG59XG5leHBvcnQgZnVuY3Rpb24gaW5pdERyb3Bkb3ducygpIHtcbiAgICBkb2N1bWVudFxuICAgICAgICAucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZHJvcGRvd24tdG9nZ2xlXScpXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciBkcm9wZG93bklkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJvcGRvd24tdG9nZ2xlJyk7XG4gICAgICAgIHZhciAkZHJvcGRvd25FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRyb3Bkb3duSWQpO1xuICAgICAgICBpZiAoJGRyb3Bkb3duRWwpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcm9wZG93bi1wbGFjZW1lbnQnKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXRTa2lkZGluZyA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyb3Bkb3duLW9mZnNldC1za2lkZGluZycpO1xuICAgICAgICAgICAgdmFyIG9mZnNldERpc3RhbmNlID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJvcGRvd24tb2Zmc2V0LWRpc3RhbmNlJyk7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlclR5cGUgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcm9wZG93bi10cmlnZ2VyJyk7XG4gICAgICAgICAgICB2YXIgZGVsYXkgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcm9wZG93bi1kZWxheScpO1xuICAgICAgICAgICAgbmV3IERyb3Bkb3duKCRkcm9wZG93bkVsLCAkdHJpZ2dlckVsLCB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQgPyBwbGFjZW1lbnQgOiBEZWZhdWx0LnBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVHlwZTogdHJpZ2dlclR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyB0cmlnZ2VyVHlwZVxuICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHQudHJpZ2dlclR5cGUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2tpZGRpbmc6IG9mZnNldFNraWRkaW5nXG4gICAgICAgICAgICAgICAgICAgID8gcGFyc2VJbnQob2Zmc2V0U2tpZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgIDogRGVmYXVsdC5vZmZzZXRTa2lkZGluZyxcbiAgICAgICAgICAgICAgICBvZmZzZXREaXN0YW5jZTogb2Zmc2V0RGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJzZUludChvZmZzZXREaXN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0Lm9mZnNldERpc3RhbmNlLFxuICAgICAgICAgICAgICAgIGRlbGF5OiBkZWxheSA/IHBhcnNlSW50KGRlbGF5KSA6IERlZmF1bHQuZGVsYXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgZHJvcGRvd24gZWxlbWVudCB3aXRoIGlkIFxcXCJcIi5jb25jYXQoZHJvcGRvd25JZCwgXCJcXFwiIGRvZXMgbm90IGV4aXN0LiBQbGVhc2UgY2hlY2sgdGhlIGRhdGEtZHJvcGRvd24tdG9nZ2xlIGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBEcm9wZG93bjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJpbXBvcnQgeyBpbml0QWNjb3JkaW9ucyB9IGZyb20gJy4vYWNjb3JkaW9uJztcbmltcG9ydCB7IGluaXRDYXJvdXNlbHMgfSBmcm9tICcuL2Nhcm91c2VsJztcbmltcG9ydCB7IGluaXRDb2xsYXBzZXMgfSBmcm9tICcuL2NvbGxhcHNlJztcbmltcG9ydCB7IGluaXREaWFscyB9IGZyb20gJy4vZGlhbCc7XG5pbXBvcnQgeyBpbml0RGlzbWlzc2VzIH0gZnJvbSAnLi9kaXNtaXNzJztcbmltcG9ydCB7IGluaXREcmF3ZXJzIH0gZnJvbSAnLi9kcmF3ZXInO1xuaW1wb3J0IHsgaW5pdERyb3Bkb3ducyB9IGZyb20gJy4vZHJvcGRvd24nO1xuaW1wb3J0IHsgaW5pdE1vZGFscyB9IGZyb20gJy4vbW9kYWwnO1xuaW1wb3J0IHsgaW5pdFBvcG92ZXJzIH0gZnJvbSAnLi9wb3BvdmVyJztcbmltcG9ydCB7IGluaXRUYWJzIH0gZnJvbSAnLi90YWJzJztcbmltcG9ydCB7IGluaXRUb29sdGlwcyB9IGZyb20gJy4vdG9vbHRpcCc7XG5leHBvcnQgZnVuY3Rpb24gaW5pdEZsb3diaXRlKCkge1xuICAgIGluaXRBY2NvcmRpb25zKCk7XG4gICAgaW5pdENvbGxhcHNlcygpO1xuICAgIGluaXRDYXJvdXNlbHMoKTtcbiAgICBpbml0RGlzbWlzc2VzKCk7XG4gICAgaW5pdERyb3Bkb3ducygpO1xuICAgIGluaXRNb2RhbHMoKTtcbiAgICBpbml0RHJhd2VycygpO1xuICAgIGluaXRUYWJzKCk7XG4gICAgaW5pdFRvb2x0aXBzKCk7XG4gICAgaW5pdFBvcG92ZXJzKCk7XG4gICAgaW5pdERpYWxzKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIERlZmF1bHQgPSB7XG4gICAgcGxhY2VtZW50OiAnY2VudGVyJyxcbiAgICBiYWNrZHJvcENsYXNzZXM6ICdiZy1ncmF5LTkwMCBiZy1vcGFjaXR5LTUwIGRhcms6Ymctb3BhY2l0eS04MCBmaXhlZCBpbnNldC0wIHotNDAnLFxuICAgIGJhY2tkcm9wOiAnZHluYW1pYycsXG4gICAgY2xvc2FibGU6IHRydWUsXG4gICAgb25IaWRlOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25TaG93OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25Ub2dnbGU6IGZ1bmN0aW9uICgpIHsgfSxcbn07XG52YXIgTW9kYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kYWwodGFyZ2V0RWwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRhcmdldEVsID09PSB2b2lkIDApIHsgdGFyZ2V0RWwgPSBudWxsOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBEZWZhdWx0KSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2lzSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gICAgTW9kYWwucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0RWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFBsYWNlbWVudENsYXNzZXMoKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuX2NyZWF0ZUJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLl9pc0hpZGRlbikge1xuICAgICAgICAgICAgdmFyIGJhY2tkcm9wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGJhY2tkcm9wRWwuc2V0QXR0cmlidXRlKCdtb2RhbC1iYWNrZHJvcCcsICcnKTtcbiAgICAgICAgICAgIChfYSA9IGJhY2tkcm9wRWwuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2EsIHRoaXMuX29wdGlvbnMuYmFja2Ryb3BDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZChiYWNrZHJvcEVsKTtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wRWwgPSBiYWNrZHJvcEVsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuX2Rlc3Ryb3lCYWNrZHJvcEVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzSGlkZGVuKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbbW9kYWwtYmFja2Ryb3BdJykucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5fc2V0dXBNb2RhbENsb3NlRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmJhY2tkcm9wID09PSAnZHluYW1pYycpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaWNrT3V0c2lkZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlT3V0c2lkZUNsaWNrKGV2LnRhcmdldCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jbGlja091dHNpZGVFdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9rZXlkb3duRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25FdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5fcmVtb3ZlTW9kYWxDbG9zZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5iYWNrZHJvcCA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrT3V0c2lkZUV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25FdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5faGFuZGxlT3V0c2lkZUNsaWNrID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB0aGlzLl90YXJnZXRFbCB8fFxuICAgICAgICAgICAgKHRhcmdldCA9PT0gdGhpcy5fYmFja2Ryb3BFbCAmJiB0aGlzLmlzVmlzaWJsZSgpKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5fZ2V0UGxhY2VtZW50Q2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgLy8gdG9wXG4gICAgICAgICAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1zdGFydCcsICdpdGVtcy1zdGFydCddO1xuICAgICAgICAgICAgY2FzZSAndG9wLWNlbnRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1jZW50ZXInLCAnaXRlbXMtc3RhcnQnXTtcbiAgICAgICAgICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1lbmQnLCAnaXRlbXMtc3RhcnQnXTtcbiAgICAgICAgICAgIC8vIGNlbnRlclxuICAgICAgICAgICAgY2FzZSAnY2VudGVyLWxlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktc3RhcnQnLCAnaXRlbXMtY2VudGVyJ107XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktY2VudGVyJywgJ2l0ZW1zLWNlbnRlciddO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyLXJpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWVuZCcsICdpdGVtcy1jZW50ZXInXTtcbiAgICAgICAgICAgIC8vIGJvdHRvbVxuICAgICAgICAgICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktc3RhcnQnLCAnaXRlbXMtZW5kJ107XG4gICAgICAgICAgICBjYXNlICdib3R0b20tY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWNlbnRlcicsICdpdGVtcy1lbmQnXTtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1lbmQnLCAnaXRlbXMtZW5kJ107XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktY2VudGVyJywgJ2l0ZW1zLWNlbnRlciddO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblRvZ2dsZSh0aGlzKTtcbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0hpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnZmxleCcpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCAndHJ1ZScpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQmFja2Ryb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX2lzSGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGJvZHkgc2Nyb2xsXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ292ZXJmbG93LWhpZGRlbicpO1xuICAgICAgICAgICAgLy8gQWRkIGtleWJvYXJkIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuY2xvc2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cE1vZGFsQ2xvc2VFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25TaG93KHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZsZXgnKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lCYWNrZHJvcEVsKCk7XG4gICAgICAgICAgICB0aGlzLl9pc0hpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAvLyByZS1hcHBseSBib2R5IHNjcm9sbFxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdvdmVyZmxvdy1oaWRkZW4nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmNsb3NhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTW9kYWxDbG9zZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5faXNIaWRkZW47XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuaXNIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0hpZGRlbjtcbiAgICB9O1xuICAgIHJldHVybiBNb2RhbDtcbn0oKSk7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuTW9kYWwgPSBNb2RhbDtcbn1cbnZhciBnZXRNb2RhbEluc3RhbmNlID0gZnVuY3Rpb24gKGlkLCBpbnN0YW5jZXMpIHtcbiAgICBpZiAoaW5zdGFuY2VzLnNvbWUoZnVuY3Rpb24gKG1vZGFsSW5zdGFuY2UpIHsgcmV0dXJuIG1vZGFsSW5zdGFuY2UuaWQgPT09IGlkOyB9KSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzLmZpbmQoZnVuY3Rpb24gKG1vZGFsSW5zdGFuY2UpIHsgcmV0dXJuIG1vZGFsSW5zdGFuY2UuaWQgPT09IGlkOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRNb2RhbHMoKSB7XG4gICAgdmFyIG1vZGFsSW5zdGFuY2VzID0gW107XG4gICAgLy8gaW5pdGlhdGUgbW9kYWwgYmFzZWQgb24gZGF0YS1tb2RhbC10YXJnZXRcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tb2RhbC10YXJnZXRdJykuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgbW9kYWxJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGFsLXRhcmdldCcpO1xuICAgICAgICB2YXIgJG1vZGFsRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtb2RhbElkKTtcbiAgICAgICAgaWYgKCRtb2RhbEVsKSB7XG4gICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gJG1vZGFsRWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGFsLXBsYWNlbWVudCcpO1xuICAgICAgICAgICAgdmFyIGJhY2tkcm9wID0gJG1vZGFsRWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGFsLWJhY2tkcm9wJyk7XG4gICAgICAgICAgICBpZiAoIWdldE1vZGFsSW5zdGFuY2UobW9kYWxJZCwgbW9kYWxJbnN0YW5jZXMpKSB7XG4gICAgICAgICAgICAgICAgbW9kYWxJbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBtb2RhbElkLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG5ldyBNb2RhbCgkbW9kYWxFbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogRGVmYXVsdC5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcDogYmFja2Ryb3AgPyBiYWNrZHJvcCA6IERlZmF1bHQuYmFja2Ryb3AsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1vZGFsIHdpdGggaWQgXCIuY29uY2F0KG1vZGFsSWQsIFwiIGRvZXMgbm90IGV4aXN0LiBBcmUgeW91IHN1cmUgdGhhdCB0aGUgZGF0YS1tb2RhbC10YXJnZXQgYXR0cmlidXRlIHBvaW50cyB0byB0aGUgY29ycmVjdCBtb2RhbCBpZD8uXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHN1cHBvcnQgcHJlIHYxLjYuMCBkYXRhLW1vZGFsLXRvZ2dsZSBpbml0aWFsaXphdGlvblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1vZGFsLXRvZ2dsZV0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciBtb2RhbElkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwtdG9nZ2xlJyk7XG4gICAgICAgIHZhciAkbW9kYWxFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1vZGFsSWQpO1xuICAgICAgICBpZiAoJG1vZGFsRWwpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkbW9kYWxFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwtcGxhY2VtZW50Jyk7XG4gICAgICAgICAgICB2YXIgYmFja2Ryb3AgPSAkbW9kYWxFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwtYmFja2Ryb3AnKTtcbiAgICAgICAgICAgIHZhciBtb2RhbF8xID0gZ2V0TW9kYWxJbnN0YW5jZShtb2RhbElkLCBtb2RhbEluc3RhbmNlcyk7XG4gICAgICAgICAgICBpZiAoIW1vZGFsXzEpIHtcbiAgICAgICAgICAgICAgICBtb2RhbF8xID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogbW9kYWxJZCxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBuZXcgTW9kYWwoJG1vZGFsRWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHQucGxhY2VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2Ryb3A6IGJhY2tkcm9wID8gYmFja2Ryb3AgOiBEZWZhdWx0LmJhY2tkcm9wLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1vZGFsSW5zdGFuY2VzLnB1c2gobW9kYWxfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG1vZGFsXzEub2JqZWN0LnRvZ2dsZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW9kYWwgd2l0aCBpZCBcIi5jb25jYXQobW9kYWxJZCwgXCIgZG9lcyBub3QgZXhpc3QuIEFyZSB5b3Ugc3VyZSB0aGF0IHRoZSBkYXRhLW1vZGFsLXRvZ2dsZSBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IG1vZGFsIGlkP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBzaG93IG1vZGFsIG9uIGNsaWNrIGlmIGV4aXN0cyBiYXNlZCBvbiBpZFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1vZGFsLXNob3ddJykuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgbW9kYWxJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGFsLXNob3cnKTtcbiAgICAgICAgdmFyICRtb2RhbEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobW9kYWxJZCk7XG4gICAgICAgIGlmICgkbW9kYWxFbCkge1xuICAgICAgICAgICAgdmFyIG1vZGFsXzIgPSBnZXRNb2RhbEluc3RhbmNlKG1vZGFsSWQsIG1vZGFsSW5zdGFuY2VzKTtcbiAgICAgICAgICAgIGlmIChtb2RhbF8yKSB7XG4gICAgICAgICAgICAgICAgJHRyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGFsXzIub2JqZWN0LmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RhbF8yLm9iamVjdC5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb2RhbCB3aXRoIGlkIFwiLmNvbmNhdChtb2RhbElkLCBcIiBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIFBsZWFzZSBpbml0aWFsaXplIGl0IHVzaW5nIHRoZSBkYXRhLW1vZGFsLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb2RhbCB3aXRoIGlkIFwiLmNvbmNhdChtb2RhbElkLCBcIiBkb2VzIG5vdCBleGlzdC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtbW9kYWwtc2hvdyBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IG1vZGFsIGlkP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBoaWRlIG1vZGFsIG9uIGNsaWNrIGlmIGV4aXN0cyBiYXNlZCBvbiBpZFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1vZGFsLWhpZGVdJykuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgbW9kYWxJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGFsLWhpZGUnKTtcbiAgICAgICAgdmFyICRtb2RhbEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobW9kYWxJZCk7XG4gICAgICAgIGlmICgkbW9kYWxFbCkge1xuICAgICAgICAgICAgdmFyIG1vZGFsXzMgPSBnZXRNb2RhbEluc3RhbmNlKG1vZGFsSWQsIG1vZGFsSW5zdGFuY2VzKTtcbiAgICAgICAgICAgIGlmIChtb2RhbF8zKSB7XG4gICAgICAgICAgICAgICAgJHRyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGFsXzMub2JqZWN0LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWxfMy5vYmplY3QuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW9kYWwgd2l0aCBpZCBcIi5jb25jYXQobW9kYWxJZCwgXCIgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLiBQbGVhc2UgaW5pdGlhbGl6ZSBpdCB1c2luZyB0aGUgZGF0YS1tb2RhbC10YXJnZXQgYXR0cmlidXRlLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW9kYWwgd2l0aCBpZCBcIi5jb25jYXQobW9kYWxJZCwgXCIgZG9lcyBub3QgZXhpc3QuIEFyZSB5b3Ugc3VyZSB0aGF0IHRoZSBkYXRhLW1vZGFsLWhpZGUgYXR0cmlidXRlIHBvaW50cyB0byB0aGUgY29ycmVjdCBtb2RhbCBpZD9cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBNb2RhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uICovXG5pbXBvcnQgeyBjcmVhdGVQb3BwZXIgfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG52YXIgRGVmYXVsdCA9IHtcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIG9mZnNldDogMTAsXG4gICAgdHJpZ2dlclR5cGU6ICdob3ZlcicsXG4gICAgb25TaG93OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25IaWRlOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25Ub2dnbGU6IGZ1bmN0aW9uICgpIHsgfSxcbn07XG52YXIgUG9wb3ZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3BvdmVyKHRhcmdldEVsLCB0cmlnZ2VyRWwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRhcmdldEVsID09PSB2b2lkIDApIHsgdGFyZ2V0RWwgPSBudWxsOyB9XG4gICAgICAgIGlmICh0cmlnZ2VyRWwgPT09IHZvaWQgMCkgeyB0cmlnZ2VyRWwgPSBudWxsOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbDtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckVsID0gdHJpZ2dlckVsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UgPSB0aGlzLl9jcmVhdGVQb3BwZXJJbnN0YW5jZSgpO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX3NldHVwRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0cmlnZ2VyRXZlbnRzID0gdGhpcy5fZ2V0VHJpZ2dlckV2ZW50cygpO1xuICAgICAgICB0cmlnZ2VyRXZlbnRzLnNob3dFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyaWdnZXJFdmVudHMuaGlkZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3RhcmdldEVsLm1hdGNoZXMoJzpob3ZlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl90cmlnZ2VyRWwubWF0Y2hlcygnOmhvdmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5fY3JlYXRlUG9wcGVySW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3BwZXIodGhpcy5fdHJpZ2dlckVsLCB0aGlzLl90YXJnZXRFbCwge1xuICAgICAgICAgICAgcGxhY2VtZW50OiB0aGlzLl9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgICAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogWzAsIHRoaXMuX29wdGlvbnMub2Zmc2V0XSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5fZ2V0VHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLnRyaWdnZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdob3Zlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydtb3VzZWVudGVyJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnbW91c2VsZWF2ZScsICdibHVyJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ2NsaWNrJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnZm9jdXNvdXQnLCAnYmx1ciddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydtb3VzZWVudGVyJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnbW91c2VsZWF2ZScsICdibHVyJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX3NldHVwS2V5ZG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9rZXlkb3duRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25FdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLl9yZW1vdmVLZXlkb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25FdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLl9zZXR1cENsaWNrT3V0c2lkZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jbGlja091dHNpZGVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlQ2xpY2tPdXRzaWRlKGV2LCBfdGhpcy5fdGFyZ2V0RWwpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5fcmVtb3ZlQ2xpY2tPdXRzaWRlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jbGlja091dHNpZGVFdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLl9oYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoZXYsIHRhcmdldEVsKSB7XG4gICAgICAgIHZhciBjbGlja2VkRWwgPSBldi50YXJnZXQ7XG4gICAgICAgIGlmIChjbGlja2VkRWwgIT09IHRhcmdldEVsICYmXG4gICAgICAgICAgICAhdGFyZ2V0RWwuY29udGFpbnMoY2xpY2tlZEVsKSAmJlxuICAgICAgICAgICAgIXRoaXMuX3RyaWdnZXJFbC5jb250YWlucyhjbGlja2VkRWwpICYmXG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblRvZ2dsZSh0aGlzKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ29wYWNpdHktMCcsICdpbnZpc2libGUnKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnb3BhY2l0eS0xMDAnLCAndmlzaWJsZScpO1xuICAgICAgICAvLyBFbmFibGUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS5zZXRPcHRpb25zKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1vZGlmaWVyczogX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBvcHRpb25zLm1vZGlmaWVycywgdHJ1ZSksIFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdldmVudExpc3RlbmVycycsIGVuYWJsZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIF0sIGZhbHNlKSB9KSk7IH0pO1xuICAgICAgICAvLyBoYW5kbGUgY2xpY2sgb3V0c2lkZVxuICAgICAgICB0aGlzLl9zZXR1cENsaWNrT3V0c2lkZUxpc3RlbmVyKCk7XG4gICAgICAgIC8vIGhhbmRsZSBlc2Mga2V5ZG93blxuICAgICAgICB0aGlzLl9zZXR1cEtleWRvd25MaXN0ZW5lcigpO1xuICAgICAgICAvLyBVcGRhdGUgaXRzIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICAvLyBzZXQgdmlzaWJpbGl0eSB0byB0cnVlXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uU2hvdyh0aGlzKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ29wYWNpdHktMTAwJywgJ3Zpc2libGUnKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnb3BhY2l0eS0wJywgJ2ludmlzaWJsZScpO1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2Uuc2V0T3B0aW9ucyhmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtb2RpZmllcnM6IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb3B0aW9ucy5tb2RpZmllcnMsIHRydWUpLCBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLCBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgXSwgZmFsc2UpIH0pKTsgfSk7XG4gICAgICAgIC8vIGhhbmRsZSBjbGljayBvdXRzaWRlXG4gICAgICAgIHRoaXMuX3JlbW92ZUNsaWNrT3V0c2lkZUxpc3RlbmVyKCk7XG4gICAgICAgIC8vIGhhbmRsZSBlc2Mga2V5ZG93blxuICAgICAgICB0aGlzLl9yZW1vdmVLZXlkb3duTGlzdGVuZXIoKTtcbiAgICAgICAgLy8gc2V0IHZpc2liaWxpdHkgdG8gZmFsc2VcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uSGlkZSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBQb3BvdmVyO1xufSgpKTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5Qb3BvdmVyID0gUG9wb3Zlcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbml0UG9wb3ZlcnMoKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtcG9wb3Zlci10YXJnZXRdJykuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgcG9wb3ZlcklEID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcG9wb3Zlci10YXJnZXQnKTtcbiAgICAgICAgdmFyICRwb3BvdmVyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwb3BvdmVySUQpO1xuICAgICAgICBpZiAoJHBvcG92ZXJFbCkge1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJUeXBlID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcG9wb3Zlci10cmlnZ2VyJyk7XG4gICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcG9wb3Zlci1wbGFjZW1lbnQnKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wb3BvdmVyLW9mZnNldCcpO1xuICAgICAgICAgICAgbmV3IFBvcG92ZXIoJHBvcG92ZXJFbCwgJHRyaWdnZXJFbCwge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50ID8gcGxhY2VtZW50IDogRGVmYXVsdC5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgPyBwYXJzZUludChvZmZzZXQpIDogRGVmYXVsdC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgdHJpZ2dlclR5cGU6IHRyaWdnZXJUeXBlXG4gICAgICAgICAgICAgICAgICAgID8gdHJpZ2dlclR5cGVcbiAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LnRyaWdnZXJUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIHBvcG92ZXIgZWxlbWVudCB3aXRoIGlkIFxcXCJcIi5jb25jYXQocG9wb3ZlcklELCBcIlxcXCIgZG9lcyBub3QgZXhpc3QuIFBsZWFzZSBjaGVjayB0aGUgZGF0YS1wb3BvdmVyLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgUG9wb3Zlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIERlZmF1bHQgPSB7XG4gICAgZGVmYXVsdFRhYklkOiBudWxsLFxuICAgIGFjdGl2ZUNsYXNzZXM6ICd0ZXh0LWJsdWUtNjAwIGhvdmVyOnRleHQtYmx1ZS02MDAgZGFyazp0ZXh0LWJsdWUtNTAwIGRhcms6aG92ZXI6dGV4dC1ibHVlLTUwMCBib3JkZXItYmx1ZS02MDAgZGFyazpib3JkZXItYmx1ZS01MDAnLFxuICAgIGluYWN0aXZlQ2xhc3NlczogJ2Rhcms6Ym9yZGVyLXRyYW5zcGFyZW50IHRleHQtZ3JheS01MDAgaG92ZXI6dGV4dC1ncmF5LTYwMCBkYXJrOnRleHQtZ3JheS00MDAgYm9yZGVyLWdyYXktMTAwIGhvdmVyOmJvcmRlci1ncmF5LTMwMCBkYXJrOmJvcmRlci1ncmF5LTcwMCBkYXJrOmhvdmVyOnRleHQtZ3JheS0zMDAnLFxuICAgIG9uU2hvdzogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBUYWJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhYnMoaXRlbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSBbXTsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVRhYiA9IG9wdGlvbnMgPyB0aGlzLmdldFRhYihvcHRpb25zLmRlZmF1bHRUYWJJZCkgOiBudWxsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICBUYWJzLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBmaXJzdCB0YWIgYXMgYWN0aXZlIGlmIG5vdCBzZXQgYnkgZXhwbGljaXRseVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmVUYWIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBY3RpdmVUYWIodGhpcy5faXRlbXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm9yY2Ugc2hvdyB0aGUgZmlyc3QgZGVmYXVsdCB0YWJcbiAgICAgICAgICAgIHRoaXMuc2hvdyh0aGlzLl9hY3RpdmVUYWIuaWQsIHRydWUpO1xuICAgICAgICAgICAgLy8gc2hvdyB0YWIgY29udGVudCBiYXNlZCBvbiBjbGlja1xuICAgICAgICAgICAgdGhpcy5faXRlbXMubWFwKGZ1bmN0aW9uICh0YWIpIHtcbiAgICAgICAgICAgICAgICB0YWIudHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaG93KHRhYi5pZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFicy5wcm90b3R5cGUuZ2V0QWN0aXZlVGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlVGFiO1xuICAgIH07XG4gICAgVGFicy5wcm90b3R5cGUuX3NldEFjdGl2ZVRhYiA9IGZ1bmN0aW9uICh0YWIpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlVGFiID0gdGFiO1xuICAgIH07XG4gICAgVGFicy5wcm90b3R5cGUuZ2V0VGFiID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuaWQgPT09IGlkOyB9KVswXTtcbiAgICB9O1xuICAgIFRhYnMucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoaWQsIGZvcmNlU2hvdykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZm9yY2VTaG93ID09PSB2b2lkIDApIHsgZm9yY2VTaG93ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHRhYiA9IHRoaXMuZ2V0VGFiKGlkKTtcbiAgICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgYWxyZWFkeSBhY3RpdmVcbiAgICAgICAgaWYgKHRhYiA9PT0gdGhpcy5fYWN0aXZlVGFiICYmICFmb3JjZVNob3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBoaWRlIG90aGVyIHRhYnNcbiAgICAgICAgdGhpcy5faXRlbXMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKHQgIT09IHRhYikge1xuICAgICAgICAgICAgICAgIChfYSA9IHQudHJpZ2dlckVsLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9hLCBfdGhpcy5fb3B0aW9ucy5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgICAgIChfYiA9IHQudHJpZ2dlckVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9iLCBfdGhpcy5fb3B0aW9ucy5pbmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICAgICAgdC50YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB0LnRyaWdnZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNob3cgYWN0aXZlIHRhYlxuICAgICAgICAoX2EgPSB0YWIudHJpZ2dlckVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9hLCB0aGlzLl9vcHRpb25zLmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgIChfYiA9IHRhYi50cmlnZ2VyRWwuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2IsIHRoaXMuX29wdGlvbnMuaW5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICB0YWIudHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICAgIHRhYi50YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlVGFiKHRhYik7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25TaG93KHRoaXMsIHRhYik7XG4gICAgfTtcbiAgICByZXR1cm4gVGFicztcbn0oKSk7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuVGFicyA9IFRhYnM7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5pdFRhYnMoKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGFicy10b2dnbGVdJykuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgdGFiSXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIGRlZmF1bHRUYWJJZCA9IG51bGw7XG4gICAgICAgICR0cmlnZ2VyRWxcbiAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRhYlwiXScpXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICAgICAgdmFyIGlzQWN0aXZlID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnKSA9PT0gJ3RydWUnO1xuICAgICAgICAgICAgdmFyIHRhYiA9IHtcbiAgICAgICAgICAgICAgICBpZDogJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFicy10YXJnZXQnKSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWw6ICR0cmlnZ2VyRWwsXG4gICAgICAgICAgICAgICAgdGFyZ2V0RWw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFicy10YXJnZXQnKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFiSXRlbXMucHVzaCh0YWIpO1xuICAgICAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhYklkID0gdGFiLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbmV3IFRhYnModGFiSXRlbXMsIHtcbiAgICAgICAgICAgIGRlZmF1bHRUYWJJZDogZGVmYXVsdFRhYklkLFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IFRhYnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbiAqL1xuaW1wb3J0IHsgY3JlYXRlUG9wcGVyIH0gZnJvbSAnQHBvcHBlcmpzL2NvcmUnO1xudmFyIERlZmF1bHQgPSB7XG4gICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICB0cmlnZ2VyVHlwZTogJ2hvdmVyJyxcbiAgICBvblNob3c6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblRvZ2dsZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBUb29sdGlwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvb2x0aXAodGFyZ2V0RWwsIHRyaWdnZXJFbCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGFyZ2V0RWwgPT09IHZvaWQgMCkgeyB0YXJnZXRFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRyaWdnZXJFbCA9PT0gdm9pZCAwKSB7IHRyaWdnZXJFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgICB0aGlzLl90cmlnZ2VyRWwgPSB0cmlnZ2VyRWw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZSA9IHRoaXMuX2NyZWF0ZVBvcHBlckluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICBUb29sdGlwLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5fc2V0dXBFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRyaWdnZXJFdmVudHMgPSB0aGlzLl9nZXRUcmlnZ2VyRXZlbnRzKCk7XG4gICAgICAgIHRyaWdnZXJFdmVudHMuc2hvd0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmlnZ2VyRXZlbnRzLmhpZGVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLl9jcmVhdGVQb3BwZXJJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcHBlcih0aGlzLl90cmlnZ2VyRWwsIHRoaXMuX3RhcmdldEVsLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBbMCwgOF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2dldFRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fb3B0aW9ucy50cmlnZ2VyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaG92ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFsnbW91c2VlbnRlcicsICdmb2N1cyddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbJ21vdXNlbGVhdmUnLCAnYmx1ciddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydjbGljaycsICdmb2N1cyddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbJ2ZvY3Vzb3V0JywgJ2JsdXInXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFsnbW91c2VlbnRlcicsICdmb2N1cyddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbJ21vdXNlbGVhdmUnLCAnYmx1ciddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLl9zZXR1cEtleWRvd25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fa2V5ZG93bkV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5fcmVtb3ZlS2V5ZG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5fc2V0dXBDbGlja091dHNpZGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUNsaWNrT3V0c2lkZShldiwgX3RoaXMuX3RhcmdldEVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrT3V0c2lkZUV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX3JlbW92ZUNsaWNrT3V0c2lkZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5faGFuZGxlQ2xpY2tPdXRzaWRlID0gZnVuY3Rpb24gKGV2LCB0YXJnZXRFbCkge1xuICAgICAgICB2YXIgY2xpY2tlZEVsID0gZXYudGFyZ2V0O1xuICAgICAgICBpZiAoY2xpY2tlZEVsICE9PSB0YXJnZXRFbCAmJlxuICAgICAgICAgICAgIXRhcmdldEVsLmNvbnRhaW5zKGNsaWNrZWRFbCkgJiZcbiAgICAgICAgICAgICF0aGlzLl90cmlnZ2VyRWwuY29udGFpbnMoY2xpY2tlZEVsKSAmJlxuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdvcGFjaXR5LTAnLCAnaW52aXNpYmxlJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ29wYWNpdHktMTAwJywgJ3Zpc2libGUnKTtcbiAgICAgICAgLy8gRW5hYmxlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2Uuc2V0T3B0aW9ucyhmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtb2RpZmllcnM6IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb3B0aW9ucy5tb2RpZmllcnMsIHRydWUpLCBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLCBlbmFibGVkOiB0cnVlIH0sXG4gICAgICAgICAgICBdLCBmYWxzZSkgfSkpOyB9KTtcbiAgICAgICAgLy8gaGFuZGxlIGNsaWNrIG91dHNpZGVcbiAgICAgICAgdGhpcy5fc2V0dXBDbGlja091dHNpZGVMaXN0ZW5lcigpO1xuICAgICAgICAvLyBoYW5kbGUgZXNjIGtleWRvd25cbiAgICAgICAgdGhpcy5fc2V0dXBLZXlkb3duTGlzdGVuZXIoKTtcbiAgICAgICAgLy8gVXBkYXRlIGl0cyBwb3NpdGlvblxuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgLy8gc2V0IHZpc2liaWxpdHlcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25TaG93KHRoaXMpO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnb3BhY2l0eS0xMDAnLCAndmlzaWJsZScpO1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdvcGFjaXR5LTAnLCAnaW52aXNpYmxlJyk7XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS5zZXRPcHRpb25zKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1vZGlmaWVyczogX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBvcHRpb25zLm1vZGlmaWVycywgdHJ1ZSksIFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdldmVudExpc3RlbmVycycsIGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICBdLCBmYWxzZSkgfSkpOyB9KTtcbiAgICAgICAgLy8gaGFuZGxlIGNsaWNrIG91dHNpZGVcbiAgICAgICAgdGhpcy5fcmVtb3ZlQ2xpY2tPdXRzaWRlTGlzdGVuZXIoKTtcbiAgICAgICAgLy8gaGFuZGxlIGVzYyBrZXlkb3duXG4gICAgICAgIHRoaXMuX3JlbW92ZUtleWRvd25MaXN0ZW5lcigpO1xuICAgICAgICAvLyBzZXQgdmlzaWJpbGl0eVxuICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25IaWRlKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2x0aXA7XG59KCkpO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LlRvb2x0aXAgPSBUb29sdGlwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluaXRUb29sdGlwcygpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10b29sdGlwLXRhcmdldF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciB0b29sdGlwSWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXRhcmdldCcpO1xuICAgICAgICB2YXIgJHRvb2x0aXBFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRvb2x0aXBJZCk7XG4gICAgICAgIGlmICgkdG9vbHRpcEVsKSB7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlclR5cGUgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXRyaWdnZXInKTtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXBsYWNlbWVudCcpO1xuICAgICAgICAgICAgbmV3IFRvb2x0aXAoJHRvb2x0aXBFbCwgJHRyaWdnZXJFbCwge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50ID8gcGxhY2VtZW50IDogRGVmYXVsdC5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgdHJpZ2dlclR5cGU6IHRyaWdnZXJUeXBlXG4gICAgICAgICAgICAgICAgICAgID8gdHJpZ2dlclR5cGVcbiAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LnRyaWdnZXJUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIHRvb2x0aXAgZWxlbWVudCB3aXRoIGlkIFxcXCJcIi5jb25jYXQodG9vbHRpcElkLCBcIlxcXCIgZG9lcyBub3QgZXhpc3QuIFBsZWFzZSBjaGVjayB0aGUgZGF0YS10b29sdGlwLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgVG9vbHRpcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJ2YXIgRXZlbnRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50cyhldmVudFR5cGUsIGV2ZW50RnVuY3Rpb25zKSB7XG4gICAgICAgIGlmIChldmVudEZ1bmN0aW9ucyA9PT0gdm9pZCAwKSB7IGV2ZW50RnVuY3Rpb25zID0gW107IH1cbiAgICAgICAgdGhpcy5fZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuICAgICAgICB0aGlzLl9ldmVudEZ1bmN0aW9ucyA9IGV2ZW50RnVuY3Rpb25zO1xuICAgIH1cbiAgICBFdmVudHMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2V2ZW50RnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKF90aGlzLl9ldmVudFR5cGUsIGV2ZW50RnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudHM7XG59KCkpO1xuZXhwb3J0IGRlZmF1bHQgRXZlbnRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCIsImltcG9ydCBFdmVudHMgZnJvbSAnLi9kb20vZXZlbnRzJztcbmltcG9ydCB7IGluaXRBY2NvcmRpb25zIH0gZnJvbSAnLi9jb21wb25lbnRzL2FjY29yZGlvbic7XG5pbXBvcnQgeyBpbml0Q29sbGFwc2VzIH0gZnJvbSAnLi9jb21wb25lbnRzL2NvbGxhcHNlJztcbmltcG9ydCB7IGluaXRDYXJvdXNlbHMgfSBmcm9tICcuL2NvbXBvbmVudHMvY2Fyb3VzZWwnO1xuaW1wb3J0IHsgaW5pdERpc21pc3NlcyB9IGZyb20gJy4vY29tcG9uZW50cy9kaXNtaXNzJztcbmltcG9ydCB7IGluaXREcm9wZG93bnMgfSBmcm9tICcuL2NvbXBvbmVudHMvZHJvcGRvd24nO1xuaW1wb3J0IHsgaW5pdE1vZGFscyB9IGZyb20gJy4vY29tcG9uZW50cy9tb2RhbCc7XG5pbXBvcnQgeyBpbml0RHJhd2VycyB9IGZyb20gJy4vY29tcG9uZW50cy9kcmF3ZXInO1xuaW1wb3J0IHsgaW5pdFRhYnMgfSBmcm9tICcuL2NvbXBvbmVudHMvdGFicyc7XG5pbXBvcnQgeyBpbml0VG9vbHRpcHMgfSBmcm9tICcuL2NvbXBvbmVudHMvdG9vbHRpcCc7XG5pbXBvcnQgeyBpbml0UG9wb3ZlcnMgfSBmcm9tICcuL2NvbXBvbmVudHMvcG9wb3Zlcic7XG5pbXBvcnQgeyBpbml0RGlhbHMgfSBmcm9tICcuL2NvbXBvbmVudHMvZGlhbCc7XG4vLyBzZXR1cCBldmVudHMgZm9yIGRhdGEgYXR0cmlidXRlc1xudmFyIGV2ZW50cyA9IG5ldyBFdmVudHMoJ2xvYWQnLCBbXG4gICAgaW5pdEFjY29yZGlvbnMsXG4gICAgaW5pdENvbGxhcHNlcyxcbiAgICBpbml0Q2Fyb3VzZWxzLFxuICAgIGluaXREaXNtaXNzZXMsXG4gICAgaW5pdERyb3Bkb3ducyxcbiAgICBpbml0TW9kYWxzLFxuICAgIGluaXREcmF3ZXJzLFxuICAgIGluaXRUYWJzLFxuICAgIGluaXRUb29sdGlwcyxcbiAgICBpbml0UG9wb3ZlcnMsXG4gICAgaW5pdERpYWxzLFxuXSk7XG5ldmVudHMuaW5pdCgpO1xuLy8gZXhwb3J0IGFsbCBjb21wb25lbnRzXG5leHBvcnQgeyBkZWZhdWx0IGFzIEFjY29yZGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy9hY2NvcmRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYXJvdXNlbCB9IGZyb20gJy4vY29tcG9uZW50cy9jYXJvdXNlbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbGxhcHNlIH0gZnJvbSAnLi9jb21wb25lbnRzL2NvbGxhcHNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlhbCB9IGZyb20gJy4vY29tcG9uZW50cy9kaWFsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlzbWlzcyB9IGZyb20gJy4vY29tcG9uZW50cy9kaXNtaXNzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRHJhd2VyIH0gZnJvbSAnLi9jb21wb25lbnRzL2RyYXdlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERyb3Bkb3duIH0gZnJvbSAnLi9jb21wb25lbnRzL2Ryb3Bkb3duJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTW9kYWwgfSBmcm9tICcuL2NvbXBvbmVudHMvbW9kYWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb3BvdmVyIH0gZnJvbSAnLi9jb21wb25lbnRzL3BvcG92ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJzIH0gZnJvbSAnLi9jb21wb25lbnRzL3RhYnMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUb29sdGlwIH0gZnJvbSAnLi9jb21wb25lbnRzL3Rvb2x0aXAnO1xuLy8gZXhwb3J0IGFsbCB0eXBlc1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2FjY29yZGlvbi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvY2Fyb3VzZWwvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2NvbGxhcHNlL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9kaWFsL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9kaXNtaXNzL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9kcmF3ZXIvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2Ryb3Bkb3duL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9tb2RhbC90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvcG9wb3Zlci90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvdGFicy90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvdG9vbHRpcC90eXBlcyc7XG4vLyBleHBvcnQgYWxsIGludGVyZmFjZXNcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9hY2NvcmRpb24vaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9jYXJvdXNlbC9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2NvbGxhcHNlL2ludGVyZmFjZSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvZGlhbC9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2Rpc21pc3MvaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9kcmF3ZXIvaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9kcm9wZG93bi9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL21vZGFsL2ludGVyZmFjZSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvcG9wb3Zlci9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL3RhYnMvaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy90b29sdGlwL2ludGVyZmFjZSc7XG4vLyBleHBvcnQgaW5pdCBmdW5jdGlvbnNcbmV4cG9ydCB7IGluaXRBY2NvcmRpb25zIH0gZnJvbSAnLi9jb21wb25lbnRzL2FjY29yZGlvbic7XG5leHBvcnQgeyBpbml0Q2Fyb3VzZWxzIH0gZnJvbSAnLi9jb21wb25lbnRzL2Nhcm91c2VsJztcbmV4cG9ydCB7IGluaXRDb2xsYXBzZXMgfSBmcm9tICcuL2NvbXBvbmVudHMvY29sbGFwc2UnO1xuZXhwb3J0IHsgaW5pdERpYWxzIH0gZnJvbSAnLi9jb21wb25lbnRzL2RpYWwnO1xuZXhwb3J0IHsgaW5pdERpc21pc3NlcyB9IGZyb20gJy4vY29tcG9uZW50cy9kaXNtaXNzJztcbmV4cG9ydCB7IGluaXREcmF3ZXJzIH0gZnJvbSAnLi9jb21wb25lbnRzL2RyYXdlcic7XG5leHBvcnQgeyBpbml0RHJvcGRvd25zIH0gZnJvbSAnLi9jb21wb25lbnRzL2Ryb3Bkb3duJztcbmV4cG9ydCB7IGluaXRNb2RhbHMgfSBmcm9tICcuL2NvbXBvbmVudHMvbW9kYWwnO1xuZXhwb3J0IHsgaW5pdFBvcG92ZXJzIH0gZnJvbSAnLi9jb21wb25lbnRzL3BvcG92ZXInO1xuZXhwb3J0IHsgaW5pdFRhYnMgfSBmcm9tICcuL2NvbXBvbmVudHMvdGFicyc7XG5leHBvcnQgeyBpbml0VG9vbHRpcHMgfSBmcm9tICcuL2NvbXBvbmVudHMvdG9vbHRpcCc7XG4vLyBleHBvcnQgYWxsIGluaXQgZnVuY3Rpb25zXG5leHBvcnQgeyBpbml0Rmxvd2JpdGUgfSBmcm9tICcuL2NvbXBvbmVudHMvaW5kZXgnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHtNb2RhbCwgTW9kYWxJbnRlcmZhY2UsIE1vZGFsT3B0aW9ucyB9IGZyb20gXCJmbG93Yml0ZVwiO1xuaW1wb3J0IHsgSVByb2R1Y3RBbGxvY2F0ZWRCYXNlIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuY29uc3QgY3JlYXRlSW5ib3VuZE9yZGVySGFuZGxlciA9ICgpID0+IHtcbiAgY29uc3QgY3JlYXRlSW5ib3VuZE9yZGVyQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luYm91bmQtb3JkZXItY3JlYXRlLWJ0bicpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICBjb25zdCBjcmVhdGVJbmJvdW5kT3JkZXJCdG5TdWJtaXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5ib3VuZC1vcmRlci1hZGQtc3VibWl0LWJ0bicpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICBpZighY3JlYXRlSW5ib3VuZE9yZGVyQnRuKSB7XG4gICAgY29uc29sZS5sb2coXCJFcnJvcjogbm8gY3JlYXRlIGluYm91bmQgb3JkZXIgYnV0dG9uXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjcmVhdGVJbmJvdW5kT3JkZXJCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgY29uc3QgYWxsb2NhdGVkUHJvZHVjdHNEYXRhOiBJUHJvZHVjdEFsbG9jYXRlZEJhc2VbXSA9IFtdXG4gICAgLy8gU2V0IHByb2R1Y3RzIGFzIEpTT04gdG8gZmllbGRcbiAgICBjb25zdCBwcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lcnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucHJvZHVjdC1hbGxvY2F0ZWQnKTtcblxuICAgIHByb2R1Y3RzQWxsb2NhdGVkQ29udGFpbmVycy5mb3JFYWNoKChwcm9kdWN0Q29udGFpbmVyKSA9PiB7XG4gICAgICAvLyBHZXQgSFRNTCBub2RlcyB3aXRoIHByb2R1Y3QgdmFsdWVzXG4gICAgICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkUXVhbnRpdHlJbnB1dCA9IHByb2R1Y3RDb250YWluZXIucXVlcnlTZWxlY3RvcignLnByb2R1Y3QtYWxsb2NhdGVkLXF1YW50aXR5JykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRTaGVsZkxpZmVTdGFydElucHV0ID0gcHJvZHVjdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1hbGxvY2F0ZWQtc2hlbGYtbGlmZS1zdGFydCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkU2hlbGZMaWZlRW5kSW5wdXQgPSBwcm9kdWN0Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LWFsbG9jYXRlZC1zaGVsZi1saWZlLWVuZCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICAgIGxldCBwcm9kdWN0SWQ7ICAgICAgXG4gICAgICBjb25zdCBpbnB1dEZpZWxkID0gcHJvZHVjdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci1hZGQtYWRkLXByb2R1Y3Qtc2VsZWN0JykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9uID0gcHJvZHVjdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGAjcHJvZHVjdC1saXN0IG9wdGlvblt2YWx1ZT1cIiR7aW5wdXRGaWVsZC52YWx1ZX1cIl1gKTtcblxuICAgICAgaWYoIXNlbGVjdGVkT3B0aW9uKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFsZXJ0KCdQbGVhc2Ugc2VsZWN0IGEgdmFsaWQgcHJvZHVjdCBmcm9tIHRoZSBsaXN0Jyk7XG4gICAgICB9ICAgICAgICAgICBcbiAgICAgIHByb2R1Y3RJZCA9IHBhcnNlSW50KHNlbGVjdGVkT3B0aW9uLmdldEF0dHJpYnV0ZSgnZGF0YS1wcm9kdWN0LWlkJykpID8/IDAgOyAgICAgXG4gICAgICAvLyBSZXRyaWV2ZSB2YWx1ZXMgZnJvbSBOb2Rlc1xuICAgICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZFF1YW50aXR5ID0gcGFyc2VJbnQocHJvZHVjdEFsbG9jYXRlZFF1YW50aXR5SW5wdXQudmFsdWUpO1xuICAgICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZVN0YXJ0ID0gcHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZVN0YXJ0SW5wdXQudmFsdWU7XG4gICAgICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkU2hlbGZMaWZlRW5kID0gcHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZUVuZElucHV0LnZhbHVlO1xuXG4gICAgICBhbGxvY2F0ZWRQcm9kdWN0c0RhdGEucHVzaCh7XG4gICAgICAgIGlkOiBwcm9kdWN0SWQsXG4gICAgICAgIHF1YW50aXR5OiBwcm9kdWN0QWxsb2NhdGVkUXVhbnRpdHksXG4gICAgICAgIHNoZWxmTGlmZVN0YXJ0OiBwcm9kdWN0QWxsb2NhdGVkU2hlbGZMaWZlU3RhcnQsXG4gICAgICAgIHNoZWxmTGlmZUVuZDogcHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZUVuZCxcbiAgICAgIH0pXG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnB1dFByb2R1Y3RzOiBIVE1MSW5wdXRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgI2luYm91bmQtb3JkZXItYWRkLXByb2R1Y3RzYClcbiAgICBpbnB1dFByb2R1Y3RzLnZhbHVlID0gSlNPTi5zdHJpbmdpZnkoYWxsb2NhdGVkUHJvZHVjdHNEYXRhKVxuICAgIGNyZWF0ZUluYm91bmRPcmRlckJ0blN1Ym1pdC5jbGljaygpXG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgaW5pdEFkZEluYm91bmRPcmRlck1vZGFsID0gKCkgPT4ge1xuICBjb25zdCBhZGRNb2RhbEJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLWFkZC1tb2RhbC1idXR0b24nKTtcbiAgY29uc3QgYWRkSW5ib3VuZE9yZGVyTW9kYWxFbGVtZW50OiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhZGQtaW5ib3VuZC1vcmRlci1tb2RhbCcpXG4gIGNvbnN0IGFkZE1vZGFsT3B0aW9uczogTW9kYWxPcHRpb25zID0ge1xuICAgIHBsYWNlbWVudDogJ2JvdHRvbS1yaWdodCcsXG4gICAgYmFja2Ryb3A6ICdkeW5hbWljJyxcbiAgICBiYWNrZHJvcENsYXNzZXM6ICdiZy1ncmF5LTkwMCBiZy1vcGFjaXR5LTUwIGRhcms6Ymctb3BhY2l0eS04MCBmaXhlZCBpbnNldC0wIHotNDAnLFxuICAgIGNsb3NhYmxlOiB0cnVlLFxuICAgIG9uSGlkZTogKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ2luYm91bmQtb3JkZXIgaWQ6ICcpXG4gICAgfSxcbiAgICBvblNob3c6ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdpbmJvdW5kLW9yZGVyIGlkOiAnKVxuICAgIH0sXG4gICAgb25Ub2dnbGU6ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdtb2RhbCBoYXMgYmVlbiB0b2dnbGVkJylcbiAgICB9LFxuICB9XG5cbiAgY29uc3QgYWRkTW9kYWw6IE1vZGFsSW50ZXJmYWNlID0gbmV3IE1vZGFsKGFkZEluYm91bmRPcmRlck1vZGFsRWxlbWVudCwgYWRkTW9kYWxPcHRpb25zKTtcbiAgYWRkTW9kYWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7ICAgIFxuICAgIGFkZE1vZGFsLnNob3coKTtcbiAgfSk7XG5cbiAgY29uc3QgYWRkTW9kYWxDbG9zZUJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhZGQtbW9kYWwtYnRuLWhpZGUnKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgYWRkTW9kYWxDbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBhZGRNb2RhbC5oaWRlKCk7XG4gIH0pXG5cbiAgY3JlYXRlSW5ib3VuZE9yZGVySGFuZGxlcigpO1xufSIsImltcG9ydCB7IE1vZGFsT3B0aW9ucywgTW9kYWwgfSBmcm9tICdmbG93Yml0ZSc7XG5pbXBvcnQgeyBJSW5ib3VuZE9yZGVyT3V0LCBJUHJvZHVjdEdyb3VwQ3JlYXRlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXREYXRlcGlja2VyRGF0ZUZvcm1hdCB9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBzZXROZXdRdWFudGl0eVZpZXcgPSAocXVhbnRpdHlHcm91cENvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQpID0+IHtcbiAgY29uc3QgcXVhbnRpdGllc1Blckdyb3VwID0gcXVhbnRpdHlHcm91cENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICcuaW5ib3VuZC1vcmRlci1lZGl0LWFkZC1xdWFudGl0eSdcbiAgKSBhcyBOb2RlTGlzdE9mPEhUTUxJbnB1dEVsZW1lbnQ+O1xuICBjb25zdCBxdWFudGl0eVZpZXcgPSBxdWFudGl0eUdyb3VwQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbmJvdW5kLW9yZGVyLWVkaXQtY2hlY2stcXVhbnRpdHknKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgbGV0IHF1YW50aXR5QXZhaWxhYmxlID0gcGFyc2VJbnQocXVhbnRpdHlWaWV3LmdldEF0dHJpYnV0ZSgnZGF0YS1xdWFudGl0eScpKTtcblxuICBsZXQgcXVhbnRpdHlUb3RhbCA9IDA7XG5cbiAgcXVhbnRpdGllc1Blckdyb3VwLmZvckVhY2goKHF1YW50aXR5UGVyR3JvdXApID0+IHtcbiAgICBpZiAocXVhbnRpdHlQZXJHcm91cC52YWx1ZSkge1xuICAgICAgcXVhbnRpdHlUb3RhbCArPSBwYXJzZUludChxdWFudGl0eVBlckdyb3VwLnZhbHVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHF1YW50aXR5Vmlldy5pbm5lckhUTUwgPSAocXVhbnRpdHlBdmFpbGFibGUgLSBxdWFudGl0eVRvdGFsKS50b1N0cmluZygpO1xufTtcblxuY29uc3QgY3JlYXRlUHJvZHVjdEdyb3VwID0gKGFsbG9jYXRlZFByb2R1Y3RDb250YWluZXI6IEhUTUxEaXZFbGVtZW50KSA9PiB7XG4gIGNvbnN0IGdyb3VwSXRlbVRlbXBsYXRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmdyb3VwLXF1YW50aXR5LWl0ZW0nKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgY29uc3QgZ3JvdXBRdWFudGl0eUl0ZW1OZXcgPSBncm91cEl0ZW1UZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTERpdkVsZW1lbnQ7XG4gIGdyb3VwUXVhbnRpdHlJdGVtTmV3LmNsYXNzTGlzdC5yZW1vdmUoJ2ludmlzaWJsZScpO1xuXG4gIGdyb3VwUXVhbnRpdHlJdGVtTmV3LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLWVkaXQtYWRkLWdyb3VwJykuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICBjb25zdCB1cGxvYWRHcm91cElucHV0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICBjb25zdCBvcHRpb24gPSB1cGxvYWRHcm91cElucHV0Lmxpc3QucXVlcnlTZWxlY3Rvcignb3B0aW9uW3ZhbHVlPVwiJyArIHVwbG9hZEdyb3VwSW5wdXQudmFsdWUgKyAnXCJdJykgYXMgSFRNTEVsZW1lbnQ7XG4gICAgLy8gTk9URSBVc2UgbGFyZ2UgbnVtYmVyIGlmIG5vIGdyb3VwIHNlbGVjdGVkLiBJbXBvc3NpYmxlIHRvIHJlYWNoIHRoYXQgbnVtYmVyIGluIHByb2QuXG4gICAgLy8gVXNlZCB0byBhdm9pZCB3cm9uZyB2YWxpZGF0aW9uIGluIGJhY2tlbmQgd3Rmb3JtIHdoZW4gcGFzcyAwIGFuZCBnZXQgTm9uZVxuICAgIGxldCBncm91cElkO1xuICAgIGlmICh1cGxvYWRHcm91cElucHV0LnZhbHVlKSB7XG4gICAgICBncm91cElkID0gb3B0aW9uLmdldEF0dHJpYnV0ZSgnaW5ib3VuZC1vcmRlci1lZGl0LWFkZC1ncm91cC1pZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cElkID0gJyc7XG4gICAgfVxuXG4gICAgY29uc3QgaGlkZGVuSW5wdXQgPSBncm91cFF1YW50aXR5SXRlbU5ldy5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci1lZGl0LWFkZC1ncm91cC1oaWRkZW4nKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGhpZGRlbklucHV0LnZhbHVlID0gZ3JvdXBJZC50b1N0cmluZygpO1xuICB9KTtcblxuICBjb25zdCBidXR0b25EZWxldGVRdWFudGl0eUdyb3VwID0gZ3JvdXBRdWFudGl0eUl0ZW1OZXcucXVlcnlTZWxlY3RvcihcbiAgICAnLnF1YW50aXR5LWdyb3VwLWRlbGV0ZS1idXR0b24nXG4gICkgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG5cbiAgYnV0dG9uRGVsZXRlUXVhbnRpdHlHcm91cC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgZ3JvdXBRdWFudGl0eUl0ZW1OZXcucmVtb3ZlKCk7XG4gICAgc2V0TmV3UXVhbnRpdHlWaWV3KGFsbG9jYXRlZFByb2R1Y3RDb250YWluZXIpO1xuICB9KTtcblxuICBjb25zdCBxdWFudGl0eUlucHV0ID0gZ3JvdXBRdWFudGl0eUl0ZW1OZXcucXVlcnlTZWxlY3RvcignLmluYm91bmQtb3JkZXItZWRpdC1hZGQtcXVhbnRpdHknKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBjb25zdCBxdWFudGl0eVZpZXcgPSBhbGxvY2F0ZWRQcm9kdWN0Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbmJvdW5kLW9yZGVyLWVkaXQtY2hlY2stcXVhbnRpdHknKTtcbiAgY29uc3QgcXVhbnRpdGllc0dyb3VwSW5wdXRzID0gYWxsb2NhdGVkUHJvZHVjdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICcuaW5ib3VuZC1vcmRlci1lZGl0LWFkZC1xdWFudGl0eSdcbiAgKSBhcyBOb2RlTGlzdE9mPEhUTUxJbnB1dEVsZW1lbnQ+O1xuXG4gIGxldCBxdWFudGl0eUxlZnQgPSBwYXJzZUludChxdWFudGl0eVZpZXcuZ2V0QXR0cmlidXRlKCdkYXRhLXF1YW50aXR5JykpO1xuICBxdWFudGl0aWVzR3JvdXBJbnB1dHMuZm9yRWFjaCgocXVhbnRpdHlHcm91cElucHV0KSA9PiB7XG4gICAgaWYgKHF1YW50aXR5R3JvdXBJbnB1dC52YWx1ZSkge1xuICAgICAgcXVhbnRpdHlMZWZ0IC09IHBhcnNlSW50KHF1YW50aXR5R3JvdXBJbnB1dC52YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcXVhbnRpdHlJbnB1dC52YWx1ZSA9IHF1YW50aXR5TGVmdC50b1N0cmluZygpO1xuICAoYWxsb2NhdGVkUHJvZHVjdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuaW5ib3VuZC1vcmRlci1hZGQtcHJvZHVjdC1ncm91cC1idG4nKSBhcyBIVE1MQnV0dG9uRWxlbWVudCkuYmVmb3JlKFxuICAgIGdyb3VwUXVhbnRpdHlJdGVtTmV3XG4gICk7XG5cbiAgcXVhbnRpdHlJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG4gICAgc2V0TmV3UXVhbnRpdHlWaWV3KGFsbG9jYXRlZFByb2R1Y3RDb250YWluZXIpO1xuICB9KTtcbiAgc2V0TmV3UXVhbnRpdHlWaWV3KGFsbG9jYXRlZFByb2R1Y3RDb250YWluZXIpO1xuICByZXR1cm4gZ3JvdXBRdWFudGl0eUl0ZW1OZXc7XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdEVkaXRPcmRlck1vZGFsID0gKCkgPT4ge1xuICAvLyBOb2Rlc1xuICBjb25zdCBvcmRlckVkaXRQcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgJyNpbmJvdW5kLW9yZGVyLWVkaXQtY2hlY2stY29udGFpbmVyJ1xuICApIGFzIEhUTUxFbGVtZW50O1xuICBjb25zdCBvcmRlckVkaXRNb2RhbEhUTUwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZWRpdC1pbmJvdW5kLW9yZGVyLW1vZGFsJykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gIGNvbnN0IG9yZGVyRWRpdEJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaW5ib3VuZC1vcmRlci1lZGl0LWJ1dHRvbicpIGFzIE5vZGVMaXN0T2Y8SFRNTEJ1dHRvbkVsZW1lbnQ+O1xuICBjb25zdCBvcmRlclV1aWRJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLXV1aWQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBjb25zdCBvcmRlclN0YXR1c1NlbGVjdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLWVkaXQtc3RhdHVzJykgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XG4gIGNvbnN0IG9yZGVyU3RhdHVzRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItZWRpdC1zdGF0dXMtZGl2JykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gIGNvbnN0IG9yZGVyVGl0bGVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLWVkaXQtb3JkZXItdGl0bGUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBjb25zdCBvcmRlckFjdGl2ZURhdGVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLWVkaXQtYWN0aXZlLWRhdGUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBjb25zdCBvcmRlckFjdGl2ZVRpbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLWVkaXQtYWN0aXZlLXRpbWUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBjb25zdCBvcmRlckRlbGl2ZXJ5RGF0ZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItZWRpdC1kZWxpdmVyeS1kYXRlJykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgY29uc3Qgb3JkZXJTdXBwbGllcklkU2VsZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItZWRpdC1zdXBwbGllci1pZCcpIGFzIEhUTUxTZWxlY3RFbGVtZW50O1xuICBjb25zdCBvcmRlcldhcmVob3VzZUlkU2VsZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItZWRpdC13YXJlaG91c2UtaWQnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcbiAgY29uc3Qgb3JkZXJFZGl0QWRkR3JvdXBCdXR0b25UZW1wbGF0ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbmJvdW5kLW9yZGVyLWFkZC1wcm9kdWN0LWdyb3VwLWJ0bicpO1xuICBjb25zdCBzYXZlQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItc2F2ZS1wcm9kdWN0cy1idG4nKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcblxuICBjb25zdCBtb2RhbEVkaXRPcHRpb25zOiBNb2RhbE9wdGlvbnMgPSB7XG4gICAgcGxhY2VtZW50OiAnYm90dG9tLXJpZ2h0JyxcbiAgICBiYWNrZHJvcDogJ2R5bmFtaWMnLFxuICAgIGJhY2tkcm9wQ2xhc3NlczogJ2JnLWdyYXktOTAwIGJnLW9wYWNpdHktNTAgZGFyazpiZy1vcGFjaXR5LTgwIGZpeGVkIGluc2V0LTAgei00MCcsXG4gICAgY2xvc2FibGU6IHRydWUsXG4gICAgb25IaWRlOiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhvcmRlckVkaXRQcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lcik7XG4gICAgICB3aGlsZSAob3JkZXJFZGl0UHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBvcmRlckVkaXRQcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lci5yZW1vdmVDaGlsZChvcmRlckVkaXRQcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lci5sYXN0RWxlbWVudENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZ3JvdXBzUXVhbnRpdHkgPSBvcmRlckVkaXRQcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAnLmdyb3VwLXF1YW50aXR5LWl0ZW0nXG4gICAgICApIGFzIE5vZGVMaXN0T2Y8SFRNTERpdkVsZW1lbnQ+O1xuICAgICAgZ3JvdXBzUXVhbnRpdHkuZm9yRWFjaCgoZ3JvdXApID0+IGdyb3VwLnJlbW92ZSgpKTtcblxuICAgICAgY29uc3QgYnV0dG9uc0FkZEdyb3VwUXVhbnRpdHkgPSBvcmRlckVkaXRQcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAnLmluYm91bmQtb3JkZXItYWRkLXByb2R1Y3QtZ3JvdXAtYnRuJ1xuICAgICAgKSBhcyBOb2RlTGlzdE9mPEhUTUxCdXR0b25FbGVtZW50PjtcbiAgICAgIGJ1dHRvbnNBZGRHcm91cFF1YW50aXR5LmZvckVhY2goKGJ1dHRvbikgPT4gYnV0dG9uLnJlbW92ZSgpKTtcbiAgICB9LFxuICB9O1xuICBjb25zdCBvcmRlckVkaXRNb2RhbCA9IG5ldyBNb2RhbChvcmRlckVkaXRNb2RhbEhUTUwsIG1vZGFsRWRpdE9wdGlvbnMpO1xuXG4gIGNvbnN0IGVkaXRNb2RhbENsb3NlQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2VkaXQtbW9kYWwtYnRuLWhpZGUnKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgZWRpdE1vZGFsQ2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgb3JkZXJFZGl0TW9kYWwuaGlkZSgpO1xuICB9KTtcblxuICBvcmRlckVkaXRCdXR0b25zLmZvckVhY2goKG9yZGVyRWRpdEJ1dHRvbikgPT4ge1xuICAgIGNvbnN0IGluYm91bmRPcmRlckRhdGEgPSBKU09OLnBhcnNlKG9yZGVyRWRpdEJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykpIGFzIElJbmJvdW5kT3JkZXJPdXQ7XG4gICAgb3JkZXJFZGl0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgLy8gU2V0IG9yZGVyIGVkaXQgbW9kYWwgdmFsdWVzXG4gICAgICBvcmRlclV1aWRJbnB1dC52YWx1ZSA9IGluYm91bmRPcmRlckRhdGEudXVpZDtcbiAgICAgIG9yZGVyU3RhdHVzU2VsZWN0LnZhbHVlID0gaW5ib3VuZE9yZGVyRGF0YS5zdGF0dXM7XG4gICAgICBvcmRlclRpdGxlSW5wdXQudmFsdWUgPSBpbmJvdW5kT3JkZXJEYXRhLnRpdGxlO1xuICAgICAgb3JkZXJBY3RpdmVEYXRlSW5wdXQudmFsdWUgPSBnZXREYXRlcGlja2VyRGF0ZUZvcm1hdChpbmJvdW5kT3JkZXJEYXRhLmFjdGl2ZURhdGUpO1xuICAgICAgb3JkZXJBY3RpdmVUaW1lSW5wdXQudmFsdWUgPSBpbmJvdW5kT3JkZXJEYXRhLmFjdGl2ZVRpbWU7XG4gICAgICBvcmRlckRlbGl2ZXJ5RGF0ZUlucHV0LnZhbHVlID0gZ2V0RGF0ZXBpY2tlckRhdGVGb3JtYXQoaW5ib3VuZE9yZGVyRGF0YS5kZWxpdmVyeURhdGUpO1xuICAgICAgb3JkZXJTdXBwbGllcklkU2VsZWN0LnZhbHVlID0gaW5ib3VuZE9yZGVyRGF0YS5zdXBwbGllci5pZC50b1N0cmluZygpO1xuICAgICAgb3JkZXJXYXJlaG91c2VJZFNlbGVjdC52YWx1ZSA9IGluYm91bmRPcmRlckRhdGEud2FyZWhvdXNlLmlkLnRvU3RyaW5nKCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5ib3VuZE9yZGVyRGF0YS5wcm9kdWN0c0FsbG9jYXRlZC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZEVkaXRWaWV3ID0gb3JkZXJFZGl0UHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIuY2hpbGRyZW5bMF0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBvcmRlckVkaXRQcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lci5hcHBlbmRDaGlsZChwcm9kdWN0QWxsb2NhdGVkRWRpdFZpZXcpO1xuICAgICAgfVxuXG4gICAgICBpbmJvdW5kT3JkZXJEYXRhLnByb2R1Y3RzQWxsb2NhdGVkLmZvckVhY2goKHByb2R1Y3RBbGxvY2F0ZWQsIGkpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFByb2R1Y3RBbGxvY2F0ZWRDb250YWluZXIgPSBvcmRlckVkaXRQcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lci5jaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZElkSW5wdXQgPSBjdXJyZW50UHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICcucHJvZHVjdC1hbGxvY2F0ZWQtaWQnXG4gICAgICAgICkgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZE5hbWVEaXYgPSBjdXJyZW50UHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICcuaW5ib3VuZC1vcmRlci1lZGl0LWNoZWNrLXByb2R1Y3QnXG4gICAgICAgICkgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRTS1VEaXYgPSBjdXJyZW50UHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICcuaW5ib3VuZC1vcmRlci1lZGl0LWNoZWNrLXByb2R1Y3Qtc2t1J1xuICAgICAgICApIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgICAgICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkUXVhbnRpdHlEaXYgPSBjdXJyZW50UHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICcuaW5ib3VuZC1vcmRlci1lZGl0LWNoZWNrLXF1YW50aXR5J1xuICAgICAgICApIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgICAgICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkU2hlbGZMaWZlRnJvbURpdiA9IGN1cnJlbnRQcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgJy5pbmJvdW5kLW9yZGVyLWVkaXQtc2hlbGYtbGlmZS1mcm9tJ1xuICAgICAgICApIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgICAgICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkU2hlbGZMaWZlVG9EaXYgPSBjdXJyZW50UHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICcuaW5ib3VuZC1vcmRlci1lZGl0LXNoZWxmLWxpZmUtdG8nXG4gICAgICAgICkgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRUb3RhbFF1YW50aXR5RGl2ID0gY3VycmVudFByb2R1Y3RBbGxvY2F0ZWRDb250YWluZXIucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAnLmluYm91bmQtb3JkZXItZWRpdC10b3RhbC1xdWFudGl0eSdcbiAgICAgICAgKSBhcyBIVE1MRGl2RWxlbWVudDtcblxuICAgICAgICBwcm9kdWN0QWxsb2NhdGVkSWRJbnB1dC52YWx1ZSA9IHByb2R1Y3RBbGxvY2F0ZWQuaWQudG9TdHJpbmcoKTtcblxuICAgICAgICBwcm9kdWN0QWxsb2NhdGVkTmFtZURpdi5pbm5lckhUTUwgPSBgPHAgdGl0bGU9JyR7cHJvZHVjdEFsbG9jYXRlZC5wcm9kdWN0Lm5hbWV9JyBjbGFzcz0nY3JvcHBlZC10ZXh0Jz4ke3Byb2R1Y3RBbGxvY2F0ZWQucHJvZHVjdC5uYW1lfTwvcD5gO1xuICAgICAgICBwcm9kdWN0QWxsb2NhdGVkU0tVRGl2LmlubmVySFRNTCA9IGA8cCB0aXRsZT0nJHtwcm9kdWN0QWxsb2NhdGVkLnByb2R1Y3QuU0tVfSc+JHtwcm9kdWN0QWxsb2NhdGVkLnByb2R1Y3QuU0tVfTwvcD5gO1xuICAgICAgICBwcm9kdWN0QWxsb2NhdGVkUXVhbnRpdHlEaXYuaW5uZXJIVE1MID0gcHJvZHVjdEFsbG9jYXRlZC5xdWFudGl0eS50b1N0cmluZygpO1xuICAgICAgICBwcm9kdWN0QWxsb2NhdGVkUXVhbnRpdHlEaXYuc2V0QXR0cmlidXRlKCdkYXRhLXF1YW50aXR5JywgcHJvZHVjdEFsbG9jYXRlZC5xdWFudGl0eS50b1N0cmluZygpKTtcbiAgICAgICAgcHJvZHVjdEFsbG9jYXRlZFRvdGFsUXVhbnRpdHlEaXYuaW5uZXJIVE1MID0gcHJvZHVjdEFsbG9jYXRlZC5xdWFudGl0eS50b1N0cmluZygpO1xuICAgICAgICBwcm9kdWN0QWxsb2NhdGVkU2hlbGZMaWZlRnJvbURpdi5pbm5lckhUTUwgPSBnZXREYXRlcGlja2VyRGF0ZUZvcm1hdChwcm9kdWN0QWxsb2NhdGVkLnNoZWxmTGlmZVN0YXJ0KTtcbiAgICAgICAgcHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZVRvRGl2LmlubmVySFRNTCA9IGdldERhdGVwaWNrZXJEYXRlRm9ybWF0KHByb2R1Y3RBbGxvY2F0ZWQuc2hlbGZMaWZlRW5kKTtcblxuICAgICAgICBjb25zdCBidXR0b25BZGROZXdHcm91cCA9IG9yZGVyRWRpdEFkZEdyb3VwQnV0dG9uVGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICAgICAgICAvLyBjdXJyZW50IHBvaW50XG4gICAgICAgIGJ1dHRvbkFkZE5ld0dyb3VwLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT5cbiAgICAgICAgICBjcmVhdGVQcm9kdWN0R3JvdXAoY3VycmVudFByb2R1Y3RBbGxvY2F0ZWRDb250YWluZXIgYXMgSFRNTERpdkVsZW1lbnQpXG4gICAgICAgICk7XG5cbiAgICAgICAgKHByb2R1Y3RBbGxvY2F0ZWRTaGVsZkxpZmVUb0Rpdi5wYXJlbnROb2RlLnBhcmVudE5vZGUgYXMgSFRNTERpdkVsZW1lbnQpLmFmdGVyKGJ1dHRvbkFkZE5ld0dyb3VwKTtcbiAgICAgICAgYnV0dG9uQWRkTmV3R3JvdXAuY2xhc3NMaXN0LnJlbW92ZSgnaW52aXNpYmxlJyk7XG5cbiAgICAgICAgcHJvZHVjdEFsbG9jYXRlZC5wcm9kdWN0UXVhbnRpdHlHcm91cHMuZm9yRWFjaCgocXVhbnRpdHlHcm91cCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHF1YW50aXR5R3JvdXBDb250YWluZXIgPSBjcmVhdGVQcm9kdWN0R3JvdXAoY3VycmVudFByb2R1Y3RBbGxvY2F0ZWRDb250YWluZXIgYXMgSFRNTERpdkVsZW1lbnQpO1xuICAgICAgICAgIGNvbnN0IGdyb3VwU2VsZWN0ID0gcXVhbnRpdHlHcm91cENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci1lZGl0LWFkZC1ncm91cCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgY29uc3QgZ3JvdXBTZWxlY3RIaWRkZW4gPSBxdWFudGl0eUdyb3VwQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAnI2luYm91bmQtb3JkZXItZWRpdC1hZGQtZ3JvdXAtaGlkZGVuJ1xuICAgICAgICAgICkgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgICBjb25zdCBncm91cFF1YW50aXR5SW5wdXQgPSBxdWFudGl0eUdyb3VwQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAnLmluYm91bmQtb3JkZXItZWRpdC1hZGQtcXVhbnRpdHknXG4gICAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXG4gICAgICAgICAgZ3JvdXBTZWxlY3QudmFsdWUgPSBxdWFudGl0eUdyb3VwLmdyb3VwLm5hbWUudG9TdHJpbmcoKTtcbiAgICAgICAgICBncm91cFNlbGVjdEhpZGRlbi52YWx1ZSA9IHF1YW50aXR5R3JvdXAuZ3JvdXAubmFtZS50b1N0cmluZygpO1xuICAgICAgICAgIGdyb3VwUXVhbnRpdHlJbnB1dC52YWx1ZSA9IHF1YW50aXR5R3JvdXAucXVhbnRpdHkudG9TdHJpbmcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZ3JvdXBzSXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZ3JvdXAtcXVhbnRpdHktaXRlbScpIGFzIE5vZGVMaXN0T2Y8SFRNTERpdkVsZW1lbnQ+O1xuXG4gICAgICAgIGlmIChncm91cHNJdGVtcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgYnV0dG9uQWRkTmV3R3JvdXAuY2xpY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldE5ld1F1YW50aXR5VmlldyhjdXJyZW50UHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lciBhcyBIVE1MRGl2RWxlbWVudCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGluYm91bmRPcmRlckRhdGEuc3RhdHVzICE9PSAnQXNzaWduZWQgdG8gcGlja3VwJyAmJiBpbmJvdW5kT3JkZXJEYXRhLnN0YXR1cyAhPT0gJ0RyYWZ0Jykge1xuICAgICAgICBzYXZlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICBvcmRlclN0YXR1c0Rpdi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgb3JkZXJTdGF0dXNEaXYuaW5uZXJIVE1MID0gaW5ib3VuZE9yZGVyRGF0YS5zdGF0dXM7XG4gICAgICAgIG9yZGVyU3RhdHVzU2VsZWN0LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2F2ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgb3JkZXJTdGF0dXNEaXYuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIG9yZGVyU3RhdHVzU2VsZWN0LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgfVxuICAgICAgb3JkZXJFZGl0TW9kYWwuc2hvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBzdWJtaXQgdXBkYXRlIG9yZGVyXG4gIGNvbnN0IGJ1dHRvblNhdmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci1zYXZlLXByb2R1Y3RzLWJ0bicpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICBidXR0b25TYXZlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGNvbnN0IG9yZGVyU3RhdHVzU2VsZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItZWRpdC1zdGF0dXMnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcblxuICAgIGlmIChvcmRlclN0YXR1c1NlbGVjdC52YWx1ZSA9PT0gJ0Fzc2lnbmVkIHRvIHBpY2t1cCcpIHtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0ZUFzc2lnbmVkVG9QaWNrVXBGb3JtKCk7XG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgYWxlcnQoJ0F2YWlsYWJsZSBRdWFudGl0eSBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRHcm91cHNDb250YWluZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICcucHJvZHVjdC1hbGxvY2F0ZWQtZ3JvdXBzLWNvbnRhaW5lcidcbiAgICApIGFzIE5vZGVMaXN0T2Y8SFRNTERpdkVsZW1lbnQ+O1xuICAgIGNvbnN0IHByb2R1Y3RHcm91cHM6IElQcm9kdWN0R3JvdXBDcmVhdGVbXSA9IFtdO1xuXG4gICAgcHJvZHVjdEFsbG9jYXRlZEdyb3Vwc0NvbnRhaW5lcnMuZm9yRWFjaCgocHJvZHVjdEdyb3VwQ29udGFpbmVyKSA9PiB7XG4gICAgICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkSWRJbnB1dCA9IHByb2R1Y3RHcm91cENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1hbGxvY2F0ZWQtaWQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXG4gICAgICBjb25zdCBwcm9kdWN0R3JvdXBDcmVhdGU6IElQcm9kdWN0R3JvdXBDcmVhdGUgPSB7XG4gICAgICAgIHByb2R1Y3RBbGxvY2F0ZWRJZDogcGFyc2VJbnQocHJvZHVjdEFsbG9jYXRlZElkSW5wdXQudmFsdWUpLFxuICAgICAgICBwcm9kdWN0QWxsb2NhdGVkR3JvdXBzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGdyb3VwUXVhbnRpdHlJdGVtcyA9IHByb2R1Y3RHcm91cENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAnLmdyb3VwLXF1YW50aXR5LWl0ZW0nXG4gICAgICApIGFzIE5vZGVMaXN0T2Y8SFRNTERpdkVsZW1lbnQ+O1xuICAgICAgZ3JvdXBRdWFudGl0eUl0ZW1zLmZvckVhY2goKHF1YW50aXR5SXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBncm91cElkU2VsZWN0ID0gcXVhbnRpdHlJdGVtLnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLWVkaXQtYWRkLWdyb3VwJykgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGdyb3VwSWRTZWxlY3RIaWRkZW4gPSBxdWFudGl0eUl0ZW0ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAnI2luYm91bmQtb3JkZXItZWRpdC1hZGQtZ3JvdXAtaGlkZGVuJ1xuICAgICAgICApIGFzIEhUTUxTZWxlY3RFbGVtZW50O1xuICAgICAgICBjb25zdCBncm91cFF1YW50aXR5SW5wdXQgPSBxdWFudGl0eUl0ZW0ucXVlcnlTZWxlY3RvcignLmluYm91bmQtb3JkZXItZWRpdC1hZGQtcXVhbnRpdHknKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXG4gICAgICAgIGlmIChncm91cElkU2VsZWN0SGlkZGVuLnZhbHVlICYmIGdyb3VwUXVhbnRpdHlJbnB1dC52YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGdyb3VwSWQgPSBwYXJzZUludChncm91cElkU2VsZWN0SGlkZGVuLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBncm91cFF1YW50aXR5ID0gcGFyc2VJbnQoZ3JvdXBRdWFudGl0eUlucHV0LnZhbHVlKTtcblxuICAgICAgICAgIHByb2R1Y3RHcm91cENyZWF0ZS5wcm9kdWN0QWxsb2NhdGVkR3JvdXBzLnB1c2goe1xuICAgICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgICAgICAgIHF1YW50aXR5OiBncm91cFF1YW50aXR5LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHByb2R1Y3RHcm91cHMucHVzaChwcm9kdWN0R3JvdXBDcmVhdGUpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcHJvZHVjdEdyb3Vwc1F1YW50aXRpZXNJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAnI2luYm91bmQtb3JkZXItZWRpdC1wcm9kdWN0LXF1YW50aXRpZXMnXG4gICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgIHByb2R1Y3RHcm91cHNRdWFudGl0aWVzSW5wdXQudmFsdWUgPSBKU09OLnN0cmluZ2lmeShwcm9kdWN0R3JvdXBzKTtcblxuICAgIGNvbnN0IGJ1dHRvblN1Ym1pdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLXN1Ym1pdC1idG4nKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICBidXR0b25TdWJtaXQuY2xpY2soKTtcbiAgfSk7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUFzc2lnbmVkVG9QaWNrVXBGb3JtID0gKCkgPT4ge1xuICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkUXVhbnRpdHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaW5ib3VuZC1vcmRlci1lZGl0LWNoZWNrLXF1YW50aXR5Jyk7XG5cbiAgY29uc3QgaXNVc2VkQWxsUHJvZHVjdHMgPSBBcnJheS5mcm9tKHByb2R1Y3RBbGxvY2F0ZWRRdWFudGl0eSkuZXZlcnkoKHF1YW50aXR5Tm9kZSkgPT4ge1xuICAgIGNvbnN0IHF1YW50aXR5ID0gcGFyc2VJbnQocXVhbnRpdHlOb2RlLmlubmVySFRNTCk7XG4gICAgcmV0dXJuIHF1YW50aXR5ID09PSAwO1xuICB9KTtcbiAgcmV0dXJuIGlzVXNlZEFsbFByb2R1Y3RzO1xufTtcbiIsImltcG9ydCB7IElucHV0LCBUaW1lcGlja2VyLCBpbml0VEUgfSBmcm9tICd0dy1lbGVtZW50cyc7XG5pbXBvcnQgeyBJSW5ib3VuZE9yZGVyQmFzZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGluaXRBZGRJbmJvdW5kT3JkZXJNb2RhbCB9IGZyb20gJy4vYWRkJztcbmltcG9ydCB7IGluaXRWaWV3SW5ib3VuZE9yZGVyTW9kYWwgfSBmcm9tICcuL3ZpZXcnO1xuaW1wb3J0IHsgaW5pdEVkaXRPcmRlck1vZGFsIH0gZnJvbSAnLi9lZGl0JztcbmltcG9ydCB7IGVhc2VwaWNrIH0gZnJvbSAnQGVhc2VwaWNrL2J1bmRsZSc7XG5pbXBvcnQgRGF0ZXBpY2tlciBmcm9tICdmbG93Yml0ZS1kYXRlcGlja2VyL0RhdGVwaWNrZXInO1xuXG4vL2dsb2JhbCB2YXJpYWJsZXMgZm9yIGRhdGVwaWNrZXJcbmNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcbmNvbnN0IGZpdmVEYXlzID0gNSAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cbmluaXRURSh7IElucHV0LCBUaW1lcGlja2VyIH0pO1xuXG5jb25zdCAkYnV0dG9uRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaW5ib3VuZC1vcmRlci1lZGl0LWJ1dHRvbicpO1xuJGJ1dHRvbkVsZW1lbnRzLmZvckVhY2goKGUpID0+XG4gIGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgY29uc3QgaW5ib3VuZE9yZGVyOiBJSW5ib3VuZE9yZGVyQmFzZSA9IEpTT04ucGFyc2UoZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykpO1xuICB9KVxuKTtcblxuY29uc3QgcGlja2VySW5saW5lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RpbWVwaWNrZXItaW5saW5lLTEyJyk7XG5jb25zdCB0aW1lcGlja2VyTWF4TWluID0gbmV3IFRpbWVwaWNrZXIocGlja2VySW5saW5lLCB7XG4gIGZvcm1hdDEyOiB0cnVlLFxuICBpbmxpbmU6IHRydWUsXG59KTtcblxuLy8gc2VhcmNoIGZsb3dcbmNvbnN0IHNlYXJjaElucHV0OiBIVE1MSW5wdXRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RhYmxlLXNlYXJjaC1pbmJvdW5kLW9yZGVycycpO1xuY29uc3Qgc2VhcmNoSW5wdXRCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGFibGUtc2VhcmNoLWluYm91bmQtb3JkZXItYnV0dG9uJyk7XG5pZiAoc2VhcmNoSW5wdXRCdXR0b24gJiYgc2VhcmNoSW5wdXQpIHtcbiAgc2VhcmNoSW5wdXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3EnLCBzZWFyY2hJbnB1dC52YWx1ZSk7XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBgJHt1cmwuaHJlZn1gO1xuICB9KTtcbn1cbmNvbnN0IGRlbGV0ZUJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVsZXRlLWluYm91bmQtb3JkZXItYnRuJyk7XG5cbmRlbGV0ZUJ1dHRvbnMuZm9yRWFjaCgoZSkgPT4ge1xuICBlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgIGlmIChjb25maXJtKCdBcmUgc3VyZT8nKSkge1xuICAgICAgbGV0IGlkID0gZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5ib3VuZC1vcmRlci1pZCcpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2luYm91bmRfb3JkZXIvZGVsZXRlLyR7aWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgfSk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09IDIwMCkge1xuICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSk7XG5cbmNvbnN0IG9wZW5DdXJyZW50T3JkZXIgPSAoKSA9PiB7XG4gIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gIGNvbnN0IG9yZGVyVXVpZCA9IHVybFBhcmFtcy5nZXQoJ2N1cnJlbnRfb3JkZXJfdXVpZCcpO1xuICBjb25zb2xlLmxvZyhvcmRlclV1aWQpO1xuICBpZiAoIW9yZGVyVXVpZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9yZGVyQ29sdW1uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgI2luYm91bmQtb3JkZXItJHtvcmRlclV1aWR9YCk7XG5cbiAgaWYgKCFvcmRlckNvbHVtbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9yZGVyRWRpdEJ1dHRvbiA9IG9yZGVyQ29sdW1uLnF1ZXJ5U2VsZWN0b3IoJy5pbmJvdW5kLW9yZGVyLWVkaXQtYnV0dG9uJykgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gIG9yZGVyRWRpdEJ1dHRvbi5jbGljaygpO1xufTtcblxuY29uc3QgZGVsZXRlQWxsb2NhdGVkUHJvZHVjdCA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRDb250YWluZXIgPSAoZS5jdXJyZW50VGFyZ2V0IGFzIEhUTUxTcGFuRWxlbWVudCkucGFyZW50Tm9kZSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgY29uc3QgcHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIgPSBwcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyLnBhcmVudE5vZGUgYXMgSFRNTERpdkVsZW1lbnQ7XG5cbiAgcHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lci5yZW1vdmUoKTtcbiAgY29uc29sZS5sb2cocHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgaWYgKHByb2R1Y3RzQWxsb2NhdGVkQ29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCA9PSAyKSB7XG4gICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZERlbGV0ZUJ1dHRvbiA9IHByb2R1Y3RzQWxsb2NhdGVkQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LWFsbG9jYXRlZC1kZWxldGUtYnV0dG9uJyk7XG4gICAgY29uc29sZS5sb2cocHJvZHVjdEFsbG9jYXRlZERlbGV0ZUJ1dHRvbik7XG4gICAgcHJvZHVjdEFsbG9jYXRlZERlbGV0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdpbnZpc2libGUnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlQWxsb2NhdGlvblByb2R1Y3RDb250YWluZXIgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICBjb25zdCBidG4gPSBlLmN1cnJlbnRUYXJnZXQgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1hbGxvY2F0ZWQnKS5wYXJlbnROb2RlIGFzIEhUTUxEaXZFbGVtZW50O1xuXG4gIGlmIChwcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyLnBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoID09IDIpIHtcbiAgICBjb25zdCBidXR0b25SZW1vdmVQcm9kdWN0QWxsb2NhdGVkID0gcHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1hbGxvY2F0ZWQtZGVsZXRlLWJ1dHRvbicpO1xuICAgIGJ1dHRvblJlbW92ZVByb2R1Y3RBbGxvY2F0ZWQuY2xhc3NMaXN0LnJlbW92ZSgnaW52aXNpYmxlJyk7XG4gIH1cblxuICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkTmV3ID0gcHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lci5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTERpdkVsZW1lbnQ7XG4gIC8vIENsZWFyIGlucHV0c1xuICBwcm9kdWN0QWxsb2NhdGVkTmV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JykuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICB9KTtcblxuICBjb25zdCBidXR0b25EZWxldGVBbGxvY2F0ZWRQcm9kdWN0ID0gcHJvZHVjdEFsbG9jYXRlZE5ldy5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1hbGxvY2F0ZWQtZGVsZXRlLWJ1dHRvbicpO1xuICBidXR0b25EZWxldGVBbGxvY2F0ZWRQcm9kdWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZGVsZXRlQWxsb2NhdGVkUHJvZHVjdCk7XG5cbiAgY29uc3QgcHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIgPSBidG4ucGFyZW50Tm9kZS5wYXJlbnROb2RlIGFzIEhUTUxEaXZFbGVtZW50O1xuXG4gIHByb2R1Y3RzQWxsb2NhdGVkQ29udGFpbmVyLmluc2VydEJlZm9yZShwcm9kdWN0QWxsb2NhdGVkTmV3LCBidG4ucGFyZW50Tm9kZSk7XG4gIGFkZERhdGVSYW5nZVBpY2tlcigpO1xufTtcblxuLy8gIyBOT1RFOiBkZXBlbmRzIG9uIGZsYXNoIGZyb20gY3JlYXRlIHJvdXRlIG9uIGluYm91bmRfb3JkZXJfYmx1ZXByaW50XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAvLyB2aWV3IG9yZGVyXG4gIGluaXRWaWV3SW5ib3VuZE9yZGVyTW9kYWwoKTtcbiAgLy8gQWRkIG5ldyBpbmJvdW5kIG9yZGVyIGhhbmRsZXJcbiAgaW5pdEFkZEluYm91bmRPcmRlck1vZGFsKCk7XG4gIC8vIEFkZCBlZGl0IGluYm91bmQgb3JkZXIgaGFuZGxlclxuICBpbml0RWRpdE9yZGVyTW9kYWwoKTtcblxuICBjb25zdCBidXR0b25BbGxvY2F0ZVByb2R1Y3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5ib3VuZC1vcmRlci1hbGxvY2F0ZS1wcm9kdWN0LWJ0bicpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICBidXR0b25BbGxvY2F0ZVByb2R1Y3QuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjcmVhdGVBbGxvY2F0aW9uUHJvZHVjdENvbnRhaW5lcik7XG5cbiAgY29uc3QgYnV0dG9uRGVsZXRlQWxsb2NhdGVkUHJvZHVjdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LWFsbG9jYXRlZC1kZWxldGUtYnV0dG9uJyk7XG4gIGJ1dHRvbkRlbGV0ZUFsbG9jYXRlZFByb2R1Y3QuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBkZWxldGVBbGxvY2F0ZWRQcm9kdWN0KTtcblxuICAvLyBPcGVuIGN1cnJlbnQgb3JkZXJcbiAgb3BlbkN1cnJlbnRPcmRlcigpO1xufSk7XG5cbmNvbnN0IGFkZERhdGVSYW5nZVBpY2tlciA9ICgpID0+IHtcbiAgY29uc3Qgc2hlbGZMaWZlU3RhcnRFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNkYXRlcGlja2VyRWwtc3RhcnQtYWRkLTEnKTtcbiAgY29uc3Qgc2hlbGZMaWZlRW5kRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZGF0ZXBpY2tlckVsLWVuZC1hZGQtMScpO1xuICBjb25zdCBjdXJyZW50U2hlbGZMaWZlU3RhcnQgPSBzaGVsZkxpZmVTdGFydEVsZW1lbnRzW3NoZWxmTGlmZVN0YXJ0RWxlbWVudHMubGVuZ3RoIC0gMV0gYXMgSFRNTElucHV0RWxlbWVudDtcbiAgY29uc3QgY3VycmVudFNoZWxmTGlmZUVuZCA9IHNoZWxmTGlmZUVuZEVsZW1lbnRzW3NoZWxmTGlmZUVuZEVsZW1lbnRzLmxlbmd0aCAtIDFdIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgY29uc3QgZGF0ZXBpY2tlclN0YXJ0ID0gbmV3IERhdGVwaWNrZXIoY3VycmVudFNoZWxmTGlmZVN0YXJ0LCB7fSk7XG4gIGNvbnN0IGRhdGVwaWNrZXJFbmQgPSBuZXcgRGF0ZXBpY2tlcihjdXJyZW50U2hlbGZMaWZlRW5kLCB7fSk7XG59O1xuXG4vLyBmaWx0ZXIgZmxvd1xuY29uc3QgZmlsdGVyQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItZmlsdGVyLWJ1dHRvbicpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuY29uc3Qgb3JkZXJGaWx0ZXJJbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaW5ib3VuZC1vcmRlci1maWx0ZXItaW5wdXQnKTtcbmNvbnN0IGhpZGRlbklucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NvcnRfYnknKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXG5maWx0ZXJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIG9yZGVyRmlsdGVySW5wdXRzLmZvckVhY2goKGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB7XG4gICAgaWYgKGlucHV0LmNoZWNrZWQgJiYgaW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nLnRleHRDb250ZW50LnRyaW0oKSAhPSAnRGVmYXVsdCBWYWx1ZScpIHtcbiAgICAgIGhpZGRlbklucHV0LnZhbHVlID0gaW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nLnRleHRDb250ZW50LnRyaW0oKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbmNvbnN0IHRvZGF5RGF0ZVRpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG5jb25zdCBhY3RpdmVUaW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci1hZGQtYWN0aXZlX3RpbWUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXG5jb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG5jb25zdCBob3VycyA9IHBhcnNlSW50KGN1cnJlbnRUaW1lLnNwbGl0KCc6JylbMF0pO1xuY29uc3QgbWludXRlcyA9IHBhcnNlSW50KGN1cnJlbnRUaW1lLnNwbGl0KCc6JylbMV0pO1xuY29uc3QgYW1PclBtID0gaG91cnMgPj0gMTIgPyAnUE0nIDogJ0FNJztcbmNvbnN0IGZvcm1hdHRlZEhvdXJzID0gaG91cnMgJSAxMiA9PT0gMCA/IDEyIDogaG91cnMgJSAxMjtcbmNvbnN0IGZvcm1hdHRlZE1pbnV0ZXMgPSBtaW51dGVzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbmFjdGl2ZVRpbWVJbnB1dC52YWx1ZSA9IGAke2Zvcm1hdHRlZEhvdXJzfToke2Zvcm1hdHRlZE1pbnV0ZXN9ICR7YW1PclBtfWA7XG5cbmNvbnN0IGRhdGVQaWNrZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmluYm91bmQtb3JkZXItZGF0ZXBpY2tlcicpO1xuZGF0ZVBpY2tlcnMuZm9yRWFjaCgoZGF0ZVBpY2tlcjogSFRNTElucHV0RWxlbWVudCkgPT4ge1xuICBkYXRlUGlja2VyLnZhbHVlID0gdG9kYXlEYXRlVGltZS5zcGxpdCgnVCcpWzBdO1xuICBjb25zdCBwaWNrZXIgPSBuZXcgZWFzZXBpY2suY3JlYXRlKHtcbiAgICBlbGVtZW50OiBkYXRlUGlja2VyLFxuICAgIGNzczogW1xuICAgICAgJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQGVhc2VwaWNrL2J1bmRsZUAxLjIuMS9kaXN0L2luZGV4LmNzcycsXG4gICAgICAnaHR0cHM6Ly9lYXNlcGljay5jb20vY3NzL2RlbW9faG90ZWxjYWwuY3NzJyxcbiAgICBdLFxuICAgIHBsdWdpbnM6IFsnTG9ja1BsdWdpbiddLFxuICAgIExvY2tQbHVnaW46IHtcbiAgICAgIG1pbkRhdGU6IG5ldyBEYXRlKCksXG4gICAgICBtaW5EYXlzOiAxLFxuICAgICAgaW5zZXBhcmFibGU6IHRydWUsXG4gICAgfSxcbiAgICB6SW5kZXg6IDQsXG4gIH0pO1xufSk7XG4iLCJleHBvcnQgY29uc3QgZ2V0RGF0ZXBpY2tlckRhdGVGb3JtYXQgPSAoZGF0ZVN0cmluZzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcblxuICBjb25zdCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDEgPCAxMCA/ICcwJyArIChkYXRlLmdldE1vbnRoKCkgKyAxKSA6IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF0ZSgpIDwgMTAgPyAnMCcgKyBkYXRlLmdldERhdGUoKSA6IGRhdGUuZ2V0RGF0ZSgpO1xuICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gIHJldHVybiB5ZWFyICsgJy0nICsgbW9udGggKyAnLScgKyBkYXk7XG59O1xuIiwiaW1wb3J0IHsgTW9kYWwgfSBmcm9tICdmbG93Yml0ZSdcbmltcG9ydCB0eXBlIHsgTW9kYWxPcHRpb25zIH0gZnJvbSAnZmxvd2JpdGUnXG5pbXBvcnQgeyBJSW5ib3VuZE9yZGVyT3V0IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXREYXRlcGlja2VyRGF0ZUZvcm1hdCB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgaW5pdFZpZXdJbmJvdW5kT3JkZXJNb2RhbCA9ICgpID0+IHtcbiAgICAvLyBtb2RhbCBOb2Rlc1xuICAgIGNvbnN0IHZpZXdJbmJvdW5kT3JkZXJNb2RhbEVsZW1lbnQ6IEhUTUxEaXZFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3ZpZXctaW5ib3VuZC1vcmRlci1tb2RhbCcpIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgIGNvbnN0IG9yZGVySWRWaWV3ID0gdmlld0luYm91bmRPcmRlck1vZGFsRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci12aWV3LW9yZGVyX2lkJykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgY29uc3Qgb3JkZXJTdGF0dXMgPSB2aWV3SW5ib3VuZE9yZGVyTW9kYWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLXZpZXctc3RhdHVzJykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgY29uc3Qgb3JkZXJBY3RpdmVEYXRlID0gdmlld0luYm91bmRPcmRlck1vZGFsRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci12aWV3LWFjdGl2ZV9kYXRlJykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgY29uc3Qgb3JkZXJBY3RpdmVUaW1lID0gdmlld0luYm91bmRPcmRlck1vZGFsRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci12aWV3LWFjdGl2ZV90aW1lJykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgY29uc3Qgb3JkZXJUaXRsZSA9IHZpZXdJbmJvdW5kT3JkZXJNb2RhbEVsZW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItdmlldy1vcmRlcl90aXRsZScpIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgIGNvbnN0IG9yZGVyRGVsaXZlcnlEYXRlID0gdmlld0luYm91bmRPcmRlck1vZGFsRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci12aWV3LWRlbGl2ZXJ5X2RhdGUnKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICBjb25zdCBvcmRlcldhcmVob3VzZU5hbWUgPSB2aWV3SW5ib3VuZE9yZGVyTW9kYWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLXZpZXctd2FyZWhvdXNlLW5hbWUnKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICBjb25zdCBvcmRlclN1cHBsaWVyTmFtZSA9IHZpZXdJbmJvdW5kT3JkZXJNb2RhbEVsZW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItdmlldy1zdXBwbGllci1uYW1lJylcbiAgICBjb25zdCBvcmRlclN1cHBsaWVyQWRkcmVzcyA9IHZpZXdJbmJvdW5kT3JkZXJNb2RhbEVsZW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItdmlldy1zdXBwbGllci1hZGRyZXNzJylcblxuICAgIGNvbnN0IG1vZGFsVmlld0RpdnMgPSBbb3JkZXJJZFZpZXcsIG9yZGVyU3RhdHVzLCBvcmRlckFjdGl2ZURhdGUsIG9yZGVyQWN0aXZlVGltZSwgb3JkZXJUaXRsZSwgb3JkZXJEZWxpdmVyeURhdGUsIG9yZGVyV2FyZWhvdXNlTmFtZSwgb3JkZXJTdXBwbGllck5hbWUsIG9yZGVyU3VwcGxpZXJBZGRyZXNzXTtcbiAgICAvLyBjcmVhdGUgbW9kYWxcbiAgICBjb25zdCB2aWV3TW9kYWxPcHRpb25zOiBNb2RhbE9wdGlvbnMgPSB7XG4gICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbS1yaWdodCcsXG4gICAgICAgIGJhY2tkcm9wOiAnZHluYW1pYycsXG4gICAgICAgIGJhY2tkcm9wQ2xhc3NlczogJ2JnLWdyYXktOTAwIGJnLW9wYWNpdHktNTAgZGFyazpiZy1vcGFjaXR5LTgwIGZpeGVkIGluc2V0LTAgei00MCcsXG4gICAgICAgIGNsb3NhYmxlOiB0cnVlLFxuICAgICAgICBvbkhpZGU6ICgpID0+IHtcbiAgICAgICAgICAgIG1vZGFsVmlld0RpdnMuZm9yRWFjaChtb2RhbERpdiA9PiB7XG4gICAgICAgICAgICAgIG1vZGFsRGl2LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfVxuXG4gICAgY29uc3Qgdmlld01vZGFsID0gbmV3IE1vZGFsKHZpZXdJbmJvdW5kT3JkZXJNb2RhbEVsZW1lbnQsIHZpZXdNb2RhbE9wdGlvbnMpO1xuICAgIGNvbnN0IG9yZGVyVmlld0J1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaW5ib3VuZC1vcmRlci12aWV3LWJ1dHRvbicpO1xuICAgIG9yZGVyVmlld0J1dHRvbnMuZm9yRWFjaCgodmlld0J1dHRvbikgPT4ge1xuICAgICAgY29uc3QgaW5ib3VuZE9yZGVyRGF0YSA9IEpTT04ucGFyc2Uodmlld0J1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykpIGFzIElJbmJvdW5kT3JkZXJPdXQ7XG4gICAgICAvLyBOb2Rlc1xuICAgICAgdmlld0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgLy8gRmlsbCBvcmRlciB2aWV3IG1vZGFsIGRhdGFcbiAgICAgICAgb3JkZXJJZFZpZXcuaW5uZXJIVE1MID0gaW5ib3VuZE9yZGVyRGF0YS5vcmRlcklkO1xuICAgICAgICBvcmRlclN0YXR1cy5pbm5lckhUTUwgPSBpbmJvdW5kT3JkZXJEYXRhLnN0YXR1cztcbiAgICAgICAgb3JkZXJBY3RpdmVEYXRlLmlubmVySFRNTCA9IGdldERhdGVwaWNrZXJEYXRlRm9ybWF0KGluYm91bmRPcmRlckRhdGEuYWN0aXZlRGF0ZSk7XG4gICAgICAgIG9yZGVyQWN0aXZlVGltZS5pbm5lckhUTUwgPSBpbmJvdW5kT3JkZXJEYXRhLmFjdGl2ZVRpbWU7XG4gICAgICAgIG9yZGVyVGl0bGUuaW5uZXJIVE1MID0gaW5ib3VuZE9yZGVyRGF0YS50aXRsZTtcbiAgICAgICAgb3JkZXJEZWxpdmVyeURhdGUuaW5uZXJIVE1MID0gZ2V0RGF0ZXBpY2tlckRhdGVGb3JtYXQoaW5ib3VuZE9yZGVyRGF0YS5kZWxpdmVyeURhdGUpO1xuICAgICAgICBvcmRlcldhcmVob3VzZU5hbWUuaW5uZXJIVE1MID0gaW5ib3VuZE9yZGVyRGF0YS53YXJlaG91c2UubmFtZTtcbiAgICAgICAgb3JkZXJTdXBwbGllck5hbWUuaW5uZXJIVE1MID0gaW5ib3VuZE9yZGVyRGF0YS5zdXBwbGllci5uYW1lO1xuICAgICAgICBvcmRlclN1cHBsaWVyQWRkcmVzcy5pbm5lckhUTUwgPSBpbmJvdW5kT3JkZXJEYXRhLnN1cHBsaWVyLmFkZHJlc3M7XG5cbiAgICAgICAgdmlld01vZGFsLnNob3coKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgdmlld01vZGFsQ2xvc2VCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdmlldy1tb2RhbC1idG4taGlkZScpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICAgIHZpZXdNb2RhbENsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdmlld01vZGFsLmhpZGUoKTtcbiAgICB9KVxuXG4gICAgXG4gICAgY29uc3QgY29weUxpbmtCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci1zaGFyZScpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICAgIGNvcHlMaW5rQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgY29weUN1cnJlbnRMaW5rKClcbiAgICB9KTtcbn1cblxuY29uc3QgY29weUN1cnJlbnRMaW5rID0gKCkgPT4ge1xuICBjb25zdCBjdXJyZW50VVJMID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIGNvbnN0IHRlbXBJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gIHRlbXBJbnB1dC52YWx1ZSA9IGN1cnJlbnRVUkw7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcElucHV0KTtcbiAgdGVtcElucHV0LnNlbGVjdCgpO1xuICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRlbXBJbnB1dCk7XG5cbiAgY29uc3QgbGlua0NvcGllZFBvcHVwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpbmstY29waWVkLXBvcHVwJyk7XG4gIGxpbmtDb3BpZWRQb3B1cC5jbGFzc0xpc3QucmVtb3ZlKCdpbnZpc2libGUnKTtcbiAgY29uc3QgaGlkZVBvcHVwVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGxpbmtDb3BpZWRQb3B1cC5jbGFzc0xpc3QuYWRkKCdpbnZpc2libGUnKTtcbiAgICBjbGVhclRpbWVvdXQoaGlkZVBvcHVwVGltZW91dCk7XG4gIH0sIDEwMDApOyBcbn0iLCIvKiFcbiogVGFsaXdpbmQgRWxlbWVudHMgMS4wLjAtYmV0YTJcbiogXG4qIFRhaWx3aW5kIEVsZW1lbnRzIGlzIGFuIG9wZW4tc291cmNlIFVJIGtpdCBvZiBhZHZhbmNlZCBjb21wb25lbnRzIGZvciBUYWlsd2luZENTUy5cbiogQ29weXJpZ2h0IMKpIDIwMjMgTURCb290c3RyYXAuY29tXG4qIFxuKiBVbmxlc3MgYSBjdXN0b20sIGluZGl2aWR1YWxseSBhc3NpZ25lZCBsaWNlbnNlIGhhcyBiZWVuIGdyYW50ZWQsIHRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuKiBJbiBhZGRpdGlvbiwgYSBjdXN0b20gbGljZW5zZSBtYXkgYmUgYXZhaWxhYmxlIHVwb24gcmVxdWVzdCwgc3ViamVjdCB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhhdCBsaWNlbnNlLiBQbGVhc2UgY29udGFjdCB0YWlsd2luZEBtZGJvb3RzdHJhcC5jb20gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gb2J0YWluaW5nIGEgY3VzdG9tIGxpY2Vuc2UuXG4qIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4qIFxuKi9cbnZhciBYbCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBHbCA9IChzLCB0LCBlKSA9PiB0IGluIHMgPyBYbChzLCB0LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBlIH0pIDogc1t0XSA9IGU7XG52YXIgVHQgPSAocywgdCwgZSkgPT4gKEdsKHMsIHR5cGVvZiB0ICE9IFwic3ltYm9sXCIgPyB0ICsgXCJcIiA6IHQsIGUpLCBlKTtcbmNvbnN0IEJzID0gKCgpID0+IHtcbiAgY29uc3QgcyA9IHt9O1xuICBsZXQgdCA9IDE7XG4gIHJldHVybiB7XG4gICAgc2V0KGUsIGksIG4pIHtcbiAgICAgIHR5cGVvZiBlW2ldID4gXCJ1XCIgJiYgKGVbaV0gPSB7XG4gICAgICAgIGtleTogaSxcbiAgICAgICAgaWQ6IHRcbiAgICAgIH0sIHQrKyksIHNbZVtpXS5pZF0gPSBuO1xuICAgIH0sXG4gICAgZ2V0KGUsIGkpIHtcbiAgICAgIGlmICghZSB8fCB0eXBlb2YgZVtpXSA+IFwidVwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IG4gPSBlW2ldO1xuICAgICAgcmV0dXJuIG4ua2V5ID09PSBpID8gc1tuLmlkXSA6IG51bGw7XG4gICAgfSxcbiAgICBkZWxldGUoZSwgaSkge1xuICAgICAgaWYgKHR5cGVvZiBlW2ldID4gXCJ1XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG4gPSBlW2ldO1xuICAgICAgbi5rZXkgPT09IGkgJiYgKGRlbGV0ZSBzW24uaWRdLCBkZWxldGUgZVtpXSk7XG4gICAgfVxuICB9O1xufSkoKSwgSSA9IHtcbiAgc2V0RGF0YShzLCB0LCBlKSB7XG4gICAgQnMuc2V0KHMsIHQsIGUpO1xuICB9LFxuICBnZXREYXRhKHMsIHQpIHtcbiAgICByZXR1cm4gQnMuZ2V0KHMsIHQpO1xuICB9LFxuICByZW1vdmVEYXRhKHMsIHQpIHtcbiAgICBCcy5kZWxldGUocywgdCk7XG4gIH1cbn0sIHFsID0gMWU2LCBRbCA9IDFlMywgRG4gPSBcInRyYW5zaXRpb25lbmRcIiwgWmwgPSAocykgPT4gcyA9PSBudWxsID8gYCR7c31gIDoge30udG9TdHJpbmcuY2FsbChzKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKSwgT3QgPSAocykgPT4ge1xuICBkb1xuICAgIHMgKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcWwpO1xuICB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocykpO1xuICByZXR1cm4gcztcbn0sIHZhID0gKHMpID0+IHtcbiAgbGV0IHQgPSBzLmdldEF0dHJpYnV0ZShcImRhdGEtdGUtdGFyZ2V0XCIpO1xuICBpZiAoIXQgfHwgdCA9PT0gXCIjXCIpIHtcbiAgICBsZXQgZSA9IHMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICBpZiAoIWUgfHwgIWUuaW5jbHVkZXMoXCIjXCIpICYmICFlLnN0YXJ0c1dpdGgoXCIuXCIpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZS5pbmNsdWRlcyhcIiNcIikgJiYgIWUuc3RhcnRzV2l0aChcIiNcIikgJiYgKGUgPSBgIyR7ZS5zcGxpdChcIiNcIilbMV19YCksIHQgPSBlICYmIGUgIT09IFwiI1wiID8gZS50cmltKCkgOiBudWxsO1xuICB9XG4gIHJldHVybiB0O1xufSwgWG4gPSAocykgPT4ge1xuICBjb25zdCB0ID0gdmEocyk7XG4gIHJldHVybiB0ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgPyB0IDogbnVsbDtcbn0sIFh0ID0gKHMpID0+IHtcbiAgY29uc3QgdCA9IHZhKHMpO1xuICByZXR1cm4gdCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgOiBudWxsO1xufSwgSmwgPSAocykgPT4ge1xuICBpZiAoIXMpXG4gICAgcmV0dXJuIDA7XG4gIGxldCB7IHRyYW5zaXRpb25EdXJhdGlvbjogdCwgdHJhbnNpdGlvbkRlbGF5OiBlIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzKTtcbiAgY29uc3QgaSA9IE51bWJlci5wYXJzZUZsb2F0KHQpLCBuID0gTnVtYmVyLnBhcnNlRmxvYXQoZSk7XG4gIHJldHVybiAhaSAmJiAhbiA/IDAgOiAodCA9IHQuc3BsaXQoXCIsXCIpWzBdLCBlID0gZS5zcGxpdChcIixcIilbMF0sIChOdW1iZXIucGFyc2VGbG9hdCh0KSArIE51bWJlci5wYXJzZUZsb2F0KGUpKSAqIFFsKTtcbn0sIEVhID0gKHMpID0+IHtcbiAgcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChEbikpO1xufSwgTmUgPSAocykgPT4gIXMgfHwgdHlwZW9mIHMgIT0gXCJvYmplY3RcIiA/ICExIDogKHR5cGVvZiBzLmpxdWVyeSA8IFwidVwiICYmIChzID0gc1swXSksIHR5cGVvZiBzLm5vZGVUeXBlIDwgXCJ1XCIpLCBHdCA9IChzKSA9PiBOZShzKSA/IHMuanF1ZXJ5ID8gc1swXSA6IHMgOiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiICYmIHMubGVuZ3RoID4gMCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocykgOiBudWxsLCBOID0gKHMsIHQsIGUpID0+IHtcbiAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGNvbnN0IG4gPSBlW2ldLCBvID0gdFtpXSwgciA9IG8gJiYgTmUobykgPyBcImVsZW1lbnRcIiA6IFpsKG8pO1xuICAgIGlmICghbmV3IFJlZ0V4cChuKS50ZXN0KHIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtzLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCIke2l9XCIgcHJvdmlkZWQgdHlwZSBcIiR7cn1cIiBidXQgZXhwZWN0ZWQgdHlwZSBcIiR7bn1cIi5gXG4gICAgICApO1xuICB9KTtcbn0sIFN0ID0gKHMpID0+IHtcbiAgaWYgKCFzIHx8IHMuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuICExO1xuICBpZiAocy5zdHlsZSAmJiBzLnBhcmVudE5vZGUgJiYgcy5wYXJlbnROb2RlLnN0eWxlKSB7XG4gICAgY29uc3QgdCA9IGdldENvbXB1dGVkU3R5bGUocyksIGUgPSBnZXRDb21wdXRlZFN0eWxlKHMucGFyZW50Tm9kZSk7XG4gICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocykuZ2V0UHJvcGVydHlWYWx1ZShcInZpc2liaWxpdHlcIikgPT09IFwidmlzaWJsZVwiIHx8IHQuZGlzcGxheSAhPT0gXCJub25lXCIgJiYgZS5kaXNwbGF5ICE9PSBcIm5vbmVcIiAmJiB0LnZpc2liaWxpdHkgIT09IFwiaGlkZGVuXCI7XG4gIH1cbiAgcmV0dXJuICExO1xufSwgdWUgPSAocykgPT4gIXMgfHwgcy5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgfHwgcy5jbGFzc0xpc3QuY29udGFpbnMoXCJkaXNhYmxlZFwiKSA/ICEwIDogdHlwZW9mIHMuZGlzYWJsZWQgPCBcInVcIiA/IHMuZGlzYWJsZWQgOiBzLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpICYmIHMuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgIT09IFwiZmFsc2VcIiwgVGEgPSAocykgPT4ge1xuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh0eXBlb2Ygcy5nZXRSb290Tm9kZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCB0ID0gcy5nZXRSb290Tm9kZSgpO1xuICAgIHJldHVybiB0IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHQgOiBudWxsO1xuICB9XG4gIHJldHVybiBzIGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHMgOiBzLnBhcmVudE5vZGUgPyBUYShzLnBhcmVudE5vZGUpIDogbnVsbDtcbn0sIHZzID0gKCkgPT4gZnVuY3Rpb24oKSB7XG59LCBGZSA9IChzKSA9PiB7XG4gIHMub2Zmc2V0SGVpZ2h0O1xufSwgQ2EgPSAoKSA9PiB7XG4gIGNvbnN0IHsgalF1ZXJ5OiBzIH0gPSB3aW5kb3c7XG4gIHJldHVybiBzICYmICFkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZShcImRhdGEtdGUtbm8tanF1ZXJ5XCIpID8gcyA6IG51bGw7XG59LCBWcyA9IFtdLCBBYSA9IChzKSA9PiB7XG4gIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiID8gKFZzLmxlbmd0aCB8fCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gICAgVnMuZm9yRWFjaCgodCkgPT4gdCgpKTtcbiAgfSksIFZzLnB1c2gocykpIDogcygpO1xufSwgRiA9ICgpID0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgPT09IFwicnRsXCIsIHRjID0gKHMpID0+IEFycmF5LmZyb20ocyksIE0gPSAocykgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChzKSwgaGUgPSAocykgPT4ge1xuICB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgJiYgcygpO1xufSwgeWEgPSAocywgdCwgZSA9ICEwKSA9PiB7XG4gIGlmICghZSkge1xuICAgIGhlKHMpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpID0gNSwgbiA9IEpsKHQpICsgaTtcbiAgbGV0IG8gPSAhMTtcbiAgY29uc3QgciA9ICh7IHRhcmdldDogYSB9KSA9PiB7XG4gICAgYSA9PT0gdCAmJiAobyA9ICEwLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoRG4sIHIpLCBoZShzKSk7XG4gIH07XG4gIHQuYWRkRXZlbnRMaXN0ZW5lcihEbiwgciksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIG8gfHwgRWEodCk7XG4gIH0sIG4pO1xufSwgd2EgPSAocywgdCwgZSwgaSkgPT4ge1xuICBsZXQgbiA9IHMuaW5kZXhPZih0KTtcbiAgaWYgKG4gPT09IC0xKVxuICAgIHJldHVybiBzWyFlICYmIGkgPyBzLmxlbmd0aCAtIDEgOiAwXTtcbiAgY29uc3QgbyA9IHMubGVuZ3RoO1xuICByZXR1cm4gbiArPSBlID8gMSA6IC0xLCBpICYmIChuID0gKG4gKyBvKSAlIG8pLCBzW01hdGgubWF4KDAsIE1hdGgubWluKG4sIG8gLSAxKSldO1xufSwgZWMgPSAvW14uXSooPz1cXC4uKilcXC58LiovLCBpYyA9IC9cXC4uKi8sIHNjID0gLzo6XFxkKyQvLCBXcyA9IHt9O1xubGV0IEVvID0gMTtcbmNvbnN0IG5jID0ge1xuICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJcbn0sIG9jID0gL14obW91c2VlbnRlcnxtb3VzZWxlYXZlKS9pLCBrYSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjbGlja1wiLFxuICBcImRibGNsaWNrXCIsXG4gIFwibW91c2V1cFwiLFxuICBcIm1vdXNlZG93blwiLFxuICBcImNvbnRleHRtZW51XCIsXG4gIFwibW91c2V3aGVlbFwiLFxuICBcIkRPTU1vdXNlU2Nyb2xsXCIsXG4gIFwibW91c2VvdmVyXCIsXG4gIFwibW91c2VvdXRcIixcbiAgXCJtb3VzZW1vdmVcIixcbiAgXCJzZWxlY3RzdGFydFwiLFxuICBcInNlbGVjdGVuZFwiLFxuICBcImtleWRvd25cIixcbiAgXCJrZXlwcmVzc1wiLFxuICBcImtleXVwXCIsXG4gIFwib3JpZW50YXRpb25jaGFuZ2VcIixcbiAgXCJ0b3VjaHN0YXJ0XCIsXG4gIFwidG91Y2htb3ZlXCIsXG4gIFwidG91Y2hlbmRcIixcbiAgXCJ0b3VjaGNhbmNlbFwiLFxuICBcInBvaW50ZXJkb3duXCIsXG4gIFwicG9pbnRlcm1vdmVcIixcbiAgXCJwb2ludGVydXBcIixcbiAgXCJwb2ludGVybGVhdmVcIixcbiAgXCJwb2ludGVyY2FuY2VsXCIsXG4gIFwiZ2VzdHVyZXN0YXJ0XCIsXG4gIFwiZ2VzdHVyZWNoYW5nZVwiLFxuICBcImdlc3R1cmVlbmRcIixcbiAgXCJmb2N1c1wiLFxuICBcImJsdXJcIixcbiAgXCJjaGFuZ2VcIixcbiAgXCJyZXNldFwiLFxuICBcInNlbGVjdFwiLFxuICBcInN1Ym1pdFwiLFxuICBcImZvY3VzaW5cIixcbiAgXCJmb2N1c291dFwiLFxuICBcImxvYWRcIixcbiAgXCJ1bmxvYWRcIixcbiAgXCJiZWZvcmV1bmxvYWRcIixcbiAgXCJyZXNpemVcIixcbiAgXCJtb3ZlXCIsXG4gIFwiRE9NQ29udGVudExvYWRlZFwiLFxuICBcInJlYWR5c3RhdGVjaGFuZ2VcIixcbiAgXCJlcnJvclwiLFxuICBcImFib3J0XCIsXG4gIFwic2Nyb2xsXCJcbl0pO1xuZnVuY3Rpb24gT2EocywgdCkge1xuICByZXR1cm4gdCAmJiBgJHt0fTo6JHtFbysrfWAgfHwgcy51aWRFdmVudCB8fCBFbysrO1xufVxuZnVuY3Rpb24geGEocykge1xuICBjb25zdCB0ID0gT2Eocyk7XG4gIHJldHVybiBzLnVpZEV2ZW50ID0gdCwgV3NbdF0gPSBXc1t0XSB8fCB7fSwgV3NbdF07XG59XG5mdW5jdGlvbiByYyhzLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBlKGkpIHtcbiAgICByZXR1cm4gaS5kZWxlZ2F0ZVRhcmdldCA9IHMsIGUub25lT2ZmICYmIHUub2ZmKHMsIGkudHlwZSwgdCksIHQuYXBwbHkocywgW2ldKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFjKHMsIHQsIGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGkobikge1xuICAgIGNvbnN0IG8gPSBzLnF1ZXJ5U2VsZWN0b3JBbGwodCk7XG4gICAgZm9yIChsZXQgeyB0YXJnZXQ6IHIgfSA9IG47IHIgJiYgciAhPT0gdGhpczsgciA9IHIucGFyZW50Tm9kZSlcbiAgICAgIGZvciAobGV0IGEgPSBvLmxlbmd0aDsgYS0tOyBcIlwiKVxuICAgICAgICBpZiAob1thXSA9PT0gcilcbiAgICAgICAgICByZXR1cm4gbi5kZWxlZ2F0ZVRhcmdldCA9IHIsIGkub25lT2ZmICYmIHUub2ZmKHMsIG4udHlwZSwgZSksIGUuYXBwbHkociwgW25dKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cbmZ1bmN0aW9uIFNhKHMsIHQsIGUgPSBudWxsKSB7XG4gIGNvbnN0IGkgPSBPYmplY3Qua2V5cyhzKTtcbiAgZm9yIChsZXQgbiA9IDAsIG8gPSBpLmxlbmd0aDsgbiA8IG87IG4rKykge1xuICAgIGNvbnN0IHIgPSBzW2lbbl1dO1xuICAgIGlmIChyLm9yaWdpbmFsSGFuZGxlciA9PT0gdCAmJiByLmRlbGVnYXRpb25TZWxlY3RvciA9PT0gZSlcbiAgICAgIHJldHVybiByO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gRGEocywgdCwgZSkge1xuICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiwgbiA9IGkgPyBlIDogdDtcbiAgbGV0IG8gPSBJYShzKTtcbiAgcmV0dXJuIGthLmhhcyhvKSB8fCAobyA9IHMpLCBbaSwgbiwgb107XG59XG5mdW5jdGlvbiBUbyhzLCB0LCBlLCBpLCBuKSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFzKVxuICAgIHJldHVybjtcbiAgaWYgKGUgfHwgKGUgPSBpLCBpID0gbnVsbCksIG9jLnRlc3QodCkpIHtcbiAgICBjb25zdCBtID0gKGcpID0+IGZ1bmN0aW9uKGIpIHtcbiAgICAgIGlmICghYi5yZWxhdGVkVGFyZ2V0IHx8IGIucmVsYXRlZFRhcmdldCAhPT0gYi5kZWxlZ2F0ZVRhcmdldCAmJiAhYi5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhiLnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICByZXR1cm4gZy5jYWxsKHRoaXMsIGIpO1xuICAgIH07XG4gICAgaSA/IGkgPSBtKGkpIDogZSA9IG0oZSk7XG4gIH1cbiAgY29uc3QgW28sIHIsIGFdID0gRGEoXG4gICAgdCxcbiAgICBlLFxuICAgIGlcbiAgKSwgbCA9IHhhKHMpLCBjID0gbFthXSB8fCAobFthXSA9IHt9KSwgZCA9IFNhKFxuICAgIGMsXG4gICAgcixcbiAgICBvID8gZSA6IG51bGxcbiAgKTtcbiAgaWYgKGQpIHtcbiAgICBkLm9uZU9mZiA9IGQub25lT2ZmICYmIG47XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IF8gPSBPYShcbiAgICByLFxuICAgIHQucmVwbGFjZShlYywgXCJcIilcbiAgKSwgZiA9IG8gPyBhYyhzLCBlLCBpKSA6IHJjKHMsIGUpO1xuICBmLmRlbGVnYXRpb25TZWxlY3RvciA9IG8gPyBlIDogbnVsbCwgZi5vcmlnaW5hbEhhbmRsZXIgPSByLCBmLm9uZU9mZiA9IG4sIGYudWlkRXZlbnQgPSBfLCBjW19dID0gZiwgcy5hZGRFdmVudExpc3RlbmVyKGEsIGYsIG8pO1xufVxuZnVuY3Rpb24gSW4ocywgdCwgZSwgaSwgbikge1xuICBjb25zdCBvID0gU2EodFtlXSwgaSwgbik7XG4gIG8gJiYgKHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBvLCAhIW4pLCBkZWxldGUgdFtlXVtvLnVpZEV2ZW50XSk7XG59XG5mdW5jdGlvbiBsYyhzLCB0LCBlLCBpKSB7XG4gIGNvbnN0IG4gPSB0W2VdIHx8IHt9O1xuICBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgaWYgKG8uaW5jbHVkZXMoaSkpIHtcbiAgICAgIGNvbnN0IHIgPSBuW29dO1xuICAgICAgSW4oXG4gICAgICAgIHMsXG4gICAgICAgIHQsXG4gICAgICAgIGUsXG4gICAgICAgIHIub3JpZ2luYWxIYW5kbGVyLFxuICAgICAgICByLmRlbGVnYXRpb25TZWxlY3RvclxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gSWEocykge1xuICByZXR1cm4gcyA9IHMucmVwbGFjZShpYywgXCJcIiksIG5jW3NdIHx8IHM7XG59XG5jb25zdCB1ID0ge1xuICBvbihzLCB0LCBlLCBpKSB7XG4gICAgVG8ocywgdCwgZSwgaSwgITEpO1xuICB9LFxuICBvbmUocywgdCwgZSwgaSkge1xuICAgIFRvKHMsIHQsIGUsIGksICEwKTtcbiAgfSxcbiAgb2ZmKHMsIHQsIGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIiB8fCAhcylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbbiwgbywgcl0gPSBEYShcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgaVxuICAgICksIGEgPSByICE9PSB0LCBsID0geGEocyksIGMgPSB0LnN0YXJ0c1dpdGgoXCIuXCIpO1xuICAgIGlmICh0eXBlb2YgbyA8IFwidVwiKSB7XG4gICAgICBpZiAoIWwgfHwgIWxbcl0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIEluKFxuICAgICAgICBzLFxuICAgICAgICBsLFxuICAgICAgICByLFxuICAgICAgICBvLFxuICAgICAgICBuID8gZSA6IG51bGxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGMgJiYgT2JqZWN0LmtleXMobCkuZm9yRWFjaCgoXykgPT4ge1xuICAgICAgbGMoXG4gICAgICAgIHMsXG4gICAgICAgIGwsXG4gICAgICAgIF8sXG4gICAgICAgIHQuc2xpY2UoMSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgY29uc3QgZCA9IGxbcl0gfHwge307XG4gICAgT2JqZWN0LmtleXMoZCkuZm9yRWFjaCgoXykgPT4ge1xuICAgICAgY29uc3QgZiA9IF8ucmVwbGFjZShzYywgXCJcIik7XG4gICAgICBpZiAoIWEgfHwgdC5pbmNsdWRlcyhmKSkge1xuICAgICAgICBjb25zdCBtID0gZFtfXTtcbiAgICAgICAgSW4oXG4gICAgICAgICAgcyxcbiAgICAgICAgICBsLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgbS5vcmlnaW5hbEhhbmRsZXIsXG4gICAgICAgICAgbS5kZWxlZ2F0aW9uU2VsZWN0b3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgdHJpZ2dlcihzLCB0LCBlKSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgfHwgIXMpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpID0gQ2EoKSwgbiA9IElhKHQpLCBvID0gdCAhPT0gbiwgciA9IGthLmhhcyhuKTtcbiAgICBsZXQgYSwgbCA9ICEwLCBjID0gITAsIGQgPSAhMSwgXyA9IG51bGw7XG4gICAgcmV0dXJuIG8gJiYgaSAmJiAoYSA9IGkuRXZlbnQodCwgZSksIGkocykudHJpZ2dlcihhKSwgbCA9ICFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCksIGMgPSAhYS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpLCBkID0gYS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSksIHIgPyAoXyA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKSwgXy5pbml0RXZlbnQobiwgbCwgITApKSA6IF8gPSBuZXcgQ3VzdG9tRXZlbnQodCwge1xuICAgICAgYnViYmxlczogbCxcbiAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgfSksIHR5cGVvZiBlIDwgXCJ1XCIgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIGYsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBlW2ZdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSwgZCAmJiBfLnByZXZlbnREZWZhdWx0KCksIGMgJiYgcy5kaXNwYXRjaEV2ZW50KF8pLCBfLmRlZmF1bHRQcmV2ZW50ZWQgJiYgdHlwZW9mIGEgPCBcInVcIiAmJiBhLnByZXZlbnREZWZhdWx0KCksIF87XG4gIH1cbn0sIGVlID0ge1xuICBvbihzLCB0LCBlLCBpKSB7XG4gICAgY29uc3QgbiA9IHQuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgbi5sZW5ndGg7IG8rKylcbiAgICAgIHUub24ocywgbltvXSwgZSwgaSk7XG4gIH0sXG4gIG9mZihzLCB0LCBlLCBpKSB7XG4gICAgY29uc3QgbiA9IHQuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgbi5sZW5ndGg7IG8rKylcbiAgICAgIHUub2ZmKHMsIG5bb10sIGUsIGkpO1xuICB9XG59LCBjYyA9IFwiNS4xLjNcIjtcbmNsYXNzIHZ0IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHQgPSBHdCh0KSwgdCAmJiAodGhpcy5fZWxlbWVudCA9IHQsIEkuc2V0RGF0YSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSksIHUub2ZmKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKSwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpc1t0XSA9IG51bGw7XG4gICAgfSk7XG4gIH1cbiAgX3F1ZXVlQ2FsbGJhY2sodCwgZSwgaSA9ICEwKSB7XG4gICAgeWEodCwgZSwgaSk7XG4gIH1cbiAgLyoqIFN0YXRpYyAqL1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEoR3QodCksIHRoaXMuREFUQV9LRVkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBjYztcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcIk5BTUVcIiwgZm9yIGVhY2ggY29tcG9uZW50ISdcbiAgICApO1xuICB9XG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XG4gICAgcmV0dXJuIGB0ZS4ke3RoaXMuTkFNRX1gO1xuICB9XG4gIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xuICAgIHJldHVybiBgLiR7dGhpcy5EQVRBX0tFWX1gO1xuICB9XG59XG5jb25zdCBkYyA9IFwiYnV0dG9uXCIsIGhjID0gXCJhY3RpdmVcIjtcbmNsYXNzICRhIGV4dGVuZHMgdnQge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gZGM7XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1wcmVzc2VkXCIsXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoaGMpXG4gICAgKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSAkYS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgdCA9PT0gXCJ0b2dnbGVcIiAmJiBlW3RdKCk7XG4gICAgfSk7XG4gIH1cbn1cbnZhciBaID0gXCJ0b3BcIiwgZHQgPSBcImJvdHRvbVwiLCBodCA9IFwicmlnaHRcIiwgSiA9IFwibGVmdFwiLCBtaSA9IFwiYXV0b1wiLCBZZSA9IFtaLCBkdCwgaHQsIEpdLCBfZSA9IFwic3RhcnRcIiwgUmUgPSBcImVuZFwiLCBMYSA9IFwiY2xpcHBpbmdQYXJlbnRzXCIsIEduID0gXCJ2aWV3cG9ydFwiLCB5ZSA9IFwicG9wcGVyXCIsIE1hID0gXCJyZWZlcmVuY2VcIiwgJG4gPSAvKiBAX19QVVJFX18gKi8gWWUucmVkdWNlKGZ1bmN0aW9uKHMsIHQpIHtcbiAgcmV0dXJuIHMuY29uY2F0KFt0ICsgXCItXCIgKyBfZSwgdCArIFwiLVwiICsgUmVdKTtcbn0sIFtdKSwgcW4gPSAvKiBAX19QVVJFX18gKi8gW10uY29uY2F0KFllLCBbbWldKS5yZWR1Y2UoZnVuY3Rpb24ocywgdCkge1xuICByZXR1cm4gcy5jb25jYXQoW3QsIHQgKyBcIi1cIiArIF9lLCB0ICsgXCItXCIgKyBSZV0pO1xufSwgW10pLCBOYSA9IFwiYmVmb3JlUmVhZFwiLCBSYSA9IFwicmVhZFwiLCBQYSA9IFwiYWZ0ZXJSZWFkXCIsIEhhID0gXCJiZWZvcmVNYWluXCIsIEJhID0gXCJtYWluXCIsIFZhID0gXCJhZnRlck1haW5cIiwgV2EgPSBcImJlZm9yZVdyaXRlXCIsIEZhID0gXCJ3cml0ZVwiLCBZYSA9IFwiYWZ0ZXJXcml0ZVwiLCBFcyA9IFtOYSwgUmEsIFBhLCBIYSwgQmEsIFZhLCBXYSwgRmEsIFlhXTtcbmZ1bmN0aW9uIEl0KHMpIHtcbiAgcmV0dXJuIHMgPyAocy5ub2RlTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHV0KHMpIHtcbiAgaWYgKHMgPT0gbnVsbClcbiAgICByZXR1cm4gd2luZG93O1xuICBpZiAocy50b1N0cmluZygpICE9PSBcIltvYmplY3QgV2luZG93XVwiKSB7XG4gICAgdmFyIHQgPSBzLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIHQgJiYgdC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBtZShzKSB7XG4gIHZhciB0ID0gdXQocykuRWxlbWVudDtcbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0IHx8IHMgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuZnVuY3Rpb24gY3Qocykge1xuICB2YXIgdCA9IHV0KHMpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gcyBpbnN0YW5jZW9mIHQgfHwgcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gUW4ocykge1xuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPiBcInVcIilcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gdXQocykuU2hhZG93Um9vdDtcbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0IHx8IHMgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuZnVuY3Rpb24gdWMocykge1xuICB2YXIgdCA9IHMuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHQuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgIHZhciBpID0gdC5zdHlsZXNbZV0gfHwge30sIG4gPSB0LmF0dHJpYnV0ZXNbZV0gfHwge30sIG8gPSB0LmVsZW1lbnRzW2VdO1xuICAgICFjdChvKSB8fCAhSXQobykgfHwgKE9iamVjdC5hc3NpZ24oby5zdHlsZSwgaSksIE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGEgPSBuW3JdO1xuICAgICAgYSA9PT0gITEgPyBvLnJlbW92ZUF0dHJpYnV0ZShyKSA6IG8uc2V0QXR0cmlidXRlKHIsIGEgPT09ICEwID8gXCJcIiA6IGEpO1xuICAgIH0pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwYyhzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiB0Lm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiBcIjBcIixcbiAgICAgIHRvcDogXCIwXCIsXG4gICAgICBtYXJnaW46IFwiMFwiXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgZS5wb3BwZXIpLCB0LnN0eWxlcyA9IGUsIHQuZWxlbWVudHMuYXJyb3cgJiYgT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLmFycm93LnN0eWxlLCBlLmFycm93KSwgZnVuY3Rpb24oKSB7XG4gICAgT2JqZWN0LmtleXModC5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgbiA9IHQuZWxlbWVudHNbaV0sIG8gPSB0LmF0dHJpYnV0ZXNbaV0gfHwge30sIHIgPSBPYmplY3Qua2V5cyh0LnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShpKSA/IHQuc3R5bGVzW2ldIDogZVtpXSksIGEgPSByLnJlZHVjZShmdW5jdGlvbihsLCBjKSB7XG4gICAgICAgIHJldHVybiBsW2NdID0gXCJcIiwgbDtcbiAgICAgIH0sIHt9KTtcbiAgICAgICFjdChuKSB8fCAhSXQobikgfHwgKE9iamVjdC5hc3NpZ24obi5zdHlsZSwgYSksIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgICAgICBuLnJlbW92ZUF0dHJpYnV0ZShsKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfTtcbn1cbmNvbnN0IFpuID0ge1xuICBuYW1lOiBcImFwcGx5U3R5bGVzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJ3cml0ZVwiLFxuICBmbjogdWMsXG4gIGVmZmVjdDogcGMsXG4gIHJlcXVpcmVzOiBbXCJjb21wdXRlU3R5bGVzXCJdXG59O1xuZnVuY3Rpb24gZ3Qocykge1xuICByZXR1cm4gcy5zcGxpdChcIi1cIilbMF07XG59XG52YXIgcGUgPSBNYXRoLm1heCwgVHMgPSBNYXRoLm1pbiwgUGUgPSBNYXRoLnJvdW5kO1xuZnVuY3Rpb24gTG4oKSB7XG4gIHZhciBzID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIHJldHVybiBzICE9IG51bGwgJiYgcy5icmFuZHMgJiYgQXJyYXkuaXNBcnJheShzLmJyYW5kcykgPyBzLmJyYW5kcy5tYXAoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LmJyYW5kICsgXCIvXCIgKyB0LnZlcnNpb247XG4gIH0pLmpvaW4oXCIgXCIpIDogbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cbmZ1bmN0aW9uIGphKCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoTG4oKSk7XG59XG5mdW5jdGlvbiBIZShzLCB0LCBlKSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9ICExKSwgZSA9PT0gdm9pZCAwICYmIChlID0gITEpO1xuICB2YXIgaSA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSAxLCBvID0gMTtcbiAgdCAmJiBjdChzKSAmJiAobiA9IHMub2Zmc2V0V2lkdGggPiAwICYmIFBlKGkud2lkdGgpIC8gcy5vZmZzZXRXaWR0aCB8fCAxLCBvID0gcy5vZmZzZXRIZWlnaHQgPiAwICYmIFBlKGkuaGVpZ2h0KSAvIHMub2Zmc2V0SGVpZ2h0IHx8IDEpO1xuICB2YXIgciA9IG1lKHMpID8gdXQocykgOiB3aW5kb3csIGEgPSByLnZpc3VhbFZpZXdwb3J0LCBsID0gIWphKCkgJiYgZSwgYyA9IChpLmxlZnQgKyAobCAmJiBhID8gYS5vZmZzZXRMZWZ0IDogMCkpIC8gbiwgZCA9IChpLnRvcCArIChsICYmIGEgPyBhLm9mZnNldFRvcCA6IDApKSAvIG8sIF8gPSBpLndpZHRoIC8gbiwgZiA9IGkuaGVpZ2h0IC8gbztcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogXyxcbiAgICBoZWlnaHQ6IGYsXG4gICAgdG9wOiBkLFxuICAgIHJpZ2h0OiBjICsgXyxcbiAgICBib3R0b206IGQgKyBmLFxuICAgIGxlZnQ6IGMsXG4gICAgeDogYyxcbiAgICB5OiBkXG4gIH07XG59XG5mdW5jdGlvbiBKbihzKSB7XG4gIHZhciB0ID0gSGUocyksIGUgPSBzLm9mZnNldFdpZHRoLCBpID0gcy5vZmZzZXRIZWlnaHQ7XG4gIHJldHVybiBNYXRoLmFicyh0LndpZHRoIC0gZSkgPD0gMSAmJiAoZSA9IHQud2lkdGgpLCBNYXRoLmFicyh0LmhlaWdodCAtIGkpIDw9IDEgJiYgKGkgPSB0LmhlaWdodCksIHtcbiAgICB4OiBzLm9mZnNldExlZnQsXG4gICAgeTogcy5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IGUsXG4gICAgaGVpZ2h0OiBpXG4gIH07XG59XG5mdW5jdGlvbiBLYShzLCB0KSB7XG4gIHZhciBlID0gdC5nZXRSb290Tm9kZSAmJiB0LmdldFJvb3ROb2RlKCk7XG4gIGlmIChzLmNvbnRhaW5zKHQpKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKGUgJiYgUW4oZSkpIHtcbiAgICB2YXIgaSA9IHQ7XG4gICAgZG8ge1xuICAgICAgaWYgKGkgJiYgcy5pc1NhbWVOb2RlKGkpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpID0gaS5wYXJlbnROb2RlIHx8IGkuaG9zdDtcbiAgICB9IHdoaWxlIChpKTtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBidChzKSB7XG4gIHJldHVybiB1dChzKS5nZXRDb21wdXRlZFN0eWxlKHMpO1xufVxuZnVuY3Rpb24gZmMocykge1xuICByZXR1cm4gW1widGFibGVcIiwgXCJ0ZFwiLCBcInRoXCJdLmluZGV4T2YoSXQocykpID49IDA7XG59XG5mdW5jdGlvbiBxdChzKSB7XG4gIHJldHVybiAoKG1lKHMpID8gcy5vd25lckRvY3VtZW50IDogKFxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHMuZG9jdW1lbnRcbiAgKSkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiB3cyhzKSB7XG4gIHJldHVybiBJdChzKSA9PT0gXCJodG1sXCIgPyBzIDogKFxuICAgIC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHMuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgcy5wYXJlbnROb2RlIHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgKFFuKHMpID8gcy5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBxdChzKVxuICApO1xufVxuZnVuY3Rpb24gQ28ocykge1xuICByZXR1cm4gIWN0KHMpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGJ0KHMpLnBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBudWxsIDogcy5vZmZzZXRQYXJlbnQ7XG59XG5mdW5jdGlvbiBfYyhzKSB7XG4gIHZhciB0ID0gL2ZpcmVmb3gvaS50ZXN0KExuKCkpLCBlID0gL1RyaWRlbnQvaS50ZXN0KExuKCkpO1xuICBpZiAoZSAmJiBjdChzKSkge1xuICAgIHZhciBpID0gYnQocyk7XG4gICAgaWYgKGkucG9zaXRpb24gPT09IFwiZml4ZWRcIilcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBuID0gd3Mocyk7XG4gIGZvciAoUW4obikgJiYgKG4gPSBuLmhvc3QpOyBjdChuKSAmJiBbXCJodG1sXCIsIFwiYm9keVwiXS5pbmRleE9mKEl0KG4pKSA8IDA7ICkge1xuICAgIHZhciBvID0gYnQobik7XG4gICAgaWYgKG8udHJhbnNmb3JtICE9PSBcIm5vbmVcIiB8fCBvLnBlcnNwZWN0aXZlICE9PSBcIm5vbmVcIiB8fCBvLmNvbnRhaW4gPT09IFwicGFpbnRcIiB8fCBbXCJ0cmFuc2Zvcm1cIiwgXCJwZXJzcGVjdGl2ZVwiXS5pbmRleE9mKG8ud2lsbENoYW5nZSkgIT09IC0xIHx8IHQgJiYgby53aWxsQ2hhbmdlID09PSBcImZpbHRlclwiIHx8IHQgJiYgby5maWx0ZXIgJiYgby5maWx0ZXIgIT09IFwibm9uZVwiKVxuICAgICAgcmV0dXJuIG47XG4gICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdpKHMpIHtcbiAgZm9yICh2YXIgdCA9IHV0KHMpLCBlID0gQ28ocyk7IGUgJiYgZmMoZSkgJiYgYnQoZSkucG9zaXRpb24gPT09IFwic3RhdGljXCI7IClcbiAgICBlID0gQ28oZSk7XG4gIHJldHVybiBlICYmIChJdChlKSA9PT0gXCJodG1sXCIgfHwgSXQoZSkgPT09IFwiYm9keVwiICYmIGJ0KGUpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiKSA/IHQgOiBlIHx8IF9jKHMpIHx8IHQ7XG59XG5mdW5jdGlvbiB0byhzKSB7XG4gIHJldHVybiBbXCJ0b3BcIiwgXCJib3R0b21cIl0uaW5kZXhPZihzKSA+PSAwID8gXCJ4XCIgOiBcInlcIjtcbn1cbmZ1bmN0aW9uIGxpKHMsIHQsIGUpIHtcbiAgcmV0dXJuIHBlKHMsIFRzKHQsIGUpKTtcbn1cbmZ1bmN0aW9uIG1jKHMsIHQsIGUpIHtcbiAgdmFyIGkgPSBsaShzLCB0LCBlKTtcbiAgcmV0dXJuIGkgPiBlID8gZSA6IGk7XG59XG5mdW5jdGlvbiBVYSgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHphKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIFVhKCksIHMpO1xufVxuZnVuY3Rpb24gWGEocywgdCkge1xuICByZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24oZSwgaSkge1xuICAgIHJldHVybiBlW2ldID0gcywgZTtcbiAgfSwge30pO1xufVxudmFyIGdjID0gZnVuY3Rpb24odCwgZSkge1xuICByZXR1cm4gdCA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQoT2JqZWN0LmFzc2lnbih7fSwgZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogZS5wbGFjZW1lbnRcbiAgfSkpIDogdCwgemEodHlwZW9mIHQgIT0gXCJudW1iZXJcIiA/IHQgOiBYYSh0LCBZZSkpO1xufTtcbmZ1bmN0aW9uIGJjKHMpIHtcbiAgdmFyIHQsIGUgPSBzLnN0YXRlLCBpID0gcy5uYW1lLCBuID0gcy5vcHRpb25zLCBvID0gZS5lbGVtZW50cy5hcnJvdywgciA9IGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLCBhID0gZ3QoZS5wbGFjZW1lbnQpLCBsID0gdG8oYSksIGMgPSBbSiwgaHRdLmluZGV4T2YoYSkgPj0gMCwgZCA9IGMgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICBpZiAoISghbyB8fCAhcikpIHtcbiAgICB2YXIgXyA9IGdjKG4ucGFkZGluZywgZSksIGYgPSBKbihvKSwgbSA9IGwgPT09IFwieVwiID8gWiA6IEosIGcgPSBsID09PSBcInlcIiA/IGR0IDogaHQsIGIgPSBlLnJlY3RzLnJlZmVyZW5jZVtkXSArIGUucmVjdHMucmVmZXJlbmNlW2xdIC0gcltsXSAtIGUucmVjdHMucG9wcGVyW2RdLCBUID0gcltsXSAtIGUucmVjdHMucmVmZXJlbmNlW2xdLCBDID0gZ2kobyksIHcgPSBDID8gbCA9PT0gXCJ5XCIgPyBDLmNsaWVudEhlaWdodCB8fCAwIDogQy5jbGllbnRXaWR0aCB8fCAwIDogMCwgdiA9IGIgLyAyIC0gVCAvIDIsIEUgPSBfW21dLCBBID0gdyAtIGZbZF0gLSBfW2ddLCB5ID0gdyAvIDIgLSBmW2RdIC8gMiArIHYsIFMgPSBsaShFLCB5LCBBKSwgTyA9IGw7XG4gICAgZS5tb2RpZmllcnNEYXRhW2ldID0gKHQgPSB7fSwgdFtPXSA9IFMsIHQuY2VudGVyT2Zmc2V0ID0gUyAtIHksIHQpO1xuICB9XG59XG5mdW5jdGlvbiB2YyhzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IGUuZWxlbWVudCwgbiA9IGkgPT09IHZvaWQgMCA/IFwiW2RhdGEtcG9wcGVyLWFycm93XVwiIDogaTtcbiAgaWYgKG4gIT0gbnVsbCAmJiAhKHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgKG4gPSB0LmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKG4pLCAhbikpKSB7XG4gICAgaWYgKHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoY3QobikgfHwgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsIFwiVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhc1wiLCBcInRoZSBhcnJvdy5cIl0uam9pbihcIiBcIikpKSwgIUthKHQuZWxlbWVudHMucG9wcGVyLCBuKSkge1xuICAgICAgKHt9KS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCBcImVsZW1lbnQuXCJdLmpvaW4oXCIgXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5lbGVtZW50cy5hcnJvdyA9IG47XG4gIH1cbn1cbmNvbnN0IEdhID0ge1xuICBuYW1lOiBcImFycm93XCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIGZuOiBiYyxcbiAgZWZmZWN0OiB2YyxcbiAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcInByZXZlbnRPdmVyZmxvd1wiXVxufTtcbmZ1bmN0aW9uIEJlKHMpIHtcbiAgcmV0dXJuIHMuc3BsaXQoXCItXCIpWzFdO1xufVxudmFyIEVjID0ge1xuICB0b3A6IFwiYXV0b1wiLFxuICByaWdodDogXCJhdXRvXCIsXG4gIGJvdHRvbTogXCJhdXRvXCIsXG4gIGxlZnQ6IFwiYXV0b1wiXG59O1xuZnVuY3Rpb24gVGMocywgdCkge1xuICB2YXIgZSA9IHMueCwgaSA9IHMueSwgbiA9IHQuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IFBlKGUgKiBuKSAvIG4gfHwgMCxcbiAgICB5OiBQZShpICogbikgLyBuIHx8IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIEFvKHMpIHtcbiAgdmFyIHQsIGUgPSBzLnBvcHBlciwgaSA9IHMucG9wcGVyUmVjdCwgbiA9IHMucGxhY2VtZW50LCBvID0gcy52YXJpYXRpb24sIHIgPSBzLm9mZnNldHMsIGEgPSBzLnBvc2l0aW9uLCBsID0gcy5ncHVBY2NlbGVyYXRpb24sIGMgPSBzLmFkYXB0aXZlLCBkID0gcy5yb3VuZE9mZnNldHMsIF8gPSBzLmlzRml4ZWQsIGYgPSByLngsIG0gPSBmID09PSB2b2lkIDAgPyAwIDogZiwgZyA9IHIueSwgYiA9IGcgPT09IHZvaWQgMCA/IDAgOiBnLCBUID0gdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiID8gZCh7XG4gICAgeDogbSxcbiAgICB5OiBiXG4gIH0pIDoge1xuICAgIHg6IG0sXG4gICAgeTogYlxuICB9O1xuICBtID0gVC54LCBiID0gVC55O1xuICB2YXIgQyA9IHIuaGFzT3duUHJvcGVydHkoXCJ4XCIpLCB3ID0gci5oYXNPd25Qcm9wZXJ0eShcInlcIiksIHYgPSBKLCBFID0gWiwgQSA9IHdpbmRvdztcbiAgaWYgKGMpIHtcbiAgICB2YXIgeSA9IGdpKGUpLCBTID0gXCJjbGllbnRIZWlnaHRcIiwgTyA9IFwiY2xpZW50V2lkdGhcIjtcbiAgICBpZiAoeSA9PT0gdXQoZSkgJiYgKHkgPSBxdChlKSwgYnQoeSkucG9zaXRpb24gIT09IFwic3RhdGljXCIgJiYgYSA9PT0gXCJhYnNvbHV0ZVwiICYmIChTID0gXCJzY3JvbGxIZWlnaHRcIiwgTyA9IFwic2Nyb2xsV2lkdGhcIikpLCB5ID0geSwgbiA9PT0gWiB8fCAobiA9PT0gSiB8fCBuID09PSBodCkgJiYgbyA9PT0gUmUpIHtcbiAgICAgIEUgPSBkdDtcbiAgICAgIHZhciBrID0gXyAmJiB5ID09PSBBICYmIEEudmlzdWFsVmlld3BvcnQgPyBBLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IChcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIHlbU11cbiAgICAgICk7XG4gICAgICBiIC09IGsgLSBpLmhlaWdodCwgYiAqPSBsID8gMSA6IC0xO1xuICAgIH1cbiAgICBpZiAobiA9PT0gSiB8fCAobiA9PT0gWiB8fCBuID09PSBkdCkgJiYgbyA9PT0gUmUpIHtcbiAgICAgIHYgPSBodDtcbiAgICAgIHZhciBEID0gXyAmJiB5ID09PSBBICYmIEEudmlzdWFsVmlld3BvcnQgPyBBLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogKFxuICAgICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgeVtPXVxuICAgICAgKTtcbiAgICAgIG0gLT0gRCAtIGkud2lkdGgsIG0gKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gIH1cbiAgdmFyIHggPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogYVxuICB9LCBjICYmIEVjKSwgJCA9IGQgPT09ICEwID8gVGMoe1xuICAgIHg6IG0sXG4gICAgeTogYlxuICB9LCB1dChlKSkgOiB7XG4gICAgeDogbSxcbiAgICB5OiBiXG4gIH07XG4gIGlmIChtID0gJC54LCBiID0gJC55LCBsKSB7XG4gICAgdmFyIFA7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHgsIChQID0ge30sIFBbRV0gPSB3ID8gXCIwXCIgOiBcIlwiLCBQW3ZdID0gQyA/IFwiMFwiIDogXCJcIiwgUC50cmFuc2Zvcm0gPSAoQS5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIG0gKyBcInB4LCBcIiArIGIgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIG0gKyBcInB4LCBcIiArIGIgKyBcInB4LCAwKVwiLCBQKSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHgsICh0ID0ge30sIHRbRV0gPSB3ID8gYiArIFwicHhcIiA6IFwiXCIsIHRbdl0gPSBDID8gbSArIFwicHhcIiA6IFwiXCIsIHQudHJhbnNmb3JtID0gXCJcIiwgdCkpO1xufVxuZnVuY3Rpb24gQ2Mocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBlLmdwdUFjY2VsZXJhdGlvbiwgbiA9IGkgPT09IHZvaWQgMCA/ICEwIDogaSwgbyA9IGUuYWRhcHRpdmUsIHIgPSBvID09PSB2b2lkIDAgPyAhMCA6IG8sIGEgPSBlLnJvdW5kT2Zmc2V0cywgbCA9IGEgPT09IHZvaWQgMCA/ICEwIDogYTtcbiAgaWYgKHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBjID0gYnQodC5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCBcIlwiO1xuICAgIHIgJiYgW1widHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdLnNvbWUoZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGMuaW5kZXhPZihfKSA+PSAwO1xuICAgIH0pICYmIGNvbnNvbGUud2FybihbXCJQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZ1wiLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgYFxuXG5gLCAnRGlzYWJsZSB0aGUgXCJjb21wdXRlU3R5bGVzXCIgbW9kaWZpZXJcXCdzIGBhZGFwdGl2ZWAgb3B0aW9uIHRvIGFsbG93JywgXCJmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1NcIiwgXCJ0cmFuc2l0aW9uIGRlY2xhcmF0aW9uIG9uIHRoZSBwb3BwZXIgZWxlbWVudCBpZiBvbmx5IHRyYW5zaXRpb25pbmdcIiwgXCJvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuXCIsIGBcblxuYCwgXCJXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXJcIiwgXCJlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuXCJdLmpvaW4oXCIgXCIpKTtcbiAgfVxuICB2YXIgZCA9IHtcbiAgICBwbGFjZW1lbnQ6IGd0KHQucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IEJlKHQucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHQuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHQucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogbixcbiAgICBpc0ZpeGVkOiB0Lm9wdGlvbnMuc3RyYXRlZ3kgPT09IFwiZml4ZWRcIlxuICB9O1xuICB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsICYmICh0LnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0LnN0eWxlcy5wb3BwZXIsIEFvKE9iamVjdC5hc3NpZ24oe30sIGQsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICBwb3NpdGlvbjogdC5vcHRpb25zLnN0cmF0ZWd5LFxuICAgIGFkYXB0aXZlOiByLFxuICAgIHJvdW5kT2Zmc2V0czogbFxuICB9KSkpKSwgdC5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwgJiYgKHQuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgdC5zdHlsZXMuYXJyb3csIEFvKE9iamVjdC5hc3NpZ24oe30sIGQsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBhZGFwdGl2ZTogITEsXG4gICAgcm91bmRPZmZzZXRzOiBsXG4gIH0pKSkpLCB0LmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgIFwiZGF0YS1wb3BwZXItcGxhY2VtZW50XCI6IHQucGxhY2VtZW50XG4gIH0pO1xufVxuY29uc3QgZW8gPSB7XG4gIG5hbWU6IFwiY29tcHV0ZVN0eWxlc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwiYmVmb3JlV3JpdGVcIixcbiAgZm46IENjLFxuICBkYXRhOiB7fVxufTtcbnZhciBEaSA9IHtcbiAgcGFzc2l2ZTogITBcbn07XG5mdW5jdGlvbiBBYyhzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMuaW5zdGFuY2UsIGkgPSBzLm9wdGlvbnMsIG4gPSBpLnNjcm9sbCwgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgciA9IGkucmVzaXplLCBhID0gciA9PT0gdm9pZCAwID8gITAgOiByLCBsID0gdXQodC5lbGVtZW50cy5wb3BwZXIpLCBjID0gW10uY29uY2F0KHQuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHQuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuICByZXR1cm4gbyAmJiBjLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgIGQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBlLnVwZGF0ZSwgRGkpO1xuICB9KSwgYSAmJiBsLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZS51cGRhdGUsIERpKSwgZnVuY3Rpb24oKSB7XG4gICAgbyAmJiBjLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgZC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGUudXBkYXRlLCBEaSk7XG4gICAgfSksIGEgJiYgbC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGUudXBkYXRlLCBEaSk7XG4gIH07XG59XG5jb25zdCBpbyA9IHtcbiAgbmFtZTogXCJldmVudExpc3RlbmVyc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwid3JpdGVcIixcbiAgZm46IGZ1bmN0aW9uKCkge1xuICB9LFxuICBlZmZlY3Q6IEFjLFxuICBkYXRhOiB7fVxufTtcbnZhciB5YyA9IHtcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCIsXG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiXG59O1xuZnVuY3Rpb24gc3Mocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB5Y1t0XTtcbiAgfSk7XG59XG52YXIgd2MgPSB7XG4gIHN0YXJ0OiBcImVuZFwiLFxuICBlbmQ6IFwic3RhcnRcIlxufTtcbmZ1bmN0aW9uIHlvKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gd2NbdF07XG4gIH0pO1xufVxuZnVuY3Rpb24gc28ocykge1xuICB2YXIgdCA9IHV0KHMpLCBlID0gdC5wYWdlWE9mZnNldCwgaSA9IHQucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZSxcbiAgICBzY3JvbGxUb3A6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vKHMpIHtcbiAgcmV0dXJuIEhlKHF0KHMpKS5sZWZ0ICsgc28ocykuc2Nyb2xsTGVmdDtcbn1cbmZ1bmN0aW9uIGtjKHMsIHQpIHtcbiAgdmFyIGUgPSB1dChzKSwgaSA9IHF0KHMpLCBuID0gZS52aXN1YWxWaWV3cG9ydCwgbyA9IGkuY2xpZW50V2lkdGgsIHIgPSBpLmNsaWVudEhlaWdodCwgYSA9IDAsIGwgPSAwO1xuICBpZiAobikge1xuICAgIG8gPSBuLndpZHRoLCByID0gbi5oZWlnaHQ7XG4gICAgdmFyIGMgPSBqYSgpO1xuICAgIChjIHx8ICFjICYmIHQgPT09IFwiZml4ZWRcIikgJiYgKGEgPSBuLm9mZnNldExlZnQsIGwgPSBuLm9mZnNldFRvcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbyxcbiAgICBoZWlnaHQ6IHIsXG4gICAgeDogYSArIG5vKHMpLFxuICAgIHk6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIE9jKHMpIHtcbiAgdmFyIHQsIGUgPSBxdChzKSwgaSA9IHNvKHMpLCBuID0gKHQgPSBzLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiB0LmJvZHksIG8gPSBwZShlLnNjcm9sbFdpZHRoLCBlLmNsaWVudFdpZHRoLCBuID8gbi5zY3JvbGxXaWR0aCA6IDAsIG4gPyBuLmNsaWVudFdpZHRoIDogMCksIHIgPSBwZShlLnNjcm9sbEhlaWdodCwgZS5jbGllbnRIZWlnaHQsIG4gPyBuLnNjcm9sbEhlaWdodCA6IDAsIG4gPyBuLmNsaWVudEhlaWdodCA6IDApLCBhID0gLWkuc2Nyb2xsTGVmdCArIG5vKHMpLCBsID0gLWkuc2Nyb2xsVG9wO1xuICByZXR1cm4gYnQobiB8fCBlKS5kaXJlY3Rpb24gPT09IFwicnRsXCIgJiYgKGEgKz0gcGUoZS5jbGllbnRXaWR0aCwgbiA/IG4uY2xpZW50V2lkdGggOiAwKSAtIG8pLCB7XG4gICAgd2lkdGg6IG8sXG4gICAgaGVpZ2h0OiByLFxuICAgIHg6IGEsXG4gICAgeTogbFxuICB9O1xufVxuZnVuY3Rpb24gb28ocykge1xuICB2YXIgdCA9IGJ0KHMpLCBlID0gdC5vdmVyZmxvdywgaSA9IHQub3ZlcmZsb3dYLCBuID0gdC5vdmVyZmxvd1k7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3QoZSArIG4gKyBpKTtcbn1cbmZ1bmN0aW9uIHFhKHMpIHtcbiAgcmV0dXJuIFtcImh0bWxcIiwgXCJib2R5XCIsIFwiI2RvY3VtZW50XCJdLmluZGV4T2YoSXQocykpID49IDAgPyBzLm93bmVyRG9jdW1lbnQuYm9keSA6IGN0KHMpICYmIG9vKHMpID8gcyA6IHFhKHdzKHMpKTtcbn1cbmZ1bmN0aW9uIGNpKHMsIHQpIHtcbiAgdmFyIGU7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IFtdKTtcbiAgdmFyIGkgPSBxYShzKSwgbiA9IGkgPT09ICgoZSA9IHMub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGUuYm9keSksIG8gPSB1dChpKSwgciA9IG4gPyBbb10uY29uY2F0KG8udmlzdWFsVmlld3BvcnQgfHwgW10sIG9vKGkpID8gaSA6IFtdKSA6IGksIGEgPSB0LmNvbmNhdChyKTtcbiAgcmV0dXJuIG4gPyBhIDogKFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICAgIGEuY29uY2F0KGNpKHdzKHIpKSlcbiAgKTtcbn1cbmZ1bmN0aW9uIE1uKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHMsIHtcbiAgICBsZWZ0OiBzLngsXG4gICAgdG9wOiBzLnksXG4gICAgcmlnaHQ6IHMueCArIHMud2lkdGgsXG4gICAgYm90dG9tOiBzLnkgKyBzLmhlaWdodFxuICB9KTtcbn1cbmZ1bmN0aW9uIHhjKHMsIHQpIHtcbiAgdmFyIGUgPSBIZShzLCAhMSwgdCA9PT0gXCJmaXhlZFwiKTtcbiAgcmV0dXJuIGUudG9wID0gZS50b3AgKyBzLmNsaWVudFRvcCwgZS5sZWZ0ID0gZS5sZWZ0ICsgcy5jbGllbnRMZWZ0LCBlLmJvdHRvbSA9IGUudG9wICsgcy5jbGllbnRIZWlnaHQsIGUucmlnaHQgPSBlLmxlZnQgKyBzLmNsaWVudFdpZHRoLCBlLndpZHRoID0gcy5jbGllbnRXaWR0aCwgZS5oZWlnaHQgPSBzLmNsaWVudEhlaWdodCwgZS54ID0gZS5sZWZ0LCBlLnkgPSBlLnRvcCwgZTtcbn1cbmZ1bmN0aW9uIHdvKHMsIHQsIGUpIHtcbiAgcmV0dXJuIHQgPT09IEduID8gTW4oa2MocywgZSkpIDogbWUodCkgPyB4Yyh0LCBlKSA6IE1uKE9jKHF0KHMpKSk7XG59XG5mdW5jdGlvbiBTYyhzKSB7XG4gIHZhciB0ID0gY2kod3MocykpLCBlID0gW1wiYWJzb2x1dGVcIiwgXCJmaXhlZFwiXS5pbmRleE9mKGJ0KHMpLnBvc2l0aW9uKSA+PSAwLCBpID0gZSAmJiBjdChzKSA/IGdpKHMpIDogcztcbiAgcmV0dXJuIG1lKGkpID8gdC5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgIHJldHVybiBtZShuKSAmJiBLYShuLCBpKSAmJiBJdChuKSAhPT0gXCJib2R5XCI7XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiBEYyhzLCB0LCBlLCBpKSB7XG4gIHZhciBuID0gdCA9PT0gXCJjbGlwcGluZ1BhcmVudHNcIiA/IFNjKHMpIDogW10uY29uY2F0KHQpLCBvID0gW10uY29uY2F0KG4sIFtlXSksIHIgPSBvWzBdLCBhID0gby5yZWR1Y2UoZnVuY3Rpb24obCwgYykge1xuICAgIHZhciBkID0gd28ocywgYywgaSk7XG4gICAgcmV0dXJuIGwudG9wID0gcGUoZC50b3AsIGwudG9wKSwgbC5yaWdodCA9IFRzKGQucmlnaHQsIGwucmlnaHQpLCBsLmJvdHRvbSA9IFRzKGQuYm90dG9tLCBsLmJvdHRvbSksIGwubGVmdCA9IHBlKGQubGVmdCwgbC5sZWZ0KSwgbDtcbiAgfSwgd28ocywgciwgaSkpO1xuICByZXR1cm4gYS53aWR0aCA9IGEucmlnaHQgLSBhLmxlZnQsIGEuaGVpZ2h0ID0gYS5ib3R0b20gLSBhLnRvcCwgYS54ID0gYS5sZWZ0LCBhLnkgPSBhLnRvcCwgYTtcbn1cbmZ1bmN0aW9uIFFhKHMpIHtcbiAgdmFyIHQgPSBzLnJlZmVyZW5jZSwgZSA9IHMuZWxlbWVudCwgaSA9IHMucGxhY2VtZW50LCBuID0gaSA/IGd0KGkpIDogbnVsbCwgbyA9IGkgPyBCZShpKSA6IG51bGwsIHIgPSB0LnggKyB0LndpZHRoIC8gMiAtIGUud2lkdGggLyAyLCBhID0gdC55ICsgdC5oZWlnaHQgLyAyIC0gZS5oZWlnaHQgLyAyLCBsO1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIFo6XG4gICAgICBsID0ge1xuICAgICAgICB4OiByLFxuICAgICAgICB5OiB0LnkgLSBlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZHQ6XG4gICAgICBsID0ge1xuICAgICAgICB4OiByLFxuICAgICAgICB5OiB0LnkgKyB0LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaHQ6XG4gICAgICBsID0ge1xuICAgICAgICB4OiB0LnggKyB0LndpZHRoLFxuICAgICAgICB5OiBhXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBKOlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54IC0gZS53aWR0aCxcbiAgICAgICAgeTogYVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsID0ge1xuICAgICAgICB4OiB0LngsXG4gICAgICAgIHk6IHQueVxuICAgICAgfTtcbiAgfVxuICB2YXIgYyA9IG4gPyB0byhuKSA6IG51bGw7XG4gIGlmIChjICE9IG51bGwpIHtcbiAgICB2YXIgZCA9IGMgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgICBzd2l0Y2ggKG8pIHtcbiAgICAgIGNhc2UgX2U6XG4gICAgICAgIGxbY10gPSBsW2NdIC0gKHRbZF0gLyAyIC0gZVtkXSAvIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUmU6XG4gICAgICAgIGxbY10gPSBsW2NdICsgKHRbZF0gLyAyIC0gZVtkXSAvIDIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5mdW5jdGlvbiBWZShzLCB0KSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IHt9KTtcbiAgdmFyIGUgPSB0LCBpID0gZS5wbGFjZW1lbnQsIG4gPSBpID09PSB2b2lkIDAgPyBzLnBsYWNlbWVudCA6IGksIG8gPSBlLnN0cmF0ZWd5LCByID0gbyA9PT0gdm9pZCAwID8gcy5zdHJhdGVneSA6IG8sIGEgPSBlLmJvdW5kYXJ5LCBsID0gYSA9PT0gdm9pZCAwID8gTGEgOiBhLCBjID0gZS5yb290Qm91bmRhcnksIGQgPSBjID09PSB2b2lkIDAgPyBHbiA6IGMsIF8gPSBlLmVsZW1lbnRDb250ZXh0LCBmID0gXyA9PT0gdm9pZCAwID8geWUgOiBfLCBtID0gZS5hbHRCb3VuZGFyeSwgZyA9IG0gPT09IHZvaWQgMCA/ICExIDogbSwgYiA9IGUucGFkZGluZywgVCA9IGIgPT09IHZvaWQgMCA/IDAgOiBiLCBDID0gemEodHlwZW9mIFQgIT0gXCJudW1iZXJcIiA/IFQgOiBYYShULCBZZSkpLCB3ID0gZiA9PT0geWUgPyBNYSA6IHllLCB2ID0gcy5yZWN0cy5wb3BwZXIsIEUgPSBzLmVsZW1lbnRzW2cgPyB3IDogZl0sIEEgPSBEYyhtZShFKSA/IEUgOiBFLmNvbnRleHRFbGVtZW50IHx8IHF0KHMuZWxlbWVudHMucG9wcGVyKSwgbCwgZCwgciksIHkgPSBIZShzLmVsZW1lbnRzLnJlZmVyZW5jZSksIFMgPSBRYSh7XG4gICAgcmVmZXJlbmNlOiB5LFxuICAgIGVsZW1lbnQ6IHYsXG4gICAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIixcbiAgICBwbGFjZW1lbnQ6IG5cbiAgfSksIE8gPSBNbihPYmplY3QuYXNzaWduKHt9LCB2LCBTKSksIGsgPSBmID09PSB5ZSA/IE8gOiB5LCBEID0ge1xuICAgIHRvcDogQS50b3AgLSBrLnRvcCArIEMudG9wLFxuICAgIGJvdHRvbTogay5ib3R0b20gLSBBLmJvdHRvbSArIEMuYm90dG9tLFxuICAgIGxlZnQ6IEEubGVmdCAtIGsubGVmdCArIEMubGVmdCxcbiAgICByaWdodDogay5yaWdodCAtIEEucmlnaHQgKyBDLnJpZ2h0XG4gIH0sIHggPSBzLm1vZGlmaWVyc0RhdGEub2Zmc2V0O1xuICBpZiAoZiA9PT0geWUgJiYgeCkge1xuICAgIHZhciAkID0geFtuXTtcbiAgICBPYmplY3Qua2V5cyhEKS5mb3JFYWNoKGZ1bmN0aW9uKFApIHtcbiAgICAgIHZhciB0dCA9IFtodCwgZHRdLmluZGV4T2YoUCkgPj0gMCA/IDEgOiAtMSwgZXQgPSBbWiwgZHRdLmluZGV4T2YoUCkgPj0gMCA/IFwieVwiIDogXCJ4XCI7XG4gICAgICBEW1BdICs9ICRbZXRdICogdHQ7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIEQ7XG59XG5mdW5jdGlvbiBJYyhzLCB0KSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IHt9KTtcbiAgdmFyIGUgPSB0LCBpID0gZS5wbGFjZW1lbnQsIG4gPSBlLmJvdW5kYXJ5LCBvID0gZS5yb290Qm91bmRhcnksIHIgPSBlLnBhZGRpbmcsIGEgPSBlLmZsaXBWYXJpYXRpb25zLCBsID0gZS5hbGxvd2VkQXV0b1BsYWNlbWVudHMsIGMgPSBsID09PSB2b2lkIDAgPyBxbiA6IGwsIGQgPSBCZShpKSwgXyA9IGQgPyBhID8gJG4gOiAkbi5maWx0ZXIoZnVuY3Rpb24oZykge1xuICAgIHJldHVybiBCZShnKSA9PT0gZDtcbiAgfSkgOiBZZSwgZiA9IF8uZmlsdGVyKGZ1bmN0aW9uKGcpIHtcbiAgICByZXR1cm4gYy5pbmRleE9mKGcpID49IDA7XG4gIH0pO1xuICBmLmxlbmd0aCA9PT0gMCAmJiAoZiA9IF8sIHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFtcIlBvcHBlcjogVGhlIGBhbGxvd2VkQXV0b1BsYWNlbWVudHNgIG9wdGlvbiBkaWQgbm90IGFsbG93IGFueVwiLCBcInBsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvblwiLCBcIm9mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuXCIsICdGb3IgZXhhbXBsZSwgXCJhdXRvXCIgY2Fubm90IGJlIHVzZWQgdG8gYWxsb3cgXCJib3R0b20tc3RhcnRcIi4nLCAnVXNlIFwiYXV0by1zdGFydFwiIGluc3RlYWQuJ10uam9pbihcIiBcIikpKTtcbiAgdmFyIG0gPSBmLnJlZHVjZShmdW5jdGlvbihnLCBiKSB7XG4gICAgcmV0dXJuIGdbYl0gPSBWZShzLCB7XG4gICAgICBwbGFjZW1lbnQ6IGIsXG4gICAgICBib3VuZGFyeTogbixcbiAgICAgIHJvb3RCb3VuZGFyeTogbyxcbiAgICAgIHBhZGRpbmc6IHJcbiAgICB9KVtndChiKV0sIGc7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG0pLnNvcnQoZnVuY3Rpb24oZywgYikge1xuICAgIHJldHVybiBtW2ddIC0gbVtiXTtcbiAgfSk7XG59XG5mdW5jdGlvbiAkYyhzKSB7XG4gIGlmIChndChzKSA9PT0gbWkpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgdCA9IHNzKHMpO1xuICByZXR1cm4gW3lvKHMpLCB0LCB5byh0KV07XG59XG5mdW5jdGlvbiBMYyhzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IHMubmFtZTtcbiAgaWYgKCF0Lm1vZGlmaWVyc0RhdGFbaV0uX3NraXApIHtcbiAgICBmb3IgKHZhciBuID0gZS5tYWluQXhpcywgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgciA9IGUuYWx0QXhpcywgYSA9IHIgPT09IHZvaWQgMCA/ICEwIDogciwgbCA9IGUuZmFsbGJhY2tQbGFjZW1lbnRzLCBjID0gZS5wYWRkaW5nLCBkID0gZS5ib3VuZGFyeSwgXyA9IGUucm9vdEJvdW5kYXJ5LCBmID0gZS5hbHRCb3VuZGFyeSwgbSA9IGUuZmxpcFZhcmlhdGlvbnMsIGcgPSBtID09PSB2b2lkIDAgPyAhMCA6IG0sIGIgPSBlLmFsbG93ZWRBdXRvUGxhY2VtZW50cywgVCA9IHQub3B0aW9ucy5wbGFjZW1lbnQsIEMgPSBndChUKSwgdyA9IEMgPT09IFQsIHYgPSBsIHx8ICh3IHx8ICFnID8gW3NzKFQpXSA6ICRjKFQpKSwgRSA9IFtUXS5jb25jYXQodikucmVkdWNlKGZ1bmN0aW9uKGJlLCBOdCkge1xuICAgICAgcmV0dXJuIGJlLmNvbmNhdChndChOdCkgPT09IG1pID8gSWModCwge1xuICAgICAgICBwbGFjZW1lbnQ6IE50LFxuICAgICAgICBib3VuZGFyeTogZCxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiBfLFxuICAgICAgICBwYWRkaW5nOiBjLFxuICAgICAgICBmbGlwVmFyaWF0aW9uczogZyxcbiAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBiXG4gICAgICB9KSA6IE50KTtcbiAgICB9LCBbXSksIEEgPSB0LnJlY3RzLnJlZmVyZW5jZSwgeSA9IHQucmVjdHMucG9wcGVyLCBTID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgTyA9ICEwLCBrID0gRVswXSwgRCA9IDA7IEQgPCBFLmxlbmd0aDsgRCsrKSB7XG4gICAgICB2YXIgeCA9IEVbRF0sICQgPSBndCh4KSwgUCA9IEJlKHgpID09PSBfZSwgdHQgPSBbWiwgZHRdLmluZGV4T2YoJCkgPj0gMCwgZXQgPSB0dCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIsIHogPSBWZSh0LCB7XG4gICAgICAgIHBsYWNlbWVudDogeCxcbiAgICAgICAgYm91bmRhcnk6IGQsXG4gICAgICAgIHJvb3RCb3VuZGFyeTogXyxcbiAgICAgICAgYWx0Qm91bmRhcnk6IGYsXG4gICAgICAgIHBhZGRpbmc6IGNcbiAgICAgIH0pLCBfdCA9IHR0ID8gUCA/IGh0IDogSiA6IFAgPyBkdCA6IFo7XG4gICAgICBBW2V0XSA+IHlbZXRdICYmIChfdCA9IHNzKF90KSk7XG4gICAgICB2YXIgd2kgPSBzcyhfdCksIFp0ID0gW107XG4gICAgICBpZiAobyAmJiBadC5wdXNoKHpbJF0gPD0gMCksIGEgJiYgWnQucHVzaCh6W190XSA8PSAwLCB6W3dpXSA8PSAwKSwgWnQuZXZlcnkoZnVuY3Rpb24oYmUpIHtcbiAgICAgICAgcmV0dXJuIGJlO1xuICAgICAgfSkpIHtcbiAgICAgICAgayA9IHgsIE8gPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBTLnNldCh4LCBadCk7XG4gICAgfVxuICAgIGlmIChPKVxuICAgICAgZm9yICh2YXIga2kgPSBnID8gMyA6IDEsIE5zID0gZnVuY3Rpb24oTnQpIHtcbiAgICAgICAgdmFyIFhlID0gRS5maW5kKGZ1bmN0aW9uKHhpKSB7XG4gICAgICAgICAgdmFyIEp0ID0gUy5nZXQoeGkpO1xuICAgICAgICAgIGlmIChKdClcbiAgICAgICAgICAgIHJldHVybiBKdC5zbGljZSgwLCBOdCkuZXZlcnkoZnVuY3Rpb24oUnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFJzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoWGUpXG4gICAgICAgICAgcmV0dXJuIGsgPSBYZSwgXCJicmVha1wiO1xuICAgICAgfSwgemUgPSBraTsgemUgPiAwOyB6ZS0tKSB7XG4gICAgICAgIHZhciBPaSA9IE5zKHplKTtcbiAgICAgICAgaWYgKE9pID09PSBcImJyZWFrXCIpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgdC5wbGFjZW1lbnQgIT09IGsgJiYgKHQubW9kaWZpZXJzRGF0YVtpXS5fc2tpcCA9ICEwLCB0LnBsYWNlbWVudCA9IGssIHQucmVzZXQgPSAhMCk7XG4gIH1cbn1cbmNvbnN0IFphID0ge1xuICBuYW1lOiBcImZsaXBcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IExjLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJvZmZzZXRcIl0sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogITFcbiAgfVxufTtcbmZ1bmN0aW9uIGtvKHMsIHQsIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSksIHtcbiAgICB0b3A6IHMudG9wIC0gdC5oZWlnaHQgLSBlLnksXG4gICAgcmlnaHQ6IHMucmlnaHQgLSB0LndpZHRoICsgZS54LFxuICAgIGJvdHRvbTogcy5ib3R0b20gLSB0LmhlaWdodCArIGUueSxcbiAgICBsZWZ0OiBzLmxlZnQgLSB0LndpZHRoIC0gZS54XG4gIH07XG59XG5mdW5jdGlvbiBPbyhzKSB7XG4gIHJldHVybiBbWiwgaHQsIGR0LCBKXS5zb21lKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gc1t0XSA+PSAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIE1jKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5uYW1lLCBpID0gdC5yZWN0cy5yZWZlcmVuY2UsIG4gPSB0LnJlY3RzLnBvcHBlciwgbyA9IHQubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3csIHIgPSBWZSh0LCB7XG4gICAgZWxlbWVudENvbnRleHQ6IFwicmVmZXJlbmNlXCJcbiAgfSksIGEgPSBWZSh0LCB7XG4gICAgYWx0Qm91bmRhcnk6ICEwXG4gIH0pLCBsID0ga28ociwgaSksIGMgPSBrbyhhLCBuLCBvKSwgZCA9IE9vKGwpLCBfID0gT28oYyk7XG4gIHQubW9kaWZpZXJzRGF0YVtlXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IGwsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogYyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogZCxcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBfXG4gIH0sIHQuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0LmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgXCJkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuXCI6IGQsXG4gICAgXCJkYXRhLXBvcHBlci1lc2NhcGVkXCI6IF9cbiAgfSk7XG59XG5jb25zdCBKYSA9IHtcbiAgbmFtZTogXCJoaWRlXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcInByZXZlbnRPdmVyZmxvd1wiXSxcbiAgZm46IE1jXG59O1xuZnVuY3Rpb24gTmMocywgdCwgZSkge1xuICB2YXIgaSA9IGd0KHMpLCBuID0gW0osIFpdLmluZGV4T2YoaSkgPj0gMCA/IC0xIDogMSwgbyA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUoT2JqZWN0LmFzc2lnbih7fSwgdCwge1xuICAgIHBsYWNlbWVudDogc1xuICB9KSkgOiBlLCByID0gb1swXSwgYSA9IG9bMV07XG4gIHJldHVybiByID0gciB8fCAwLCBhID0gKGEgfHwgMCkgKiBuLCBbSiwgaHRdLmluZGV4T2YoaSkgPj0gMCA/IHtcbiAgICB4OiBhLFxuICAgIHk6IHJcbiAgfSA6IHtcbiAgICB4OiByLFxuICAgIHk6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIFJjKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5vcHRpb25zLCBpID0gcy5uYW1lLCBuID0gZS5vZmZzZXQsIG8gPSBuID09PSB2b2lkIDAgPyBbMCwgMF0gOiBuLCByID0gcW4ucmVkdWNlKGZ1bmN0aW9uKGQsIF8pIHtcbiAgICByZXR1cm4gZFtfXSA9IE5jKF8sIHQucmVjdHMsIG8pLCBkO1xuICB9LCB7fSksIGEgPSByW3QucGxhY2VtZW50XSwgbCA9IGEueCwgYyA9IGEueTtcbiAgdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCAmJiAodC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSBsLCB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IGMpLCB0Lm1vZGlmaWVyc0RhdGFbaV0gPSByO1xufVxuY29uc3QgdGwgPSB7XG4gIG5hbWU6IFwib2Zmc2V0XCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIHJlcXVpcmVzOiBbXCJwb3BwZXJPZmZzZXRzXCJdLFxuICBmbjogUmNcbn07XG5mdW5jdGlvbiBQYyhzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMubmFtZTtcbiAgdC5tb2RpZmllcnNEYXRhW2VdID0gUWEoe1xuICAgIHJlZmVyZW5jZTogdC5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogdC5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIixcbiAgICBwbGFjZW1lbnQ6IHQucGxhY2VtZW50XG4gIH0pO1xufVxuY29uc3Qgcm8gPSB7XG4gIG5hbWU6IFwicG9wcGVyT2Zmc2V0c1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwicmVhZFwiLFxuICBmbjogUGMsXG4gIGRhdGE6IHt9XG59O1xuZnVuY3Rpb24gSGMocykge1xuICByZXR1cm4gcyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiO1xufVxuZnVuY3Rpb24gQmMocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBzLm5hbWUsIG4gPSBlLm1haW5BeGlzLCBvID0gbiA9PT0gdm9pZCAwID8gITAgOiBuLCByID0gZS5hbHRBeGlzLCBhID0gciA9PT0gdm9pZCAwID8gITEgOiByLCBsID0gZS5ib3VuZGFyeSwgYyA9IGUucm9vdEJvdW5kYXJ5LCBkID0gZS5hbHRCb3VuZGFyeSwgXyA9IGUucGFkZGluZywgZiA9IGUudGV0aGVyLCBtID0gZiA9PT0gdm9pZCAwID8gITAgOiBmLCBnID0gZS50ZXRoZXJPZmZzZXQsIGIgPSBnID09PSB2b2lkIDAgPyAwIDogZywgVCA9IFZlKHQsIHtcbiAgICBib3VuZGFyeTogbCxcbiAgICByb290Qm91bmRhcnk6IGMsXG4gICAgcGFkZGluZzogXyxcbiAgICBhbHRCb3VuZGFyeTogZFxuICB9KSwgQyA9IGd0KHQucGxhY2VtZW50KSwgdyA9IEJlKHQucGxhY2VtZW50KSwgdiA9ICF3LCBFID0gdG8oQyksIEEgPSBIYyhFKSwgeSA9IHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLCBTID0gdC5yZWN0cy5yZWZlcmVuY2UsIE8gPSB0LnJlY3RzLnBvcHBlciwgayA9IHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIiA/IGIoT2JqZWN0LmFzc2lnbih7fSwgdC5yZWN0cywge1xuICAgIHBsYWNlbWVudDogdC5wbGFjZW1lbnRcbiAgfSkpIDogYiwgRCA9IHR5cGVvZiBrID09IFwibnVtYmVyXCIgPyB7XG4gICAgbWFpbkF4aXM6IGssXG4gICAgYWx0QXhpczoga1xuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCBrKSwgeCA9IHQubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyB0Lm1vZGlmaWVyc0RhdGEub2Zmc2V0W3QucGxhY2VtZW50XSA6IG51bGwsICQgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGlmICh5KSB7XG4gICAgaWYgKG8pIHtcbiAgICAgIHZhciBQLCB0dCA9IEUgPT09IFwieVwiID8gWiA6IEosIGV0ID0gRSA9PT0gXCJ5XCIgPyBkdCA6IGh0LCB6ID0gRSA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLCBfdCA9IHlbRV0sIHdpID0gX3QgKyBUW3R0XSwgWnQgPSBfdCAtIFRbZXRdLCBraSA9IG0gPyAtT1t6XSAvIDIgOiAwLCBOcyA9IHcgPT09IF9lID8gU1t6XSA6IE9bel0sIHplID0gdyA9PT0gX2UgPyAtT1t6XSA6IC1TW3pdLCBPaSA9IHQuZWxlbWVudHMuYXJyb3csIGJlID0gbSAmJiBPaSA/IEpuKE9pKSA6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSwgTnQgPSB0Lm1vZGlmaWVyc0RhdGFbXCJhcnJvdyNwZXJzaXN0ZW50XCJdID8gdC5tb2RpZmllcnNEYXRhW1wiYXJyb3cjcGVyc2lzdGVudFwiXS5wYWRkaW5nIDogVWEoKSwgWGUgPSBOdFt0dF0sIHhpID0gTnRbZXRdLCBKdCA9IGxpKDAsIFNbel0sIGJlW3pdKSwgUnMgPSB2ID8gU1t6XSAvIDIgLSBraSAtIEp0IC0gWGUgLSBELm1haW5BeGlzIDogTnMgLSBKdCAtIFhlIC0gRC5tYWluQXhpcywgRmwgPSB2ID8gLVNbel0gLyAyICsga2kgKyBKdCArIHhpICsgRC5tYWluQXhpcyA6IHplICsgSnQgKyB4aSArIEQubWFpbkF4aXMsIFBzID0gdC5lbGVtZW50cy5hcnJvdyAmJiBnaSh0LmVsZW1lbnRzLmFycm93KSwgWWwgPSBQcyA/IEUgPT09IFwieVwiID8gUHMuY2xpZW50VG9wIHx8IDAgOiBQcy5jbGllbnRMZWZ0IHx8IDAgOiAwLCBobyA9IChQID0geCA9PSBudWxsID8gdm9pZCAwIDogeFtFXSkgIT0gbnVsbCA/IFAgOiAwLCBqbCA9IF90ICsgUnMgLSBobyAtIFlsLCBLbCA9IF90ICsgRmwgLSBobywgdW8gPSBsaShtID8gVHMod2ksIGpsKSA6IHdpLCBfdCwgbSA/IHBlKFp0LCBLbCkgOiBadCk7XG4gICAgICB5W0VdID0gdW8sICRbRV0gPSB1byAtIF90O1xuICAgIH1cbiAgICBpZiAoYSkge1xuICAgICAgdmFyIHBvLCBVbCA9IEUgPT09IFwieFwiID8gWiA6IEosIHpsID0gRSA9PT0gXCJ4XCIgPyBkdCA6IGh0LCB0ZSA9IHlbQV0sIFNpID0gQSA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLCBmbyA9IHRlICsgVFtVbF0sIF9vID0gdGUgLSBUW3psXSwgSHMgPSBbWiwgSl0uaW5kZXhPZihDKSAhPT0gLTEsIG1vID0gKHBvID0geCA9PSBudWxsID8gdm9pZCAwIDogeFtBXSkgIT0gbnVsbCA/IHBvIDogMCwgZ28gPSBIcyA/IGZvIDogdGUgLSBTW1NpXSAtIE9bU2ldIC0gbW8gKyBELmFsdEF4aXMsIGJvID0gSHMgPyB0ZSArIFNbU2ldICsgT1tTaV0gLSBtbyAtIEQuYWx0QXhpcyA6IF9vLCB2byA9IG0gJiYgSHMgPyBtYyhnbywgdGUsIGJvKSA6IGxpKG0gPyBnbyA6IGZvLCB0ZSwgbSA/IGJvIDogX28pO1xuICAgICAgeVtBXSA9IHZvLCAkW0FdID0gdm8gLSB0ZTtcbiAgICB9XG4gICAgdC5tb2RpZmllcnNEYXRhW2ldID0gJDtcbiAgfVxufVxuY29uc3QgZWwgPSB7XG4gIG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIGZuOiBCYyxcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wib2Zmc2V0XCJdXG59O1xuZnVuY3Rpb24gVmMocykge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHMuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHMuc2Nyb2xsVG9wXG4gIH07XG59XG5mdW5jdGlvbiBXYyhzKSB7XG4gIHJldHVybiBzID09PSB1dChzKSB8fCAhY3QocykgPyBzbyhzKSA6IFZjKHMpO1xufVxuZnVuY3Rpb24gRmMocykge1xuICB2YXIgdCA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGUgPSBQZSh0LndpZHRoKSAvIHMub2Zmc2V0V2lkdGggfHwgMSwgaSA9IFBlKHQuaGVpZ2h0KSAvIHMub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBlICE9PSAxIHx8IGkgIT09IDE7XG59XG5mdW5jdGlvbiBZYyhzLCB0LCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9ICExKTtcbiAgdmFyIGkgPSBjdCh0KSwgbiA9IGN0KHQpICYmIEZjKHQpLCBvID0gcXQodCksIHIgPSBIZShzLCBuLCBlKSwgYSA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9LCBsID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICByZXR1cm4gKGkgfHwgIWkgJiYgIWUpICYmICgoSXQodCkgIT09IFwiYm9keVwiIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICBvbyhvKSkgJiYgKGEgPSBXYyh0KSksIGN0KHQpID8gKGwgPSBIZSh0LCAhMCksIGwueCArPSB0LmNsaWVudExlZnQsIGwueSArPSB0LmNsaWVudFRvcCkgOiBvICYmIChsLnggPSBubyhvKSkpLCB7XG4gICAgeDogci5sZWZ0ICsgYS5zY3JvbGxMZWZ0IC0gbC54LFxuICAgIHk6IHIudG9wICsgYS5zY3JvbGxUb3AgLSBsLnksXG4gICAgd2lkdGg6IHIud2lkdGgsXG4gICAgaGVpZ2h0OiByLmhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gamMocykge1xuICB2YXIgdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBpID0gW107XG4gIHMuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgdC5zZXQoby5uYW1lLCBvKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIG4obykge1xuICAgIGUuYWRkKG8ubmFtZSk7XG4gICAgdmFyIHIgPSBbXS5jb25jYXQoby5yZXF1aXJlcyB8fCBbXSwgby5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgaWYgKCFlLmhhcyhhKSkge1xuICAgICAgICB2YXIgbCA9IHQuZ2V0KGEpO1xuICAgICAgICBsICYmIG4obCk7XG4gICAgICB9XG4gICAgfSksIGkucHVzaChvKTtcbiAgfVxuICByZXR1cm4gcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICBlLmhhcyhvLm5hbWUpIHx8IG4obyk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gS2Mocykge1xuICB2YXIgdCA9IGpjKHMpO1xuICByZXR1cm4gRXMucmVkdWNlKGZ1bmN0aW9uKGUsIGkpIHtcbiAgICByZXR1cm4gZS5jb25jYXQodC5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIG4ucGhhc2UgPT09IGk7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiBVYyhzKSB7XG4gIHZhciB0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQgfHwgKHQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihlKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICB0ID0gdm9pZCAwLCBlKHMoKSk7XG4gICAgICB9KTtcbiAgICB9KSksIHQ7XG4gIH07XG59XG5mdW5jdGlvbiBSdChzKSB7XG4gIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBlID0gbmV3IEFycmF5KHQgPiAxID8gdCAtIDEgOiAwKSwgaSA9IDE7IGkgPCB0OyBpKyspXG4gICAgZVtpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gIHJldHVybiBbXS5jb25jYXQoZSkucmVkdWNlKGZ1bmN0aW9uKG4sIG8pIHtcbiAgICByZXR1cm4gbi5yZXBsYWNlKC8lcy8sIG8pO1xuICB9LCBzKTtcbn1cbnZhciBpZSA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiBwcm92aWRlZCBhbiBpbnZhbGlkICVzIHByb3BlcnR5LCBleHBlY3RlZCAlcyBidXQgZ290ICVzJywgemMgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcmVxdWlyZXMgXCIlc1wiLCBidXQgXCIlc1wiIG1vZGlmaWVyIGlzIG5vdCBhdmFpbGFibGUnLCB4byA9IFtcIm5hbWVcIiwgXCJlbmFibGVkXCIsIFwicGhhc2VcIiwgXCJmblwiLCBcImVmZmVjdFwiLCBcInJlcXVpcmVzXCIsIFwib3B0aW9uc1wiXTtcbmZ1bmN0aW9uIFhjKHMpIHtcbiAgcy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICBbXS5jb25jYXQoT2JqZWN0LmtleXModCksIHhvKS5maWx0ZXIoZnVuY3Rpb24oZSwgaSwgbikge1xuICAgICAgcmV0dXJuIG4uaW5kZXhPZihlKSA9PT0gaTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgIHR5cGVvZiB0Lm5hbWUgIT0gXCJzdHJpbmdcIiAmJiBjb25zb2xlLmVycm9yKFJ0KGllLCBTdHJpbmcodC5uYW1lKSwgJ1wibmFtZVwiJywgJ1wic3RyaW5nXCInLCAnXCInICsgU3RyaW5nKHQubmFtZSkgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbmFibGVkXCI6XG4gICAgICAgICAgdHlwZW9mIHQuZW5hYmxlZCAhPSBcImJvb2xlYW5cIiAmJiBjb25zb2xlLmVycm9yKFJ0KGllLCB0Lm5hbWUsICdcImVuYWJsZWRcIicsICdcImJvb2xlYW5cIicsICdcIicgKyBTdHJpbmcodC5lbmFibGVkKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBoYXNlXCI6XG4gICAgICAgICAgRXMuaW5kZXhPZih0LnBoYXNlKSA8IDAgJiYgY29uc29sZS5lcnJvcihSdChpZSwgdC5uYW1lLCAnXCJwaGFzZVwiJywgXCJlaXRoZXIgXCIgKyBFcy5qb2luKFwiLCBcIiksICdcIicgKyBTdHJpbmcodC5waGFzZSkgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmblwiOlxuICAgICAgICAgIHR5cGVvZiB0LmZuICE9IFwiZnVuY3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFJ0KGllLCB0Lm5hbWUsICdcImZuXCInLCAnXCJmdW5jdGlvblwiJywgJ1wiJyArIFN0cmluZyh0LmZuKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVmZmVjdFwiOlxuICAgICAgICAgIHQuZWZmZWN0ICE9IG51bGwgJiYgdHlwZW9mIHQuZWZmZWN0ICE9IFwiZnVuY3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFJ0KGllLCB0Lm5hbWUsICdcImVmZmVjdFwiJywgJ1wiZnVuY3Rpb25cIicsICdcIicgKyBTdHJpbmcodC5mbikgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZXF1aXJlc1wiOlxuICAgICAgICAgIHQucmVxdWlyZXMgIT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh0LnJlcXVpcmVzKSAmJiBjb25zb2xlLmVycm9yKFJ0KGllLCB0Lm5hbWUsICdcInJlcXVpcmVzXCInLCAnXCJhcnJheVwiJywgJ1wiJyArIFN0cmluZyh0LnJlcXVpcmVzKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlcXVpcmVzSWZFeGlzdHNcIjpcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHQucmVxdWlyZXNJZkV4aXN0cykgfHwgY29uc29sZS5lcnJvcihSdChpZSwgdC5uYW1lLCAnXCJyZXF1aXJlc0lmRXhpc3RzXCInLCAnXCJhcnJheVwiJywgJ1wiJyArIFN0cmluZyh0LnJlcXVpcmVzSWZFeGlzdHMpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib3B0aW9uc1wiOlxuICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BvcHBlckpTOiBhbiBpbnZhbGlkIHByb3BlcnR5IGhhcyBiZWVuIHByb3ZpZGVkIHRvIHRoZSBcIicgKyB0Lm5hbWUgKyAnXCIgbW9kaWZpZXIsIHZhbGlkIHByb3BlcnRpZXMgYXJlICcgKyB4by5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgcmV0dXJuICdcIicgKyBpICsgJ1wiJztcbiAgICAgICAgICB9KS5qb2luKFwiLCBcIikgKyAnOyBidXQgXCInICsgZSArICdcIiB3YXMgcHJvdmlkZWQuJyk7XG4gICAgICB9XG4gICAgICB0LnJlcXVpcmVzICYmIHQucmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIHMuZmluZChmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG4ubmFtZSA9PT0gaTtcbiAgICAgICAgfSkgPT0gbnVsbCAmJiBjb25zb2xlLmVycm9yKFJ0KHpjLCBTdHJpbmcodC5uYW1lKSwgaSwgaSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gR2MocywgdCkge1xuICB2YXIgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHJldHVybiBzLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgdmFyIG4gPSB0KGkpO1xuICAgIGlmICghZS5oYXMobikpXG4gICAgICByZXR1cm4gZS5hZGQobiksICEwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHFjKHMpIHtcbiAgdmFyIHQgPSBzLnJlZHVjZShmdW5jdGlvbihlLCBpKSB7XG4gICAgdmFyIG4gPSBlW2kubmFtZV07XG4gICAgcmV0dXJuIGVbaS5uYW1lXSA9IG4gPyBPYmplY3QuYXNzaWduKHt9LCBuLCBpLCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBuLm9wdGlvbnMsIGkub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBuLmRhdGEsIGkuZGF0YSlcbiAgICB9KSA6IGksIGU7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLm1hcChmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRbZV07XG4gIH0pO1xufVxudmFyIFNvID0gXCJQb3BwZXI6IEludmFsaWQgcmVmZXJlbmNlIG9yIHBvcHBlciBhcmd1bWVudCBwcm92aWRlZC4gVGhleSBtdXN0IGJlIGVpdGhlciBhIERPTSBlbGVtZW50IG9yIHZpcnR1YWwgZWxlbWVudC5cIiwgUWMgPSBcIlBvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guXCIsIERvID0ge1xuICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiBcImFic29sdXRlXCJcbn07XG5mdW5jdGlvbiBJbygpIHtcbiAgZm9yICh2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkocyksIGUgPSAwOyBlIDwgczsgZSsrKVxuICAgIHRbZV0gPSBhcmd1bWVudHNbZV07XG4gIHJldHVybiAhdC5zb21lKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gIShpICYmIHR5cGVvZiBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PSBcImZ1bmN0aW9uXCIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGtzKHMpIHtcbiAgcyA9PT0gdm9pZCAwICYmIChzID0ge30pO1xuICB2YXIgdCA9IHMsIGUgPSB0LmRlZmF1bHRNb2RpZmllcnMsIGkgPSBlID09PSB2b2lkIDAgPyBbXSA6IGUsIG4gPSB0LmRlZmF1bHRPcHRpb25zLCBvID0gbiA9PT0gdm9pZCAwID8gRG8gOiBuO1xuICByZXR1cm4gZnVuY3Rpb24oYSwgbCwgYykge1xuICAgIGMgPT09IHZvaWQgMCAmJiAoYyA9IG8pO1xuICAgIHZhciBkID0ge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbVwiLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBEbywgbyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogYSxcbiAgICAgICAgcG9wcGVyOiBsXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfSwgXyA9IFtdLCBmID0gITEsIG0gPSB7XG4gICAgICBzdGF0ZTogZCxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKEMpIHtcbiAgICAgICAgdmFyIHcgPSB0eXBlb2YgQyA9PSBcImZ1bmN0aW9uXCIgPyBDKGQub3B0aW9ucykgOiBDO1xuICAgICAgICBiKCksIGQub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG8sIGQub3B0aW9ucywgdyksIGQuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IG1lKGEpID8gY2koYSkgOiBhLmNvbnRleHRFbGVtZW50ID8gY2koYS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGNpKGwpXG4gICAgICAgIH07XG4gICAgICAgIHZhciB2ID0gS2MocWMoW10uY29uY2F0KGksIGQub3B0aW9ucy5tb2RpZmllcnMpKSk7XG4gICAgICAgIGlmIChkLm9yZGVyZWRNb2RpZmllcnMgPSB2LmZpbHRlcihmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIHguZW5hYmxlZDtcbiAgICAgICAgfSksIHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBFID0gR2MoW10uY29uY2F0KHYsIGQub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICB2YXIgJCA9IHgubmFtZTtcbiAgICAgICAgICAgIHJldHVybiAkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChYYyhFKSwgZ3QoZC5vcHRpb25zLnBsYWNlbWVudCkgPT09IG1pKSB7XG4gICAgICAgICAgICB2YXIgQSA9IGQub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgdmFyICQgPSB4Lm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiAkID09PSBcImZsaXBcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgQSB8fCBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImF1dG9cIiBwbGFjZW1lbnRzIHJlcXVpcmUgdGhlIFwiZmxpcFwiIG1vZGlmaWVyIGJlJywgXCJwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuXCJdLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHkgPSBidChsKSwgUyA9IHkubWFyZ2luVG9wLCBPID0geS5tYXJnaW5SaWdodCwgayA9IHkubWFyZ2luQm90dG9tLCBEID0geS5tYXJnaW5MZWZ0O1xuICAgICAgICAgIFtTLCBPLCBrLCBEXS5zb21lKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHgpO1xuICAgICAgICAgIH0pICYmIGNvbnNvbGUud2FybihbJ1BvcHBlcjogQ1NTIFwibWFyZ2luXCIgc3R5bGVzIGNhbm5vdCBiZSB1c2VkIHRvIGFwcGx5IHBhZGRpbmcnLCBcImJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LlwiLCBcIlRvIHJlcGxpY2F0ZSBtYXJnaW4sIHVzZSB0aGUgYG9mZnNldGAgbW9kaWZpZXIsIGFzIHdlbGwgYXNcIiwgXCJ0aGUgYHBhZGRpbmdgIG9wdGlvbiBpbiB0aGUgYHByZXZlbnRPdmVyZmxvd2AgYW5kIGBmbGlwYFwiLCBcIm1vZGlmaWVycy5cIl0uam9pbihcIiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnKCksIG0udXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWYpIHtcbiAgICAgICAgICB2YXIgQyA9IGQuZWxlbWVudHMsIHcgPSBDLnJlZmVyZW5jZSwgdiA9IEMucG9wcGVyO1xuICAgICAgICAgIGlmICghSW8odywgdikpIHtcbiAgICAgICAgICAgICh7fSkuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoU28pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkLnJlY3RzID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlOiBZYyh3LCBnaSh2KSwgZC5vcHRpb25zLnN0cmF0ZWd5ID09PSBcImZpeGVkXCIpLFxuICAgICAgICAgICAgcG9wcGVyOiBKbih2KVxuICAgICAgICAgIH0sIGQucmVzZXQgPSAhMSwgZC5wbGFjZW1lbnQgPSBkLm9wdGlvbnMucGxhY2VtZW50LCBkLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICByZXR1cm4gZC5tb2RpZmllcnNEYXRhW3gubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCB4LmRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAodmFyIEUgPSAwLCBBID0gMDsgQSA8IGQub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IEErKykge1xuICAgICAgICAgICAgaWYgKHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoRSArPSAxLCBFID4gMTAwKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFFjKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZC5yZXNldCA9PT0gITApIHtcbiAgICAgICAgICAgICAgZC5yZXNldCA9ICExLCBBID0gLTE7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHkgPSBkLm9yZGVyZWRNb2RpZmllcnNbQV0sIFMgPSB5LmZuLCBPID0geS5vcHRpb25zLCBrID0gTyA9PT0gdm9pZCAwID8ge30gOiBPLCBEID0geS5uYW1lO1xuICAgICAgICAgICAgdHlwZW9mIFMgPT0gXCJmdW5jdGlvblwiICYmIChkID0gUyh7XG4gICAgICAgICAgICAgIHN0YXRlOiBkLFxuICAgICAgICAgICAgICBvcHRpb25zOiBrLFxuICAgICAgICAgICAgICBuYW1lOiBELFxuICAgICAgICAgICAgICBpbnN0YW5jZTogbVxuICAgICAgICAgICAgfSkgfHwgZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogVWMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihUKSB7XG4gICAgICAgICAgbS5mb3JjZVVwZGF0ZSgpLCBUKGQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGIoKSwgZiA9ICEwO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFJbyhhLCBsKSlcbiAgICAgIHJldHVybiB7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihTbyksIG07XG4gICAgbS5zZXRPcHRpb25zKGMpLnRoZW4oZnVuY3Rpb24oVCkge1xuICAgICAgIWYgJiYgYy5vbkZpcnN0VXBkYXRlICYmIGMub25GaXJzdFVwZGF0ZShUKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgZC5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24oVCkge1xuICAgICAgICB2YXIgQyA9IFQubmFtZSwgdyA9IFQub3B0aW9ucywgdiA9IHcgPT09IHZvaWQgMCA/IHt9IDogdywgRSA9IFQuZWZmZWN0O1xuICAgICAgICBpZiAodHlwZW9mIEUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdmFyIEEgPSBFKHtcbiAgICAgICAgICAgIHN0YXRlOiBkLFxuICAgICAgICAgICAgbmFtZTogQyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBtLFxuICAgICAgICAgICAgb3B0aW9uczogdlxuICAgICAgICAgIH0pLCB5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfLnB1c2goQSB8fCB5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICBfLmZvckVhY2goZnVuY3Rpb24oVCkge1xuICAgICAgICByZXR1cm4gVCgpO1xuICAgICAgfSksIF8gPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH07XG59XG52YXIgWmMgPSAvKiBAX19QVVJFX18gKi8ga3MoKSwgSmMgPSBbaW8sIHJvLCBlbywgWm5dLCB0ZCA9IC8qIEBfX1BVUkVfXyAqLyBrcyh7XG4gIGRlZmF1bHRNb2RpZmllcnM6IEpjXG59KSwgZWQgPSBbaW8sIHJvLCBlbywgWm4sIHRsLCBaYSwgZWwsIEdhLCBKYV0sIGplID0gLyogQF9fUFVSRV9fICovIGtzKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZWRcbn0pO1xuY29uc3QgaWwgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhZnRlck1haW46IFZhLFxuICBhZnRlclJlYWQ6IFBhLFxuICBhZnRlcldyaXRlOiBZYSxcbiAgYXBwbHlTdHlsZXM6IFpuLFxuICBhcnJvdzogR2EsXG4gIGF1dG86IG1pLFxuICBiYXNlUGxhY2VtZW50czogWWUsXG4gIGJlZm9yZU1haW46IEhhLFxuICBiZWZvcmVSZWFkOiBOYSxcbiAgYmVmb3JlV3JpdGU6IFdhLFxuICBib3R0b206IGR0LFxuICBjbGlwcGluZ1BhcmVudHM6IExhLFxuICBjb21wdXRlU3R5bGVzOiBlbyxcbiAgY3JlYXRlUG9wcGVyOiBqZSxcbiAgY3JlYXRlUG9wcGVyQmFzZTogWmMsXG4gIGNyZWF0ZVBvcHBlckxpdGU6IHRkLFxuICBkZXRlY3RPdmVyZmxvdzogVmUsXG4gIGVuZDogUmUsXG4gIGV2ZW50TGlzdGVuZXJzOiBpbyxcbiAgZmxpcDogWmEsXG4gIGhpZGU6IEphLFxuICBsZWZ0OiBKLFxuICBtYWluOiBCYSxcbiAgbW9kaWZpZXJQaGFzZXM6IEVzLFxuICBvZmZzZXQ6IHRsLFxuICBwbGFjZW1lbnRzOiBxbixcbiAgcG9wcGVyOiB5ZSxcbiAgcG9wcGVyR2VuZXJhdG9yOiBrcyxcbiAgcG9wcGVyT2Zmc2V0czogcm8sXG4gIHByZXZlbnRPdmVyZmxvdzogZWwsXG4gIHJlYWQ6IFJhLFxuICByZWZlcmVuY2U6IE1hLFxuICByaWdodDogaHQsXG4gIHN0YXJ0OiBfZSxcbiAgdG9wOiBaLFxuICB2YXJpYXRpb25QbGFjZW1lbnRzOiAkbixcbiAgdmlld3BvcnQ6IEduLFxuICB3cml0ZTogRmFcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5mdW5jdGlvbiBGcyhzKSB7XG4gIHJldHVybiBzID09PSBcInRydWVcIiA/ICEwIDogcyA9PT0gXCJmYWxzZVwiID8gITEgOiBzID09PSBOdW1iZXIocykudG9TdHJpbmcoKSA/IE51bWJlcihzKSA6IHMgPT09IFwiXCIgfHwgcyA9PT0gXCJudWxsXCIgPyBudWxsIDogcztcbn1cbmZ1bmN0aW9uIFlzKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvW0EtWl0vZywgKHQpID0+IGAtJHt0LnRvTG93ZXJDYXNlKCl9YCk7XG59XG5jb25zdCBwID0ge1xuICBzZXREYXRhQXR0cmlidXRlKHMsIHQsIGUpIHtcbiAgICBzLnNldEF0dHJpYnV0ZShgZGF0YS10ZS0ke1lzKHQpfWAsIGUpO1xuICB9LFxuICByZW1vdmVEYXRhQXR0cmlidXRlKHMsIHQpIHtcbiAgICBzLnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS0ke1lzKHQpfWApO1xuICB9LFxuICBnZXREYXRhQXR0cmlidXRlcyhzKSB7XG4gICAgaWYgKCFzKVxuICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocy5kYXRhc2V0KS5maWx0ZXIoKGUpID0+IGUuc3RhcnRzV2l0aChcInRlXCIpKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBpZiAoZS5zdGFydHNXaXRoKFwidGVDbGFzc1wiKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IGkgPSBlLnJlcGxhY2UoL150ZS8sIFwiXCIpO1xuICAgICAgaSA9IGkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBpLnNsaWNlKDEsIGkubGVuZ3RoKSwgdFtpXSA9IEZzKHMuZGF0YXNldFtlXSk7XG4gICAgfSksIHQ7XG4gIH0sXG4gIGdldERhdGFDbGFzc0F0dHJpYnV0ZXMocykge1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgLi4ucy5kYXRhc2V0XG4gICAgfTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModCkuZmlsdGVyKChlKSA9PiBlLnN0YXJ0c1dpdGgoXCJ0ZUNsYXNzXCIpKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBsZXQgaSA9IGUucmVwbGFjZSgvXnRlQ2xhc3MvLCBcIlwiKTtcbiAgICAgIGkgPSBpLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgaS5zbGljZSgxLCBpLmxlbmd0aCksIHRbaV0gPSBGcyh0W2VdKTtcbiAgICB9KSwgdDtcbiAgfSxcbiAgZ2V0RGF0YUF0dHJpYnV0ZShzLCB0KSB7XG4gICAgcmV0dXJuIEZzKFxuICAgICAgcy5nZXRBdHRyaWJ1dGUoYGRhdGEtdGUtJHtZcyh0KX1gKVxuICAgICk7XG4gIH0sXG4gIG9mZnNldChzKSB7XG4gICAgY29uc3QgdCA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdC50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICAgIGxlZnQ6IHQubGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdFxuICAgIH07XG4gIH0sXG4gIHBvc2l0aW9uKHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBzLm9mZnNldFRvcCxcbiAgICAgIGxlZnQ6IHMub2Zmc2V0TGVmdFxuICAgIH07XG4gIH0sXG4gIHN0eWxlKHMsIHQpIHtcbiAgICBPYmplY3QuYXNzaWduKHMuc3R5bGUsIHQpO1xuICB9LFxuICB0b2dnbGVDbGFzcyhzLCB0KSB7XG4gICAgcyAmJiBqcyh0KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBzLmNsYXNzTGlzdC5jb250YWlucyhlKSA/IHMuY2xhc3NMaXN0LnJlbW92ZShlKSA6IHMuY2xhc3NMaXN0LmFkZChlKTtcbiAgICB9KTtcbiAgfSxcbiAgYWRkQ2xhc3MocywgdCkge1xuICAgIGpzKHQpLmZvckVhY2goXG4gICAgICAoZSkgPT4gIXMuY2xhc3NMaXN0LmNvbnRhaW5zKGUpICYmIHMuY2xhc3NMaXN0LmFkZChlKVxuICAgICk7XG4gIH0sXG4gIGFkZFN0eWxlKHMsIHQpIHtcbiAgICBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBzLnN0eWxlW2VdID0gdFtlXTtcbiAgICB9KTtcbiAgfSxcbiAgcmVtb3ZlQ2xhc3MocywgdCkge1xuICAgIGpzKHQpLmZvckVhY2goXG4gICAgICAoZSkgPT4gcy5jbGFzc0xpc3QuY29udGFpbnMoZSkgJiYgcy5jbGFzc0xpc3QucmVtb3ZlKGUpXG4gICAgKTtcbiAgfSxcbiAgaGFzQ2xhc3MocywgdCkge1xuICAgIHJldHVybiBzLmNsYXNzTGlzdC5jb250YWlucyh0KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGpzKHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzLnNwbGl0KFwiIFwiKSA6IEFycmF5LmlzQXJyYXkocykgPyBzIDogITE7XG59XG5jb25zdCBpZCA9IDMsIGggPSB7XG4gIGNsb3Nlc3QocywgdCkge1xuICAgIHJldHVybiBzLmNsb3Nlc3QodCk7XG4gIH0sXG4gIG1hdGNoZXMocywgdCkge1xuICAgIHJldHVybiBzLm1hdGNoZXModCk7XG4gIH0sXG4gIGZpbmQocywgdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAuLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwodCwgcylcbiAgICApO1xuICB9LFxuICBmaW5kT25lKHMsIHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKHQsIHMpO1xuICB9LFxuICBjaGlsZHJlbihzLCB0KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5zLmNoaWxkcmVuKS5maWx0ZXIoKGkpID0+IGkubWF0Y2hlcyh0KSk7XG4gIH0sXG4gIHBhcmVudHMocywgdCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICBsZXQgaSA9IHMucGFyZW50Tm9kZTtcbiAgICBmb3IgKDsgaSAmJiBpLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBpLm5vZGVUeXBlICE9PSBpZDsgKVxuICAgICAgdGhpcy5tYXRjaGVzKGksIHQpICYmIGUucHVzaChpKSwgaSA9IGkucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gZTtcbiAgfSxcbiAgcHJldihzLCB0KSB7XG4gICAgbGV0IGUgPSBzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgZm9yICg7IGU7ICkge1xuICAgICAgaWYgKGUubWF0Y2hlcyh0KSlcbiAgICAgICAgcmV0dXJuIFtlXTtcbiAgICAgIGUgPSBlLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgbmV4dChzLCB0KSB7XG4gICAgbGV0IGUgPSBzLm5leHRFbGVtZW50U2libGluZztcbiAgICBmb3IgKDsgZTsgKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaGVzKGUsIHQpKVxuICAgICAgICByZXR1cm4gW2VdO1xuICAgICAgZSA9IGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGZvY3VzYWJsZUNoaWxkcmVuKHMpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgXCJhXCIsXG4gICAgICBcImJ1dHRvblwiLFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgXCJ0ZXh0YXJlYVwiLFxuICAgICAgXCJzZWxlY3RcIixcbiAgICAgIFwiZGV0YWlsc1wiLFxuICAgICAgXCJbdGFiaW5kZXhdXCIsXG4gICAgICAnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nXG4gICAgXS5tYXAoKGUpID0+IGAke2V9Om5vdChbdGFiaW5kZXhePVwiLVwiXSlgKS5qb2luKFwiLCBcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluZCh0LCBzKS5maWx0ZXIoXG4gICAgICAoZSkgPT4gIXVlKGUpICYmIFN0KGUpXG4gICAgKTtcbiAgfVxufSwgS3MgPSBcImRyb3Bkb3duXCIsIHNkID0gXCJ0ZS5kcm9wZG93blwiLCBnZSA9IGAuJHtzZH1gLCBhbyA9IFwiLmRhdGEtYXBpXCIsIG5zID0gXCJFc2NhcGVcIiwgJG8gPSBcIlNwYWNlXCIsIExvID0gXCJUYWJcIiwgTm4gPSBcIkFycm93VXBcIiwgb3MgPSBcIkFycm93RG93blwiLCBuZCA9IDIsIG9kID0gbmV3IFJlZ0V4cChcbiAgYCR7Tm59fCR7b3N9fCR7bnN9YFxuKSwgcmQgPSBgaGlkZSR7Z2V9YCwgYWQgPSBgaGlkZGVuJHtnZX1gLCBsZCA9IGBzaG93JHtnZX1gLCBjZCA9IGBzaG93biR7Z2V9YCwgZGQgPSBgY2xpY2ske2dlfSR7YW99YCwgTW8gPSBga2V5ZG93biR7Z2V9JHthb31gLCBoZCA9IGBrZXl1cCR7Z2V9JHthb31gLCBQdCA9IFwic2hvd1wiLCB1ZCA9IFwiZHJvcHVwXCIsIHBkID0gXCJkcm9wZW5kXCIsIGZkID0gXCJkcm9wc3RhcnRcIiwgX2QgPSBcIltkYXRhLXRlLW5hdmJhci1yZWZdXCIsIElpID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBVcyA9IFwiW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdXCIsIG1kID0gXCJbZGF0YS10ZS1uYXZiYXItbmF2LXJlZl1cIiwgZ2QgPSBcIltkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXSBbZGF0YS10ZS1kcm9wZG93bi1pdGVtLXJlZl06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZClcIiwgYmQgPSBGKCkgPyBcInRvcC1lbmRcIiA6IFwidG9wLXN0YXJ0XCIsIHZkID0gRigpID8gXCJ0b3Atc3RhcnRcIiA6IFwidG9wLWVuZFwiLCBFZCA9IEYoKSA/IFwiYm90dG9tLWVuZFwiIDogXCJib3R0b20tc3RhcnRcIiwgVGQgPSBGKCkgPyBcImJvdHRvbS1zdGFydFwiIDogXCJib3R0b20tZW5kXCIsIENkID0gRigpID8gXCJsZWZ0LXN0YXJ0XCIgOiBcInJpZ2h0LXN0YXJ0XCIsIEFkID0gRigpID8gXCJyaWdodC1zdGFydFwiIDogXCJsZWZ0LXN0YXJ0XCIsIHlkID0gW3sgb3BhY2l0eTogXCIwXCIgfSwgeyBvcGFjaXR5OiBcIjFcIiB9XSwgd2QgPSBbeyBvcGFjaXR5OiBcIjFcIiB9LCB7IG9wYWNpdHk6IFwiMFwiIH1dLCAkaSA9IHtcbiAgZHVyYXRpb246IDU1MCxcbiAgaXRlcmF0aW9uczogMSxcbiAgZWFzaW5nOiBcImVhc2VcIixcbiAgZmlsbDogXCJib3RoXCJcbn0sIGtkID0ge1xuICBvZmZzZXQ6IFswLCAyXSxcbiAgYm91bmRhcnk6IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gIHJlZmVyZW5jZTogXCJ0b2dnbGVcIixcbiAgZGlzcGxheTogXCJkeW5hbWljXCIsXG4gIHBvcHBlckNvbmZpZzogbnVsbCxcbiAgYXV0b0Nsb3NlOiAhMCxcbiAgZHJvcGRvd25BbmltYXRpb246IFwib25cIlxufSwgT2QgPSB7XG4gIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gIHJlZmVyZW5jZTogXCIoc3RyaW5nfGVsZW1lbnR8b2JqZWN0KVwiLFxuICBkaXNwbGF5OiBcInN0cmluZ1wiLFxuICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiLFxuICBhdXRvQ2xvc2U6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBkcm9wZG93bkFuaW1hdGlvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIHd0IGV4dGVuZHMgdnQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fbWVudSA9IHRoaXMuX2dldE1lbnVFbGVtZW50KCksIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCksIHRoaXMuX2ZhZGVPdXRBbmltYXRlID0gbnVsbDtcbiAgICBjb25zdCBpID0gd2luZG93Lm1hdGNoTWVkaWEoXG4gICAgICBcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCJcbiAgICApLm1hdGNoZXM7XG4gICAgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSA9IHRoaXMuX2NvbmZpZy5kcm9wZG93bkFuaW1hdGlvbiA9PT0gXCJvblwiICYmICFpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4ga2Q7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gT2Q7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBLcztcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHVlKHRoaXMuX2VsZW1lbnQpIHx8IHRoaXMuX2lzU2hvd24odGhpcy5fbWVudSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9O1xuICAgIGlmICh1LnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgbGQsXG4gICAgICB0XG4gICAgKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB3dC5nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9pbk5hdmJhciA/IHAuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiLCBcIm5vbmVcIikgOiB0aGlzLl9jcmVhdGVQb3BwZXIoaSksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICFpLmNsb3Nlc3QobWQpICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChuKSA9PiB1Lm9uKG4sIFwibW91c2VvdmVyXCIsIHZzKSksIHRoaXMuX2VsZW1lbnQuZm9jdXMoKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICEwKSwgdGhpcy5fbWVudS5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtQdH1gLCBcIlwiKSwgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSAmJiB0aGlzLl9tZW51LmFuaW1hdGUoeWQsICRpKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtQdH1gLCBcIlwiKSwgc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGNkLCB0KTtcbiAgICAgIH0sXG4gICAgICB0aGlzLl9hbmltYXRpb25DYW5QbGF5ID8gJGkuZHVyYXRpb24gOiAwXG4gICAgKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh1ZSh0aGlzLl9lbGVtZW50KSB8fCAhdGhpcy5faXNTaG93bih0aGlzLl9tZW51KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH07XG4gICAgdGhpcy5fY29tcGxldGVIaWRlKHQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5kZXN0cm95KCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKHUub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIE1vLFxuICAgICAgSWksXG4gICAgICB3dC5kYXRhQXBpS2V5ZG93bkhhbmRsZXJcbiAgICApLCB1Lm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBNbyxcbiAgICAgIFVzLFxuICAgICAgd3QuZGF0YUFwaUtleWRvd25IYW5kbGVyXG4gICAgKSwgdS5vbihkb2N1bWVudCwgZGQsIHd0LmNsZWFyTWVudXMpLCB1Lm9uKGRvY3VtZW50LCBoZCwgd3QuY2xlYXJNZW51cyksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2NvbXBsZXRlSGlkZSh0KSB7XG4gICAgdGhpcy5fZmFkZU91dEFuaW1hdGUgJiYgdGhpcy5fZmFkZU91dEFuaW1hdGUucGxheVN0YXRlID09PSBcInJ1bm5pbmdcIiB8fCB1LnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgcmQsXG4gICAgICB0XG4gICAgKS5kZWZhdWx0UHJldmVudGVkIHx8IChcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgoaSkgPT4gdS5vZmYoaSwgXCJtb3VzZW92ZXJcIiwgdnMpKSwgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSAmJiAodGhpcy5fZmFkZU91dEFuaW1hdGUgPSB0aGlzLl9tZW51LmFuaW1hdGUoXG4gICAgICB3ZCxcbiAgICAgICRpXG4gICAgKSksIHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9tZW51LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke1B0fWApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke1B0fWApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKSwgcC5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsIFwicG9wcGVyXCIpLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYWQsIHQpO1xuICAgICAgfSxcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPyAkaS5kdXJhdGlvbiA6IDBcbiAgICApKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBpZiAodCA9IHtcbiAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLnAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfSwgTihLcywgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHR5cGVvZiB0LnJlZmVyZW5jZSA9PSBcIm9iamVjdFwiICYmICFOZSh0LnJlZmVyZW5jZSkgJiYgdHlwZW9mIHQucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgJHtLcy50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gXG4gICAgICApO1xuICAgIHJldHVybiB0O1xuICB9XG4gIF9jcmVhdGVQb3BwZXIodCkge1xuICAgIGlmICh0eXBlb2YgaWwgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiQm9vdHN0cmFwJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpXCJcbiAgICAgICk7XG4gICAgbGV0IGUgPSB0aGlzLl9lbGVtZW50O1xuICAgIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09IFwicGFyZW50XCIgPyBlID0gdCA6IE5lKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpID8gZSA9IEd0KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpIDogdHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT0gXCJvYmplY3RcIiAmJiAoZSA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpO1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRQb3BwZXJDb25maWcoKSwgbiA9IGkubW9kaWZpZXJzLmZpbmQoXG4gICAgICAobykgPT4gby5uYW1lID09PSBcImFwcGx5U3R5bGVzXCIgJiYgby5lbmFibGVkID09PSAhMVxuICAgICk7XG4gICAgdGhpcy5fcG9wcGVyID0gamUoXG4gICAgICBlLFxuICAgICAgdGhpcy5fbWVudSxcbiAgICAgIGlcbiAgICApLCBuICYmIHAuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiLCBcInN0YXRpY1wiKTtcbiAgfVxuICBfaXNTaG93bih0ID0gdGhpcy5fZWxlbWVudCkge1xuICAgIHJldHVybiB0LmRhdGFzZXRbYHRlRHJvcGRvd24ke1B0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgUHQuc2xpY2UoMSl9YF0gPT09IFwiXCI7XG4gIH1cbiAgX2dldE1lbnVFbGVtZW50KCkge1xuICAgIHJldHVybiBoLm5leHQodGhpcy5fZWxlbWVudCwgVXMpWzBdO1xuICB9XG4gIF9nZXRQbGFjZW1lbnQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAodC5kYXRhc2V0LnRlRHJvcGRvd25Qb3NpdGlvbiA9PT0gcGQpXG4gICAgICByZXR1cm4gQ2Q7XG4gICAgaWYgKHQuZGF0YXNldC50ZURyb3Bkb3duUG9zaXRpb24gPT09IGZkKVxuICAgICAgcmV0dXJuIEFkO1xuICAgIGNvbnN0IGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX21lbnUpLmdldFByb3BlcnR5VmFsdWUoXCItLXRlLXBvc2l0aW9uXCIpLnRyaW0oKSA9PT0gXCJlbmRcIjtcbiAgICByZXR1cm4gdC5kYXRhc2V0LnRlRHJvcGRvd25Qb3NpdGlvbiA9PT0gdWQgPyBlID8gdmQgOiBiZCA6IGUgPyBUZCA6IEVkO1xuICB9XG4gIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChfZCkgIT09IG51bGw7XG4gIH1cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCB7IG9mZnNldDogdCB9ID0gdGhpcy5fY29uZmlnO1xuICAgIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdC5zcGxpdChcIixcIikubWFwKChlKSA9PiBOdW1iZXIucGFyc2VJbnQoZSwgMTApKSA6IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IChlKSA9PiB0KGUsIHRoaXMuX2VsZW1lbnQpIDogdDtcbiAgfVxuICBfZ2V0UG9wcGVyQ29uZmlnKCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gXCJzdGF0aWNcIiAmJiAodC5tb2RpZmllcnMgPSBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiYXBwbHlTdHlsZXNcIixcbiAgICAgICAgZW5hYmxlZDogITFcbiAgICAgIH1cbiAgICBdKSwge1xuICAgICAgLi4udCxcbiAgICAgIC4uLnR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcodCkgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnXG4gICAgfTtcbiAgfVxuICBfc2VsZWN0TWVudUl0ZW0oeyBrZXk6IHQsIHRhcmdldDogZSB9KSB7XG4gICAgY29uc3QgaSA9IGguZmluZChcbiAgICAgIGdkLFxuICAgICAgdGhpcy5fbWVudVxuICAgICkuZmlsdGVyKFN0KTtcbiAgICBpLmxlbmd0aCAmJiB3YShcbiAgICAgIGksXG4gICAgICBlLFxuICAgICAgdCA9PT0gb3MsXG4gICAgICAhaS5pbmNsdWRlcyhlKVxuICAgICkuZm9jdXMoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSB3dC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgY2xlYXJNZW51cyh0KSB7XG4gICAgaWYgKHQgJiYgKHQuYnV0dG9uID09PSBuZCB8fCB0LnR5cGUgPT09IFwia2V5dXBcIiAmJiB0LmtleSAhPT0gTG8pKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSBoLmZpbmQoSWkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gZS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IG8gPSB3dC5nZXRJbnN0YW5jZShlW2ldKTtcbiAgICAgIGlmICghbyB8fCBvLl9jb25maWcuYXV0b0Nsb3NlID09PSAhMSB8fCAhby5faXNTaG93bigpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHIgPSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG8uX2VsZW1lbnRcbiAgICAgIH07XG4gICAgICBpZiAodCkge1xuICAgICAgICBjb25zdCBhID0gdC5jb21wb3NlZFBhdGgoKSwgbCA9IGEuaW5jbHVkZXMoby5fbWVudSk7XG4gICAgICAgIGlmIChhLmluY2x1ZGVzKG8uX2VsZW1lbnQpIHx8IG8uX2NvbmZpZy5hdXRvQ2xvc2UgPT09IFwiaW5zaWRlXCIgJiYgIWwgfHwgby5fY29uZmlnLmF1dG9DbG9zZSA9PT0gXCJvdXRzaWRlXCIgJiYgbCB8fCBvLl9tZW51LmNvbnRhaW5zKHQudGFyZ2V0KSAmJiAodC50eXBlID09PSBcImtleXVwXCIgJiYgdC5rZXkgPT09IExvIHx8IC9pbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGZvcm0vaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdC50eXBlID09PSBcImNsaWNrXCIgJiYgKHIuY2xpY2tFdmVudCA9IHQpO1xuICAgICAgfVxuICAgICAgby5fY29tcGxldGVIaWRlKHIpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0UGFyZW50RnJvbUVsZW1lbnQodCkge1xuICAgIHJldHVybiBYdCh0KSB8fCB0LnBhcmVudE5vZGU7XG4gIH1cbiAgc3RhdGljIGRhdGFBcGlLZXlkb3duSGFuZGxlcih0KSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkgPyB0LmtleSA9PT0gJG8gfHwgdC5rZXkgIT09IG5zICYmICh0LmtleSAhPT0gb3MgJiYgdC5rZXkgIT09IE5uIHx8IHQudGFyZ2V0LmNsb3Nlc3QoVXMpKSA6ICFvZC50ZXN0KHQua2V5KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5kYXRhc2V0W2B0ZURyb3Bkb3duJHtQdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIFB0LnNsaWNlKDEpfWBdID09PSBcIlwiO1xuICAgIGlmICghZSAmJiB0LmtleSA9PT0gbnMgfHwgKHQucHJldmVudERlZmF1bHQoKSwgdC5zdG9wUHJvcGFnYXRpb24oKSwgdWUodGhpcykpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB0aGlzLm1hdGNoZXMoSWkpID8gdGhpcyA6IGgucHJldih0aGlzLCBJaSlbMF0sIG4gPSB3dC5nZXRPckNyZWF0ZUluc3RhbmNlKGkpO1xuICAgIGlmICh0LmtleSA9PT0gbnMpIHtcbiAgICAgIG4uaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodC5rZXkgPT09IE5uIHx8IHQua2V5ID09PSBvcykge1xuICAgICAgZSB8fCBuLnNob3coKSwgbi5fc2VsZWN0TWVudUl0ZW0odCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICghZSB8fCB0LmtleSA9PT0gJG8pICYmIHd0LmNsZWFyTWVudXMoKTtcbiAgfVxufVxuY29uc3QgenMgPSBcImNvbGxhcHNlXCIsIHNsID0gXCJ0ZS5jb2xsYXBzZVwiLCBPcyA9IGAuJHtzbH1gLCBObyA9IHtcbiAgdG9nZ2xlOiAhMCxcbiAgcGFyZW50OiBudWxsXG59LCB4ZCA9IHtcbiAgdG9nZ2xlOiBcImJvb2xlYW5cIixcbiAgcGFyZW50OiBcIihudWxsfGVsZW1lbnQpXCJcbn0sIFNkID0gYHNob3cke09zfWAsIERkID0gYHNob3duJHtPc31gLCBJZCA9IGBoaWRlJHtPc31gLCAkZCA9IGBoaWRkZW4ke09zfWAsIFhzID0gXCJkYXRhLXRlLWNvbGxhcHNlLXNob3dcIiwgUm8gPSBcImRhdGEtdGUtY29sbGFwc2UtY29sbGFwc2VkXCIsIExpID0gXCJkYXRhLXRlLWNvbGxhcHNlLWNvbGxhcHNpbmdcIiwgTGQgPSBcImRhdGEtdGUtY29sbGFwc2UtaG9yaXpvbnRhbFwiLCBPZSA9IFwiZGF0YS10ZS1jb2xsYXBzZS1pdGVtXCIsIFBvID0gYDpzY29wZSBbJHtPZX1dIFske09lfV1gLCBNZCA9IFwid2lkdGhcIiwgTmQgPSBcImhlaWdodFwiLCBSZCA9IFwiW2RhdGEtdGUtY29sbGFwc2UtaXRlbV1bZGF0YS10ZS1jb2xsYXBzZS1zaG93XSwgW2RhdGEtdGUtY29sbGFwc2UtaXRlbV1bZGF0YS10ZS1jb2xsYXBzZS1jb2xsYXBzaW5nXVwiLCBIbyA9IFwiW2RhdGEtdGUtY29sbGFwc2UtaW5pdF1cIiwgUGQgPSB7XG4gIHZpc2libGU6IFwiIXZpc2libGVcIixcbiAgaGlkZGVuOiBcImhpZGRlblwiLFxuICBiYXNlVHJhbnNpdGlvbjogXCJvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBjb2xsYXBzaW5nOiBcImgtMCB0cmFuc2l0aW9uLVtoZWlnaHRdIG92ZXJmbG93LWhpZGRlbiBkdXJhdGlvbi1bMzUwbXNdIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEuMCldIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIGNvbGxhcHNpbmdIb3Jpem9udGFsOiBcInctMCBoLWF1dG8gdHJhbnNpdGlvbi1bd2lkdGhdIG92ZXJmbG93LWhpZGRlbiBkdXJhdGlvbi1bMzUwbXNdIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEuMCldIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCJcbn0sIEhkID0ge1xuICB2aXNpYmxlOiBcInN0cmluZ1wiLFxuICBoaWRkZW46IFwic3RyaW5nXCIsXG4gIGJhc2VUcmFuc2l0aW9uOiBcInN0cmluZ1wiLFxuICBjb2xsYXBzaW5nOiBcInN0cmluZ1wiLFxuICBjb2xsYXBzaW5nSG9yaXpvbnRhbDogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFV0IGV4dGVuZHMgdnQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl90cmlnZ2VyQXJyYXkgPSBbXTtcbiAgICBjb25zdCBuID0gaC5maW5kKEhvKTtcbiAgICBmb3IgKGxldCBvID0gMCwgciA9IG4ubGVuZ3RoOyBvIDwgcjsgbysrKSB7XG4gICAgICBjb25zdCBhID0gbltvXSwgbCA9IFhuKGEpLCBjID0gaC5maW5kKGwpLmZpbHRlcihcbiAgICAgICAgKGQpID0+IGQgPT09IHRoaXMuX2VsZW1lbnRcbiAgICAgICk7XG4gICAgICBsICE9PSBudWxsICYmIGMubGVuZ3RoICYmICh0aGlzLl9zZWxlY3RvciA9IGwsIHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKGEpKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCksIHRoaXMuX2NvbmZpZy5wYXJlbnQgfHwgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdGhpcy5faXNTaG93bigpKSwgdGhpcy5fY29uZmlnLnRvZ2dsZSAmJiB0aGlzLnRvZ2dsZSgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBObztcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHpzO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgdGhpcy5faXNTaG93bigpKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0ID0gW10sIGU7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIGNvbnN0IGQgPSBoLmZpbmQoXG4gICAgICAgIFBvLFxuICAgICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICApO1xuICAgICAgdCA9IGguZmluZChcbiAgICAgICAgUmQsXG4gICAgICAgIHRoaXMuX2NvbmZpZy5wYXJlbnRcbiAgICAgICkuZmlsdGVyKChfKSA9PiAhZC5pbmNsdWRlcyhfKSk7XG4gICAgfVxuICAgIGNvbnN0IGkgPSBoLmZpbmRPbmUodGhpcy5fc2VsZWN0b3IpO1xuICAgIGlmICh0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZCA9IHQuZmluZCgoXykgPT4gaSAhPT0gXyk7XG4gICAgICBpZiAoZSA9IGQgPyBVdC5nZXRJbnN0YW5jZShkKSA6IG51bGwsIGUgJiYgZS5faXNUcmFuc2l0aW9uaW5nKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgU2QpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdC5mb3JFYWNoKChkKSA9PiB7XG4gICAgICBpICE9PSBkICYmIFV0LmdldE9yQ3JlYXRlSW5zdGFuY2UoZCwgeyB0b2dnbGU6ICExIH0pLmhpZGUoKSwgZSB8fCBJLnNldERhdGEoZCwgc2wsIG51bGwpO1xuICAgIH0pO1xuICAgIGNvbnN0IG8gPSB0aGlzLl9nZXREaW1lbnNpb24oKSwgciA9IG8gPT09IFwiaGVpZ2h0XCIgPyB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmcgOiB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmdIb3Jpem9udGFsO1xuICAgIHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgcC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIHAuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgciksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKE9lKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoTGksIFwiXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlW29dID0gMCwgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgITApLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMDtcbiAgICBjb25zdCBhID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5oaWRkZW4pLCBwLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHIpLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMudmlzaWJsZSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKExpKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoT2UsIFwiXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShYcywgXCJcIiksIHRoaXMuX2VsZW1lbnQuc3R5bGVbb10gPSBcIlwiLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRGQpO1xuICAgIH0sIGMgPSBgc2Nyb2xsJHtvWzBdLnRvVXBwZXJDYXNlKCkgKyBvLnNsaWNlKDEpfWA7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhhLCB0aGlzLl9lbGVtZW50LCAhMCksIHRoaXMuX2VsZW1lbnQuc3R5bGVbb10gPSBgJHt0aGlzLl9lbGVtZW50W2NdfXB4YDtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgIXRoaXMuX2lzU2hvd24oKSB8fCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgSWQpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldERpbWVuc2lvbigpLCBpID0gZSA9PT0gXCJoZWlnaHRcIiA/IHRoaXMuX2NsYXNzZXMuY29sbGFwc2luZyA6IHRoaXMuX2NsYXNzZXMuY29sbGFwc2luZ0hvcml6b250YWw7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtlXSA9IGAke3RoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZV19cHhgLCBGZSh0aGlzLl9lbGVtZW50KSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBpKSwgcC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCBwLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoTGksIFwiXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShPZSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFhzKTtcbiAgICBjb25zdCBuID0gdGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IG47IHIrKykge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX3RyaWdnZXJBcnJheVtyXSwgbCA9IFh0KGEpO1xuICAgICAgbCAmJiAhdGhpcy5faXNTaG93bihsKSAmJiB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW2FdLCAhMSk7XG4gICAgfVxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICEwO1xuICAgIGNvbnN0IG8gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgcC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBpKSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoTGkpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShPZSwgXCJcIiksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCAkZCk7XG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2VdID0gXCJcIiwgdGhpcy5fcXVldWVDYWxsYmFjayhvLCB0aGlzLl9lbGVtZW50LCAhMCk7XG4gIH1cbiAgX2lzU2hvd24odCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gdC5oYXNBdHRyaWJ1dGUoWHMpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5ObyxcbiAgICAgIC4uLnAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfSwgdC50b2dnbGUgPSAhIXQudG9nZ2xlLCB0LnBhcmVudCA9IEd0KHQucGFyZW50KSwgTih6cywgdCwgeGQpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uUGQsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4oenMsIHQsIEhkKSwgdDtcbiAgfVxuICBfZ2V0RGltZW5zaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShMZCkgPyBNZCA6IE5kO1xuICB9XG4gIF9pbml0aWFsaXplQ2hpbGRyZW4oKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBoLmZpbmQoXG4gICAgICBQbyxcbiAgICAgIHRoaXMuX2NvbmZpZy5wYXJlbnRcbiAgICApO1xuICAgIGguZmluZChIbywgdGhpcy5fY29uZmlnLnBhcmVudCkuZmlsdGVyKChlKSA9PiAhdC5pbmNsdWRlcyhlKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IFh0KGUpO1xuICAgICAgaSAmJiB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW2VdLCB0aGlzLl9pc1Nob3duKGkpKTtcbiAgICB9KTtcbiAgfVxuICBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHQsIGUpIHtcbiAgICB0Lmxlbmd0aCAmJiB0LmZvckVhY2goKGkpID0+IHtcbiAgICAgIGUgPyBpLnJlbW92ZUF0dHJpYnV0ZShSbykgOiBpLnNldEF0dHJpYnV0ZShgJHtSb31gLCBcIlwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIGUpO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IHt9O1xuICAgICAgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAvc2hvd3xoaWRlLy50ZXN0KHQpICYmIChlLnRvZ2dsZSA9ICExKTtcbiAgICAgIGNvbnN0IGkgPSBVdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGUpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQm8gPSBcIi5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3BcIiwgVm8gPSBcIi5zdGlja3ktdG9wXCI7XG5jbGFzcyBwaSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xuICB9XG4gIGdldFdpZHRoKCkge1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gdCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIHRoaXMuX2Rpc2FibGVPdmVyRmxvdygpLCB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcInBhZGRpbmdSaWdodFwiLFxuICAgICAgKGUpID0+IGUgKyB0XG4gICAgKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICBCbyxcbiAgICAgIFwicGFkZGluZ1JpZ2h0XCIsXG4gICAgICAoZSkgPT4gZSArIHRcbiAgICApLCB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhcbiAgICAgIFZvLFxuICAgICAgXCJtYXJnaW5SaWdodFwiLFxuICAgICAgKGUpID0+IGUgLSB0XG4gICAgKTtcbiAgfVxuICBfZGlzYWJsZU92ZXJGbG93KCkge1xuICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsIFwib3ZlcmZsb3dcIiksIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICB9XG4gIF9zZXRFbGVtZW50QXR0cmlidXRlcyh0LCBlLCBpKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0V2lkdGgoKSwgbyA9IChyKSA9PiB7XG4gICAgICBpZiAociAhPT0gdGhpcy5fZWxlbWVudCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IHIuY2xpZW50V2lkdGggKyBuKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZShyLCBlKTtcbiAgICAgIGNvbnN0IGEgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyKVtlXTtcbiAgICAgIHIuc3R5bGVbZV0gPSBgJHtpKFxuICAgICAgICBOdW1iZXIucGFyc2VGbG9hdChhKVxuICAgICAgKX1weGA7XG4gICAgfTtcbiAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHQsIG8pO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgXCJvdmVyZmxvd1wiKSwgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBcInBhZGRpbmdSaWdodFwiKSwgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhCbywgXCJwYWRkaW5nUmlnaHRcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoVm8sIFwibWFyZ2luUmlnaHRcIik7XG4gIH1cbiAgX3NhdmVJbml0aWFsQXR0cmlidXRlKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdC5zdHlsZVtlXTtcbiAgICBpICYmIHAuc2V0RGF0YUF0dHJpYnV0ZSh0LCBlLCBpKTtcbiAgfVxuICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0LCBlKSB7XG4gICAgY29uc3QgaSA9IChuKSA9PiB7XG4gICAgICBjb25zdCBvID0gcC5nZXREYXRhQXR0cmlidXRlKG4sIGUpO1xuICAgICAgdHlwZW9mIG8gPiBcInVcIiA/IG4uc3R5bGUucmVtb3ZlUHJvcGVydHkoZSkgOiAocC5yZW1vdmVEYXRhQXR0cmlidXRlKG4sIGUpLCBuLnN0eWxlW2VdID0gbyk7XG4gICAgfTtcbiAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHQsIGkpO1xuICB9XG4gIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHQsIGUpIHtcbiAgICBOZSh0KSA/IGUodCkgOiBoLmZpbmQodCwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChlKTtcbiAgfVxuICBpc092ZXJmbG93aW5nKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgPiAwO1xuICB9XG59XG5jb25zdCBCZCA9IHtcbiAgaXNWaXNpYmxlOiAhMCxcbiAgLy8gaWYgZmFsc2UsIHdlIHVzZSB0aGUgYmFja2Ryb3AgaGVscGVyIHdpdGhvdXQgYWRkaW5nIGFueSBlbGVtZW50IHRvIHRoZSBkb21cbiAgaXNBbmltYXRlZDogITEsXG4gIHJvb3RFbGVtZW50OiBcImJvZHlcIixcbiAgLy8gZ2l2ZSB0aGUgY2hvaWNlIHRvIHBsYWNlIGJhY2tkcm9wIHVuZGVyIGRpZmZlcmVudCBlbGVtZW50c1xuICBjbGlja0NhbGxiYWNrOiBudWxsLFxuICBiYWNrZHJvcENsYXNzZXM6IG51bGxcbn0sIFZkID0ge1xuICBpc1Zpc2libGU6IFwiYm9vbGVhblwiLFxuICBpc0FuaW1hdGVkOiBcImJvb2xlYW5cIixcbiAgcm9vdEVsZW1lbnQ6IFwiKGVsZW1lbnR8c3RyaW5nKVwiLFxuICBjbGlja0NhbGxiYWNrOiBcIihmdW5jdGlvbnxudWxsKVwiLFxuICBiYWNrZHJvcENsYXNzZXM6IFwiKGFycmF5fG51bGwpXCJcbn0sIG5sID0gXCJiYWNrZHJvcFwiLCBXbyA9IGBtb3VzZWRvd24udGUuJHtubH1gO1xuY2xhc3MgbG8ge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKHQpLCB0aGlzLl9pc0FwcGVuZGVkID0gITEsIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIHNob3codCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgaGUodCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2FwcGVuZCgpLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCAmJiBGZSh0aGlzLl9nZXRFbGVtZW50KCkpO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jb25maWcuYmFja2Ryb3BDbGFzc2VzIHx8IFtcbiAgICAgIFwib3BhY2l0eS01MFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uLWFsbFwiLFxuICAgICAgXCJkdXJhdGlvbi0zMDBcIixcbiAgICAgIFwiZWFzZS1pbi1vdXRcIixcbiAgICAgIFwiZml4ZWRcIixcbiAgICAgIFwidG9wLTBcIixcbiAgICAgIFwibGVmdC0wXCIsXG4gICAgICBcInotWzEwNDBdXCIsXG4gICAgICBcImJnLWJsYWNrXCIsXG4gICAgICBcInctc2NyZWVuXCIsXG4gICAgICBcImgtc2NyZWVuXCJcbiAgICBdO1xuICAgIHAucmVtb3ZlQ2xhc3ModGhpcy5fZ2V0RWxlbWVudCgpLCBcIm9wYWNpdHktMFwiKSwgcC5hZGRDbGFzcyh0aGlzLl9nZXRFbGVtZW50KCksIGUpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtYmFja2Ryb3Atc2hvd1wiLCBcIlwiKSwgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICBoZSh0KTtcbiAgICB9KTtcbiAgfVxuICBoaWRlKHQpIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcbiAgICAgIGhlKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtYmFja2Ryb3Atc2hvd1wiKSwgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTBcIiksIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS01MFwiKSwgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKSwgaGUodCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0RWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdC5jbGFzc05hbWUgPSB0aGlzLl9jb25maWcuY2xhc3NOYW1lLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCAmJiB0LmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTUwXCIpLCB0aGlzLl9lbGVtZW50ID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5CZCxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCB0LnJvb3RFbGVtZW50ID0gR3QodC5yb290RWxlbWVudCksIE4obmwsIHQsIFZkKSwgdDtcbiAgfVxuICBfYXBwZW5kKCkge1xuICAgIHRoaXMuX2lzQXBwZW5kZWQgfHwgKHRoaXMuX2NvbmZpZy5yb290RWxlbWVudC5hcHBlbmQodGhpcy5fZ2V0RWxlbWVudCgpKSwgdS5vbih0aGlzLl9nZXRFbGVtZW50KCksIFdvLCAoKSA9PiB7XG4gICAgICBoZSh0aGlzLl9jb25maWcuY2xpY2tDYWxsYmFjayk7XG4gICAgfSksIHRoaXMuX2lzQXBwZW5kZWQgPSAhMCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9pc0FwcGVuZGVkICYmICh1Lm9mZih0aGlzLl9lbGVtZW50LCBXbyksIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCksIHRoaXMuX2lzQXBwZW5kZWQgPSAhMSk7XG4gIH1cbiAgX2VtdWxhdGVBbmltYXRpb24odCkge1xuICAgIHlhKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX2dldEVsZW1lbnQoKSxcbiAgICAgIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgYmkge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fdG9nZ2xlciA9IGksIHRoaXMuX2V2ZW50ID0gZS5ldmVudCB8fCBcImJsdXJcIiwgdGhpcy5fY29uZGl0aW9uID0gZS5jb25kaXRpb24gfHwgKCgpID0+ICEwKSwgdGhpcy5fc2VsZWN0b3IgPSBlLnNlbGVjdG9yIHx8ICdidXR0b24sIGEsIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLCB0aGlzLl9vbmx5VmlzaWJsZSA9IGUub25seVZpc2libGUgfHwgITEsIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzID0gW10sIHRoaXMuX2ZpcnN0RWxlbWVudCA9IG51bGwsIHRoaXMuX2xhc3RFbGVtZW50ID0gbnVsbCwgdGhpcy5oYW5kbGVyID0gKG4pID0+IHtcbiAgICAgIHRoaXMuX2NvbmRpdGlvbihuKSAmJiAhbi5zaGlmdEtleSAmJiBuLnRhcmdldCA9PT0gdGhpcy5fbGFzdEVsZW1lbnQgPyAobi5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9maXJzdEVsZW1lbnQuZm9jdXMoKSkgOiB0aGlzLl9jb25kaXRpb24obikgJiYgbi5zaGlmdEtleSAmJiBuLnRhcmdldCA9PT0gdGhpcy5fZmlyc3RFbGVtZW50ICYmIChuLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2xhc3RFbGVtZW50LmZvY3VzKCkpO1xuICAgIH07XG4gIH1cbiAgdHJhcCgpIHtcbiAgICB0aGlzLl9zZXRFbGVtZW50cygpLCB0aGlzLl9pbml0KCksIHRoaXMuX3NldEZvY3VzVHJhcCgpO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX2V2ZW50LCB0aGlzLmhhbmRsZXIpO1xuICAgIH0pLCB0aGlzLl90b2dnbGVyICYmIHRoaXMuX3RvZ2dsZXIuZm9jdXMoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fc2V0RWxlbWVudHMoKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKCk7XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAhdGhpcy5fZmlyc3RFbGVtZW50IHx8IGUua2V5ICE9PSBcIlRhYlwiIHx8IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmluY2x1ZGVzKGUudGFyZ2V0KSB8fCAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9maXJzdEVsZW1lbnQuZm9jdXMoKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHQpKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0KTtcbiAgfVxuICBfZmlsdGVyVmlzaWJsZSh0KSB7XG4gICAgcmV0dXJuIHQuZmlsdGVyKChlKSA9PiB7XG4gICAgICBpZiAoIVN0KGUpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBpID0gaC5wYXJlbnRzKGUsIFwiKlwiKTtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaS5sZW5ndGg7IG4rKykge1xuICAgICAgICBjb25zdCBvID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaVtuXSk7XG4gICAgICAgIGlmIChvICYmIChvLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IG8udmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH0pO1xuICB9XG4gIF9zZXRFbGVtZW50cygpIHtcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cyA9IGguZm9jdXNhYmxlQ2hpbGRyZW4odGhpcy5fZWxlbWVudCksIHRoaXMuX29ubHlWaXNpYmxlICYmICh0aGlzLl9mb2N1c2FibGVFbGVtZW50cyA9IHRoaXMuX2ZpbHRlclZpc2libGUodGhpcy5fZm9jdXNhYmxlRWxlbWVudHMpKSwgdGhpcy5fZmlyc3RFbGVtZW50ID0gdGhpcy5fZm9jdXNhYmxlRWxlbWVudHNbMF0sIHRoaXMuX2xhc3RFbGVtZW50ID0gdGhpcy5fZm9jdXNhYmxlRWxlbWVudHNbdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgX3NldEZvY3VzVHJhcCgpIHtcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBlID09PSB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxIHx8IGUgPT09IDAgPyB0LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fZXZlbnQsIHRoaXMuaGFuZGxlcikgOiB0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fZXZlbnQsIHRoaXMuaGFuZGxlcik7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IHhzID0gKHMsIHQgPSBcImhpZGVcIikgPT4ge1xuICBjb25zdCBlID0gYGNsaWNrLmRpc21pc3Mke3MuRVZFTlRfS0VZfWAsIGkgPSBzLk5BTUU7XG4gIHUub24oXG4gICAgZG9jdW1lbnQsXG4gICAgZSxcbiAgICBgW2RhdGEtdGUtJHtpfS1kaXNtaXNzXWAsXG4gICAgZnVuY3Rpb24obikge1xuICAgICAgaWYgKFtcIkFcIiwgXCJBUkVBXCJdLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkgJiYgbi5wcmV2ZW50RGVmYXVsdCgpLCB1ZSh0aGlzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbyA9IFh0KHRoaXMpIHx8IHRoaXMuY2xvc2VzdChgLiR7aX1gKSB8fCB0aGlzLmNsb3Nlc3QoYFtkYXRhLXRlLSR7aX0taW5pdF1gKTtcbiAgICAgIGlmICghbylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcy5nZXRPckNyZWF0ZUluc3RhbmNlKG8pW3RdKCk7XG4gICAgfVxuICApO1xufSwgRm8gPSBcIm9mZmNhbnZhc1wiLCBXZCA9IFwidGUub2ZmY2FudmFzXCIsIEtlID0gYC4ke1dkfWAsIEZkID0gXCIuZGF0YS1hcGlcIiwgWWQgPSBgbG9hZCR7S2V9JHtGZH1gLCBqZCA9IFwiRXNjYXBlXCIsIFlvID0ge1xuICBiYWNrZHJvcDogITAsXG4gIGtleWJvYXJkOiAhMCxcbiAgc2Nyb2xsOiAhMVxufSwgS2QgPSB7XG4gIGJhY2tkcm9wOiBcImJvb2xlYW5cIixcbiAga2V5Ym9hcmQ6IFwiYm9vbGVhblwiLFxuICBzY3JvbGw6IFwiYm9vbGVhblwiXG59LCBqbyA9IFwic2hvd1wiLCBVZCA9IFwiW2RhdGEtdGUtb2ZmY2FudmFzLWluaXRdW2RhdGEtdGUtb2ZmY2FudmFzLXNob3ddXCIsIHpkID0gYHNob3cke0tlfWAsIFhkID0gYHNob3duJHtLZX1gLCBHZCA9IGBoaWRlJHtLZX1gLCBxZCA9IGBoaWRkZW4ke0tlfWAsIFFkID0gYGtleWRvd24uZGlzbWlzcyR7S2V9YDtcbmNsYXNzIHJzIGV4dGVuZHMgdnQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCksIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBGbztcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFlvO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUodCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3codCk7XG4gIH1cbiAgc2hvdyh0KSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHpkLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc1Nob3duID0gITAsIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiLCB0aGlzLl9iYWNrZHJvcC5zaG93KCksIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgbmV3IHBpKCkuaGlkZSgpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwgITApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLXRlLW9mZmNhbnZhcy0ke2pvfWAsIFwiXCIpO1xuICAgIGNvbnN0IGkgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcuc2Nyb2xsIHx8IHRoaXMuX2ZvY3VzdHJhcC50cmFwKCksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBYZCwgeyByZWxhdGVkVGFyZ2V0OiB0IH0pO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhpLCB0aGlzLl9lbGVtZW50LCAhMCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEdkKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHRoaXMuX2VsZW1lbnQuYmx1cigpLCB0aGlzLl9pc1Nob3duID0gITEsIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGBkYXRhLXRlLW9mZmNhbnZhcy0ke2pvfWApLCB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKSwgdGhpcy5fZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgdGhpcy5fY29uZmlnLnNjcm9sbCB8fCBuZXcgcGkoKS5yZXNldCgpLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgcWQpO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhlLCB0aGlzLl9lbGVtZW50LCAhMCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKHUub24oXG4gICAgICB3aW5kb3csXG4gICAgICBZZCxcbiAgICAgICgpID0+IGguZmluZChVZCkuZm9yRWFjaChcbiAgICAgICAgKHQpID0+IHJzLmdldE9yQ3JlYXRlSW5zdGFuY2UodCkuc2hvdygpXG4gICAgICApXG4gICAgKSwgeHMocnMpLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uWW8sXG4gICAgICAuLi5wLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIE4oRm8sIHQsIEtkKSwgdDtcbiAgfVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgbG8oe1xuICAgICAgaXNWaXNpYmxlOiB0aGlzLl9jb25maWcuYmFja2Ryb3AsXG4gICAgICBpc0FuaW1hdGVkOiAhMCxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICBjbGlja0NhbGxiYWNrOiAoKSA9PiB0aGlzLmhpZGUoKVxuICAgIH0pO1xuICB9XG4gIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgIHJldHVybiBuZXcgYmkodGhpcy5fZWxlbWVudCwge1xuICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgY29uZGl0aW9uOiAodCkgPT4gdC5rZXkgPT09IFwiVGFiXCJcbiAgICB9KTtcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdS5vbih0aGlzLl9lbGVtZW50LCBRZCwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gamQgJiYgdGhpcy5oaWRlKCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gcnMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChlW3RdID09PSB2b2lkIDAgfHwgdC5zdGFydHNXaXRoKFwiX1wiKSB8fCB0ID09PSBcImNvbnN0cnVjdG9yXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEdzID0gXCJhbGVydFwiLCBaZCA9IFwidGUuYWxlcnRcIiwgb2wgPSBgLiR7WmR9YCwgSmQgPSBgY2xvc2Uke29sfWAsIHRoID0gYGNsb3NlZCR7b2x9YCwgR2UgPSBcImRhdGEtdGUtYWxlcnQtc2hvd1wiLCBlaCA9IHtcbiAgYW5pbWF0aW9uOiBcImJvb2xlYW5cIixcbiAgYXV0b2hpZGU6IFwiYm9vbGVhblwiLFxuICBkZWxheTogXCJudW1iZXJcIlxufSwgS28gPSB7XG4gIGFuaW1hdGlvbjogITAsXG4gIGF1dG9oaWRlOiAhMCxcbiAgZGVsYXk6IDFlM1xufSwgaWggPSB7XG4gIGZhZGVJbjogXCJhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF0gcC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIixcbiAgZmFkZU91dDogXCJhbmltYXRlLVtmYWRlLW91dF8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCJcbn0sIHNoID0ge1xuICBmYWRlSW46IFwic3RyaW5nXCIsXG4gIGZhZGVPdXQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBSbiBleHRlbmRzIHZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBlaDtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIEtvO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gR3M7XG4gIH1cbiAgLy8gUHVibGljXG4gIGNsb3NlKCkge1xuICAgIGlmICh1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgSmQpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGUgPSAwO1xuICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKGUgPSAzMDAsIHAuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKEdlKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKFxuICAgICAgICAoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLFxuICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICB0aGlzLl9jb25maWcuYW5pbWF0aW9uXG4gICAgICApO1xuICAgIH0sIGUpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2hpZGUgJiYgdGhpcy5fc2V0dXBBdXRvaGlkZSgpLCAhdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoR2UpICYmIChwLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIFwiaGlkZGVuXCIpLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIFwiYmxvY2tcIiksIFN0KHRoaXMuX2VsZW1lbnQpKSkge1xuICAgICAgICBjb25zdCB0ID0gKGUpID0+IHtcbiAgICAgICAgICBwLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIFwiaGlkZGVuXCIpLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIFwiYmxvY2tcIiksIHUub2ZmKGUudGFyZ2V0LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoR2UsIFwiXCIpLCB1Lm9uKHRoaXMuX2VsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsIHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiAocC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSk7XG4gICAgfVxuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQgJiYgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoR2UpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShHZSk7XG4gICAgICBjb25zdCB0ID0gKGUpID0+IHtcbiAgICAgICAgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgcC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCB0aGlzLl90aW1lb3V0ICE9PSBudWxsICYmIChjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksIHRoaXMuX3RpbWVvdXQgPSBudWxsKSwgdS5vZmYoZS50YXJnZXQsIFwiYW5pbWF0aW9uZW5kXCIsIHQpO1xuICAgICAgfTtcbiAgICAgIHUub24odGhpcy5fZWxlbWVudCwgXCJhbmltYXRpb25lbmRcIiwgdCksIHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCk7XG4gICAgfVxuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoeHMoUm4sIFwiY2xvc2VcIiksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5LbyxcbiAgICAgIC4uLnAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgPyB0IDoge31cbiAgICB9LCBOKEdzLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmloLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKEdzLCB0LCBzaCksIHQ7XG4gIH1cbiAgX3NldHVwQXV0b2hpZGUoKSB7XG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KTtcbiAgfVxuICBfZGVzdHJveUVsZW1lbnQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKSwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoKSwgdGhpcy5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gUm4uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChlW3RdID09PSB2b2lkIDAgfHwgdC5zdGFydHNXaXRoKFwiX1wiKSB8fCB0ID09PSBcImNvbnN0cnVjdG9yXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IHFzID0gXCJjYXJvdXNlbFwiLCBuaCA9IFwidGUuY2Fyb3VzZWxcIiwgcHQgPSBgLiR7bmh9YCwgcmwgPSBcIi5kYXRhLWFwaVwiLCBvaCA9IFwiQXJyb3dMZWZ0XCIsIHJoID0gXCJBcnJvd1JpZ2h0XCIsIGFoID0gNTAwLCBsaCA9IDQwLCBVbyA9IHtcbiAgaW50ZXJ2YWw6IDVlMyxcbiAga2V5Ym9hcmQ6ICEwLFxuICBzbGlkZTogITEsXG4gIHBhdXNlOiBcImhvdmVyXCIsXG4gIHdyYXA6ICEwLFxuICB0b3VjaDogITBcbn0sIGNoID0ge1xuICBpbnRlcnZhbDogXCIobnVtYmVyfGJvb2xlYW4pXCIsXG4gIGtleWJvYXJkOiBcImJvb2xlYW5cIixcbiAgc2xpZGU6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBwYXVzZTogXCIoc3RyaW5nfGJvb2xlYW4pXCIsXG4gIHdyYXA6IFwiYm9vbGVhblwiLFxuICB0b3VjaDogXCJib29sZWFuXCJcbn0sIGRoID0ge1xuICBwb2ludGVyOiBcInRvdWNoLXBhbi15XCIsXG4gIGJsb2NrOiBcIiFibG9ja1wiLFxuICB2aXNpYmxlOiBcImRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOm9wYWNpdHktMTAwIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOnotWzFdXCIsXG4gIGludmlzaWJsZTogXCJkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTp6LTAgZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06b3BhY2l0eS0wIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOmR1cmF0aW9uLTAgZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06ZGVsYXktNjAwXCIsXG4gIHNsaWRlUmlnaHQ6IFwidHJhbnNsYXRlLXgtZnVsbFwiLFxuICBzbGlkZUxlZnQ6IFwiLXRyYW5zbGF0ZS14LWZ1bGxcIlxufSwgaGggPSB7XG4gIHBvaW50ZXI6IFwic3RyaW5nXCIsXG4gIGJsb2NrOiBcInN0cmluZ1wiLFxuICB2aXNpYmxlOiBcInN0cmluZ1wiLFxuICBpbnZpc2libGU6IFwic3RyaW5nXCIsXG4gIHNsaWRlUmlnaHQ6IFwic3RyaW5nXCIsXG4gIHNsaWRlTGVmdDogXCJzdHJpbmdcIlxufSwgc2UgPSBcIm5leHRcIiwgbmUgPSBcInByZXZcIiwgY2UgPSBcImxlZnRcIiwgc2kgPSBcInJpZ2h0XCIsIHVoID0ge1xuICBbb2hdOiBzaSxcbiAgW3JoXTogY2Vcbn0sIHBoID0gYHNsaWRlJHtwdH1gLCB6byA9IGBzbGlkJHtwdH1gLCBmaCA9IGBrZXlkb3duJHtwdH1gLCBfaCA9IGBtb3VzZWVudGVyJHtwdH1gLCBtaCA9IGBtb3VzZWxlYXZlJHtwdH1gLCBnaCA9IGB0b3VjaHN0YXJ0JHtwdH1gLCBiaCA9IGB0b3VjaG1vdmUke3B0fWAsIHZoID0gYHRvdWNoZW5kJHtwdH1gLCBFaCA9IGBwb2ludGVyZG93biR7cHR9YCwgVGggPSBgcG9pbnRlcnVwJHtwdH1gLCBDaCA9IGBkcmFnc3RhcnQke3B0fWAsIEFoID0gYGxvYWQke3B0fSR7cmx9YCwgeWggPSBgY2xpY2ske3B0fSR7cmx9YCwgd2ggPSBcImRhdGEtdGUtY2Fyb3VzZWwtaW5pdFwiLCBvZSA9IFwiZGF0YS10ZS1jYXJvdXNlbC1hY3RpdmVcIiwga2ggPSBcImRhdGEtdGUtY2Fyb3VzZWwtc2xpZGVcIiwgT2ggPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1lbmRcIiwgUXMgPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1zdGFydFwiLCB4aCA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pdGVtLW5leHRcIiwgU2ggPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1wcmV2XCIsIERoID0gXCJkYXRhLXRlLWNhcm91c2VsLXBvaW50ZXItZXZlbnRcIiwgSWggPSBcIltkYXRhLXRlLWNhcm91c2VsLWluaXRdXCIsIGFsID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1hY3RpdmVdXCIsIGNvID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1pdGVtXVwiLCB2ZSA9IGAke2FsfSR7Y299YCwgJGggPSBgJHtjb30gaW1nYCwgTGggPSBcIltkYXRhLXRlLWNhcm91c2VsLWl0ZW0tbmV4dF0sIFtkYXRhLXRlLWNhcm91c2VsLWl0ZW0tcHJldl1cIiwgTWggPSBcIltkYXRhLXRlLWNhcm91c2VsLWluZGljYXRvcnNdXCIsIE5oID0gXCJbZGF0YS10ZS10YXJnZXRdXCIsIFJoID0gXCJbZGF0YS10ZS1zbGlkZV0sIFtkYXRhLXRlLXNsaWRlLXRvXVwiLCBQaCA9IFwidG91Y2hcIiwgSGggPSBcInBlblwiO1xuY2xhc3MgWXQgZXh0ZW5kcyB2dCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5faXRlbXMgPSBudWxsLCB0aGlzLl9pbnRlcnZhbCA9IG51bGwsIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsLCB0aGlzLl9pc1BhdXNlZCA9ICExLCB0aGlzLl9pc1NsaWRpbmcgPSAhMSwgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsLCB0aGlzLnRvdWNoU3RhcnRYID0gMCwgdGhpcy50b3VjaERlbHRhWCA9IDAsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gaC5maW5kT25lKFxuICAgICAgTWgsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fdG91Y2hTdXBwb3J0ZWQgPSBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwLCB0aGlzLl9wb2ludGVyRXZlbnQgPSAhIXdpbmRvdy5Qb2ludGVyRXZlbnQsIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRDbGFzcygpLCB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gVW87XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBxcztcbiAgfVxuICAvLyBQdWJsaWNcbiAgbmV4dCgpIHtcbiAgICB0aGlzLl9zbGlkZShzZSk7XG4gIH1cbiAgbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgICFkb2N1bWVudC5oaWRkZW4gJiYgU3QodGhpcy5fZWxlbWVudCkgJiYgdGhpcy5uZXh0KCk7XG4gIH1cbiAgcHJldigpIHtcbiAgICB0aGlzLl9zbGlkZShuZSk7XG4gIH1cbiAgcGF1c2UodCkge1xuICAgIHQgfHwgKHRoaXMuX2lzUGF1c2VkID0gITApLCBoLmZpbmRPbmUoTGgsIHRoaXMuX2VsZW1lbnQpICYmIChFYSh0aGlzLl9lbGVtZW50KSwgdGhpcy5jeWNsZSghMCkpLCBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICB9XG4gIGN5Y2xlKHQpIHtcbiAgICB0IHx8ICh0aGlzLl9pc1BhdXNlZCA9ICExKSwgdGhpcy5faW50ZXJ2YWwgJiYgKGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCB0aGlzLl9pbnRlcnZhbCA9IG51bGwpLCB0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLmludGVydmFsICYmICF0aGlzLl9pc1BhdXNlZCAmJiAodGhpcy5fdXBkYXRlSW50ZXJ2YWwoKSwgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPyB0aGlzLm5leHRXaGVuVmlzaWJsZSA6IHRoaXMubmV4dCkuYmluZChcbiAgICAgICAgdGhpc1xuICAgICAgKSxcbiAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxuICAgICkpO1xuICB9XG4gIHRvKHQpIHtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gaC5maW5kT25lKFxuICAgICAgdmUsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2FjdGl2ZUVsZW1lbnQpO1xuICAgIGlmICh0ID4gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSB8fCB0IDwgMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICB1Lm9uZSh0aGlzLl9lbGVtZW50LCB6bywgKCkgPT4gdGhpcy50byh0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlID09PSB0KSB7XG4gICAgICB0aGlzLnBhdXNlKCksIHRoaXMuY3ljbGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaSA9IHQgPiBlID8gc2UgOiBuZTtcbiAgICB0aGlzLl9zbGlkZShpLCB0aGlzLl9pdGVtc1t0XSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8ICh1Lm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICB5aCxcbiAgICAgIFJoLFxuICAgICAgWXQuZGF0YUFwaUNsaWNrSGFuZGxlclxuICAgICksIHUub24od2luZG93LCBBaCwgKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IGguZmluZChJaCk7XG4gICAgICBmb3IgKGxldCBlID0gMCwgaSA9IHQubGVuZ3RoOyBlIDwgaTsgZSsrKVxuICAgICAgICBZdC5jYXJvdXNlbEludGVyZmFjZShcbiAgICAgICAgICB0W2VdLFxuICAgICAgICAgIFl0LmdldEluc3RhbmNlKHRbZV0pXG4gICAgICAgICk7XG4gICAgfSksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5VbyxcbiAgICAgIC4uLnAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgTihxcywgdCwgY2gpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZGgsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4ocXMsIHQsIGhoKSwgdDtcbiAgfVxuICBfYXBwbHlJbml0aWFsQ2xhc3NlcygpIHtcbiAgICBjb25zdCB0ID0gaC5maW5kT25lKFxuICAgICAgdmUsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICB0LmNsYXNzTGlzdC5hZGQoXG4gICAgICB0aGlzLl9jbGFzc2VzLmJsb2NrLFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKVxuICAgICksIHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQodCk7XG4gIH1cbiAgX2hhbmRsZVN3aXBlKCkge1xuICAgIGNvbnN0IHQgPSBNYXRoLmFicyh0aGlzLnRvdWNoRGVsdGFYKTtcbiAgICBpZiAodCA8PSBsaClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdCAvIHRoaXMudG91Y2hEZWx0YVg7XG4gICAgdGhpcy50b3VjaERlbHRhWCA9IDAsIGUgJiYgdGhpcy5fc2xpZGUoZSA+IDAgPyBzaSA6IGNlKTtcbiAgfVxuICBfc2V0QWN0aXZlRWxlbWVudENsYXNzKCkge1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBoLmZpbmRPbmUoXG4gICAgICB2ZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBwLmFkZENsYXNzKHRoaXMuX2FjdGl2ZUVsZW1lbnQsIFwiaGlkZGVuXCIpO1xuICB9XG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBmaCxcbiAgICAgICh0KSA9PiB0aGlzLl9rZXlkb3duKHQpXG4gICAgKSwgdGhpcy5fY29uZmlnLnBhdXNlID09PSBcImhvdmVyXCIgJiYgKHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgX2gsXG4gICAgICAodCkgPT4gdGhpcy5wYXVzZSh0KVxuICAgICksIHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgbWgsXG4gICAgICAodCkgPT4gdGhpcy5jeWNsZSh0KVxuICAgICkpLCB0aGlzLl9jb25maWcudG91Y2ggJiYgdGhpcy5fdG91Y2hTdXBwb3J0ZWQgJiYgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpLCB0aGlzLl9hcHBseUluaXRpYWxDbGFzc2VzKCk7XG4gIH1cbiAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdCA9IChvKSA9PiB0aGlzLl9wb2ludGVyRXZlbnQgJiYgKG8ucG9pbnRlclR5cGUgPT09IEhoIHx8IG8ucG9pbnRlclR5cGUgPT09IFBoKSwgZSA9IChvKSA9PiB7XG4gICAgICB0KG8pID8gdGhpcy50b3VjaFN0YXJ0WCA9IG8uY2xpZW50WCA6IHRoaXMuX3BvaW50ZXJFdmVudCB8fCAodGhpcy50b3VjaFN0YXJ0WCA9IG8udG91Y2hlc1swXS5jbGllbnRYKTtcbiAgICB9LCBpID0gKG8pID0+IHtcbiAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBvLnRvdWNoZXMgJiYgby50b3VjaGVzLmxlbmd0aCA+IDEgPyAwIDogby50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYO1xuICAgIH0sIG4gPSAobykgPT4ge1xuICAgICAgdChvKSAmJiAodGhpcy50b3VjaERlbHRhWCA9IG8uY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFgpLCB0aGlzLl9oYW5kbGVTd2lwZSgpLCB0aGlzLl9jb25maWcucGF1c2UgPT09IFwiaG92ZXJcIiAmJiAodGhpcy5wYXVzZSgpLCB0aGlzLnRvdWNoVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpLCB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgIChyKSA9PiB0aGlzLmN5Y2xlKHIpLFxuICAgICAgICBhaCArIHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxuICAgICAgKSk7XG4gICAgfTtcbiAgICBoLmZpbmQoJGgsIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goXG4gICAgICAobykgPT4ge1xuICAgICAgICB1Lm9uKFxuICAgICAgICAgIG8sXG4gICAgICAgICAgQ2gsXG4gICAgICAgICAgKHIpID0+IHIucHJldmVudERlZmF1bHQoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICksIHRoaXMuX3BvaW50ZXJFdmVudCA/ICh1Lm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIEVoLFxuICAgICAgKG8pID0+IGUobylcbiAgICApLCB1Lm9uKHRoaXMuX2VsZW1lbnQsIFRoLCAobykgPT4gbihvKSksIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLnBvaW50ZXIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShgJHtEaH1gLCBcIlwiKSkgOiAodS5vbih0aGlzLl9lbGVtZW50LCBnaCwgKG8pID0+IGUobykpLCB1Lm9uKHRoaXMuX2VsZW1lbnQsIGJoLCAobykgPT4gaShvKSksIHUub24odGhpcy5fZWxlbWVudCwgdmgsIChvKSA9PiBuKG8pKSk7XG4gIH1cbiAgX2tleWRvd24odCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB1aFt0LmtleV07XG4gICAgZSAmJiAodC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9zbGlkZShlKSk7XG4gIH1cbiAgX2dldEl0ZW1JbmRleCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zID0gdCAmJiB0LnBhcmVudE5vZGUgPyBoLmZpbmQoY28sIHQucGFyZW50Tm9kZSkgOiBbXSwgdGhpcy5faXRlbXMuaW5kZXhPZih0KTtcbiAgfVxuICBfZ2V0SXRlbUJ5T3JkZXIodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0ID09PSBzZTtcbiAgICByZXR1cm4gd2EoXG4gICAgICB0aGlzLl9pdGVtcyxcbiAgICAgIGUsXG4gICAgICBpLFxuICAgICAgdGhpcy5fY29uZmlnLndyYXBcbiAgICApO1xuICB9XG4gIF90cmlnZ2VyU2xpZGVFdmVudCh0LCBlKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2dldEl0ZW1JbmRleCh0KSwgbiA9IHRoaXMuX2dldEl0ZW1JbmRleChcbiAgICAgIGguZmluZE9uZSh2ZSwgdGhpcy5fZWxlbWVudClcbiAgICApO1xuICAgIHJldHVybiB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgcGgsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHQsXG4gICAgICBkaXJlY3Rpb246IGUsXG4gICAgICBmcm9tOiBuLFxuICAgICAgdG86IGlcbiAgICB9KTtcbiAgfVxuICBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCh0KSB7XG4gICAgaWYgKHRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XG4gICAgICBjb25zdCBlID0gaC5maW5kT25lKFxuICAgICAgICBhbCxcbiAgICAgICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnRcbiAgICAgICk7XG4gICAgICBlLnJlbW92ZUF0dHJpYnV0ZShvZSksIGUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1jdXJyZW50XCIpLCBlLmNsYXNzTGlzdC5yZW1vdmUoXCIhb3BhY2l0eS0xMDBcIik7XG4gICAgICBjb25zdCBpID0gaC5maW5kKFxuICAgICAgICBOaCxcbiAgICAgICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnRcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGkubGVuZ3RoOyBuKyspXG4gICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoXG4gICAgICAgICAgaVtuXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNsaWRlLXRvXCIpLFxuICAgICAgICAgIDEwXG4gICAgICAgICkgPT09IHRoaXMuX2dldEl0ZW1JbmRleCh0KSkge1xuICAgICAgICAgIGlbbl0uc2V0QXR0cmlidXRlKGAke29lfWAsIFwiXCIpLCBpW25dLnNldEF0dHJpYnV0ZShcImFyaWEtY3VycmVudFwiLCBcInRydWVcIiksIGlbbl0uY2xhc3NMaXN0LmFkZChcIiFvcGFjaXR5LTEwMFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBfdXBkYXRlSW50ZXJ2YWwoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2FjdGl2ZUVsZW1lbnQgfHwgaC5maW5kT25lKHZlLCB0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IE51bWJlci5wYXJzZUludChcbiAgICAgIHQuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1pbnRlcnZhbFwiKSxcbiAgICAgIDEwXG4gICAgKTtcbiAgICBlID8gKHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgPSB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5pbnRlcnZhbCwgdGhpcy5fY29uZmlnLmludGVydmFsID0gZSkgOiB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5pbnRlcnZhbDtcbiAgfVxuICBfc2xpZGUodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKHQpLCBuID0gaC5maW5kT25lKFxuICAgICAgdmUsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgbyA9IHRoaXMuX2dldEl0ZW1JbmRleChuKSwgciA9IGUgfHwgdGhpcy5fZ2V0SXRlbUJ5T3JkZXIoaSwgbiksIGEgPSB0aGlzLl9nZXRJdGVtSW5kZXgociksIGwgPSAhIXRoaXMuX2ludGVydmFsLCBjID0gaSA9PT0gc2UsIGQgPSBjID8gUXMgOiBPaCwgXyA9IGMgPyB4aCA6IFNoLCBmID0gdGhpcy5fb3JkZXJUb0RpcmVjdGlvbihpKSwgbSA9IGQgPT09IFFzID8gdGhpcy5fY2xhc3Nlcy5zbGlkZUxlZnQgOiB0aGlzLl9jbGFzc2VzLnNsaWRlUmlnaHQsIGcgPSBkICE9PSBRcyA/IHRoaXMuX2NsYXNzZXMuc2xpZGVMZWZ0IDogdGhpcy5fY2xhc3Nlcy5zbGlkZVJpZ2h0O1xuICAgIGlmIChyICYmIHIuaGFzQXR0cmlidXRlKG9lKSkge1xuICAgICAgdGhpcy5faXNTbGlkaW5nID0gITE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcgfHwgdGhpcy5fdHJpZ2dlclNsaWRlRXZlbnQociwgZikuZGVmYXVsdFByZXZlbnRlZCB8fCAhbiB8fCAhcilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc1NsaWRpbmcgPSAhMCwgbCAmJiB0aGlzLnBhdXNlKCksIHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQociksIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSByO1xuICAgIGNvbnN0IFQgPSAoKSA9PiB7XG4gICAgICB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgem8sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcixcbiAgICAgICAgZGlyZWN0aW9uOiBmLFxuICAgICAgICBmcm9tOiBvLFxuICAgICAgICB0bzogYVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoa2gpKSB7XG4gICAgICByLnNldEF0dHJpYnV0ZShgJHtffWAsIFwiXCIpLCByLmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5ibG9jaywgZyksIEZlKHIpLCBuLnNldEF0dHJpYnV0ZShgJHtkfWAsIFwiXCIpLCBuLmNsYXNzTGlzdC5hZGQoXG4gICAgICAgIG0sXG4gICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW52aXNpYmxlLnNwbGl0KFwiIFwiKVxuICAgICAgKSwgbi5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMudmlzaWJsZS5zcGxpdChcIiBcIikpLCByLnNldEF0dHJpYnV0ZShgJHtkfWAsIFwiXCIpLCByLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKSksIHIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgdGhpcy5fY2xhc3Nlcy5zbGlkZVJpZ2h0LFxuICAgICAgICB0aGlzLl9jbGFzc2VzLnNsaWRlTGVmdFxuICAgICAgKTtcbiAgICAgIGNvbnN0IEMgPSAoKSA9PiB7XG4gICAgICAgIHIucmVtb3ZlQXR0cmlidXRlKGQpLCByLnJlbW92ZUF0dHJpYnV0ZShfKSwgci5zZXRBdHRyaWJ1dGUoYCR7b2V9YCwgXCJcIiksIG4ucmVtb3ZlQXR0cmlidXRlKG9lKSwgbi5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAgIG0sXG4gICAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnZpc2libGUuc3BsaXQoXCIgXCIpLFxuICAgICAgICAgIHRoaXMuX2NsYXNzZXMuYmxvY2tcbiAgICAgICAgKSwgbi5yZW1vdmVBdHRyaWJ1dGUoXyksIG4ucmVtb3ZlQXR0cmlidXRlKGQpLCB0aGlzLl9pc1NsaWRpbmcgPSAhMSwgc2V0VGltZW91dChULCAwKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKEMsIG4sICEwKTtcbiAgICB9IGVsc2VcbiAgICAgIG4ucmVtb3ZlQXR0cmlidXRlKG9lKSwgbi5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2NsYXNzZXMuYmxvY2spLCByLnNldEF0dHJpYnV0ZShgJHtvZX1gLCBcIlwiKSwgci5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMuYmxvY2spLCB0aGlzLl9pc1NsaWRpbmcgPSAhMSwgVCgpO1xuICAgIGwgJiYgdGhpcy5jeWNsZSgpO1xuICB9XG4gIF9kaXJlY3Rpb25Ub09yZGVyKHQpIHtcbiAgICByZXR1cm4gW3NpLCBjZV0uaW5jbHVkZXModCkgPyBGKCkgPyB0ID09PSBjZSA/IG5lIDogc2UgOiB0ID09PSBjZSA/IHNlIDogbmUgOiB0O1xuICB9XG4gIF9vcmRlclRvRGlyZWN0aW9uKHQpIHtcbiAgICByZXR1cm4gW3NlLCBuZV0uaW5jbHVkZXModCkgPyBGKCkgPyB0ID09PSBuZSA/IGNlIDogc2kgOiB0ID09PSBuZSA/IHNpIDogY2UgOiB0O1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgY2Fyb3VzZWxJbnRlcmZhY2UodCwgZSkge1xuICAgIGNvbnN0IGkgPSBZdC5nZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUpO1xuICAgIGxldCB7IF9jb25maWc6IG4gfSA9IGk7XG4gICAgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiAobiA9IHtcbiAgICAgIC4uLm4sXG4gICAgICAuLi5lXG4gICAgfSk7XG4gICAgY29uc3QgbyA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogbi5zbGlkZTtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICAgIGkudG8oZSk7XG4gICAgZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHR5cGVvZiBpW29dID4gXCJ1XCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7b31cImApO1xuICAgICAgaVtvXSgpO1xuICAgIH0gZWxzZVxuICAgICAgbi5pbnRlcnZhbCAmJiBuLmNhcm91c2VsSW5pdCA9PT0gbnVsbCAmJiAoaS5wYXVzZSgpLCBpLmN5Y2xlKCkpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBZdC5jYXJvdXNlbEludGVyZmFjZSh0aGlzLCB0KTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZGF0YUFwaUNsaWNrSGFuZGxlcih0KSB7XG4gICAgY29uc3QgZSA9IFh0KHRoaXMpO1xuICAgIGlmICghZSB8fCAhZS5oYXNBdHRyaWJ1dGUod2gpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB7XG4gICAgICAuLi5wLmdldERhdGFBdHRyaWJ1dGVzKGUpLFxuICAgICAgLi4ucC5nZXREYXRhQXR0cmlidXRlcyh0aGlzKVxuICAgIH0sIG4gPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdGUtc2xpZGUtdG9cIik7XG4gICAgbiAmJiAoaS5pbnRlcnZhbCA9ICExKSwgWXQuY2Fyb3VzZWxJbnRlcmZhY2UoZSwgaSksIG4gJiYgWXQuZ2V0SW5zdGFuY2UoZSkudG8obiksIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuY29uc3QgWnMgPSBcIm1vZGFsXCIsIEJoID0gXCJ0ZS5tb2RhbFwiLCBFdCA9IGAuJHtCaH1gLCBYbyA9IFwiRXNjYXBlXCIsIEdvID0ge1xuICBiYWNrZHJvcDogITAsXG4gIGtleWJvYXJkOiAhMCxcbiAgZm9jdXM6ICEwXG59LCBWaCA9IHtcbiAgYmFja2Ryb3A6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBrZXlib2FyZDogXCJib29sZWFuXCIsXG4gIGZvY3VzOiBcImJvb2xlYW5cIlxufSwgV2ggPSB7XG4gIHNob3c6IFwidHJhbnNmb3JtLW5vbmVcIixcbiAgc3RhdGljOiBcInNjYWxlLVsxLjAyXVwiLFxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInRyYW5zaXRpb24tc2NhbGUgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0XCJcbn0sIEZoID0ge1xuICBzaG93OiBcInN0cmluZ1wiLFxuICBzdGF0aWM6IFwic3RyaW5nXCIsXG4gIHN0YXRpY1Byb3BlcnRpZXM6IFwic3RyaW5nXCJcbn0sIFloID0gYGhpZGUke0V0fWAsIGpoID0gYGhpZGVQcmV2ZW50ZWQke0V0fWAsIEtoID0gYGhpZGRlbiR7RXR9YCwgVWggPSBgc2hvdyR7RXR9YCwgemggPSBgc2hvd24ke0V0fWAsIHFvID0gYHJlc2l6ZSR7RXR9YCwgUW8gPSBgY2xpY2suZGlzbWlzcyR7RXR9YCwgWm8gPSBga2V5ZG93bi5kaXNtaXNzJHtFdH1gLCBYaCA9IGBtb3VzZXVwLmRpc21pc3Mke0V0fWAsIEpvID0gYG1vdXNlZG93bi5kaXNtaXNzJHtFdH1gLCB0ciA9IFwiZGF0YS10ZS1tb2RhbC1vcGVuXCIsIGVyID0gXCJkYXRhLXRlLW9wZW5cIiwgcWUgPSBcIltkYXRhLXRlLW1vZGFsLWRpYWxvZy1yZWZdXCIsIEdoID0gXCJbZGF0YS10ZS1tb2RhbC1ib2R5LXJlZl1cIjtcbmNsYXNzIFBuIGV4dGVuZHMgdnQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2RpYWxvZyA9IGguZmluZE9uZShxZSwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCksIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gITEsIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9zY3JvbGxCYXIgPSBuZXcgcGkoKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIEdvO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gWnM7XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyh0KTtcbiAgfVxuICBzaG93KHQpIHtcbiAgICB0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVWgsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkIHx8ICh0aGlzLl9pc1Nob3duID0gITAsIHRoaXMuX2lzQW5pbWF0ZWQoKSAmJiAodGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITApLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpLCBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZSh0ciwgXCJ0cnVlXCIpLCB0aGlzLl9hZGp1c3REaWFsb2coKSwgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKSwgdGhpcy5fc2V0UmVzaXplRXZlbnQoKSwgdS5vbih0aGlzLl9kaWFsb2csIEpvLCAoKSA9PiB7XG4gICAgICB1Lm9uZSh0aGlzLl9lbGVtZW50LCBYaCwgKGkpID0+IHtcbiAgICAgICAgaS50YXJnZXQgPT09IHRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMCk7XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy5fc2hvd0VsZW1lbnQodCksIHRoaXMuX3Nob3dCYWNrZHJvcCgpKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFloKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2hvd24gPSAhMTtcbiAgICBjb25zdCBlID0gdGhpcy5faXNBbmltYXRlZCgpO1xuICAgIGUgJiYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICEwKSwgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKSwgdGhpcy5fc2V0UmVzaXplRXZlbnQoKSwgdGhpcy5fZm9jdXN0cmFwLmRpc2FibGUoKSwgaC5maW5kT25lKHFlLCB0aGlzLl9lbGVtZW50KS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc2hvdyksIHUub2ZmKHRoaXMuX2VsZW1lbnQsIFFvKSwgdS5vZmYodGhpcy5fZGlhbG9nLCBKbyksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIGUpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShlcik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBbd2luZG93LCB0aGlzLl9kaWFsb2ddLmZvckVhY2goXG4gICAgICAodCkgPT4gdS5vZmYodCwgRXQpXG4gICAgKSwgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgaGFuZGxlVXBkYXRlKCkge1xuICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoeHMoUG4pLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XG4gICAgcmV0dXJuIG5ldyBsbyh7XG4gICAgICBpc1Zpc2libGU6ICEhdGhpcy5fY29uZmlnLmJhY2tkcm9wLFxuICAgICAgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlXG4gICAgICBpc0FuaW1hdGVkOiB0aGlzLl9pc0FuaW1hdGVkKClcbiAgICB9KTtcbiAgfVxuICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcbiAgICByZXR1cm4gbmV3IGJpKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIGV2ZW50OiBcImtleWRvd25cIixcbiAgICAgIGNvbmRpdGlvbjogKHQpID0+IHQua2V5ID09PSBcIlRhYlwiXG4gICAgfSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5HbyxcbiAgICAgIC4uLnAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgTihacywgdCwgVmgpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uV2gsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4oWnMsIHQsIEZoKSwgdDtcbiAgfVxuICBfc2hvd0VsZW1lbnQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9pc0FuaW1hdGVkKCksIGkgPSBoLmZpbmRPbmUoR2gsIHRoaXMuX2RpYWxvZyk7XG4gICAgKCF0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgfHwgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkgJiYgZG9jdW1lbnQuYm9keS5hcHBlbmQodGhpcy5fZWxlbWVudCksIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIiwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwgITApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGAke2VyfWAsIFwidHJ1ZVwiKSwgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgIGNvbnN0IG4gPSBoLmZpbmRPbmUocWUsIHRoaXMuX2VsZW1lbnQpO1xuICAgIG4uY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLnNob3cpLCBuLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTBcIiksIG4uY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMTAwXCIpLCBpICYmIChpLnNjcm9sbFRvcCA9IDApLCBlICYmIEZlKHRoaXMuX2VsZW1lbnQpO1xuICAgIGNvbnN0IG8gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcuZm9jdXMgJiYgdGhpcy5fZm9jdXN0cmFwLnRyYXAoKSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB6aCwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2sobywgdGhpcy5fZGlhbG9nLCBlKTtcbiAgfVxuICBfc2V0RXNjYXBlRXZlbnQoKSB7XG4gICAgdGhpcy5faXNTaG93biA/IHUub24oZG9jdW1lbnQsIFpvLCAodCkgPT4ge1xuICAgICAgdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIHQua2V5ID09PSBYbyA/ICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuaGlkZSgpKSA6ICF0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdC5rZXkgPT09IFhvICYmIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICB9KSA6IHUub2ZmKHRoaXMuX2VsZW1lbnQsIFpvKTtcbiAgfVxuICBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgdGhpcy5faXNTaG93biA/IHUub24od2luZG93LCBxbywgKCkgPT4gdGhpcy5fYWRqdXN0RGlhbG9nKCkpIDogdS5vZmYod2luZG93LCBxbyk7XG4gIH1cbiAgX2hpZGVNb2RhbCgpIHtcbiAgICBjb25zdCB0ID0gaC5maW5kT25lKHFlLCB0aGlzLl9lbGVtZW50KTtcbiAgICB0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3Nlcy5zaG93KSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0xMDBcIiksIHQuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMFwiKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9LCAzMDApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIiksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9iYWNrZHJvcC5oaWRlKCgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKHRyKSwgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKSwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEtoKTtcbiAgICB9KTtcbiAgfVxuICBfc2hvd0JhY2tkcm9wKHQpIHtcbiAgICB1Lm9uKHRoaXMuX2VsZW1lbnQsIFFvLCAoZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9ICExO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0ICYmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICEwID8gdGhpcy5oaWRlKCkgOiB0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09IFwic3RhdGljXCIgJiYgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpKTtcbiAgICB9KSwgdGhpcy5fYmFja2Ryb3Auc2hvdyh0KTtcbiAgfVxuICBfaXNBbmltYXRlZCgpIHtcbiAgICByZXR1cm4gISFoLmZpbmRPbmUocWUsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkge1xuICAgIGlmICh1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgamgpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBjbGFzc0xpc3Q6IGUsIHNjcm9sbEhlaWdodDogaSwgc3R5bGU6IG4gfSA9IHRoaXMuX2VsZW1lbnQsIG8gPSBpID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAhbyAmJiBuLm92ZXJmbG93WSA9PT0gXCJoaWRkZW5cIiB8fCBlLmNvbnRhaW5zKHRoaXMuX2NsYXNzZXMuc3RhdGljKSB8fCAobyB8fCAobi5vdmVyZmxvd1kgPSBcImhpZGRlblwiKSwgZS5hZGQoLi4udGhpcy5fY2xhc3Nlcy5zdGF0aWMuc3BsaXQoXCIgXCIpKSwgZS5hZGQoLi4udGhpcy5fY2xhc3Nlcy5zdGF0aWNQcm9wZXJ0aWVzLnNwbGl0KFwiIFwiKSksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgZS5yZW1vdmUodGhpcy5fY2xhc3Nlcy5zdGF0aWMpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZS5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5zdGF0aWNQcm9wZXJ0aWVzLnNwbGl0KFwiIFwiKSk7XG4gICAgICB9LCAzMDApLCBvIHx8IHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBuLm92ZXJmbG93WSA9IFwiXCI7XG4gICAgICB9LCB0aGlzLl9kaWFsb2cpO1xuICAgIH0sIHRoaXMuX2RpYWxvZyksIHRoaXMuX2VsZW1lbnQuZm9jdXMoKSk7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIF9hZGp1c3REaWFsb2coKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgZSA9IHRoaXMuX3Njcm9sbEJhci5nZXRXaWR0aCgpLCBpID0gZSA+IDA7XG4gICAgKCFpICYmIHQgJiYgIUYoKSB8fCBpICYmICF0ICYmIEYoKSkgJiYgKHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBgJHtlfXB4YCksIChpICYmICF0ICYmICFGKCkgfHwgIWkgJiYgdCAmJiBGKCkpICYmICh0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke2V9cHhgKTtcbiAgfVxuICBfcmVzZXRBZGp1c3RtZW50cygpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCJcIiwgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgaSA9IFBuLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgcWggPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYmFja2dyb3VuZFwiLFxuICBcImNpdGVcIixcbiAgXCJocmVmXCIsXG4gIFwiaXRlbXR5cGVcIixcbiAgXCJsb25nZGVzY1wiLFxuICBcInBvc3RlclwiLFxuICBcInNyY1wiLFxuICBcInhsaW5rOmhyZWZcIlxuXSksIFFoID0gL15hcmlhLVtcXHctXSokL2ksIFpoID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZXxzbXMpOnxbXiMmLzo/XSooPzpbIy8/XXwkKSkvaSwgSmggPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbXFxkKy9hLXpdKz0qJC9pLCB0dSA9IChzLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSBzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmICh0LmluY2x1ZGVzKGUpKVxuICAgIHJldHVybiBxaC5oYXMoZSkgPyAhIShaaC50ZXN0KHMubm9kZVZhbHVlKSB8fCBKaC50ZXN0KHMubm9kZVZhbHVlKSkgOiAhMDtcbiAgY29uc3QgaSA9IHQuZmlsdGVyKFxuICAgIChuKSA9PiBuIGluc3RhbmNlb2YgUmVnRXhwXG4gICk7XG4gIGZvciAobGV0IG4gPSAwLCBvID0gaS5sZW5ndGg7IG4gPCBvOyBuKyspXG4gICAgaWYgKGlbbl0udGVzdChlKSlcbiAgICAgIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufSwgZXUgPSB7XG4gIC8vIEdsb2JhbCBhdHRyaWJ1dGVzIGFsbG93ZWQgb24gYW55IHN1cHBsaWVkIGVsZW1lbnQgYmVsb3cuXG4gIFwiKlwiOiBbXCJjbGFzc1wiLCBcImRpclwiLCBcImlkXCIsIFwibGFuZ1wiLCBcInJvbGVcIiwgUWhdLFxuICBhOiBbXCJ0YXJnZXRcIiwgXCJocmVmXCIsIFwidGl0bGVcIiwgXCJyZWxcIl0sXG4gIGFyZWE6IFtdLFxuICBiOiBbXSxcbiAgYnI6IFtdLFxuICBjb2w6IFtdLFxuICBjb2RlOiBbXSxcbiAgZGl2OiBbXSxcbiAgZW06IFtdLFxuICBocjogW10sXG4gIGgxOiBbXSxcbiAgaDI6IFtdLFxuICBoMzogW10sXG4gIGg0OiBbXSxcbiAgaDU6IFtdLFxuICBoNjogW10sXG4gIGk6IFtdLFxuICBpbWc6IFtcInNyY1wiLCBcInNyY3NldFwiLCBcImFsdFwiLCBcInRpdGxlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0sXG4gIGxpOiBbXSxcbiAgb2w6IFtdLFxuICBwOiBbXSxcbiAgcHJlOiBbXSxcbiAgczogW10sXG4gIHNtYWxsOiBbXSxcbiAgc3BhbjogW10sXG4gIHN1YjogW10sXG4gIHN1cDogW10sXG4gIHN0cm9uZzogW10sXG4gIHU6IFtdLFxuICB1bDogW11cbn07XG5mdW5jdGlvbiBpcihzLCB0LCBlKSB7XG4gIGlmICghcy5sZW5ndGgpXG4gICAgcmV0dXJuIHM7XG4gIGlmIChlICYmIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gZShzKTtcbiAgY29uc3QgbiA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHMsIFwidGV4dC9odG1sXCIpLCBvID0gW10uY29uY2F0KC4uLm4uYm9keS5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSk7XG4gIGZvciAobGV0IHIgPSAwLCBhID0gby5sZW5ndGg7IHIgPCBhOyByKyspIHtcbiAgICBjb25zdCBsID0gb1tyXSwgYyA9IGwubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHQpLmluY2x1ZGVzKGMpKSB7XG4gICAgICBsLnJlbW92ZSgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGQgPSBbXS5jb25jYXQoLi4ubC5hdHRyaWJ1dGVzKSwgXyA9IFtdLmNvbmNhdChcbiAgICAgIHRbXCIqXCJdIHx8IFtdLFxuICAgICAgdFtjXSB8fCBbXVxuICAgICk7XG4gICAgZC5mb3JFYWNoKChmKSA9PiB7XG4gICAgICB0dShmLCBfKSB8fCBsLnJlbW92ZUF0dHJpYnV0ZShmLm5vZGVOYW1lKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbi5ib2R5LmlubmVySFRNTDtcbn1cbmNvbnN0IHNyID0gXCJ0b29sdGlwXCIsIGl1ID0gXCJ0ZS50b29sdGlwXCIsIEN0ID0gYC4ke2l1fWAsIHN1ID0gXCJ0ZS10b29sdGlwXCIsIG51ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wic2FuaXRpemVcIiwgXCJhbGxvd0xpc3RcIiwgXCJzYW5pdGl6ZUZuXCJdKSwgb3UgPSB7XG4gIGFuaW1hdGlvbjogXCJib29sZWFuXCIsXG4gIHRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICB0aXRsZTogXCIoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pXCIsXG4gIHRyaWdnZXI6IFwic3RyaW5nXCIsXG4gIGRlbGF5OiBcIihudW1iZXJ8b2JqZWN0KVwiLFxuICBodG1sOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0b3I6IFwiKHN0cmluZ3xib29sZWFuKVwiLFxuICBwbGFjZW1lbnQ6IFwiKHN0cmluZ3xmdW5jdGlvbilcIixcbiAgb2Zmc2V0OiBcIihhcnJheXxzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIGNvbnRhaW5lcjogXCIoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbilcIixcbiAgZmFsbGJhY2tQbGFjZW1lbnRzOiBcImFycmF5XCIsXG4gIGJvdW5kYXJ5OiBcIihzdHJpbmd8ZWxlbWVudClcIixcbiAgY3VzdG9tQ2xhc3M6IFwiKHN0cmluZ3xmdW5jdGlvbilcIixcbiAgc2FuaXRpemU6IFwiYm9vbGVhblwiLFxuICBzYW5pdGl6ZUZuOiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBhbGxvd0xpc3Q6IFwib2JqZWN0XCIsXG4gIHBvcHBlckNvbmZpZzogXCIobnVsbHxvYmplY3R8ZnVuY3Rpb24pXCJcbn0sIHJ1ID0ge1xuICBBVVRPOiBcImF1dG9cIixcbiAgVE9QOiBcInRvcFwiLFxuICBSSUdIVDogRigpID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXG4gIEJPVFRPTTogXCJib3R0b21cIixcbiAgTEVGVDogRigpID8gXCJyaWdodFwiIDogXCJsZWZ0XCJcbn0sIGF1ID0ge1xuICBhbmltYXRpb246ICEwLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJvcGFjaXR5LTAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dCBhYnNvbHV0ZSB6LVsxMDgwXSBibG9jayBtLTAgdGV4dC1zbSBub3QtaXRhbGljIGZvbnQtbm9ybWFsIHRleHQtbGVmdCBuby11bmRlcmxpbmUgdW5kZXJsaW5lLW9mZnNldC1hdXRvIG5vcm1hbC1jYXNlIGxlYWRpbmctNiB0cmFja2luZy1ub3JtYWwgYnJlYWstbm9ybWFsIHdoaXRlc3BhY2Utbm9ybWFsXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGRhdGEtdGUtdG9vbHRpcC1pbm5lci1yZWYgY2xhc3M9XCJ0b29sdGlwLWlubmVyIG1heC13LVsyMDBweF0gdGV4dC1zbSBweS0xLjUgcHgtNCB0ZXh0LXdoaXRlIHRleHQtY2VudGVyIGJnLVsjNmQ2ZDZkXSByb3VuZGVkXCI+PC9kaXY+PC9kaXY+JyxcbiAgdHJpZ2dlcjogXCJob3ZlciBmb2N1c1wiLFxuICB0aXRsZTogXCJcIixcbiAgZGVsYXk6IDAsXG4gIGh0bWw6ICExLFxuICBzZWxlY3RvcjogITEsXG4gIHBsYWNlbWVudDogXCJ0b3BcIixcbiAgb2Zmc2V0OiBbMCwgMF0sXG4gIGNvbnRhaW5lcjogITEsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdLFxuICBib3VuZGFyeTogXCJjbGlwcGluZ1BhcmVudHNcIixcbiAgY3VzdG9tQ2xhc3M6IFwiXCIsXG4gIHNhbml0aXplOiAhMCxcbiAgc2FuaXRpemVGbjogbnVsbCxcbiAgYWxsb3dMaXN0OiBldSxcbiAgcG9wcGVyQ29uZmlnOiB7IGhpZGU6ICEwIH1cbn0sIGx1ID0ge1xuICBISURFOiBgaGlkZSR7Q3R9YCxcbiAgSElEREVOOiBgaGlkZGVuJHtDdH1gLFxuICBTSE9XOiBgc2hvdyR7Q3R9YCxcbiAgU0hPV046IGBzaG93biR7Q3R9YCxcbiAgSU5TRVJURUQ6IGBpbnNlcnRlZCR7Q3R9YCxcbiAgQ0xJQ0s6IGBjbGljayR7Q3R9YCxcbiAgRk9DVVNJTjogYGZvY3VzaW4ke0N0fWAsXG4gIEZPQ1VTT1VUOiBgZm9jdXNvdXQke0N0fWAsXG4gIE1PVVNFRU5URVI6IGBtb3VzZWVudGVyJHtDdH1gLFxuICBNT1VTRUxFQVZFOiBgbW91c2VsZWF2ZSR7Q3R9YFxufSwgY3UgPSBcImZhZGVcIiwgZHUgPSBcIm1vZGFsXCIsIEpzID0gXCJzaG93XCIsIFFlID0gXCJzaG93XCIsIHRuID0gXCJvdXRcIiwgbnIgPSBcIi50b29sdGlwLWlubmVyXCIsIG9yID0gYC4ke2R1fWAsIHJyID0gXCJoaWRlLnRlLm1vZGFsXCIsIFplID0gXCJob3ZlclwiLCBlbiA9IFwiZm9jdXNcIiwgaHUgPSBcImNsaWNrXCIsIHV1ID0gXCJtYW51YWxcIjtcbmNsYXNzIHZpIGV4dGVuZHMgdnQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgaWYgKHR5cGVvZiBpbCA+IFwidVwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJCb290c3RyYXAncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKVwiXG4gICAgICApO1xuICAgIHN1cGVyKHQpLCB0aGlzLl9pc0VuYWJsZWQgPSAhMCwgdGhpcy5fdGltZW91dCA9IDAsIHRoaXMuX2hvdmVyU3RhdGUgPSBcIlwiLCB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge30sIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy50aXAgPSBudWxsLCB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gYXU7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBzcjtcbiAgfVxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBsdTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBvdTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICEwO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gITE7XG4gIH1cbiAgdG9nZ2xlRW5hYmxlZCgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhdGhpcy5faXNFbmFibGVkO1xuICB9XG4gIHRvZ2dsZSh0KSB7XG4gICAgaWYgKHRoaXMuX2lzRW5hYmxlZClcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQodCk7XG4gICAgICAgIGUuX2FjdGl2ZVRyaWdnZXIuY2xpY2sgPSAhZS5fYWN0aXZlVHJpZ2dlci5jbGljaywgZS5faXNXaXRoQWN0aXZlVHJpZ2dlcigpID8gZS5fZW50ZXIobnVsbCwgZSkgOiBlLl9sZWF2ZShudWxsLCBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmdldFRpcEVsZW1lbnQoKS5jbGFzc0xpc3QuY29udGFpbnMoSnMpKSB7XG4gICAgICAgICAgdGhpcy5fbGVhdmUobnVsbCwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VudGVyKG51bGwsIHRoaXMpO1xuICAgICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLCB1Lm9mZihcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChvciksXG4gICAgICBycixcbiAgICAgIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXJcbiAgICApLCB0aGlzLnRpcCAmJiB0aGlzLnRpcC5yZW1vdmUoKSwgdGhpcy5fZGlzcG9zZVBvcHBlcigpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzXCIpO1xuICAgIGlmICghKHRoaXMuaXNXaXRoQ29udGVudCgpICYmIHRoaXMuX2lzRW5hYmxlZCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHUudHJpZ2dlcihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1dcbiAgICApLCBlID0gVGEodGhpcy5fZWxlbWVudCksIGkgPSBlID09PSBudWxsID8gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLl9lbGVtZW50KSA6IGUuY29udGFpbnModGhpcy5fZWxlbWVudCk7XG4gICAgaWYgKHQuZGVmYXVsdFByZXZlbnRlZCB8fCAhaSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLk5BTUUgPT09IFwidG9vbHRpcFwiICYmIHRoaXMudGlwICYmIHRoaXMuZ2V0VGl0bGUoKSAhPT0gdGhpcy50aXAucXVlcnlTZWxlY3RvcihucikuaW5uZXJIVE1MICYmICh0aGlzLl9kaXNwb3NlUG9wcGVyKCksIHRoaXMudGlwLnJlbW92ZSgpLCB0aGlzLnRpcCA9IG51bGwpO1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldFRpcEVsZW1lbnQoKSwgbyA9IE90KHRoaXMuY29uc3RydWN0b3IuTkFNRSk7XG4gICAgbi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBvKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIG8pLCB0aGlzLl9jb25maWcuYW5pbWF0aW9uICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50aXAuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMTAwXCIpLCB0aGlzLnRpcC5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0wXCIpO1xuICAgIH0sIDEwMCk7XG4gICAgY29uc3QgciA9IHR5cGVvZiB0aGlzLl9jb25maWcucGxhY2VtZW50ID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQuY2FsbCh0aGlzLCBuLCB0aGlzLl9lbGVtZW50KSA6IHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQsIGEgPSB0aGlzLl9nZXRBdHRhY2htZW50KHIpO1xuICAgIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyhhKTtcbiAgICBjb25zdCB7IGNvbnRhaW5lcjogbCB9ID0gdGhpcy5fY29uZmlnO1xuICAgIGlmIChJLnNldERhdGEobiwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyksIHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy50aXApIHx8IChsLmFwcGVuZChuKSwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSU5TRVJURUQpKSwgdGhpcy5fcG9wcGVyID8gdGhpcy5fcG9wcGVyLnVwZGF0ZSgpIDogdGhpcy5fcG9wcGVyID0gamUoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgbixcbiAgICAgIHRoaXMuX2dldFBvcHBlckNvbmZpZyhhKVxuICAgICksIG4uZ2V0QXR0cmlidXRlKFwiaWRcIikuaW5jbHVkZXMoXCJ0b29sdGlwXCIpKVxuICAgICAgc3dpdGNoIChyKSB7XG4gICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICBuLmNsYXNzTGlzdC5hZGQoXCJweS1bMC40cmVtXVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICBuLmNsYXNzTGlzdC5hZGQoXCJweC1bMC40cmVtXVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHgtWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHktWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY29uc3QgZCA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcyk7XG4gICAgZCAmJiBuLmNsYXNzTGlzdC5hZGQoLi4uZC5zcGxpdChcIiBcIikpLCBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgdS5vbihtLCBcIm1vdXNlb3ZlclwiLCB2cyk7XG4gICAgfSk7XG4gICAgY29uc3QgXyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLl9ob3ZlclN0YXRlO1xuICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9IG51bGwsIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1dOKSwgbSA9PT0gdG4gJiYgdGhpcy5fbGVhdmUobnVsbCwgdGhpcyk7XG4gICAgfSwgZiA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhcInRyYW5zaXRpb24tb3BhY2l0eVwiKTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKF8sIHRoaXMudGlwLCBmKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5fcG9wcGVyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFRpcEVsZW1lbnQoKSwgZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB8fCAodGhpcy5faG92ZXJTdGF0ZSAhPT0gUWUgJiYgdC5yZW1vdmUoKSwgdGhpcy5fY2xlYW5UaXBDbGFzcygpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIiksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTiksIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSk7XG4gICAgfTtcbiAgICBpZiAodS50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElERVxuICAgICkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0LmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTBcIiksIHQuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMTAwXCIpLCBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgobykgPT4gdS5vZmYobywgXCJtb3VzZW92ZXJcIiwgdnMpKSwgdGhpcy5fYWN0aXZlVHJpZ2dlcltodV0gPSAhMSwgdGhpcy5fYWN0aXZlVHJpZ2dlcltlbl0gPSAhMSwgdGhpcy5fYWN0aXZlVHJpZ2dlcltaZV0gPSAhMTtcbiAgICBjb25zdCBuID0gdGhpcy50aXAuY2xhc3NMaXN0LmNvbnRhaW5zKFwib3BhY2l0eS0wXCIpO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZSwgdGhpcy50aXAsIG4pLCB0aGlzLl9ob3ZlclN0YXRlID0gXCJcIjtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fcG9wcGVyICE9PSBudWxsICYmIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcbiAgfVxuICAvLyBQcm90ZWN0ZWRcbiAgaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldFRpdGxlKCk7XG4gIH1cbiAgZ2V0VGlwRWxlbWVudCgpIHtcbiAgICBpZiAodGhpcy50aXApXG4gICAgICByZXR1cm4gdGhpcy50aXA7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdC5pbm5lckhUTUwgPSB0aGlzLl9jb25maWcudGVtcGxhdGU7XG4gICAgY29uc3QgZSA9IHQuY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIHRoaXMuc2V0Q29udGVudChlKSwgZS5jbGFzc0xpc3QucmVtb3ZlKGN1LCBKcyksIHRoaXMudGlwID0gZSwgdGhpcy50aXA7XG4gIH1cbiAgc2V0Q29udGVudCh0KSB7XG4gICAgdGhpcy5fc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIHRoaXMuZ2V0VGl0bGUoKSwgbnIpO1xuICB9XG4gIF9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSBoLmZpbmRPbmUoaSwgdCk7XG4gICAgaWYgKCFlICYmIG4pIHtcbiAgICAgIG4ucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQobiwgZSk7XG4gIH1cbiAgc2V0RWxlbWVudENvbnRlbnQodCwgZSkge1xuICAgIGlmICh0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoTmUoZSkpIHtcbiAgICAgICAgZSA9IEd0KGUpLCB0aGlzLl9jb25maWcuaHRtbCA/IGUucGFyZW50Tm9kZSAhPT0gdCAmJiAodC5pbm5lckhUTUwgPSBcIlwiLCB0LmFwcGVuZChlKSkgOiB0LnRleHRDb250ZW50ID0gZS50ZXh0Q29udGVudDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uZmlnLmh0bWwgPyAodGhpcy5fY29uZmlnLnNhbml0aXplICYmIChlID0gaXIoXG4gICAgICAgIGUsXG4gICAgICAgIHRoaXMuX2NvbmZpZy5hbGxvd0xpc3QsXG4gICAgICAgIHRoaXMuX2NvbmZpZy5zYW5pdGl6ZUZuXG4gICAgICApKSwgdC5pbm5lckhUTUwgPSBlKSA6IHQudGV4dENvbnRlbnQgPSBlO1xuICAgIH1cbiAgfVxuICBnZXRUaXRsZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLW9yaWdpbmFsLXRpdGxlXCIpIHx8IHRoaXMuX2NvbmZpZy50aXRsZTtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odCk7XG4gIH1cbiAgdXBkYXRlQXR0YWNobWVudCh0KSB7XG4gICAgcmV0dXJuIHQgPT09IFwicmlnaHRcIiA/IFwiZW5kXCIgOiB0ID09PSBcImxlZnRcIiA/IFwic3RhcnRcIiA6IHQ7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQsIGUpIHtcbiAgICByZXR1cm4gZSB8fCB0aGlzLmNvbnN0cnVjdG9yLmdldE9yQ3JlYXRlSW5zdGFuY2UoXG4gICAgICB0LmRlbGVnYXRlVGFyZ2V0LFxuICAgICAgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKVxuICAgICk7XG4gIH1cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCB7IG9mZnNldDogdCB9ID0gdGhpcy5fY29uZmlnO1xuICAgIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdC5zcGxpdChcIixcIikubWFwKChlKSA9PiBOdW1iZXIucGFyc2VJbnQoZSwgMTApKSA6IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IChlKSA9PiB0KGUsIHRoaXMuX2VsZW1lbnQpIDogdDtcbiAgfVxuICBfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0LmNhbGwodGhpcy5fZWxlbWVudCkgOiB0O1xuICB9XG4gIF9nZXRQb3BwZXJDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6IHQsXG4gICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiZmxpcFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogdGhpcy5fY29uZmlnLmZhbGxiYWNrUGxhY2VtZW50c1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwib2Zmc2V0XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiYXJyb3dcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBlbGVtZW50OiBgLiR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfS1hcnJvd2BcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9uQ2hhbmdlXCIsXG4gICAgICAgICAgZW5hYmxlZDogITAsXG4gICAgICAgICAgcGhhc2U6IFwiYWZ0ZXJXcml0ZVwiLFxuICAgICAgICAgIGZuOiAoaSkgPT4gdGhpcy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGkpXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBvbkZpcnN0VXBkYXRlOiAoaSkgPT4ge1xuICAgICAgICBpLm9wdGlvbnMucGxhY2VtZW50ICE9PSBpLnBsYWNlbWVudCAmJiB0aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoaSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZSxcbiAgICAgIC4uLnR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcoZSkgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnXG4gICAgfTtcbiAgfVxuICBfYWRkQXR0YWNobWVudENsYXNzKHQpIHtcbiAgICB0aGlzLmdldFRpcEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKFxuICAgICAgYCR7dGhpcy5fZ2V0QmFzaWNDbGFzc1ByZWZpeCgpfS0ke3RoaXMudXBkYXRlQXR0YWNobWVudCh0KX1gXG4gICAgKTtcbiAgfVxuICBfZ2V0QXR0YWNobWVudCh0KSB7XG4gICAgcmV0dXJuIHJ1W3QudG9VcHBlckNhc2UoKV07XG4gIH1cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9jb25maWcudHJpZ2dlci5zcGxpdChcIiBcIikuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaWYgKGUgPT09IFwiY2xpY2tcIilcbiAgICAgICAgdS5vbihcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuQ0xJQ0ssXG4gICAgICAgICAgdGhpcy5fY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIChpKSA9PiB0aGlzLnRvZ2dsZShpKVxuICAgICAgICApO1xuICAgICAgZWxzZSBpZiAoZSAhPT0gdXUpIHtcbiAgICAgICAgY29uc3QgaSA9IGUgPT09IFplID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUVOVEVSIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU0lOLCBuID0gZSA9PT0gWmUgPyB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFTEVBVkUgOiB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUO1xuICAgICAgICB1Lm9uKFxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgaSxcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXG4gICAgICAgICAgKG8pID0+IHRoaXMuX2VudGVyKG8pXG4gICAgICAgICksIHUub24oXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICBuLFxuICAgICAgICAgIHRoaXMuX2NvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAobykgPT4gdGhpcy5fbGVhdmUobylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgJiYgdGhpcy5oaWRlKCk7XG4gICAgfSwgdS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChvciksXG4gICAgICBycixcbiAgICAgIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXJcbiAgICApLCB0aGlzLl9jb25maWcuc2VsZWN0b3IgPyB0aGlzLl9jb25maWcgPSB7XG4gICAgICAuLi50aGlzLl9jb25maWcsXG4gICAgICB0cmlnZ2VyOiBcIm1hbnVhbFwiLFxuICAgICAgc2VsZWN0b3I6IFwiXCJcbiAgICB9IDogdGhpcy5fZml4VGl0bGUoKTtcbiAgfVxuICBfZml4VGl0bGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGl0bGVcIiksIGUgPSB0eXBlb2YgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXG4gICAgICBcImRhdGEtdGUtb3JpZ2luYWwtdGl0bGVcIlxuICAgICk7XG4gICAgKHQgfHwgZSAhPT0gXCJzdHJpbmdcIikgJiYgKHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1vcmlnaW5hbC10aXRsZVwiLCB0IHx8IFwiXCIpLCB0ICYmICF0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIikgJiYgIXRoaXMuX2VsZW1lbnQudGV4dENvbnRlbnQgJiYgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHQpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIFwiXCIpKTtcbiAgfVxuICBfZW50ZXIodCwgZSkge1xuICAgIGlmIChlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQsIGUpLCB0ICYmIChlLl9hY3RpdmVUcmlnZ2VyW3QudHlwZSA9PT0gXCJmb2N1c2luXCIgPyBlbiA6IFplXSA9ICEwKSwgZS5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKEpzKSB8fCBlLl9ob3ZlclN0YXRlID09PSBRZSkge1xuICAgICAgZS5faG92ZXJTdGF0ZSA9IFFlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLCBlLl9ob3ZlclN0YXRlID0gUWUsICFlLl9jb25maWcuZGVsYXkgfHwgIWUuX2NvbmZpZy5kZWxheS5zaG93KSB7XG4gICAgICBlLnNob3coKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZS5faG92ZXJTdGF0ZSA9PT0gUWUgJiYgZS5zaG93KCk7XG4gICAgfSwgZS5fY29uZmlnLmRlbGF5LnNob3cpO1xuICB9XG4gIF9sZWF2ZSh0LCBlKSB7XG4gICAgaWYgKGUgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQodCwgZSksIHQgJiYgKGUuX2FjdGl2ZVRyaWdnZXJbdC50eXBlID09PSBcImZvY3Vzb3V0XCIgPyBlbiA6IFplXSA9IGUuX2VsZW1lbnQuY29udGFpbnModC5yZWxhdGVkVGFyZ2V0KSksICFlLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgIGlmIChjbGVhclRpbWVvdXQoZS5fdGltZW91dCksIGUuX2hvdmVyU3RhdGUgPSB0biwgIWUuX2NvbmZpZy5kZWxheSB8fCAhZS5fY29uZmlnLmRlbGF5LmhpZGUpIHtcbiAgICAgICAgZS5oaWRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZS5faG92ZXJTdGF0ZSA9PT0gdG4gJiYgZS5oaWRlKCk7XG4gICAgICB9LCBlLl9jb25maWcuZGVsYXkuaGlkZSk7XG4gICAgfVxuICB9XG4gIF9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkge1xuICAgIGZvciAoY29uc3QgdCBpbiB0aGlzLl9hY3RpdmVUcmlnZ2VyKVxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRyaWdnZXJbdF0pXG4gICAgICAgIHJldHVybiAhMDtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGkpID0+IHtcbiAgICAgIG51LmhhcyhpKSAmJiBkZWxldGUgZVtpXTtcbiAgICB9KSwgdCA9IHtcbiAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgPyB0IDoge31cbiAgICB9LCB0LmNvbnRhaW5lciA9IHQuY29udGFpbmVyID09PSAhMSA/IGRvY3VtZW50LmJvZHkgOiBHdCh0LmNvbnRhaW5lciksIHR5cGVvZiB0LmRlbGF5ID09IFwibnVtYmVyXCIgJiYgKHQuZGVsYXkgPSB7XG4gICAgICBzaG93OiB0LmRlbGF5LFxuICAgICAgaGlkZTogdC5kZWxheVxuICAgIH0pLCB0eXBlb2YgdC50aXRsZSA9PSBcIm51bWJlclwiICYmICh0LnRpdGxlID0gdC50aXRsZS50b1N0cmluZygpKSwgdHlwZW9mIHQuY29udGVudCA9PSBcIm51bWJlclwiICYmICh0LmNvbnRlbnQgPSB0LmNvbnRlbnQudG9TdHJpbmcoKSksIE4oc3IsIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0LnNhbml0aXplICYmICh0LnRlbXBsYXRlID0gaXIoXG4gICAgICB0LnRlbXBsYXRlLFxuICAgICAgdC5hbGxvd0xpc3QsXG4gICAgICB0LnNhbml0aXplRm5cbiAgICApKSwgdDtcbiAgfVxuICBfZ2V0RGVsZWdhdGVDb25maWcoKSB7XG4gICAgY29uc3QgdCA9IHt9O1xuICAgIGZvciAoY29uc3QgZSBpbiB0aGlzLl9jb25maWcpXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRbZV0gIT09IHRoaXMuX2NvbmZpZ1tlXSAmJiAodFtlXSA9IHRoaXMuX2NvbmZpZ1tlXSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpLCBlID0gbmV3IFJlZ0V4cChcbiAgICAgIGAoXnxcXFxccykke3RoaXMuX2dldEJhc2ljQ2xhc3NQcmVmaXgoKX1cXFxcUytgLFxuICAgICAgXCJnXCJcbiAgICApLCBpID0gdC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKS5tYXRjaChlKTtcbiAgICBpICE9PSBudWxsICYmIGkubGVuZ3RoID4gMCAmJiBpLm1hcCgobikgPT4gbi50cmltKCkpLmZvckVhY2goKG4pID0+IHQuY2xhc3NMaXN0LnJlbW92ZShuKSk7XG4gIH1cbiAgX2dldEJhc2ljQ2xhc3NQcmVmaXgoKSB7XG4gICAgcmV0dXJuIHN1O1xuICB9XG4gIF9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UodCkge1xuICAgIGNvbnN0IHsgc3RhdGU6IGUgfSA9IHQ7XG4gICAgZSAmJiAodGhpcy50aXAgPSBlLmVsZW1lbnRzLnBvcHBlciwgdGhpcy5fY2xlYW5UaXBDbGFzcygpLCB0aGlzLl9hZGRBdHRhY2htZW50Q2xhc3ModGhpcy5fZ2V0QXR0YWNobWVudChlLnBsYWNlbWVudCkpKTtcbiAgfVxuICBfZGlzcG9zZVBvcHBlcigpIHtcbiAgICB0aGlzLl9wb3BwZXIgJiYgKHRoaXMuX3BvcHBlci5kZXN0cm95KCksIHRoaXMuX3BvcHBlciA9IG51bGwpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IHZpLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBwdSA9IFwicG9wb3ZlclwiLCBmdSA9IFwidGUucG9wb3ZlclwiLCBBdCA9IGAuJHtmdX1gLCBfdSA9IFwidGUtcG9wb3ZlclwiLCBtdSA9IHtcbiAgLi4udmkuRGVmYXVsdCxcbiAgcGxhY2VtZW50OiBcInJpZ2h0XCIsXG4gIG9mZnNldDogWzAsIDhdLFxuICB0cmlnZ2VyOiBcImNsaWNrXCIsXG4gIGNvbnRlbnQ6IFwiXCIsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cIm9wYWNpdHktMCB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGFic29sdXRlIHRvcC0wIGxlZnQtMCB6LVsxMDcwXSBibG9jayBtYXgtdy1bMjY3cHhdIGJyZWFrLXdvcmRzIGJnLXdoaXRlIGJnLWNsaXAtcGFkZGluZyBib3JkZXIgYm9yZGVyLW5ldXRyYWwtMTAwIHJvdW5kZWQtbGcgc2hhZG93LVswXzBweF8zcHhfMF9yZ2JhKDAsMCwwLDAuMDcpLDBfMnB4XzJweF8wX3JnYmEoMCwwLDAsMC4wNCldIHRleHQtc20gbm90LWl0YWxpYyBmb250LW5vcm1hbCB0ZXh0LWxlZnQgbm8tdW5kZXJsaW5lIHVuZGVybGluZS1vZmZzZXQtYXV0byBub3JtYWwtY2FzZSBsZWFkaW5nLTYgdHJhY2tpbmctbm9ybWFsIGJyZWFrLW5vcm1hbCB3aGl0ZXNwYWNlLW5vcm1hbCBkYXJrOmJnLW5ldXRyYWwtNzAwIGRhcms6Ym9yZGVyLTAgZGFyazp0ZXh0LXdoaXRlIGRhdGEtW3BvcHBlci1yZWZlcmVuY2UtaGlkZGVuXTpoaWRkZW5cIiByb2xlPVwidG9vbHRpcFwiPjxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyIHB5LTIgcHgtNCBtYi0wIGJvcmRlci1iLTIgYm9yZGVyLW5ldXRyYWwtMTAwIHJvdW5kZWQtdC1sZyBmb250LW1lZGl1bSBlbXB0eTpoaWRkZW4gZGFyazpib3JkZXItbmV1dHJhbC01MDBcIj48L2gzPjxkaXYgY2xhc3M9XCJwb3BvdmVyLWJvZHkgcC00IHRleHQtWyMyMTI1MjldIGRhcms6dGV4dC13aGl0ZVwiPjwvZGl2PjwvZGl2Pidcbn0sIGd1ID0ge1xuICAuLi52aS5EZWZhdWx0VHlwZSxcbiAgY29udGVudDogXCIoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pXCJcbn0sIGJ1ID0ge1xuICBISURFOiBgaGlkZSR7QXR9YCxcbiAgSElEREVOOiBgaGlkZGVuJHtBdH1gLFxuICBTSE9XOiBgc2hvdyR7QXR9YCxcbiAgU0hPV046IGBzaG93biR7QXR9YCxcbiAgSU5TRVJURUQ6IGBpbnNlcnRlZCR7QXR9YCxcbiAgQ0xJQ0s6IGBjbGljayR7QXR9YCxcbiAgRk9DVVNJTjogYGZvY3VzaW4ke0F0fWAsXG4gIEZPQ1VTT1VUOiBgZm9jdXNvdXQke0F0fWAsXG4gIE1PVVNFRU5URVI6IGBtb3VzZWVudGVyJHtBdH1gLFxuICBNT1VTRUxFQVZFOiBgbW91c2VsZWF2ZSR7QXR9YFxufSwgdnUgPSBcIi5wb3BvdmVyLWhlYWRlclwiLCBFdSA9IFwiLnBvcG92ZXItYm9keVwiO1xuY2xhc3MgbGwgZXh0ZW5kcyB2aSB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBtdTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHB1O1xuICB9XG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgcmV0dXJuIGJ1O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIGd1O1xuICB9XG4gIC8vIE92ZXJyaWRlc1xuICBpc1dpdGhDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5fZ2V0Q29udGVudCgpO1xuICB9XG4gIHNldENvbnRlbnQodCkge1xuICAgIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLmdldFRpdGxlKCksIHZ1KSwgdGhpcy5fc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIHRoaXMuX2dldENvbnRlbnQoKSwgRXUpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb250ZW50KTtcbiAgfVxuICBfZ2V0QmFzaWNDbGFzc1ByZWZpeCgpIHtcbiAgICByZXR1cm4gX3U7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gbGwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IHNuID0gXCJzY3JvbGxzcHlcIiwgVHUgPSBcInRlLnNjcm9sbHNweVwiLCBTcyA9IGAuJHtUdX1gLCBDdSA9IFwiLmRhdGEtYXBpXCIsIGFyID0ge1xuICBvZmZzZXQ6IDEwLFxuICBtZXRob2Q6IFwiYXV0b1wiLFxuICB0YXJnZXQ6IFwiXCJcbn0sIEF1ID0ge1xuICBvZmZzZXQ6IFwibnVtYmVyXCIsXG4gIG1ldGhvZDogXCJzdHJpbmdcIixcbiAgdGFyZ2V0OiBcIihzdHJpbmd8ZWxlbWVudClcIlxufSwgeXUgPSB7XG4gIGFjdGl2ZTogXCIhdGV4dC1wcmltYXJ5IGRhcms6IXRleHQtcHJpbWFyeS00MDAgZm9udC1zZW1pYm9sZCBib3JkZXItbC1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItcHJpbWFyeSBkYXJrOmJvcmRlci1wcmltYXJ5LTQwMFwiXG59LCB3dSA9IHtcbiAgYWN0aXZlOiBcInN0cmluZ1wiXG59LCBrdSA9IGBhY3RpdmF0ZSR7U3N9YCwgT3UgPSBgc2Nyb2xsJHtTc31gLCB4dSA9IGBsb2FkJHtTc30ke0N1fWAsIG5uID0gXCJkYXRhLXRlLW5hdi1saW5rLWFjdGl2ZVwiLCBjbCA9IFwiW2RhdGEtdGUtZHJvcGRvd24taXRlbS1yZWZdXCIsIFN1ID0gJ1tkYXRhLXRlLXNweT1cInNjcm9sbFwiXScsIER1ID0gXCJbZGF0YS10ZS1uYXYtbGlzdC1yZWZdXCIsIEhuID0gXCJbZGF0YS10ZS1uYXYtbGluay1yZWZdXCIsIEl1ID0gXCJbZGF0YS10ZS1uYXYtaXRlbS1yZWZdXCIsIGRsID0gXCJbZGF0YS10ZS1saXN0LWdyb3VwLWl0ZW0tcmVmXVwiLCBvbiA9IGAke0hufSwgJHtkbH0sICR7Y2x9YCwgJHUgPSBcIltkYXRhLXRlLWRyb3Bkb3duLXJlZl1cIiwgTHUgPSBcIltkYXRhLXRlLWRyb3Bkb3duLXRvZ2dsZS1yZWZdXCIsIE11ID0gXCJvZmZzZXRcIiwgbHIgPSBcInBvc2l0aW9uXCI7XG5jbGFzcyBCbiBleHRlbmRzIHZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9zY3JvbGxFbGVtZW50ID0gdGhpcy5fZWxlbWVudC50YWdOYW1lID09PSBcIkJPRFlcIiA/IHdpbmRvdyA6IHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX29mZnNldHMgPSBbXSwgdGhpcy5fdGFyZ2V0cyA9IFtdLCB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsLCB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwLCB1Lm9uKHRoaXMuX3Njcm9sbEVsZW1lbnQsIE91LCAoKSA9PiB0aGlzLl9wcm9jZXNzKCkpLCB0aGlzLnJlZnJlc2goKSwgdGhpcy5fcHJvY2VzcygpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gYXI7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBzbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgPyBNdSA6IGxyLCBlID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gXCJhdXRvXCIgPyB0IDogdGhpcy5fY29uZmlnLm1ldGhvZCwgaSA9IGUgPT09IGxyID8gdGhpcy5fZ2V0U2Nyb2xsVG9wKCkgOiAwO1xuICAgIHRoaXMuX29mZnNldHMgPSBbXSwgdGhpcy5fdGFyZ2V0cyA9IFtdLCB0aGlzLl9zY3JvbGxIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSwgaC5maW5kKFxuICAgICAgb24sXG4gICAgICB0aGlzLl9jb25maWcudGFyZ2V0XG4gICAgKS5tYXAoKG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBYbihvKSwgYSA9IHIgPyBoLmZpbmRPbmUocikgOiBudWxsO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgY29uc3QgbCA9IGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChsLndpZHRoIHx8IGwuaGVpZ2h0KVxuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwW2VdKGEpLnRvcCArIGksXG4gICAgICAgICAgICByXG4gICAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbHRlcigobykgPT4gbykuc29ydCgobywgcikgPT4gb1swXSAtIHJbMF0pLmZvckVhY2goKG8pID0+IHtcbiAgICAgIHRoaXMuX29mZnNldHMucHVzaChvWzBdKSwgdGhpcy5fdGFyZ2V0cy5wdXNoKG9bMV0pO1xuICAgIH0pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdS5vZmYodGhpcy5fc2Nyb2xsRWxlbWVudCwgU3MpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8ICh1Lm9uKHdpbmRvdywgeHUsICgpID0+IHtcbiAgICAgIGguZmluZChTdSkuZm9yRWFjaChcbiAgICAgICAgKHQpID0+IG5ldyBCbih0KVxuICAgICAgKTtcbiAgICB9KSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmFyLFxuICAgICAgLi4ucC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCA/IHQgOiB7fVxuICAgIH0sIHQudGFyZ2V0ID0gR3QodC50YXJnZXQpIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgTihzbiwgdCwgQXUpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ueXUsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4oc24sIHQsIHd1KSwgdDtcbiAgfVxuICBfZ2V0U2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB0aGlzLl9zY3JvbGxFbGVtZW50LnBhZ2VZT2Zmc2V0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cbiAgX2dldFNjcm9sbEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgoXG4gICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgICApO1xuICB9XG4gIF9nZXRPZmZzZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICB9XG4gIF9wcm9jZXNzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXQsIGUgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSwgaSA9IHRoaXMuX2NvbmZpZy5vZmZzZXQgKyBlIC0gdGhpcy5fZ2V0T2Zmc2V0SGVpZ2h0KCk7XG4gICAgaWYgKHRoaXMuX3Njcm9sbEhlaWdodCAhPT0gZSAmJiB0aGlzLnJlZnJlc2goKSwgdCA+PSBpKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5fdGFyZ2V0c1t0aGlzLl90YXJnZXRzLmxlbmd0aCAtIDFdO1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSBuICYmIHRoaXMuX2FjdGl2YXRlKG4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICYmIHQgPCB0aGlzLl9vZmZzZXRzWzBdICYmIHRoaXMuX29mZnNldHNbMF0gPiAwKSB7XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsLCB0aGlzLl9jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBuID0gdGhpcy5fb2Zmc2V0cy5sZW5ndGg7IG4tLTsgKVxuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0aGlzLl90YXJnZXRzW25dICYmIHQgPj0gdGhpcy5fb2Zmc2V0c1tuXSAmJiAodHlwZW9mIHRoaXMuX29mZnNldHNbbiArIDFdID4gXCJ1XCIgfHwgdCA8IHRoaXMuX29mZnNldHNbbiArIDFdKSAmJiB0aGlzLl9hY3RpdmF0ZSh0aGlzLl90YXJnZXRzW25dKTtcbiAgfVxuICBfYWN0aXZhdGUodCkge1xuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHQsIHRoaXMuX2NsZWFyKCk7XG4gICAgY29uc3QgZSA9IG9uLnNwbGl0KFwiLFwiKS5tYXAoXG4gICAgICAobikgPT4gYCR7bn1bZGF0YS10ZS10YXJnZXQ9XCIke3R9XCJdLCR7bn1baHJlZj1cIiR7dH1cIl1gXG4gICAgKSwgaSA9IGguZmluZE9uZShlLmpvaW4oXCIsXCIpLCB0aGlzLl9jb25maWcudGFyZ2V0KTtcbiAgICBpLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKSwgaS5zZXRBdHRyaWJ1dGUobm4sIFwiXCIpLCBpLmdldEF0dHJpYnV0ZShjbCkgPyBoLmZpbmRPbmUoXG4gICAgICBMdSxcbiAgICAgIGkuY2xvc2VzdCgkdSlcbiAgICApLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKSA6IGgucGFyZW50cyhpLCBEdSkuZm9yRWFjaChcbiAgICAgIChuKSA9PiB7XG4gICAgICAgIGgucHJldihcbiAgICAgICAgICBuLFxuICAgICAgICAgIGAke0hufSwgJHtkbH1gXG4gICAgICAgICkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICAgIG8uY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCBvLnNldEF0dHJpYnV0ZShubiwgXCJcIik7XG4gICAgICAgIH0pLCBoLnByZXYobiwgSXUpLmZvckVhY2goXG4gICAgICAgICAgKG8pID0+IHtcbiAgICAgICAgICAgIGguY2hpbGRyZW4obywgSG4pLmZvckVhY2goXG4gICAgICAgICAgICAgIChyKSA9PiByLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSwgdS50cmlnZ2VyKHRoaXMuX3Njcm9sbEVsZW1lbnQsIGt1LCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSk7XG4gIH1cbiAgX2NsZWFyKCkge1xuICAgIGguZmluZChvbiwgdGhpcy5fY29uZmlnLnRhcmdldCkuZmlsdGVyKFxuICAgICAgKHQpID0+IHQuY2xhc3NMaXN0LmNvbnRhaW5zKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSlcbiAgICApLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCB0LnJlbW92ZUF0dHJpYnV0ZShubik7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gQm4uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGNyID0gXCJ0YWJcIiwgTnUgPSBcInRlLnRhYlwiLCBEcyA9IGAuJHtOdX1gLCBSdSA9IGBoaWRlJHtEc31gLCBQdSA9IGBoaWRkZW4ke0RzfWAsIEh1ID0gYHNob3cke0RzfWAsIEJ1ID0gYHNob3duJHtEc31gLCBWdSA9IFwiZGF0YS10ZS1kcm9wZG93bi1tZW51LXJlZlwiLCB3ZSA9IFwiZGF0YS10ZS10YWItYWN0aXZlXCIsIGFzID0gXCJkYXRhLXRlLW5hdi1hY3RpdmVcIiwgV3UgPSBcIltkYXRhLXRlLWRyb3Bkb3duLXJlZl1cIiwgRnUgPSBcIltkYXRhLXRlLW5hdi1yZWZdXCIsIGRyID0gYFske3dlfV1gLCBZdSA9IGBbJHthc31dYCwgaHIgPSBcIjpzY29wZSA+IGxpID4gLmFjdGl2ZVwiLCBqdSA9IFwiW2RhdGEtdGUtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIiwgS3UgPSBcIjpzY29wZSA+IFtkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXSBbZGF0YS10ZS1kcm9wZG93bi1zaG93XVwiLCBVdSA9IHtcbiAgc2hvdzogXCJvcGFjaXR5LTEwMFwiLFxuICBoaWRlOiBcIm9wYWNpdHktMFwiXG59LCB6dSA9IHtcbiAgc2hvdzogXCJzdHJpbmdcIixcbiAgaGlkZTogXCJzdHJpbmdcIlxufTtcbmNsYXNzIGhsIGV4dGVuZHMgdnQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGUpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBjcjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlICYmIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXMpID09PSBcIlwiKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0O1xuICAgIGNvbnN0IGUgPSBYdCh0aGlzLl9lbGVtZW50KSwgaSA9IHRoaXMuX2VsZW1lbnQuY2xvc2VzdChGdSksIG4gPSBoLmZpbmRPbmUoXG4gICAgICBZdSxcbiAgICAgIGlcbiAgICApO1xuICAgIGlmIChpKSB7XG4gICAgICBjb25zdCBsID0gaS5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IGkubm9kZU5hbWUgPT09IFwiT0xcIiA/IGhyIDogZHI7XG4gICAgICB0ID0gaC5maW5kKGwsIGkpLCB0ID0gdFt0Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb25zdCBvID0gdCA/IHUudHJpZ2dlcih0LCBSdSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH0pIDogbnVsbDtcbiAgICBpZiAodS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEh1LCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCB8fCBvICE9PSBudWxsICYmIG8uZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9hY3RpdmF0ZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBpLFxuICAgICAgbnVsbCxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBjb25zdCBhID0gKCkgPT4ge1xuICAgICAgdS50cmlnZ2VyKHQsIFB1LCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH0pLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgQnUsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBlID8gdGhpcy5fYWN0aXZhdGUoXG4gICAgICBlLFxuICAgICAgZS5wYXJlbnROb2RlLFxuICAgICAgYSxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSA6IGEoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uVXUsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4oY3IsIHQsIHp1KSwgdDtcbiAgfVxuICBfYWN0aXZhdGUodCwgZSwgaSwgbiwgbykge1xuICAgIGNvbnN0IGEgPSAoZSAmJiAoZS5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IGUubm9kZU5hbWUgPT09IFwiT0xcIikgPyBoLmZpbmQoaHIsIGUpIDogaC5jaGlsZHJlbihlLCBkcikpWzBdLCBsID0gaSAmJiBhICYmIGEuaGFzQXR0cmlidXRlKHdlKSwgYyA9ICgpID0+IHRoaXMuX3RyYW5zaXRpb25Db21wbGV0ZShcbiAgICAgIHQsXG4gICAgICBhLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBvXG4gICAgKTtcbiAgICBhICYmIGwgPyAocC5yZW1vdmVDbGFzcyhhLCB0aGlzLl9jbGFzc2VzLnNob3cpLCBwLmFkZENsYXNzKGEsIHRoaXMuX2NsYXNzZXMuaGlkZSksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soYywgdCwgITApKSA6IGMoKTtcbiAgfVxuICBfdHJhbnNpdGlvbkNvbXBsZXRlKHQsIGUsIGksIG4sIG8pIHtcbiAgICBpZiAoZSAmJiBuKSB7XG4gICAgICBlLnJlbW92ZUF0dHJpYnV0ZSh3ZSksIG4ucmVtb3ZlQXR0cmlidXRlKGFzKTtcbiAgICAgIGNvbnN0IGEgPSBoLmZpbmRPbmUoXG4gICAgICAgIEt1LFxuICAgICAgICBlLnBhcmVudE5vZGVcbiAgICAgICk7XG4gICAgICBhICYmIGEucmVtb3ZlQXR0cmlidXRlKHdlKSwgZS5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpID09PSBcInRhYlwiICYmIGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMSk7XG4gICAgfVxuICAgIHQuc2V0QXR0cmlidXRlKHdlLCBcIlwiKSwgby5zZXRBdHRyaWJ1dGUoYXMsIFwiXCIpLCB0LmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwidGFiXCIgJiYgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEwKSwgRmUodCksIHQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuX2NsYXNzZXMuaGlkZSkgJiYgKHAucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5oaWRlKSwgcC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnNob3cpKTtcbiAgICBsZXQgciA9IHQucGFyZW50Tm9kZTtcbiAgICBpZiAociAmJiByLm5vZGVOYW1lID09PSBcIkxJXCIgJiYgKHIgPSByLnBhcmVudE5vZGUpLCByICYmIHIuaGFzQXR0cmlidXRlKFZ1KSkge1xuICAgICAgY29uc3QgYSA9IHQuY2xvc2VzdChXdSk7XG4gICAgICBhICYmIGguZmluZChqdSwgYSkuZm9yRWFjaChcbiAgICAgICAgKGwpID0+IGwuc2V0QXR0cmlidXRlKHdlLCBcIlwiKVxuICAgICAgKSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICEwKTtcbiAgICB9XG4gICAgaSAmJiBpKCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gaGwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IHJuID0gXCJ0b2FzdFwiLCBYdSA9IFwidGUudG9hc3RcIiwgUXQgPSBgLiR7WHV9YCwgR3UgPSBgbW91c2VvdmVyJHtRdH1gLCBxdSA9IGBtb3VzZW91dCR7UXR9YCwgUXUgPSBgZm9jdXNpbiR7UXR9YCwgWnUgPSBgZm9jdXNvdXQke1F0fWAsIEp1ID0gYGhpZGUke1F0fWAsIHRwID0gYGhpZGRlbiR7UXR9YCwgZXAgPSBgc2hvdyR7UXR9YCwgaXAgPSBgc2hvd24ke1F0fWAsIHVyID0gXCJkYXRhLXRlLXRvYXN0LWhpZGVcIiwgYW4gPSBcImRhdGEtdGUtdG9hc3Qtc2hvd1wiLCBNaSA9IFwiZGF0YS10ZS10b2FzdC1zaG93aW5nXCIsIHNwID0ge1xuICBhbmltYXRpb246IFwiYm9vbGVhblwiLFxuICBhdXRvaGlkZTogXCJib29sZWFuXCIsXG4gIGRlbGF5OiBcIm51bWJlclwiXG59LCBwciA9IHtcbiAgYW5pbWF0aW9uOiAhMCxcbiAgYXV0b2hpZGU6ICEwLFxuICBkZWxheTogNWUzXG59LCBucCA9IHtcbiAgZmFkZUluOiBcImFuaW1hdGUtW2ZhZGUtaW5fMC4zc19ib3RoXSBwLVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLFxuICBmYWRlT3V0OiBcImFuaW1hdGUtW2ZhZGUtb3V0XzAuM3NfYm90aF0gcC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIlxufSwgb3AgPSB7XG4gIGZhZGVJbjogXCJzdHJpbmdcIixcbiAgZmFkZU91dDogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFZuIGV4dGVuZHMgdnQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX3RpbWVvdXQgPSBudWxsLCB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gITEsIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSAhMSwgdGhpcy5fc2V0TGlzdGVuZXJzKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gc3A7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBwcjtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHJuO1xuICB9XG4gIC8vIFB1YmxpY1xuICBzaG93KCkge1xuICAgIGlmICh1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZXApLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KCksIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbikpO1xuICAgIGNvbnN0IGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShNaSksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBpcCksIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh1ciksIEZlKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShhbiwgXCJcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKE1pLCBcIlwiKSwgdGhpcy5fcXVldWVDYWxsYmFjayhlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudCB8fCB0aGlzLl9lbGVtZW50LmRhdGFzZXQudGVUb2FzdFNob3cgPT09IHZvaWQgMCB8fCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgSnUpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKGkgPSAzMDAsIHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCkpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUodXIsIFwiXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShNaSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGFuKSwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRwKTtcbiAgICAgIH0sIGkpO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoTWksIFwiXCIpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KCksIHRoaXMuX2VsZW1lbnQuZGF0YXNldC50ZVRvYXN0U2hvdyAhPT0gdm9pZCAwICYmIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGFuKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoeHMoVm4pLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucHIsXG4gICAgICAuLi5wLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgTihybiwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5ucCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTihybiwgdCwgb3ApLCB0O1xuICB9XG4gIF9tYXliZVNjaGVkdWxlSGlkZSgpIHtcbiAgICB0aGlzLl9jb25maWcuYXV0b2hpZGUgJiYgKHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gfHwgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiB8fCAodGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KSkpO1xuICB9XG4gIF9vbkludGVyYWN0aW9uKHQsIGUpIHtcbiAgICBzd2l0Y2ggKHQudHlwZSkge1xuICAgICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgICAgY2FzZSBcIm1vdXNlb3V0XCI6XG4gICAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgICAgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoZSkge1xuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0LnJlbGF0ZWRUYXJnZXQ7XG4gICAgdGhpcy5fZWxlbWVudCA9PT0gaSB8fCB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKGkpIHx8IHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XG4gIH1cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICB1Lm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIEd1LFxuICAgICAgKHQpID0+IHRoaXMuX29uSW50ZXJhY3Rpb24odCwgITApXG4gICAgKSwgdS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBxdSxcbiAgICAgICh0KSA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICExKVxuICAgICksIHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgUXUsXG4gICAgICAodCkgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMClcbiAgICApLCB1Lm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFp1LFxuICAgICAgKHQpID0+IHRoaXMuX29uSW50ZXJhY3Rpb24odCwgITEpXG4gICAgKTtcbiAgfVxuICBfY2xlYXJUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gVm4uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4oKCkgPT4ge1xuICB2YXIgcyA9IHsgNDU0OiAoaSwgbiwgbykgPT4ge1xuICAgIG8uZChuLCB7IFo6ICgpID0+IGwgfSk7XG4gICAgdmFyIHIgPSBvKDY0NSksIGEgPSBvLm4ocikoKShmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gY1sxXTtcbiAgICB9KTtcbiAgICBhLnB1c2goW2kuaWQsIFwiSU5QVVQ6LXdlYmtpdC1hdXRvZmlsbCxTRUxFQ1Q6LXdlYmtpdC1hdXRvZmlsbCxURVhUQVJFQTotd2Via2l0LWF1dG9maWxse2FuaW1hdGlvbi1uYW1lOm9uYXV0b2ZpbGxzdGFydH1JTlBVVDpub3QoOi13ZWJraXQtYXV0b2ZpbGwpLFNFTEVDVDpub3QoOi13ZWJraXQtYXV0b2ZpbGwpLFRFWFRBUkVBOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCl7YW5pbWF0aW9uLW5hbWU6b25hdXRvZmlsbGNhbmNlbH1Aa2V5ZnJhbWVzIG9uYXV0b2ZpbGxzdGFydHt9QGtleWZyYW1lcyBvbmF1dG9maWxsY2FuY2Vse31cIiwgXCJcIl0pO1xuICAgIGNvbnN0IGwgPSBhO1xuICB9LCA2NDU6IChpKSA9PiB7XG4gICAgaS5leHBvcnRzID0gZnVuY3Rpb24obikge1xuICAgICAgdmFyIG8gPSBbXTtcbiAgICAgIHJldHVybiBvLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgdmFyIGEgPSBuKHIpO1xuICAgICAgICAgIHJldHVybiByWzJdID8gXCJAbWVkaWEgXCIuY29uY2F0KHJbMl0sIFwiIHtcIikuY29uY2F0KGEsIFwifVwiKSA6IGE7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICB9LCBvLmkgPSBmdW5jdGlvbihyLCBhLCBsKSB7XG4gICAgICAgIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgKHIgPSBbW251bGwsIHIsIFwiXCJdXSk7XG4gICAgICAgIHZhciBjID0ge307XG4gICAgICAgIGlmIChsKVxuICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgdGhpcy5sZW5ndGg7IGQrKykge1xuICAgICAgICAgICAgdmFyIF8gPSB0aGlzW2RdWzBdO1xuICAgICAgICAgICAgXyAhPSBudWxsICYmIChjW19dID0gITApO1xuICAgICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCByLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgdmFyIG0gPSBbXS5jb25jYXQocltmXSk7XG4gICAgICAgICAgbCAmJiBjW21bMF1dIHx8IChhICYmIChtWzJdID8gbVsyXSA9IFwiXCIuY29uY2F0KGEsIFwiIGFuZCBcIikuY29uY2F0KG1bMl0pIDogbVsyXSA9IGEpLCBvLnB1c2gobSkpO1xuICAgICAgICB9XG4gICAgICB9LCBvO1xuICAgIH07XG4gIH0sIDgxMDogKCkgPT4ge1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93IDwgXCJ1XCIpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGkgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwidGVzdFwiLCB7IGNhbmNlbGFibGU6ICEwIH0pO1xuICAgICAgICAgIGlmIChpLnByZXZlbnREZWZhdWx0KCksIGkuZGVmYXVsdFByZXZlbnRlZCAhPT0gITApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcHJldmVudCBkZWZhdWx0XCIpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB2YXIgbiA9IGZ1bmN0aW9uKHIsIGEpIHtcbiAgICAgICAgICAgIHZhciBsLCBjO1xuICAgICAgICAgICAgcmV0dXJuIChhID0gYSB8fCB7fSkuYnViYmxlcyA9ICEhYS5idWJibGVzLCBhLmNhbmNlbGFibGUgPSAhIWEuY2FuY2VsYWJsZSwgKGwgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpKS5pbml0Q3VzdG9tRXZlbnQociwgYS5idWJibGVzLCBhLmNhbmNlbGFibGUsIGEuZGV0YWlsKSwgYyA9IGwucHJldmVudERlZmF1bHQsIGwucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgYy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRQcmV2ZW50ZWRcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9ICEwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgbi5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlLCB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBuO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgfSwgMzc5OiAoaSwgbiwgbykgPT4ge1xuICAgIHZhciByLCBhID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgaWYgKHZbRV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBBID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihFKTtcbiAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIEEgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBBID0gQS5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICBBID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB2W0VdID0gQTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdltFXTtcbiAgICAgIH07XG4gICAgfSgpLCBsID0gW107XG4gICAgZnVuY3Rpb24gYyh2KSB7XG4gICAgICBmb3IgKHZhciBFID0gLTEsIEEgPSAwOyBBIDwgbC5sZW5ndGg7IEErKylcbiAgICAgICAgaWYgKGxbQV0uaWRlbnRpZmllciA9PT0gdikge1xuICAgICAgICAgIEUgPSBBO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gRTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZCh2LCBFKSB7XG4gICAgICBmb3IgKHZhciBBID0ge30sIHkgPSBbXSwgUyA9IDA7IFMgPCB2Lmxlbmd0aDsgUysrKSB7XG4gICAgICAgIHZhciBPID0gdltTXSwgayA9IEUuYmFzZSA/IE9bMF0gKyBFLmJhc2UgOiBPWzBdLCBEID0gQVtrXSB8fCAwLCB4ID0gXCJcIi5jb25jYXQoaywgXCIgXCIpLmNvbmNhdChEKTtcbiAgICAgICAgQVtrXSA9IEQgKyAxO1xuICAgICAgICB2YXIgJCA9IGMoeCksIFAgPSB7IGNzczogT1sxXSwgbWVkaWE6IE9bMl0sIHNvdXJjZU1hcDogT1szXSB9O1xuICAgICAgICAkICE9PSAtMSA/IChsWyRdLnJlZmVyZW5jZXMrKywgbFskXS51cGRhdGVyKFApKSA6IGwucHVzaCh7IGlkZW50aWZpZXI6IHgsIHVwZGF0ZXI6IHcoUCwgRSksIHJlZmVyZW5jZXM6IDEgfSksIHkucHVzaCh4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfKHYpIHtcbiAgICAgIHZhciBFID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLCBBID0gdi5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgaWYgKEEubm9uY2UgPT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgeSA9IG8ubmM7XG4gICAgICAgIHkgJiYgKEEubm9uY2UgPSB5KTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhBKS5mb3JFYWNoKGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgRS5zZXRBdHRyaWJ1dGUoTywgQVtPXSk7XG4gICAgICB9KSwgdHlwZW9mIHYuaW5zZXJ0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdi5pbnNlcnQoRSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIFMgPSBhKHYuaW5zZXJ0IHx8IFwiaGVhZFwiKTtcbiAgICAgICAgaWYgKCFTKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIFMuYXBwZW5kQ2hpbGQoRSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gRTtcbiAgICB9XG4gICAgdmFyIGYsIG0gPSAoZiA9IFtdLCBmdW5jdGlvbih2LCBFKSB7XG4gICAgICByZXR1cm4gZlt2XSA9IEUsIGYuZmlsdGVyKEJvb2xlYW4pLmpvaW4oYFxuYCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZyh2LCBFLCBBLCB5KSB7XG4gICAgICB2YXIgUyA9IEEgPyBcIlwiIDogeS5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdCh5Lm1lZGlhLCBcIiB7XCIpLmNvbmNhdCh5LmNzcywgXCJ9XCIpIDogeS5jc3M7XG4gICAgICBpZiAodi5zdHlsZVNoZWV0KVxuICAgICAgICB2LnN0eWxlU2hlZXQuY3NzVGV4dCA9IG0oRSwgUyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIE8gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTKSwgayA9IHYuY2hpbGROb2RlcztcbiAgICAgICAga1tFXSAmJiB2LnJlbW92ZUNoaWxkKGtbRV0pLCBrLmxlbmd0aCA/IHYuaW5zZXJ0QmVmb3JlKE8sIGtbRV0pIDogdi5hcHBlbmRDaGlsZChPKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYih2LCBFLCBBKSB7XG4gICAgICB2YXIgeSA9IEEuY3NzLCBTID0gQS5tZWRpYSwgTyA9IEEuc291cmNlTWFwO1xuICAgICAgaWYgKFMgPyB2LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIFMpIDogdi5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKSwgTyAmJiB0eXBlb2YgYnRvYSA8IFwidVwiICYmICh5ICs9IGBcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsYC5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoTykpKSksIFwiICovXCIpKSwgdi5zdHlsZVNoZWV0KVxuICAgICAgICB2LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICg7IHYuZmlyc3RDaGlsZDsgKVxuICAgICAgICAgIHYucmVtb3ZlQ2hpbGQodi5maXJzdENoaWxkKTtcbiAgICAgICAgdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh5KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBUID0gbnVsbCwgQyA9IDA7XG4gICAgZnVuY3Rpb24gdyh2LCBFKSB7XG4gICAgICB2YXIgQSwgeSwgUztcbiAgICAgIGlmIChFLnNpbmdsZXRvbikge1xuICAgICAgICB2YXIgTyA9IEMrKztcbiAgICAgICAgQSA9IFQgfHwgKFQgPSBfKEUpKSwgeSA9IGcuYmluZChudWxsLCBBLCBPLCAhMSksIFMgPSBnLmJpbmQobnVsbCwgQSwgTywgITApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIEEgPSBfKEUpLCB5ID0gYi5iaW5kKG51bGwsIEEsIEUpLCBTID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGlmIChrLnBhcmVudE5vZGUgPT09IG51bGwpXG4gICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIGsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChrKTtcbiAgICAgICAgICB9KShBKTtcbiAgICAgICAgfTtcbiAgICAgIHJldHVybiB5KHYpLCBmdW5jdGlvbihrKSB7XG4gICAgICAgIGlmIChrKSB7XG4gICAgICAgICAgaWYgKGsuY3NzID09PSB2LmNzcyAmJiBrLm1lZGlhID09PSB2Lm1lZGlhICYmIGsuc291cmNlTWFwID09PSB2LnNvdXJjZU1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB5KHYgPSBrKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgUygpO1xuICAgICAgfTtcbiAgICB9XG4gICAgaS5leHBvcnRzID0gZnVuY3Rpb24odiwgRSkge1xuICAgICAgKEUgPSBFIHx8IHt9KS5zaW5nbGV0b24gfHwgdHlwZW9mIEUuc2luZ2xldG9uID09IFwiYm9vbGVhblwiIHx8IChFLnNpbmdsZXRvbiA9IChyID09PSB2b2lkIDAgJiYgKHIgPSAhISh3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYikpLCByKSk7XG4gICAgICB2YXIgQSA9IGQodiA9IHYgfHwgW10sIEUpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgaWYgKHkgPSB5IHx8IFtdLCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeSkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgIGZvciAodmFyIFMgPSAwOyBTIDwgQS5sZW5ndGg7IFMrKykge1xuICAgICAgICAgICAgdmFyIE8gPSBjKEFbU10pO1xuICAgICAgICAgICAgbFtPXS5yZWZlcmVuY2VzLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGsgPSBkKHksIEUpLCBEID0gMDsgRCA8IEEubGVuZ3RoOyBEKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gYyhBW0RdKTtcbiAgICAgICAgICAgIGxbeF0ucmVmZXJlbmNlcyA9PT0gMCAmJiAobFt4XS51cGRhdGVyKCksIGwuc3BsaWNlKHgsIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgQSA9IGs7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfSB9LCB0ID0ge307XG4gIGZ1bmN0aW9uIGUoaSkge1xuICAgIHZhciBuID0gdFtpXTtcbiAgICBpZiAobiAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG4uZXhwb3J0cztcbiAgICB2YXIgbyA9IHRbaV0gPSB7IGlkOiBpLCBleHBvcnRzOiB7fSB9O1xuICAgIHJldHVybiBzW2ldKG8sIG8uZXhwb3J0cywgZSksIG8uZXhwb3J0cztcbiAgfVxuICBlLm4gPSAoaSkgPT4ge1xuICAgIHZhciBuID0gaSAmJiBpLl9fZXNNb2R1bGUgPyAoKSA9PiBpLmRlZmF1bHQgOiAoKSA9PiBpO1xuICAgIHJldHVybiBlLmQobiwgeyBhOiBuIH0pLCBuO1xuICB9LCBlLmQgPSAoaSwgbikgPT4ge1xuICAgIGZvciAodmFyIG8gaW4gbilcbiAgICAgIGUubyhuLCBvKSAmJiAhZS5vKGksIG8pICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBvLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IG5bb10gfSk7XG4gIH0sIGUubyA9IChpLCBuKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSwgbiksICgoKSA9PiB7XG4gICAgdmFyIGkgPSBlKDM3OSksIG4gPSBlLm4oaSksIG8gPSBlKDQ1NCk7XG4gICAgZnVuY3Rpb24gcihsKSB7XG4gICAgICBpZiAoIWwuaGFzQXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiKSkge1xuICAgICAgICBsLnNldEF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIiwgXCJcIik7XG4gICAgICAgIHZhciBjID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudChcIm9uYXV0b2NvbXBsZXRlXCIsIHsgYnViYmxlczogITAsIGNhbmNlbGFibGU6ICEwLCBkZXRhaWw6IG51bGwgfSk7XG4gICAgICAgIGwuZGlzcGF0Y2hFdmVudChjKSB8fCAobC52YWx1ZSA9IFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhKGwpIHtcbiAgICAgIGwuaGFzQXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiKSAmJiAobC5yZW1vdmVBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpLCBsLmRpc3BhdGNoRXZlbnQobmV3IHdpbmRvdy5DdXN0b21FdmVudChcIm9uYXV0b2NvbXBsZXRlXCIsIHsgYnViYmxlczogITAsIGNhbmNlbGFibGU6ICExLCBkZXRhaWw6IG51bGwgfSkpKTtcbiAgICB9XG4gICAgbigpKG8uWiwgeyBpbnNlcnQ6IFwiaGVhZFwiLCBzaW5nbGV0b246ICExIH0pLCBvLloubG9jYWxzLCBlKDgxMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25zdGFydFwiLCBmdW5jdGlvbihsKSB7XG4gICAgICBsLmFuaW1hdGlvbk5hbWUgPT09IFwib25hdXRvZmlsbHN0YXJ0XCIgPyByKGwudGFyZ2V0KSA6IGEobC50YXJnZXQpO1xuICAgIH0sICEwKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uKGwpIHtcbiAgICAgIGwuaW5wdXRUeXBlICE9PSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiICYmIFwiZGF0YVwiIGluIGwgPyBhKGwudGFyZ2V0KSA6IHIobC50YXJnZXQpO1xuICAgIH0sICEwKTtcbiAgfSkoKTtcbn0pKCk7XG5jb25zdCBsbiA9IFwiaW5wdXRcIiwgTmkgPSBcInRlLmlucHV0XCIsIHVsID0gXCJkYXRhLXRlLWlucHV0LXdyYXBwZXItaW5pdFwiLCBwbCA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1yZWZcIiwgZmwgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtbGVhZGluZy1yZWZcIiwgX2wgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtbWlkZGxlLXJlZlwiLCBycCA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC10cmFpbGluZy1yZWZcIiwgYXAgPSBcImRhdGEtdGUtaW5wdXQtaGVscGVyLXJlZlwiLCBscCA9IFwiZGF0YS10ZS1pbnB1dC1wbGFjZWhvbGRlci1hY3RpdmVcIiwgSHQgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIGZyID0gXCJkYXRhLXRlLWlucHV0LWZvY3VzZWRcIiwgX3IgPSBcImRhdGEtdGUtaW5wdXQtZm9ybS1jb3VudGVyXCIsIHJlID0gYFske3VsfV0gaW5wdXRgLCBhZSA9IGBbJHt1bH1dIHRleHRhcmVhYCwgRWUgPSBgWyR7cGx9XWAsIG1yID0gYFske2ZsfV1gLCBnciA9IGBbJHtfbH1dYCwgY3AgPSBgWyR7YXB9XWAsIGRwID0ge1xuICBpbnB1dEZvcm1XaGl0ZTogITFcbn0sIGhwID0ge1xuICBpbnB1dEZvcm1XaGl0ZTogXCIoYm9vbGVhbilcIlxufSwgdXAgPSB7XG4gIG5vdGNoOiBcImdyb3VwIGZsZXggYWJzb2x1dGUgbGVmdC0wIHRvcC0wIHctZnVsbCBtYXgtdy1mdWxsIGgtZnVsbCB0ZXh0LWxlZnQgcG9pbnRlci1ldmVudHMtbm9uZVwiLFxuICBub3RjaExlYWRpbmc6IFwicG9pbnRlci1ldmVudHMtbm9uZSBib3JkZXIgYm9yZGVyLXNvbGlkIGJveC1ib3JkZXIgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGxlZnQtMCB0b3AtMCBoLWZ1bGwgdy0yIGJvcmRlci1yLTAgcm91bmRlZC1sLVswLjI1cmVtXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItci0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXItMFwiLFxuICBub3RjaExlYWRpbmdOb3JtYWw6IFwiYm9yZGVyLW5ldXRyYWwtMzAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bLTFweF8wXzBfIzNiNzFjYSxfMF8xcHhfMF8wXyMzYjcxY2EsXzBfLTFweF8wXzBfIzNiNzFjYV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXByaW1hcnlcIixcbiAgbm90Y2hMZWFkaW5nV2hpdGU6IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bLTFweF8wXzBfI2ZmZmZmZixfMF8xcHhfMF8wXyNmZmZmZmYsXzBfLTFweF8wXzBfI2ZmZmZmZl0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXdoaXRlXCIsXG4gIG5vdGNoTWlkZGxlOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBncm93LTAgc2hyaW5rLTAgYmFzaXMtYXV0byB3LWF1dG8gbWF4LXctW2NhbGMoMTAwJS0xcmVtKV0gaC1mdWxsIGJvcmRlci1yLTAgYm9yZGVyLWwtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXIteC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXgtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItdCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci10IGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1zb2xpZCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci1zb2xpZCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItdC10cmFuc3BhcmVudCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci10LXRyYW5zcGFyZW50XCIsXG4gIG5vdGNoTWlkZGxlTm9ybWFsOiBcImJvcmRlci1uZXV0cmFsLTMwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzBfMXB4XzBfMF8jM2I3MWNhXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxuICBub3RjaE1pZGRsZVdoaXRlOiBcImJvcmRlci1uZXV0cmFsLTIwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzBfMXB4XzBfMF8jZmZmZmZmXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItd2hpdGVcIixcbiAgbm90Y2hUcmFpbGluZzogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZ3JvdyBoLWZ1bGwgYm9yZGVyLWwtMCByb3VuZGVkLXItWzAuMjVyZW1dIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1sLTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItbC0wXCIsXG4gIG5vdGNoVHJhaWxpbmdOb3JtYWw6IFwiYm9yZGVyLW5ldXRyYWwtMzAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jM2I3MWNhLF8wXy0xcHhfMF8wXyMzYjcxY2EsXzBfMXB4XzBfMF8jM2I3MWNhXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxuICBub3RjaFRyYWlsaW5nV2hpdGU6IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jZmZmZmZmLF8wXy0xcHhfMF8wXyNmZmZmZmYsXzBfMXB4XzBfMF8jZmZmZmZmXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItd2hpdGVcIixcbiAgY291bnRlcjogXCJ0ZXh0LXJpZ2h0IGxlYWRpbmctWzEuNl1cIlxufSwgcHAgPSB7XG4gIG5vdGNoOiBcInN0cmluZ1wiLFxuICBub3RjaExlYWRpbmc6IFwic3RyaW5nXCIsXG4gIG5vdGNoTGVhZGluZ05vcm1hbDogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nV2hpdGU6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlOiBcInN0cmluZ1wiLFxuICBub3RjaE1pZGRsZU5vcm1hbDogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGVXaGl0ZTogXCJzdHJpbmdcIixcbiAgbm90Y2hUcmFpbGluZzogXCJzdHJpbmdcIixcbiAgbm90Y2hUcmFpbGluZ05vcm1hbDogXCJzdHJpbmdcIixcbiAgbm90Y2hUcmFpbGluZ1doaXRlOiBcInN0cmluZ1wiLFxuICBjb3VudGVyOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgViB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSwgdCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fbGFiZWwgPSBudWxsLCB0aGlzLl9sYWJlbFdpZHRoID0gMCwgdGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gMCwgdGhpcy5fbm90Y2hMZWFkaW5nID0gbnVsbCwgdGhpcy5fbm90Y2hNaWRkbGUgPSBudWxsLCB0aGlzLl9ub3RjaFRyYWlsaW5nID0gbnVsbCwgdGhpcy5faW5pdGlhdGVkID0gITEsIHRoaXMuX2hlbHBlciA9IG51bGwsIHRoaXMuX2NvdW50ZXIgPSAhMSwgdGhpcy5fY291bnRlckVsZW1lbnQgPSBudWxsLCB0aGlzLl9tYXhMZW5ndGggPSAwLCB0aGlzLl9sZWFkaW5nSWNvbiA9IG51bGwsIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCBOaSwgdGhpcyksIHRoaXMuaW5pdCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gbG47XG4gIH1cbiAgZ2V0IGlucHV0KCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUoXCJpbnB1dFwiLCB0aGlzLl9lbGVtZW50KSB8fCBoLmZpbmRPbmUoXCJ0ZXh0YXJlYVwiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9pbml0aWF0ZWQgfHwgKHRoaXMuX2dldExhYmVsRGF0YSgpLCB0aGlzLl9hcHBseURpdnMoKSwgdGhpcy5fYXBwbHlOb3RjaCgpLCB0aGlzLl9hY3RpdmF0ZSgpLCB0aGlzLl9nZXRIZWxwZXIoKSwgdGhpcy5fZ2V0Q291bnRlcigpLCB0aGlzLl9nZXRFdmVudHMoKSwgdGhpcy5faW5pdGlhdGVkID0gITApO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9nZXRMYWJlbERhdGEoKSwgdGhpcy5fZ2V0Tm90Y2hEYXRhKCksIHRoaXMuX2FwcGx5Tm90Y2goKSwgdGhpcy5fYWN0aXZhdGUoKSwgdGhpcy5fZ2V0SGVscGVyKCksIHRoaXMuX2dldENvdW50ZXIoKTtcbiAgfVxuICBmb3JjZUFjdGl2ZSgpIHtcbiAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShIdCwgXCJcIiksIGguZmluZE9uZShFZSwgdGhpcy5pbnB1dC5wYXJlbnROb2RlKS5zZXRBdHRyaWJ1dGUoXG4gICAgICBIdCxcbiAgICAgIFwiXCJcbiAgICApO1xuICB9XG4gIGZvcmNlSW5hY3RpdmUoKSB7XG4gICAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoSHQpLCBoLmZpbmRPbmUoXG4gICAgICBFZSxcbiAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZVxuICAgICkucmVtb3ZlQXR0cmlidXRlKEh0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3JlbW92ZUJvcmRlcigpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgTmkpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCwgZSkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZHAsXG4gICAgICAuLi5wLmdldERhdGFBdHRyaWJ1dGVzKGUpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIE4obG4sIHQsIGhwKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnVwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKGxuLCB0LCBwcCksIHQ7XG4gIH1cbiAgX2dldExhYmVsRGF0YSgpIHtcbiAgICB0aGlzLl9sYWJlbCA9IGguZmluZE9uZShcImxhYmVsXCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9sYWJlbCA9PT0gbnVsbCA/IHRoaXMuX3Nob3dQbGFjZWhvbGRlcigpIDogKHRoaXMuX2dldExhYmVsV2lkdGgoKSwgdGhpcy5fZ2V0TGFiZWxQb3NpdGlvbkluSW5wdXRHcm91cCgpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKCkpO1xuICB9XG4gIF9nZXRIZWxwZXIoKSB7XG4gICAgdGhpcy5faGVscGVyID0gaC5maW5kT25lKGNwLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfZ2V0Q291bnRlcigpIHtcbiAgICB0aGlzLl9jb3VudGVyID0gcC5nZXREYXRhQXR0cmlidXRlKFxuICAgICAgdGhpcy5pbnB1dCxcbiAgICAgIFwiaW5wdXRTaG93Y291bnRlclwiXG4gICAgKSwgdGhpcy5fY291bnRlciAmJiAodGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pbnB1dC5tYXhMZW5ndGgsIHRoaXMuX3Nob3dDb3VudGVyKCkpO1xuICB9XG4gIF9nZXRFdmVudHMoKSB7XG4gICAgdS5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJmb2N1c1wiLFxuICAgICAgcmUsXG4gICAgICBWLmFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgdS5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgcmUsXG4gICAgICBWLmFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgdS5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJibHVyXCIsXG4gICAgICByZSxcbiAgICAgIFYuZGVhY3RpdmF0ZShuZXcgVigpKVxuICAgICksIHUub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgIGFlLFxuICAgICAgVi5hY3RpdmF0ZShuZXcgVigpKVxuICAgICksIHUub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIGFlLFxuICAgICAgVi5hY3RpdmF0ZShuZXcgVigpKVxuICAgICksIHUub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiYmx1clwiLFxuICAgICAgYWUsXG4gICAgICBWLmRlYWN0aXZhdGUobmV3IFYoKSlcbiAgICApLCB1Lm9uKHdpbmRvdywgXCJzaG93bi50ZS5tb2RhbFwiLCAodCkgPT4ge1xuICAgICAgaC5maW5kKHJlLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVi5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKSwgaC5maW5kKGFlLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVi5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KSwgdS5vbih3aW5kb3csIFwic2hvd24udGUuZHJvcGRvd25cIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnRhcmdldC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIFwiW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdXCJcbiAgICAgICk7XG4gICAgICBlICYmIChoLmZpbmQocmUsIGUpLmZvckVhY2goXG4gICAgICAgIChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbiA9IFYuZ2V0SW5zdGFuY2UoaS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBuICYmIG4udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICksIGguZmluZChhZSwgZSkuZm9yRWFjaChcbiAgICAgICAgKGkpID0+IHtcbiAgICAgICAgICBjb25zdCBuID0gVi5nZXRJbnN0YW5jZShpLnBhcmVudE5vZGUpO1xuICAgICAgICAgIG4gJiYgbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgfSksIHUub24od2luZG93LCBcInNob3duLnRlLnRhYlwiLCAodCkgPT4ge1xuICAgICAgbGV0IGU7XG4gICAgICB0LnRhcmdldC5ocmVmID8gZSA9IHQudGFyZ2V0LmhyZWYuc3BsaXQoXCIjXCIpWzFdIDogZSA9IHAuZ2V0RGF0YUF0dHJpYnV0ZSh0LnRhcmdldCwgXCJ0YXJnZXRcIikuc3BsaXQoXG4gICAgICAgIFwiI1wiXG4gICAgICApWzFdO1xuICAgICAgY29uc3QgaSA9IGguZmluZE9uZShgIyR7ZX1gKTtcbiAgICAgIGguZmluZChyZSwgaSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBjb25zdCBvID0gVi5nZXRJbnN0YW5jZShuLnBhcmVudE5vZGUpO1xuICAgICAgICBvICYmIG8udXBkYXRlKCk7XG4gICAgICB9KSwgaC5maW5kKGFlLCBpKS5mb3JFYWNoKFxuICAgICAgICAobikgPT4ge1xuICAgICAgICAgIGNvbnN0IG8gPSBWLmdldEluc3RhbmNlKG4ucGFyZW50Tm9kZSk7XG4gICAgICAgICAgbyAmJiBvLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pLCB1Lm9uKHdpbmRvdywgXCJyZXNldFwiLCAodCkgPT4ge1xuICAgICAgaC5maW5kKHJlLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVi5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS5mb3JjZUluYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICksIGguZmluZChhZSwgdC50YXJnZXQpLmZvckVhY2goXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IFYuZ2V0SW5zdGFuY2UoZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBpICYmIGkuZm9yY2VJbmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pLCB1Lm9uKHdpbmRvdywgXCJvbmF1dG9jb21wbGV0ZVwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IFYuZ2V0SW5zdGFuY2UodC50YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAhZSB8fCAhdC5jYW5jZWxhYmxlIHx8IGUuZm9yY2VBY3RpdmUoKTtcbiAgICB9KTtcbiAgfVxuICBfc2hvd0NvdW50ZXIoKSB7XG4gICAgaWYgKGguZmluZChcbiAgICAgIGBbJHtfcn1dYCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY291bnRlckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBwLmFkZENsYXNzKHRoaXMuX2NvdW50ZXJFbGVtZW50LCB0aGlzLl9jbGFzc2VzLmNvdW50ZXIpLCB0aGlzLl9jb3VudGVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoX3IsIFwiXCIpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aDtcbiAgICB0aGlzLl9jb3VudGVyRWxlbWVudC5pbm5lckhUTUwgPSBgJHtlfSAvICR7dGhpcy5fbWF4TGVuZ3RofWAsIHRoaXMuX2hlbHBlci5hcHBlbmRDaGlsZCh0aGlzLl9jb3VudGVyRWxlbWVudCksIHRoaXMuX2JpbmRDb3VudGVyKCk7XG4gIH1cbiAgX2JpbmRDb3VudGVyKCkge1xuICAgIHUub24odGhpcy5pbnB1dCwgXCJpbnB1dFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGg7XG4gICAgICB0aGlzLl9jb3VudGVyRWxlbWVudC5pbm5lckhUTUwgPSBgJHt0fSAvICR7dGhpcy5fbWF4TGVuZ3RofWA7XG4gICAgfSk7XG4gIH1cbiAgX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIodCA9IHRoaXMuaW5wdXQpIHtcbiAgICBpZiAoISh0LmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT09IFwiZGF0ZVwiKSlcbiAgICAgIHJldHVybjtcbiAgICAhKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHQpICYmICF0LnZhbHVlID8gdC5zdHlsZS5vcGFjaXR5ID0gMCA6IHQuc3R5bGUub3BhY2l0eSA9IDE7XG4gIH1cbiAgX3Nob3dQbGFjZWhvbGRlcigpIHtcbiAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShscCwgXCJcIik7XG4gIH1cbiAgX2dldE5vdGNoRGF0YSgpIHtcbiAgICB0aGlzLl9ub3RjaE1pZGRsZSA9IGguZmluZE9uZShcbiAgICAgIGdyLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX25vdGNoTGVhZGluZyA9IGguZmluZE9uZShcbiAgICAgIG1yLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gIH1cbiAgX2dldExhYmVsV2lkdGgoKSB7XG4gICAgdGhpcy5fbGFiZWxXaWR0aCA9IHRoaXMuX2xhYmVsLmNsaWVudFdpZHRoICogMC44ICsgODtcbiAgfVxuICBfZ2V0TGFiZWxQb3NpdGlvbkluSW5wdXRHcm91cCgpIHtcbiAgICBpZiAodGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gMCwgIXRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGF0YS10ZS1pbnB1dC1ncm91cC1yZWZcIikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuaW5wdXQsIGUgPSBoLnByZXYoXG4gICAgICB0LFxuICAgICAgXCJbZGF0YS10ZS1pbnB1dC1ncm91cC10ZXh0LXJlZl1cIlxuICAgIClbMF07XG4gICAgZSA9PT0gdm9pZCAwID8gdGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gMCA6IHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IGUub2Zmc2V0V2lkdGggLSAxO1xuICB9XG4gIF9hcHBseURpdnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZy5pbnB1dEZvcm1XaGl0ZSA/IHRoaXMuX2NsYXNzZXMubm90Y2hMZWFkaW5nV2hpdGUgOiB0aGlzLl9jbGFzc2VzLm5vdGNoTGVhZGluZ05vcm1hbCwgZSA9IHRoaXMuX2NvbmZpZy5pbnB1dEZvcm1XaGl0ZSA/IHRoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGVXaGl0ZSA6IHRoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGVOb3JtYWwsIGkgPSB0aGlzLl9jb25maWcuaW5wdXRGb3JtV2hpdGUgPyB0aGlzLl9jbGFzc2VzLm5vdGNoVHJhaWxpbmdXaGl0ZSA6IHRoaXMuX2NsYXNzZXMubm90Y2hUcmFpbGluZ05vcm1hbCwgbiA9IGguZmluZChFZSwgdGhpcy5fZWxlbWVudCksIG8gPSBNKFwiZGl2XCIpO1xuICAgIHAuYWRkQ2xhc3MobywgdGhpcy5fY2xhc3Nlcy5ub3RjaCksIG8uc2V0QXR0cmlidXRlKHBsLCBcIlwiKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gTShcImRpdlwiKSwgcC5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX25vdGNoTGVhZGluZyxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubm90Y2hMZWFkaW5nfSAke3R9YFxuICAgICksIHRoaXMuX25vdGNoTGVhZGluZy5zZXRBdHRyaWJ1dGUoZmwsIFwiXCIpLCB0aGlzLl9ub3RjaE1pZGRsZSA9IE0oXCJkaXZcIiksIHAuYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9ub3RjaE1pZGRsZSxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGV9ICR7ZX1gXG4gICAgKSwgdGhpcy5fbm90Y2hNaWRkbGUuc2V0QXR0cmlidXRlKF9sLCBcIlwiKSwgdGhpcy5fbm90Y2hUcmFpbGluZyA9IE0oXCJkaXZcIiksIHAuYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9ub3RjaFRyYWlsaW5nLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5ub3RjaFRyYWlsaW5nfSAke2l9YFxuICAgICksIHRoaXMuX25vdGNoVHJhaWxpbmcuc2V0QXR0cmlidXRlKHJwLCBcIlwiKSwgIShuLmxlbmd0aCA+PSAxKSAmJiAoby5hcHBlbmQodGhpcy5fbm90Y2hMZWFkaW5nKSwgby5hcHBlbmQodGhpcy5fbm90Y2hNaWRkbGUpLCBvLmFwcGVuZCh0aGlzLl9ub3RjaFRyYWlsaW5nKSwgdGhpcy5fZWxlbWVudC5hcHBlbmQobykpO1xuICB9XG4gIF9hcHBseU5vdGNoKCkge1xuICAgIHRoaXMuX25vdGNoTWlkZGxlLnN0eWxlLndpZHRoID0gYCR7dGhpcy5fbGFiZWxXaWR0aH1weGAsIHRoaXMuX25vdGNoTGVhZGluZy5zdHlsZS53aWR0aCA9IGAke3RoaXMuX2xhYmVsTWFyZ2luTGVmdCArIDl9cHhgLCB0aGlzLl9sYWJlbCAhPT0gbnVsbCAmJiAodGhpcy5fbGFiZWwuc3R5bGUubWFyZ2luTGVmdCA9IGAke3RoaXMuX2xhYmVsTWFyZ2luTGVmdH1weGApO1xuICB9XG4gIF9yZW1vdmVCb3JkZXIoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZE9uZShFZSwgdGhpcy5fZWxlbWVudCk7XG4gICAgdCAmJiB0LnJlbW92ZSgpO1xuICB9XG4gIF9hY3RpdmF0ZSh0KSB7XG4gICAgQWEoKCkgPT4ge1xuICAgICAgdGhpcy5fZ2V0RWxlbWVudHModCk7XG4gICAgICBjb25zdCBlID0gdCA/IHQudGFyZ2V0IDogdGhpcy5pbnB1dCwgaSA9IGguZmluZE9uZShcbiAgICAgICAgRWUsXG4gICAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICAgICk7XG4gICAgICB0ICYmIHQudHlwZSA9PT0gXCJmb2N1c1wiICYmIGkuc2V0QXR0cmlidXRlKGZyLCBcIlwiKSwgZS52YWx1ZSAhPT0gXCJcIiAmJiAoZS5zZXRBdHRyaWJ1dGUoSHQsIFwiXCIpLCBpLnNldEF0dHJpYnV0ZShIdCwgXCJcIikpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKGUpO1xuICAgIH0pO1xuICB9XG4gIF9nZXRFbGVtZW50cyh0KSB7XG4gICAgaWYgKHQgJiYgKHRoaXMuX2VsZW1lbnQgPSB0LnRhcmdldC5wYXJlbnROb2RlLCB0aGlzLl9sYWJlbCA9IGguZmluZE9uZShcImxhYmVsXCIsIHRoaXMuX2VsZW1lbnQpKSwgdCAmJiB0aGlzLl9sYWJlbCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX2xhYmVsV2lkdGg7XG4gICAgICB0aGlzLl9nZXRMYWJlbERhdGEoKSwgZSAhPT0gdGhpcy5fbGFiZWxXaWR0aCAmJiAodGhpcy5fbm90Y2hNaWRkbGUgPSBoLmZpbmRPbmUoXG4gICAgICAgIGdyLFxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXG4gICAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBoLmZpbmRPbmUoXG4gICAgICAgIG1yLFxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXG4gICAgICApLCB0aGlzLl9hcHBseU5vdGNoKCkpO1xuICAgIH1cbiAgfVxuICBfZGVhY3RpdmF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyB0LnRhcmdldCA6IHRoaXMuaW5wdXQsIGkgPSBoLmZpbmRPbmUoXG4gICAgICBFZSxcbiAgICAgIGUucGFyZW50Tm9kZVxuICAgICk7XG4gICAgaS5yZW1vdmVBdHRyaWJ1dGUoZnIpLCBlLnZhbHVlID09PSBcIlwiICYmIChlLnJlbW92ZUF0dHJpYnV0ZShIdCksIGkucmVtb3ZlQXR0cmlidXRlKEh0KSksIHRoaXMuX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIoZSk7XG4gIH1cbiAgc3RhdGljIGFjdGl2YXRlKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdC5fYWN0aXZhdGUoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVhY3RpdmF0ZSh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHQuX2RlYWN0aXZhdGUoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBJLmdldERhdGEodGhpcywgTmkpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBWKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIE5pKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBiciA9IFwiYW5pbWF0aW9uXCIsIGNuID0gXCJ0ZS5hbmltYXRpb25cIiwgZnAgPSB7XG4gIGFuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgYW5pbWF0aW9uU3RhcnQ6IFwic3RyaW5nXCIsXG4gIGFuaW1hdGlvblNob3dPbkxvYWQ6IFwiYm9vbGVhblwiLFxuICBvblN0YXJ0OiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBvbkVuZDogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgb25IaWRlOiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBvblNob3c6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGFuaW1hdGlvbk9uU2Nyb2xsOiBcIihzdHJpbmcpXCIsXG4gIGFuaW1hdGlvbldpbmRvd0hlaWdodDogXCJudW1iZXJcIixcbiAgYW5pbWF0aW9uT2Zmc2V0OiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBhbmltYXRpb25EZWxheTogXCIobnVtYmVyfHN0cmluZylcIixcbiAgYW5pbWF0aW9uUmV2ZXJzZTogXCJib29sZWFuXCIsXG4gIGFuaW1hdGlvbkludGVydmFsOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBhbmltYXRpb25SZXBlYXQ6IFwiKG51bWJlcnxib29sZWFuKVwiLFxuICBhbmltYXRpb25SZXNldDogXCJib29sZWFuXCJcbn0sIF9wID0ge1xuICBhbmltYXRpb246IFwiZmFkZVwiLFxuICBhbmltYXRpb25TdGFydDogXCJvbkNsaWNrXCIsXG4gIGFuaW1hdGlvblNob3dPbkxvYWQ6ICEwLFxuICBvblN0YXJ0OiBudWxsLFxuICBvbkVuZDogbnVsbCxcbiAgb25IaWRlOiBudWxsLFxuICBvblNob3c6IG51bGwsXG4gIGFuaW1hdGlvbk9uU2Nyb2xsOiBcIm9uY2VcIixcbiAgYW5pbWF0aW9uV2luZG93SGVpZ2h0OiAwLFxuICBhbmltYXRpb25PZmZzZXQ6IDAsXG4gIGFuaW1hdGlvbkRlbGF5OiAwLFxuICBhbmltYXRpb25SZXZlcnNlOiAhMSxcbiAgYW5pbWF0aW9uSW50ZXJ2YWw6IDAsXG4gIGFuaW1hdGlvblJlcGVhdDogITEsXG4gIGFuaW1hdGlvblJlc2V0OiAhMVxufTtcbmNsYXNzIG1sIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9hbmltYXRlRWxlbWVudCA9IHRoaXMuX2dldEFuaW1hdGVFbGVtZW50KCksIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMCwgdGhpcy5fcmVwZWF0QW5pbWF0ZU9uU2Nyb2xsID0gITAsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCBjbiwgdGhpcyksIHRoaXMuX2luaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGJyO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICBzdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl9zdGFydEFuaW1hdGlvbigpO1xuICB9XG4gIHN0b3BBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpO1xuICB9XG4gIGNoYW5nZUFuaW1hdGlvblR5cGUodCkge1xuICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uID0gdDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHUub2ZmKHRoaXMuX2VsZW1lbnQsIFwibW91c2Vkb3duXCIpLCB1Lm9mZih0aGlzLl9hbmltYXRlRWxlbWVudCwgXCJhbmltYXRpb25lbmRcIiksIHUub2ZmKHdpbmRvdywgXCJzY3JvbGxcIiksIHUub2ZmKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdmVyXCIpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgY24pLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fYW5pbWF0ZUVsZW1lbnQgPSBudWxsLCB0aGlzLl9pc0ZpcnN0U2Nyb2xsID0gbnVsbCwgdGhpcy5fcmVwZWF0QW5pbWF0ZU9uU2Nyb2xsID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uU3RhcnQpIHtcbiAgICAgIGNhc2UgXCJvbkhvdmVyXCI6XG4gICAgICAgIHRoaXMuX2JpbmRIb3ZlckV2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvbkxvYWRcIjpcbiAgICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib25TY3JvbGxcIjpcbiAgICAgICAgdGhpcy5fYmluZFNjcm9sbEV2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvbkNsaWNrXCI6XG4gICAgICAgIHRoaXMuX2JpbmRDbGlja0V2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fYmluZFRyaWdnZXJPbkVuZENhbGxiYWNrKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVzZXQgJiYgdGhpcy5fYmluZFJlc2V0QW5pbWF0aW9uQWZ0ZXJGaW5pc2goKTtcbiAgfVxuICBfZ2V0QW5pbWF0ZUVsZW1lbnQoKSB7XG4gICAgY29uc3QgdCA9IHAuZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImFuaW1hdGlvbi10YXJnZXRcIlxuICAgICk7XG4gICAgcmV0dXJuIHQgPyBoLmZpbmQodClbMF0gOiB0aGlzLl9lbGVtZW50O1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2FuaW1hdGVFbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLl9wLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKGJyLCB0LCBmcCksIHQ7XG4gIH1cbiAgX2FuaW1hdGVPblNjcm9sbCgpIHtcbiAgICBjb25zdCB0ID0gcC5vZmZzZXQodGhpcy5fYW5pbWF0ZUVsZW1lbnQpLnRvcCwgZSA9IHRoaXMuX2FuaW1hdGVFbGVtZW50Lm9mZnNldEhlaWdodCwgaSA9IHdpbmRvdy5pbm5lckhlaWdodCwgbiA9IHQgKyB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9mZnNldCA8PSBpICYmIHQgKyB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9mZnNldCArIGUgPj0gMCwgbyA9IHRoaXMuX2FuaW1hdGVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiO1xuICAgIHN3aXRjaCAoITApIHtcbiAgICAgIGNhc2UgKG4gJiYgdGhpcy5faXNGaXJzdFNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMSwgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICghbiAmJiB0aGlzLl9pc0ZpcnN0U2Nyb2xsKTpcbiAgICAgICAgdGhpcy5faXNGaXJzdFNjcm9sbCA9ICExLCB0aGlzLl9oaWRlQW5pbWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIChuICYmICFvICYmIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCk6XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uT25TY3JvbGwgIT09IFwicmVwZWF0XCIgJiYgKHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCA9ICExKSwgdGhpcy5fY2FsbGJhY2sodGhpcy5fb3B0aW9ucy5vblNob3cpLCB0aGlzLl9zaG93QW5pbWF0ZUVsZW1lbnQoKSwgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICghbiAmJiBvICYmIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2hpZGVBbmltYXRlRWxlbWVudCgpLCB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCksIHRoaXMuX2NhbGxiYWNrKHRoaXMuX29wdGlvbnMub25IaWRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIF9hZGRBbmltYXRlZENsYXNzKCkge1xuICAgIHAuYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9hbmltYXRlRWxlbWVudCxcbiAgICAgIGBhbmltYXRlLSR7dGhpcy5fb3B0aW9ucy5hbmltYXRpb259YFxuICAgICk7XG4gIH1cbiAgX2NsZWFyQW5pbWF0aW9uQ2xhc3MoKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgYW5pbWF0ZS0ke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9ufWApO1xuICB9XG4gIF9zdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uU3RhcnQpLCB0aGlzLl9hZGRBbmltYXRlZENsYXNzKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVwZWF0ICYmICF0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkludGVydmFsICYmIHRoaXMuX3NldEFuaW1hdGlvblJlcGVhdCgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJldmVyc2UgJiYgdGhpcy5fc2V0QW5pbWF0aW9uUmV2ZXJzZSgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkRlbGF5ICYmIHRoaXMuX3NldEFuaW1hdGlvbkRlbGF5KCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24gJiYgdGhpcy5fc2V0QW5pbWF0aW9uRHVyYXRpb24oKSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCAmJiB0aGlzLl9zZXRBbmltYXRpb25JbnRlcnZhbCgpO1xuICB9XG4gIF9zZXRBbmltYXRpb25SZXZlcnNlKCkge1xuICAgIHAuc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHtcbiAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJlcGVhdCA9PT0gITAgPyBcImluZmluaXRlXCIgOiBcIjJcIixcbiAgICAgIGFuaW1hdGlvbkRpcmVjdGlvbjogXCJhbHRlcm5hdGVcIlxuICAgIH0pO1xuICB9XG4gIF9zZXRBbmltYXRpb25EdXJhdGlvbigpIHtcbiAgICBwLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25EdXJhdGlvbjogYCR7dGhpcy5fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbn1tc2BcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uRGVsYXkoKSB7XG4gICAgcC5zdHlsZSh0aGlzLl9hbmltYXRlRWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uRGVsYXk6IGAke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9uRGVsYXl9bXNgXG4gICAgfSk7XG4gIH1cbiAgX3NldEFuaW1hdGlvblJlcGVhdCgpIHtcbiAgICBwLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXQgPT09ICEwID8gXCJpbmZpbml0ZVwiIDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXRcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uSW50ZXJ2YWwoKSB7XG4gICAgdS5vbih0aGlzLl9hbmltYXRlRWxlbWVudCwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRBbmltYXRlZENsYXNzKCk7XG4gICAgICB9LCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkludGVydmFsKTtcbiAgICB9KTtcbiAgfVxuICBfaGlkZUFuaW1hdGVFbGVtZW50KCkge1xuICAgIHAuc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9KTtcbiAgfVxuICBfc2hvd0FuaW1hdGVFbGVtZW50KCkge1xuICAgIHAuc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHsgdmlzaWJpbGl0eTogXCJ2aXNpYmxlXCIgfSk7XG4gIH1cbiAgX2JpbmRSZXNldEFuaW1hdGlvbkFmdGVyRmluaXNoKCkge1xuICAgIHUub24odGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2NsZWFyQW5pbWF0aW9uQ2xhc3MoKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZFRyaWdnZXJPbkVuZENhbGxiYWNrKCkge1xuICAgIHUub24odGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMuX29wdGlvbnMub25FbmQpO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kU2Nyb2xsRXZlbnRzKCkge1xuICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uU2hvd09uTG9hZCB8fCB0aGlzLl9hbmltYXRlT25TY3JvbGwoKSwgdS5vbih3aW5kb3csIFwic2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2FuaW1hdGVPblNjcm9sbCgpO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kQ2xpY2tFdmVudHMoKSB7XG4gICAgdS5vbih0aGlzLl9lbGVtZW50LCBcIm1vdXNlZG93blwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zdGFydEFuaW1hdGlvbigpO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kSG92ZXJFdmVudHMoKSB7XG4gICAgdS5vbmUodGhpcy5fZWxlbWVudCwgXCJtb3VzZW92ZXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICB9KSwgdS5vbmUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9iaW5kSG92ZXJFdmVudHMoKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSk7XG4gIH1cbiAgX2NhbGxiYWNrKHQpIHtcbiAgICB0IGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgdCgpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgYXV0b0luaXQodCkge1xuICAgIHQuX2luaXQoKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICBuZXcgbWwodGhpc1swXSwgdCkuaW5pdCgpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBjbik7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgZG4gPSBcInJpcHBsZVwiLCBSaSA9IFwidGUucmlwcGxlXCIsIG1wID0gXCJyZ2JhKHt7Y29sb3J9fSwgMC4yKSAwLCByZ2JhKHt7Y29sb3J9fSwgMC4zKSA0MCUsIHJnYmEoe3tjb2xvcn19LCAwLjQpIDUwJSwgcmdiYSh7e2NvbG9yfX0sIDAuNSkgNjAlLCByZ2JhKHt7Y29sb3J9fSwgMCkgNzAlXCIsIGdwID0gW1wiW2RhdGEtdGUtcmlwcGxlLWluaXRdXCJdLCBQaSA9IFswLCAwLCAwXSwgYnAgPSBbXG4gIHsgbmFtZTogXCJwcmltYXJ5XCIsIGdyYWRpZW50Q29sb3I6IFwiIzNCNzFDQVwiIH0sXG4gIHsgbmFtZTogXCJzZWNvbmRhcnlcIiwgZ3JhZGllbnRDb2xvcjogXCIjOUZBNkIyXCIgfSxcbiAgeyBuYW1lOiBcInN1Y2Nlc3NcIiwgZ3JhZGllbnRDb2xvcjogXCIjMTRBNDREXCIgfSxcbiAgeyBuYW1lOiBcImRhbmdlclwiLCBncmFkaWVudENvbG9yOiBcIiNEQzRDNjRcIiB9LFxuICB7IG5hbWU6IFwid2FybmluZ1wiLCBncmFkaWVudENvbG9yOiBcIiNFNEExMUJcIiB9LFxuICB7IG5hbWU6IFwiaW5mb1wiLCBncmFkaWVudENvbG9yOiBcIiM1NEI0RDNcIiB9LFxuICB7IG5hbWU6IFwibGlnaHRcIiwgZ3JhZGllbnRDb2xvcjogXCIjZmJmYmZiXCIgfSxcbiAgeyBuYW1lOiBcImRhcmtcIiwgZ3JhZGllbnRDb2xvcjogXCIjMjYyNjI2XCIgfVxuXSwgdnIgPSAwLjUsIHZwID0ge1xuICByaXBwbGVDZW50ZXJlZDogITEsXG4gIHJpcHBsZUNvbG9yOiBcIlwiLFxuICByaXBwbGVDb2xvckRhcms6IFwiXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcIjUwMG1zXCIsXG4gIHJpcHBsZVJhZGl1czogMCxcbiAgcmlwcGxlVW5ib3VuZDogITFcbn0sIEVwID0ge1xuICByaXBwbGVDZW50ZXJlZDogXCJib29sZWFuXCIsXG4gIHJpcHBsZUNvbG9yOiBcInN0cmluZ1wiLFxuICByaXBwbGVDb2xvckRhcms6IFwic3RyaW5nXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcInN0cmluZ1wiLFxuICByaXBwbGVSYWRpdXM6IFwibnVtYmVyXCIsXG4gIHJpcHBsZVVuYm91bmQ6IFwiYm9vbGVhblwiXG59LCBUcCA9IHtcbiAgcmlwcGxlOiBcInJlbGF0aXZlIG92ZXJmbG93LWhpZGRlbiBpbmxpbmUtYmxvY2sgYWxpZ24tYm90dG9tXCIsXG4gIHJpcHBsZVdhdmU6IFwicm91bmRlZC1bNTAlXSBvcGFjaXR5LTUwIHBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG91Y2gtbm9uZSBzY2FsZS0wIHRyYW5zaXRpb24tW3RyYW5zZm9ybSxfb3BhY2l0eV0gZWFzZS1bY3ViaWMtYmV6aWVyKDAsMCwwLjE1LDEpLF9jdWJpYy1iZXppZXIoMCwwLDAuMTUsMSldIHotWzk5OV1cIixcbiAgdW5ib3VuZDogXCJvdmVyZmxvdy12aXNpYmxlXCJcbn0sIENwID0ge1xuICByaXBwbGU6IFwic3RyaW5nXCIsXG4gIHJpcHBsZVdhdmU6IFwic3RyaW5nXCIsXG4gIHVuYm91bmQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBDcyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2VsZW1lbnQgJiYgKEkuc2V0RGF0YSh0LCBSaSwgdGhpcyksIHAuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpKSwgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5fY3JlYXRlUmlwcGxlLmJpbmQodGhpcyksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCwgdGhpcy5faXNNaW5XaWR0aFNldCA9ICExLCB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IG51bGwsIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBkbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9hZGRDbGlja0V2ZW50KHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIFJpKSwgdS5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfYXV0b0luaXQodCkge1xuICAgIGdwLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGguY2xvc2VzdCh0LnRhcmdldCwgZSkgJiYgKHRoaXMuX2VsZW1lbnQgPSBoLmNsb3Nlc3QodC50YXJnZXQsIGUpKTtcbiAgICB9KSwgdGhpcy5fZWxlbWVudC5zdHlsZS5taW5XaWR0aCB8fCAocC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICBcIm1pbi13aWR0aFwiOiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLndpZHRoXG4gICAgfSksIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMCksIHRoaXMuX2luaXRpYWxDbGFzc2VzID0gWy4uLnRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0XSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnJpcHBsZSksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoKSwgdGhpcy5fY3JlYXRlUmlwcGxlKHQpO1xuICB9XG4gIF9hZGRDbGlja0V2ZW50KHQpIHtcbiAgICB1Lm9uKHQsIFwibW91c2Vkb3duXCIsIHRoaXMuX2NsaWNrSGFuZGxlcik7XG4gIH1cbiAgX2NyZWF0ZVJpcHBsZSh0KSB7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZih0aGlzLl9jbGFzc2VzLnJpcHBsZSkgPCAwICYmIHAuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpO1xuICAgIGNvbnN0IHsgbGF5ZXJYOiBlLCBsYXllclk6IGkgfSA9IHQsIG4gPSBlLCBvID0gaSwgciA9IHRoaXMuX2VsZW1lbnQub2Zmc2V0SGVpZ2h0LCBhID0gdGhpcy5fZWxlbWVudC5vZmZzZXRXaWR0aCwgbCA9IHRoaXMuX2R1cmF0aW9uVG9Nc051bWJlcih0aGlzLl9vcHRpb25zLnJpcHBsZUR1cmF0aW9uKSwgYyA9IHtcbiAgICAgIG9mZnNldFg6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyByIC8gMiA6IG4sXG4gICAgICBvZmZzZXRZOiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYSAvIDIgOiBvLFxuICAgICAgaGVpZ2h0OiByLFxuICAgICAgd2lkdGg6IGFcbiAgICB9LCBkID0gdGhpcy5fZ2V0RGlhbWV0ZXIoYyksIF8gPSB0aGlzLl9vcHRpb25zLnJpcHBsZVJhZGl1cyB8fCBkIC8gMiwgZiA9IHtcbiAgICAgIGRlbGF5OiBsICogdnIsXG4gICAgICBkdXJhdGlvbjogbCAtIGwgKiB2clxuICAgIH0sIG0gPSB7XG4gICAgICBsZWZ0OiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYCR7YSAvIDIgLSBffXB4YCA6IGAke24gLSBffXB4YCxcbiAgICAgIHRvcDogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IGAke3IgLyAyIC0gX31weGAgOiBgJHtvIC0gX31weGAsXG4gICAgICBoZWlnaHQ6IGAke3RoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzICogMiB8fCBkfXB4YCxcbiAgICAgIHdpZHRoOiBgJHt0aGlzLl9vcHRpb25zLnJpcHBsZVJhZGl1cyAqIDIgfHwgZH1weGAsXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IGAwcywgJHtmLmRlbGF5fW1zYCxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7bH1tcywgJHtmLmR1cmF0aW9ufW1zYFxuICAgIH0sIGcgPSBNKFwiZGl2XCIpO1xuICAgIHRoaXMuX2NyZWF0ZUhUTUxSaXBwbGUoe1xuICAgICAgd3JhcHBlcjogdGhpcy5fZWxlbWVudCxcbiAgICAgIHJpcHBsZTogZyxcbiAgICAgIHN0eWxlczogbVxuICAgIH0pLCB0aGlzLl9yZW1vdmVIVE1MUmlwcGxlKHsgcmlwcGxlOiBnLCBkdXJhdGlvbjogbCB9KTtcbiAgfVxuICBfY3JlYXRlSFRNTFJpcHBsZSh7IHdyYXBwZXI6IHQsIHJpcHBsZTogZSwgc3R5bGVzOiBpIH0pIHtcbiAgICBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKFxuICAgICAgKG4pID0+IGUuc3R5bGVbbl0gPSBpW25dXG4gICAgKSwgcC5hZGRDbGFzcyhlLCB0aGlzLl9jbGFzc2VzLnJpcHBsZVdhdmUpLCBlLnNldEF0dHJpYnV0ZShcImRhdGEtdGUtcmlwcGxlLXJlZlwiLCBcIlwiKSwgdGhpcy5fYWRkQ29sb3IoZSwgdCksIHRoaXMuX3RvZ2dsZVVuYm91bmQodCksIHRoaXMuX2FwcGVuZFJpcHBsZShlLCB0KTtcbiAgfVxuICBfcmVtb3ZlSFRNTFJpcHBsZSh7IHJpcHBsZTogdCwgZHVyYXRpb246IGUgfSkge1xuICAgIHRoaXMuX3JpcHBsZVRpbWVyICYmIChjbGVhclRpbWVvdXQodGhpcy5fcmlwcGxlVGltZXIpLCB0aGlzLl9yaXBwbGVUaW1lciA9IG51bGwpLCB0ICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdC5jbGFzc0xpc3QuYWRkKFwiIW9wYWNpdHktMFwiKTtcbiAgICB9LCAxMCksIHRoaXMuX3JpcHBsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodCAmJiAodC5yZW1vdmUoKSwgdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgICAgaC5maW5kKFwiW2RhdGEtdGUtcmlwcGxlLXJlZl1cIiwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChcbiAgICAgICAgICAobikgPT4ge1xuICAgICAgICAgICAgbi5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICksIHRoaXMuX2lzTWluV2lkdGhTZXQgJiYgKHAuc3R5bGUodGhpcy5fZWxlbWVudCwgeyBcIm1pbi13aWR0aFwiOiBcIlwiIH0pLCB0aGlzLl9pc01pbldpZHRoU2V0ID0gITEpO1xuICAgICAgICBjb25zdCBpID0gdGhpcy5faW5pdGlhbENsYXNzZXMgPyB0aGlzLl9hZGRlZE5ld1JpcHBsZUNsYXNzZXMoXG4gICAgICAgICAgdGhpcy5fY2xhc3Nlcy5yaXBwbGUsXG4gICAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXNcbiAgICAgICAgKSA6IHRoaXMuX2NsYXNzZXMucmlwcGxlLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgcC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBpKTtcbiAgICAgIH1cbiAgICB9LCBlKTtcbiAgfVxuICBfYWRkZWROZXdSaXBwbGVDbGFzc2VzKHQsIGUpIHtcbiAgICByZXR1cm4gdC5zcGxpdChcIiBcIikuZmlsdGVyKFxuICAgICAgKGkpID0+IGUuZmluZEluZGV4KChuKSA9PiBpID09PSBuKSA9PT0gLTFcbiAgICApO1xuICB9XG4gIF9kdXJhdGlvblRvTXNOdW1iZXIodCkge1xuICAgIHJldHVybiBOdW1iZXIodC5yZXBsYWNlKFwibXNcIiwgXCJcIikucmVwbGFjZShcInNcIiwgXCIwMDBcIikpO1xuICB9XG4gIF9nZXRDb25maWcodCA9IHt9KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi52cCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTihkbiwgdCwgRXApLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uVHAsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4oZG4sIHQsIENwKSwgdDtcbiAgfVxuICBfZ2V0RGlhbWV0ZXIoeyBvZmZzZXRYOiB0LCBvZmZzZXRZOiBlLCBoZWlnaHQ6IGksIHdpZHRoOiBuIH0pIHtcbiAgICBjb25zdCBvID0gZSA8PSBpIC8gMiwgciA9IHQgPD0gbiAvIDIsIGEgPSAoZiwgbSkgPT4gTWF0aC5zcXJ0KGYgKiogMiArIG0gKiogMiksIGwgPSBlID09PSBpIC8gMiAmJiB0ID09PSBuIC8gMiwgYyA9IHtcbiAgICAgIGZpcnN0OiBvID09PSAhMCAmJiByID09PSAhMSxcbiAgICAgIHNlY29uZDogbyA9PT0gITAgJiYgciA9PT0gITAsXG4gICAgICB0aGlyZDogbyA9PT0gITEgJiYgciA9PT0gITAsXG4gICAgICBmb3VydGg6IG8gPT09ICExICYmIHIgPT09ICExXG4gICAgfSwgZCA9IHtcbiAgICAgIHRvcExlZnQ6IGEodCwgZSksXG4gICAgICB0b3BSaWdodDogYShuIC0gdCwgZSksXG4gICAgICBib3R0b21MZWZ0OiBhKHQsIGkgLSBlKSxcbiAgICAgIGJvdHRvbVJpZ2h0OiBhKG4gLSB0LCBpIC0gZSlcbiAgICB9O1xuICAgIGxldCBfID0gMDtcbiAgICByZXR1cm4gbCB8fCBjLmZvdXJ0aCA/IF8gPSBkLnRvcExlZnQgOiBjLnRoaXJkID8gXyA9IGQudG9wUmlnaHQgOiBjLnNlY29uZCA/IF8gPSBkLmJvdHRvbVJpZ2h0IDogYy5maXJzdCAmJiAoXyA9IGQuYm90dG9tTGVmdCksIF8gKiAyO1xuICB9XG4gIF9hcHBlbmRSaXBwbGUodCwgZSkge1xuICAgIGUuYXBwZW5kQ2hpbGQodCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcC5hZGRDbGFzcyh0LCBcIm9wYWNpdHktMCBzY2FsZS0xMDBcIik7XG4gICAgfSwgNTApO1xuICB9XG4gIF90b2dnbGVVbmJvdW5kKHQpIHtcbiAgICB0aGlzLl9vcHRpb25zLnJpcHBsZVVuYm91bmQgPT09ICEwID8gcC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnVuYm91bmQpIDogcC5yZW1vdmVDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnVuYm91bmQpO1xuICB9XG4gIF9hZGRDb2xvcih0KSB7XG4gICAgbGV0IGUgPSB0aGlzLl9vcHRpb25zLnJpcHBsZUNvbG9yIHx8IFwicmdiKDAsMCwwKVwiO1xuICAgIChsb2NhbFN0b3JhZ2UudGhlbWUgPT09IFwiZGFya1wiIHx8ICEoXCJ0aGVtZVwiIGluIGxvY2FsU3RvcmFnZSkgJiYgd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIpLm1hdGNoZXMpICYmIChlID0gdGhpcy5fb3B0aW9ucy5yaXBwbGVDb2xvckRhcmsgfHwgdGhpcy5fb3B0aW9ucy5yaXBwbGVDb2xvcik7XG4gICAgY29uc3QgaSA9IGJwLmZpbmQoXG4gICAgICAocikgPT4gci5uYW1lID09PSBlLnRvTG93ZXJDYXNlKClcbiAgICApLCBuID0gaSA/IHRoaXMuX2NvbG9yVG9SR0IoaS5ncmFkaWVudENvbG9yKS5qb2luKFwiLFwiKSA6IHRoaXMuX2NvbG9yVG9SR0IoZSkuam9pbihcIixcIiksIG8gPSBtcC5zcGxpdChcInt7Y29sb3J9fVwiKS5qb2luKGAke259YCk7XG4gICAgdC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgcmFkaWFsLWdyYWRpZW50KGNpcmNsZSwgJHtvfSlgO1xuICB9XG4gIF9jb2xvclRvUkdCKHQpIHtcbiAgICBmdW5jdGlvbiBlKG8pIHtcbiAgICAgIHJldHVybiBvLmxlbmd0aCA8IDcgJiYgKG8gPSBgIyR7b1sxXX0ke29bMV19JHtvWzJdfSR7b1syXX0ke29bM119JHtvWzNdfWApLCBbXG4gICAgICAgIHBhcnNlSW50KG8uc3Vic3RyKDEsIDIpLCAxNiksXG4gICAgICAgIHBhcnNlSW50KG8uc3Vic3RyKDMsIDIpLCAxNiksXG4gICAgICAgIHBhcnNlSW50KG8uc3Vic3RyKDUsIDIpLCAxNilcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGkobykge1xuICAgICAgY29uc3QgciA9IGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoXG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWN0dW1cIilcbiAgICAgICksIGEgPSBcInJnYigxLCAyLCAzKVwiO1xuICAgICAgcmV0dXJuIHIuc3R5bGUuY29sb3IgPSBhLCByLnN0eWxlLmNvbG9yICE9PSBhIHx8IChyLnN0eWxlLmNvbG9yID0gbywgci5zdHlsZS5jb2xvciA9PT0gYSB8fCByLnN0eWxlLmNvbG9yID09PSBcIlwiKSA/IFBpIDogKG8gPSBnZXRDb21wdXRlZFN0eWxlKHIpLmNvbG9yLCBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHIpLCBvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbihvKSB7XG4gICAgICByZXR1cm4gbyA9IG8ubWF0Y2goL1suXFxkXSsvZykubWFwKChyKSA9PiArTnVtYmVyKHIpKSwgby5sZW5ndGggPSAzLCBvO1xuICAgIH1cbiAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpID09PSBcInRyYW5zcGFyZW50XCIgPyBQaSA6IHRbMF0gPT09IFwiI1wiID8gZSh0KSA6ICh0LmluZGV4T2YoXCJyZ2JcIikgPT09IC0xICYmICh0ID0gaSh0KSksIHQuaW5kZXhPZihcInJnYlwiKSA9PT0gMCA/IG4odCkgOiBQaSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBhdXRvSW5pdGlhbCh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHQuX2F1dG9Jbml0KGUpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJLmdldERhdGEodGhpcywgUmkpID8gbnVsbCA6IG5ldyBDcyh0aGlzLCB0KTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgUmkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIFEocykge1xuICByZXR1cm4gcy5nZXREYXRlKCk7XG59XG5mdW5jdGlvbiBscyhzKSB7XG4gIHJldHVybiBzLmdldERheSgpO1xufVxuZnVuY3Rpb24gWShzKSB7XG4gIHJldHVybiBzLmdldE1vbnRoKCk7XG59XG5mdW5jdGlvbiBIKHMpIHtcbiAgcmV0dXJuIHMuZ2V0RnVsbFllYXIoKTtcbn1cbmZ1bmN0aW9uIEFwKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IGUuc3RhcnREYXksIG4gPSBpID4gMCA/IDcgLSBpIDogMCwgciA9IG5ldyBEYXRlKHMsIHQpLmdldERheSgpICsgbjtcbiAgcmV0dXJuIHIgPj0gNyA/IHIgLSA3IDogcjtcbn1cbmZ1bmN0aW9uIFduKHMpIHtcbiAgcmV0dXJuIHlwKHMpLmdldERhdGUoKTtcbn1cbmZ1bmN0aW9uIHlwKHMpIHtcbiAgcmV0dXJuIER0KHMuZ2V0RnVsbFllYXIoKSwgcy5nZXRNb250aCgpICsgMSwgMCk7XG59XG5mdW5jdGlvbiBEZSgpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xufVxuZnVuY3Rpb24gaXQocywgdCkge1xuICByZXR1cm4gbnQocywgdCAqIDEyKTtcbn1cbmZ1bmN0aW9uIG50KHMsIHQpIHtcbiAgY29uc3QgZSA9IER0KFxuICAgIHMuZ2V0RnVsbFllYXIoKSxcbiAgICBzLmdldE1vbnRoKCkgKyB0LFxuICAgIHMuZ2V0RGF0ZSgpXG4gICksIGkgPSBRKHMpLCBuID0gUShlKTtcbiAgcmV0dXJuIGkgIT09IG4gJiYgZS5zZXREYXRlKDApLCBlO1xufVxuZnVuY3Rpb24gVGUocywgdCkge1xuICByZXR1cm4gRHQocy5nZXRGdWxsWWVhcigpLCBzLmdldE1vbnRoKCksIHMuZ2V0RGF0ZSgpICsgdCk7XG59XG5mdW5jdGlvbiBEdChzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBuZXcgRGF0ZShzLCB0LCBlKTtcbiAgcmV0dXJuIHMgPj0gMCAmJiBzIDwgMTAwICYmIGkuc2V0RnVsbFllYXIoaS5nZXRGdWxsWWVhcigpIC0gMTkwMCksIGk7XG59XG5mdW5jdGlvbiBFcihzKSB7XG4gIGNvbnN0IHQgPSBzLnNwbGl0KFwiLVwiKSwgZSA9IHRbMF0sIGkgPSB0WzFdLCBuID0gdFsyXTtcbiAgcmV0dXJuIER0KGUsIGksIG4pO1xufVxuZnVuY3Rpb24gd3Aocykge1xuICByZXR1cm4gIU51bWJlci5pc05hTihzLmdldFRpbWUoKSk7XG59XG5mdW5jdGlvbiB4ZShzLCB0KSB7XG4gIHJldHVybiBIKHMpIC0gSCh0KSB8fCBZKHMpIC0gWSh0KSB8fCBRKHMpIC0gUSh0KTtcbn1cbmZ1bmN0aW9uIGRlKHMsIHQpIHtcbiAgcmV0dXJuIHMuc2V0SG91cnMoMCwgMCwgMCwgMCksIHQuc2V0SG91cnMoMCwgMCwgMCwgMCksIHMuZ2V0VGltZSgpID09PSB0LmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIGNzKHMsIHQpIHtcbiAgY29uc3QgaSA9IEgocykgLSBPcCgpO1xuICByZXR1cm4ga3AoaSwgdCk7XG59XG5mdW5jdGlvbiBrcChzLCB0KSB7XG4gIHJldHVybiAocyAlIHQgKyB0KSAlIHQ7XG59XG5mdW5jdGlvbiBPcChzLCB0LCBlKSB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuIGUgPyBpID0gSChlKSAtIHMgKyAxIDogdCAmJiAoaSA9IEgodCkpLCBpO1xufVxuZnVuY3Rpb24gQXMocywgdCwgZSwgaSwgbiwgbykge1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIHIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IGEgPSB0ICYmIHhlKHMsIHQpIDw9IC0xLCBsID0gZSAmJiB4ZShzLCBlKSA+PSAxLCBjID0gbiAmJiB4ZShzLCByKSA8PSAtMSwgZCA9IG8gJiYgeGUocywgcikgPj0gMSwgXyA9IGkgJiYgaShzKSA9PT0gITE7XG4gIHJldHVybiBhIHx8IGwgfHwgXyB8fCBjIHx8IGQ7XG59XG5mdW5jdGlvbiBnbChzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgYSA9IGkgJiYgSChpKSwgbCA9IGkgJiYgWShpKSwgYyA9IGUgJiYgSChlKSwgZCA9IGUgJiYgWShlKSwgXyA9IEgociksIGYgPSBZKHIpLCBtID0gbCAmJiBhICYmICh0ID4gYSB8fCB0ID09PSBhICYmIHMgPiBsKSwgZyA9IGQgJiYgYyAmJiAodCA8IGMgfHwgdCA9PT0gYyAmJiBzIDwgZCksIGIgPSBuICYmICh0IDwgXyB8fCB0ID09PSBfICYmIHMgPCBmKSwgVCA9IG8gJiYgKHQgPiBfIHx8IHQgPT09IF8gJiYgcyA+IGYpO1xuICByZXR1cm4gbSB8fCBnIHx8IGIgfHwgVDtcbn1cbmZ1bmN0aW9uIEZuKHMsIHQsIGUsIGksIG4pIHtcbiAgY29uc3QgbyA9IHQgJiYgSCh0KSwgciA9IGUgJiYgSChlKSwgYSA9IEgoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLCBsID0gciAmJiBzID4gciwgYyA9IG8gJiYgcyA8IG8sIGQgPSBpICYmIHMgPCBhLCBfID0gbiAmJiBzID4gYTtcbiAgcmV0dXJuIGwgfHwgYyB8fCBkIHx8IF87XG59XG5mdW5jdGlvbiB4cChzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSB7XG4gIGNvbnN0IGwgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgcmV0dXJuIGwuc2V0SG91cnMoMCwgMCwgMCwgMCksIChzICYmIG8gJiYgeGUobywgbCkgPCAwIHx8IHMpICYmIChvID0gbCksIG8gJiYgZGkoXG4gICAgdCxcbiAgICBvLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhXG4gICk7XG59XG5mdW5jdGlvbiBTcChzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSB7XG4gIGNvbnN0IGwgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgcmV0dXJuIGwuc2V0SG91cnMoMCwgMCwgMCwgMCksIChzICYmIG4gJiYgeGUobiwgbCkgPCAwIHx8IHMpICYmIChuID0gbCksIG4gJiYgZGkoXG4gICAgdCxcbiAgICBuLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhXG4gICk7XG59XG5mdW5jdGlvbiBkaShzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSB7XG4gIHJldHVybiBlID09PSBcImRheXNcIiA/IEgocykgPT09IEgodCkgJiYgWShzKSA9PT0gWSh0KSA6IGUgPT09IFwibW9udGhzXCIgPyBIKHMpID09PSBIKHQpIDogZSA9PT0gXCJ5ZWFyc1wiID8gSCh0KSA+PSBhICYmIEgodCkgPD0gciA6ICExO1xufVxuY29uc3QgRHAgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1tb2RhbC1jb250YWluZXItcmVmXCIsIElwID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItZHJvcGRvd24tY29udGFpbmVyLXJlZlwiLCAkcCA9IFwiZGF0YS10ZS1kcm9wZG93bi1iYWNrZHJvcC1yZWZcIiwgTHAgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1kYXRlLXRleHQtcmVmXCIsIFRyID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItdmlldy1yZWZcIiwgTXAgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1wcmV2aW91cy1idXR0b24tcmVmXCIsIE5wID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItbmV4dC1idXR0b24tcmVmXCIsIFJwID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItb2stYnV0dG9uLXJlZlwiLCBQcCA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNhbmNlbC1idXR0b24tcmVmXCIsIEhwID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2xlYXItYnV0dG9uLXJlZlwiLCBCcCA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctY2hhbmdlLWJ1dHRvbi1yZWZcIjtcbmZ1bmN0aW9uIFZwKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIGMpIHtcbiAgY29uc3QgZCA9IFkocyksIF8gPSBIKHMpLCBmID0gUShzKSwgbSA9IGxzKHMpLCBnID0gTShcImRpdlwiKSwgYiA9IGBcbiAgICAgICAgJHtDcihcbiAgICBzLFxuICAgIGQsXG4gICAgXyxcbiAgICB0LFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIGNcbiAgKX1cbiAgICBgLCBUID0gYFxuICAgICAgJHtGcChmLCBtLCBkLCBuLCBjKX1cbiAgICAgICR7Q3IoXG4gICAgcyxcbiAgICBkLFxuICAgIF8sXG4gICAgdCxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBjXG4gICl9XG4gICAgYDtcbiAgcmV0dXJuIG4uaW5saW5lID8gKHAuYWRkQ2xhc3MoZywgYy5kYXRlcGlja2VyRHJvcGRvd25Db250YWluZXIpLCBnLnNldEF0dHJpYnV0ZShJcCwgbCksIGcuaW5uZXJIVE1MID0gYikgOiAocC5hZGRDbGFzcyhnLCBjLm1vZGFsQ29udGFpbmVyKSwgZy5zZXRBdHRyaWJ1dGUoRHAsIGwpLCBnLmlubmVySFRNTCA9IFQpLCBnO1xufVxuZnVuY3Rpb24gV3Aocykge1xuICBjb25zdCB0ID0gTShcImRpdlwiKTtcbiAgcmV0dXJuIHAuYWRkQ2xhc3ModCwgcyksIHQuc2V0QXR0cmlidXRlKCRwLCBcIlwiKSwgdDtcbn1cbmZ1bmN0aW9uIEZwKHMsIHQsIGUsIGksIG4pIHtcbiAgcmV0dXJuIGBcbiAgICAgIDxkaXYgY2xhc3M9XCIke24uZGF0ZXBpY2tlckhlYWRlcn1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyVGl0bGV9XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCIke24uZGF0ZXBpY2tlclRpdGxlVGV4dH1cIj4ke2kudGl0bGV9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyRGF0ZX1cIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyRGF0ZVRleHR9XCIgJHtMcH0gPiR7aS53ZWVrZGF5c1Nob3J0W3RdfSwgJHtpLm1vbnRoc1Nob3J0W2VdfSAke3N9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG59XG5mdW5jdGlvbiBDcihzLCB0LCBlLCBpLCBuLCBvLCByLCBhLCBsLCBjLCBkKSB7XG4gIGxldCBfO1xuICByZXR1cm4gci5pbmxpbmUgPyBfID0gYFxuICAgIDxkaXYgY2xhc3M9XCIke2QuZGF0ZXBpY2tlck1haW59XCI+XG4gICAgICAke3lyKHQsIGUsIHIsIGQpfVxuICAgICAgPGRpdiBjbGFzcz1cIiR7ZC5kYXRlcGlja2VyVmlld31cIiAke1RyfSB0YWJpbmRleD1cIjBcIj5cbiAgICAgICAgJHtBcihcbiAgICBzLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIGwsXG4gICAgYyxcbiAgICBkXG4gICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCA6IF8gPSBgXG4gICAgPGRpdiBjbGFzcz1cIiR7ZC5kYXRlcGlja2VyTWFpbn1cIj5cbiAgICAgICR7eXIodCwgZSwgciwgZCl9XG4gICAgICA8ZGl2IGNsYXNzPVwiJHtkLmRhdGVwaWNrZXJWaWV3fVwiICR7VHJ9IHRhYmluZGV4PVwiMFwiPlxuICAgICAgICAke0FyKFxuICAgIHMsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgbCxcbiAgICBjLFxuICAgIGRcbiAgKX1cbiAgICAgIDwvZGl2PlxuICAgICAgJHtZcChyLCBkKX1cbiAgICA8L2Rpdj5cbiAgYCwgXztcbn1cbmZ1bmN0aW9uIEFyKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIGMpIHtcbiAgbGV0IGQ7XG4gIHJldHVybiBvLnZpZXcgPT09IFwiZGF5c1wiID8gZCA9IGRzKHMsIGUsIG8sIGMpIDogby52aWV3ID09PSBcIm1vbnRoc1wiID8gZCA9IGhzKFxuICAgIHQsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBjXG4gICkgOiBkID0gdXMoXG4gICAgcyxcbiAgICBpLFxuICAgIG8sXG4gICAgYSxcbiAgICBsLFxuICAgIGNcbiAgKSwgZDtcbn1cbmZ1bmN0aW9uIHlyKHMsIHQsIGUsIGkpIHtcbiAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJEYXRlQ29udHJvbHN9XCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJWaWV3Q2hhbmdlQnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2Uuc3dpdGNoVG9NdWx0aVllYXJWaWV3TGFiZWx9XCIgJHtCcH0+XG4gICAgICAgICR7ZS5tb250aHNGdWxsW3NdfSAke3R9ICR7a3QoXG4gICAgZSxcbiAgICBpXG4gICl9XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke2kuZGF0ZXBpY2tlckFycm93Q29udHJvbHN9XCI+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCIke2kuZGF0ZXBpY2tlclByZXZpb3VzQnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2UucHJldk1vbnRoTGFiZWx9XCIgJHtNcH0+JHtlLmNoYW5nZU1vbnRoSWNvblRlbXBsYXRlfTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJOZXh0QnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2UubmV4dE1vbnRoTGFiZWx9XCIgJHtOcH0+JHtlLmNoYW5nZU1vbnRoSWNvblRlbXBsYXRlfTwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYDtcbn1cbmZ1bmN0aW9uIGt0KHMsIHQpIHtcbiAgcmV0dXJuIGBcbiAgPHNwYW4gY2xhc3M9XCIke3QuZGF0ZXBpY2tlclZpZXdDaGFuZ2VJY29ufVwiPlxuICAke3Mudmlld0NoYW5nZUljb25UZW1wbGF0ZX1cbiAgPC9zcGFuPlxuICBgO1xufVxuZnVuY3Rpb24gWXAocywgdCkge1xuICBjb25zdCBlID0gYDxidXR0b24gY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3RlckJ0bn1cIiBhcmlhLWxhYmVsPVwiJHtzLm9rQnRuTGFiZWx9XCIgJHtScH0+JHtzLm9rQnRuVGV4dH08L2J1dHRvbj5gLCBpID0gYDxidXR0b24gY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3RlckJ0bn1cIiBhcmlhLWxhYmVsPVwiJHtzLmNhbmNlbEJ0bkxhYmVsfVwiICR7UHB9PiR7cy5jYW5jZWxCdG5UZXh0fTwvYnV0dG9uPmAsIG4gPSBgPGJ1dHRvbiBjbGFzcz1cIiR7dC5kYXRlcGlja2VyRm9vdGVyQnRufSAke3QuZGF0ZXBpY2tlckNsZWFyQnRufVwiIGFyaWEtbGFiZWw9XCIke3MuY2xlYXJCdG5MYWJlbH1cIiAke0hwfT4ke3MuY2xlYXJCdG5UZXh0fTwvYnV0dG9uPmA7XG4gIHJldHVybiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3Rlcn1cIj5cbiAgICAgICAgICBcbiAgICAgICAgJHtzLnJlbW92ZUNsZWFyQnRuID8gXCJcIiA6IG59XG4gICAgICAgICR7cy5yZW1vdmVDYW5jZWxCdG4gPyBcIlwiIDogaX1cbiAgICAgICAgJHtzLnJlbW92ZU9rQnRuID8gXCJcIiA6IGV9XG4gICAgICAgIDwvZGl2PlxuICAgICAgYDtcbn1cbmZ1bmN0aW9uIGRzKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IGpwKHMsIHQsIGUpLCByID0gYFxuICAgICAgPHRyPlxuICAgICAgICAke2Uud2Vla2RheXNOYXJyb3cubWFwKChsLCBjKSA9PiBgPHRoIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJEYXlIZWFkaW5nfVwiIHNjb3BlPVwiY29sXCIgYXJpYS1sYWJlbD1cIiR7ZS53ZWVrZGF5c0Z1bGxbY119XCI+JHtsfTwvdGg+YCkuam9pbihcIlwiKX1cbiAgICAgIDwvdHI+XG4gICAgYCwgYSA9IG4ubWFwKChsKSA9PiBgXG4gICAgICAgIDx0cj5cbiAgICAgICAgICAke2wubWFwKChjKSA9PiBgXG4gICAgICAgICAgICAgIDx0ZFxuICAgICAgICAgICAgICBjbGFzcz1cIiR7aS5kYXRlcGlja2VyQ2VsbH0gJHtpLmRhdGVwaWNrZXJDZWxsU21hbGx9XCJcbiAgICAgICAgICAgICAgZGF0YS10ZS1kYXRlPVwiJHtIKGMuZGF0ZSl9LSR7WShcbiAgICBjLmRhdGVcbiAgKX0tJHtRKGMuZGF0ZSl9XCJcbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIiR7Yy5kYXRlfVwiXG4gICAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9XCIke2MuaXNTZWxlY3RlZH1cIlxuICAgICAgICAgICAgICAke2MuaXNTZWxlY3RlZCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7IWMuY3VycmVudE1vbnRoIHx8IGMuZGlzYWJsZWQgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAke2MuaXNUb2RheSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJDZWxsQ29udGVudH0gJHtpLmRhdGVwaWNrZXJDZWxsQ29udGVudFNtYWxsfVwiXG4gICAgICAgICAgICAgICAgICBzdHlsZT1cIiR7Yy5jdXJyZW50TW9udGggPyBcImRpc3BsYXk6IGJsb2NrXCIgOiBcImRpc3BsYXk6IG5vbmVcIn1cIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgJHtjLmRheU51bWJlcn1cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgYCkuam9pbihcIlwiKX1cbiAgICAgICAgPC90cj5cbiAgICAgIGApLmpvaW4oXCJcIik7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke2kuZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgJHtyfVxuICAgICAgICA8L3RoZWFkPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAke2F9XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgIGA7XG59XG5mdW5jdGlvbiBqcChzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBbXSwgbiA9IFkocyksIG8gPSBZKG50KHMsIC0xKSksIHIgPSBZKG50KHMsIDEpKSwgYSA9IEgocyksIGwgPSBBcChhLCBuLCBlKSwgYyA9IFduKHMpLCBkID0gV24obnQocywgLTEpKSwgXyA9IDc7XG4gIGxldCBmID0gMSwgbSA9ICExO1xuICBmb3IgKGxldCBnID0gMTsgZyA8IF87IGcrKykge1xuICAgIGNvbnN0IGIgPSBbXTtcbiAgICBpZiAoZyA9PT0gMSkge1xuICAgICAgY29uc3QgVCA9IGQgLSBsICsgMTtcbiAgICAgIGZvciAobGV0IHcgPSBUOyB3IDw9IGQ7IHcrKykge1xuICAgICAgICBjb25zdCB2ID0gRHQoYSwgbywgdyk7XG4gICAgICAgIGIucHVzaCh7XG4gICAgICAgICAgZGF0ZTogdixcbiAgICAgICAgICBjdXJyZW50TW9udGg6IG0sXG4gICAgICAgICAgaXNTZWxlY3RlZDogdCAmJiBkZSh2LCB0KSxcbiAgICAgICAgICBpc1RvZGF5OiBkZSh2LCBEZSgpKSxcbiAgICAgICAgICBkYXlOdW1iZXI6IFEodilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBtID0gITA7XG4gICAgICBjb25zdCBDID0gXyAtIGIubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCBDOyB3KyspIHtcbiAgICAgICAgY29uc3QgdiA9IER0KGEsIG4sIGYpO1xuICAgICAgICBiLnB1c2goe1xuICAgICAgICAgIGRhdGU6IHYsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBtLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHQgJiYgZGUodiwgdCksXG4gICAgICAgICAgaXNUb2RheTogZGUodiwgRGUoKSksXG4gICAgICAgICAgZGF5TnVtYmVyOiBRKHYpLFxuICAgICAgICAgIGRpc2FibGVkOiBBcyhcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICBlLm1pbixcbiAgICAgICAgICAgIGUubWF4LFxuICAgICAgICAgICAgZS5maWx0ZXIsXG4gICAgICAgICAgICBlLmRpc2FibGVQYXN0LFxuICAgICAgICAgICAgZS5kaXNhYmxlRnV0dXJlXG4gICAgICAgICAgKVxuICAgICAgICB9KSwgZisrO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZm9yIChsZXQgVCA9IDE7IFQgPCA4OyBUKyspIHtcbiAgICAgICAgZiA+IGMgJiYgKGYgPSAxLCBtID0gITEpO1xuICAgICAgICBjb25zdCBDID0gRHQoXG4gICAgICAgICAgYSxcbiAgICAgICAgICBtID8gbiA6IHIsXG4gICAgICAgICAgZlxuICAgICAgICApO1xuICAgICAgICBiLnB1c2goe1xuICAgICAgICAgIGRhdGU6IEMsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBtLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHQgJiYgZGUoQywgdCksXG4gICAgICAgICAgaXNUb2RheTogZGUoQywgRGUoKSksXG4gICAgICAgICAgZGF5TnVtYmVyOiBRKEMpLFxuICAgICAgICAgIGRpc2FibGVkOiBBcyhcbiAgICAgICAgICAgIEMsXG4gICAgICAgICAgICBlLm1pbixcbiAgICAgICAgICAgIGUubWF4LFxuICAgICAgICAgICAgZS5maWx0ZXIsXG4gICAgICAgICAgICBlLmRpc2FibGVQYXN0LFxuICAgICAgICAgICAgZS5kaXNhYmxlRnV0dXJlXG4gICAgICAgICAgKVxuICAgICAgICB9KSwgZisrO1xuICAgICAgfVxuICAgIGkucHVzaChiKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIGhzKHMsIHQsIGUsIGksIG4sIG8pIHtcbiAgY29uc3QgciA9IEtwKGksIG4pLCBhID0gWShEZSgpKSwgbCA9IEgoRGUoKSksIGMgPSBgXG4gICAgICAke3IubWFwKChkKSA9PiBgXG4gICAgICAgICAgPHRyPlxuICAgICAgICAgICAgJHtkLm1hcCgoXykgPT4ge1xuICAgIGNvbnN0IGYgPSBpLm1vbnRoc1Nob3J0LmluZGV4T2YoXyk7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGx9ICR7by5kYXRlcGlja2VyQ2VsbExhcmdlfVwiXG4gICAgICAgICAgICAgICAgJHtnbChcbiAgICAgIGYsXG4gICAgICBzLFxuICAgICAgaS5taW4sXG4gICAgICBpLm1heCxcbiAgICAgIGkuZGlzYWJsZVBhc3QsXG4gICAgICBpLmRpc2FibGVGdXR1cmVcbiAgICApID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkYXRhLXRlLW1vbnRoPVwiJHtmfVwiIGRhdGEtdGUteWVhcj1cIiR7c31cIiBhcmlhLWxhYmVsPVwiJHtffSwgJHtzfVwiXG4gICAgICAgICAgICAgICAgJHtmID09PSBlICYmIHMgPT09IHQgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAgICR7ZiA9PT0gYSAmJiBzID09PSBsID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XCIgOiBcIlwifVwiIGRhdGEtdGUtbW9udGg9XCIke2Z9XCIgZGF0YS10ZS15ZWFyPVwiJHtzfVwiIGFyaWEtbGFiZWw9XCIke199LCAke3N9XCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtvLmRhdGVwaWNrZXJDZWxsQ29udGVudH0gJHtvLmRhdGVwaWNrZXJDZWxsQ29udGVudExhcmdlfVwiPiR7X308L2Rpdj5cbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICBgO1xuICB9KS5qb2luKFwiXCIpfVxuICAgICAgICAgIDwvdHI+XG4gICAgICAgIGApLmpvaW4oXCJcIil9XG4gICAgYDtcbiAgcmV0dXJuIGBcbiAgICAgIDx0YWJsZSBjbGFzcz1cIiR7by5kYXRlcGlja2VyVGFibGV9XCI+XG4gICAgICAgIDx0Ym9keT5cbiAgICAgICAgICR7Y31cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgYDtcbn1cbmZ1bmN0aW9uIEtwKHMsIHQpIHtcbiAgY29uc3QgZSA9IFtdO1xuICBsZXQgaSA9IFtdO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHMubW9udGhzU2hvcnQubGVuZ3RoOyBuKyspXG4gICAgaWYgKGkucHVzaChzLm1vbnRoc1Nob3J0W25dKSwgaS5sZW5ndGggPT09IHQpIHtcbiAgICAgIGNvbnN0IG8gPSBpO1xuICAgICAgZS5wdXNoKG8pLCBpID0gW107XG4gICAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHVzKHMsIHQsIGUsIGksIG4sIG8pIHtcbiAgY29uc3QgciA9IFVwKHMsIGksIG4pLCBhID0gSChEZSgpKSwgbCA9IGBcbiAgICAke3IubWFwKChjKSA9PiBgXG4gICAgICAgIDx0cj5cbiAgICAgICAgICAke2MubWFwKChkKSA9PiBgXG4gICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIiR7by5kYXRlcGlja2VyQ2VsbH0gJHtvLmRhdGVwaWNrZXJDZWxsTGFyZ2V9XCIgIGFyaWEtbGFiZWw9XCIke2R9XCIgZGF0YS10ZS15ZWFyPVwiJHtkfVwiXG4gICAgICAgICAgICAgICR7Rm4oXG4gICAgZCxcbiAgICBlLm1pbixcbiAgICBlLm1heCxcbiAgICBlLmRpc2FibGVQYXN0LFxuICAgIGUuZGlzYWJsZUZ1dHVyZVxuICApID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgJHtkID09PSB0ID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgJHtkID09PSBhID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XCIgOiBcIlwifVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZX1cIj4ke2R9PC9kaXY+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICBgKS5qb2luKFwiXCIpfVxuICAgICAgICA8L3RyPlxuICAgICAgYCkuam9pbihcIlwiKX1cbiAgYDtcbiAgcmV0dXJuIGBcbiAgICAgIDx0YWJsZSBjbGFzcz1cIiR7by5kYXRlcGlja2VyVGFibGV9XCI+XG4gICAgICAgIDx0Ym9keT5cbiAgICAgICAgJHtsfVxuICAgICAgICA8L3Rib2R5PlxuICAgICAgPC90YWJsZT5cbiAgICBgO1xufVxuZnVuY3Rpb24gVXAocywgdCwgZSkge1xuICBjb25zdCBpID0gW10sIG4gPSBIKHMpLCBvID0gY3MocywgdCksIHIgPSBuIC0gbztcbiAgbGV0IGEgPSBbXTtcbiAgZm9yIChsZXQgbCA9IDA7IGwgPCB0OyBsKyspXG4gICAgaWYgKGEucHVzaChyICsgbCksIGEubGVuZ3RoID09PSBlKSB7XG4gICAgICBjb25zdCBjID0gYTtcbiAgICAgIGkucHVzaChjKSwgYSA9IFtdO1xuICAgIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiB6cChzLCB0KSB7XG4gIHJldHVybiBgXG4gICAgPGJ1dHRvbiBpZD1cIiR7c31cIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke3R9XCIgZGF0YS10ZS1kYXRlcGlja2VyLXRvZ2dsZS1idXR0b24tcmVmIGRhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtcmVmPlxuICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTYuNzUgMi4yNUEuNzUuNzUgMCAwMTcuNSAzdjEuNWg5VjNBLjc1Ljc1IDAgMDExOCAzdjEuNWguNzVhMyAzIDAgMDEzIDN2MTEuMjVhMyAzIDAgMDEtMyAzSDUuMjVhMyAzIDAgMDEtMy0zVjcuNWEzIDMgMCAwMTMtM0g2VjNhLjc1Ljc1IDAgMDEuNzUtLjc1em0xMy41IDlhMS41IDEuNSAwIDAwLTEuNS0xLjVINS4yNWExLjUgMS41IDAgMDAtMS41IDEuNXY3LjVhMS41IDEuNSAwIDAwMS41IDEuNWgxMy41YTEuNSAxLjUgMCAwMDEuNS0xLjV2LTcuNXpcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgIDwvc3ZnPiAgXG4gICAgPC9idXR0b24+XG4gIGA7XG59XG5jb25zdCBJZSA9IDM3LCBydCA9IDM4LCAkZSA9IDM5LCBVID0gNDAsIExlID0gMzYsIE1lID0gMzUsIGhuID0gMzMsIHVuID0gMzQsIGx0ID0gMTMsIHBzID0gMzIsIElzID0gMjcsIGZpID0gOSwgWHAgPSA4LCBHcCA9IDQ2LCBtdCA9IDI0LCBIaSA9IDQsIEJpID0gNCwgcG4gPSBcImRhdGVwaWNrZXJcIiwgZnMgPSBcInRlLmRhdGVwaWNrZXJcIiwgJHMgPSBgLiR7ZnN9YCwgcXAgPSBcIi5kYXRhLWFwaVwiLCBRcCA9IGBjbG9zZSR7JHN9YCwgWnAgPSBgb3BlbiR7JHN9YCwgSnAgPSBgZGF0ZUNoYW5nZSR7JHN9YCwgVmkgPSBgY2xpY2skeyRzfSR7cXB9YCwgYmwgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1tb2RhbC1jb250YWluZXItcmVmXCIsIHZsID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItZHJvcGRvd24tY29udGFpbmVyLXJlZlwiLCBXaSA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtcmVmXVwiLCB0ZiA9IGBbJHtibH1dYCwgZWYgPSBgWyR7dmx9XWAsIHNmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctY2hhbmdlLWJ1dHRvbi1yZWZdXCIsIG5mID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXByZXZpb3VzLWJ1dHRvbi1yZWZdXCIsIG9mID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLW5leHQtYnV0dG9uLXJlZl1cIiwgcmYgPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItb2stYnV0dG9uLXJlZl1cIiwgYWYgPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2FuY2VsLWJ1dHRvbi1yZWZdXCIsIGxmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLWNsZWFyLWJ1dHRvbi1yZWZdXCIsIGNmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctcmVmXVwiLCBkZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZl1cIiwgaGYgPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItZGF0ZS10ZXh0LXJlZl1cIiwgdWYgPSBcIltkYXRhLXRlLWRyb3Bkb3duLWJhY2tkcm9wLXJlZl1cIiwgcGYgPSBcImFuaW1hdGUtW2ZhZGUtaW5fMC4zc19ib3RoXSBweC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIiwgZmYgPSBcImFuaW1hdGUtW2ZhZGUtb3V0XzAuM3NfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIF9mID0gXCJhbmltYXRlLVtmYWRlLWluXzAuMTVzX2JvdGhdIHB4LVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLCBtZiA9IFwiYW5pbWF0ZS1bZmFkZS1vdXRfMC4xNXNfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIGdmID0gXCJmbGV4IGZsZXgtY29sIGZpeGVkIHRvcC0xLzIgbGVmdC0xLzIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIHctWzMyOHB4XSBoLVs1MTJweF0gYmctd2hpdGUgcm91bmRlZC1bMC42cmVtXSBzaGFkb3ctbGcgei1bMTA2Nl0geHM6bWF4LW1kOmxhbmRzY2FwZTp3LVs0NzVweF0geHM6bWF4LW1kOmxhbmRzY2FwZTpoLVszNjBweF0geHM6bWF4LW1kOmxhbmRzY2FwZTpmbGV4LXJvdyBkYXJrOmJnLXppbmMtNzAwXCIsIGJmID0gXCJ3LWZ1bGwgaC1mdWxsIGZpeGVkIHRvcC0wIHJpZ2h0LTAgbGVmdC0wIGJvdHRvbS0wIGJnLWJsYWNrLzQwIHotWzEwNjVdXCIsIHZmID0gXCJyZWxhdGl2ZSBoLWZ1bGxcIiwgRWYgPSBcInhzOm1heC1tZDpsYW5kc2NhcGU6aC1mdWxsIGgtWzEyMHB4XSBweC02IGJnLXByaW1hcnkgZmxleCBmbGV4LWNvbCByb3VuZGVkLXQtbGcgZGFyazpiZy16aW5jLTgwMFwiLCBUZiA9IFwiaC04IGZsZXggZmxleC1jb2wganVzdGlmeS1lbmRcIiwgQ2YgPSBcInRleHQtWzEwcHhdIGZvbnQtbm9ybWFsIHVwcGVyY2FzZSB0cmFja2luZy1bMS43cHhdIHRleHQtd2hpdGVcIiwgQWYgPSBcInhzOm1heC1tZDpsYW5kc2NhcGU6bXQtMjQgaC1bNzJweF0gZmxleCBmbGV4LWNvbCBqdXN0aWZ5LWVuZFwiLCB5ZiA9IFwidGV4dC1bMzRweF0gZm9udC1ub3JtYWwgdGV4dC13aGl0ZVwiLCB3ZiA9IFwib3V0bGluZS1ub25lIHB4LTNcIiwga2YgPSBcInB4LTMgcHQtMi41IHBiLTAgZmxleCBqdXN0aWZ5LWJldHdlZW4gdGV4dC1ibGFjay9bNjRdXCIsIE9mID0gXCJmbGV4IGl0ZW1zLWNlbnRlciBvdXRsaW5lLW5vbmUgcC0yLjUgdGV4dC1uZXV0cmFsLTUwMCBmb250LW1lZGl1bSB0ZXh0LVswLjlyZW1dIHJvdW5kZWQteGwgc2hhZG93LW5vbmUgYmctdHJhbnNwYXJlbnQgbS0wIGJvcmRlci1ub25lIGhvdmVyOmJnLW5ldXRyYWwtMjAwIGZvY3VzOmJnLW5ldXRyYWwtMjAwICBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwXCIsIHhmID0gXCJtdC0yLjVcIiwgU2YgPSBcInAtMCB3LTEwIGgtMTAgbGVhZGluZy0xMCBib3JkZXItbm9uZSBvdXRsaW5lLW5vbmUgbS0wIHRleHQtZ3JheS02MDAgYmctdHJhbnNwYXJlbnQgbXItNiBob3ZlcjpiZy1uZXV0cmFsLTIwMCBob3Zlcjpyb3VuZGVkLVs1MCVdIGZvY3VzOmJnLW5ldXRyYWwtMjAwIGZvY3VzOnJvdW5kZWQtWzUwJV0gZGFyazp0ZXh0LXdoaXRlIGRhcms6aG92ZXI6Ymctd2hpdGUvMTAgZGFyazpmb2N1czpiZy13aGl0ZS8xMCBbJj5zdmddOnctNCBbJj5zdmddOmgtNCBbJj5zdmddOm14LWF1dG9cIiwgRGYgPSBcInAtMCB3LTEwIGgtMTAgbGVhZGluZy0xMCBib3JkZXItbm9uZSBvdXRsaW5lLW5vbmUgbS0wIHRleHQtZ3JheS02MDAgYmctdHJhbnNwYXJlbnQgaG92ZXI6YmctbmV1dHJhbC0yMDAgaG92ZXI6cm91bmRlZC1bNTAlXSBmb2N1czpiZy1uZXV0cmFsLTIwMCBmb2N1czpyb3VuZGVkLVs1MCVdIGRhcms6dGV4dC13aGl0ZSBkYXJrOmhvdmVyOmJnLXdoaXRlLzEwIGRhcms6Zm9jdXM6Ymctd2hpdGUvMTAgWyY+c3ZnXTp3LTQgWyY+c3ZnXTpoLTQgWyY+c3ZnXTpyb3RhdGUtMTgwIFsmPnN2Z106bXgtYXV0b1wiLCBJZiA9IFwiaC0xNCBmbGV4IGFic29sdXRlIHctZnVsbCBib3R0b20tMCBqdXN0aWZ5LWVuZCBpdGVtcy1jZW50ZXIgcHgtM1wiLCAkZiA9IFwib3V0bGluZS1ub25lIGJnLXdoaXRlIHRleHQtcHJpbWFyeSBib3JkZXItbm9uZSBjdXJzb3ItcG9pbnRlciBweS0wIHB4LTIuNSB1cHBlcmNhc2UgdGV4dC1bMC44cmVtXSBsZWFkaW5nLTEwIGZvbnQtbWVkaXVtIGgtMTAgdHJhY2tpbmctWy4xcmVtXSByb3VuZGVkLVsxMHB4XSBtYi0yLjUgaG92ZXI6YmctbmV1dHJhbC0yMDAgZm9jdXM6YmctbmV1dHJhbC0yMDAgZGFyazpiZy10cmFuc3BhcmVudCBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwXCIsIExmID0gXCJtci1hdXRvXCIsIE1mID0gXCJ3LTEwIGgtMTAgdGV4dC1jZW50ZXIgdGV4dC1bMTJweF0gZm9udC1ub3JtYWwgZGFyazp0ZXh0LXdoaXRlXCIsIE5mID0gXCJ0ZXh0LWNlbnRlciBkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdOnRleHQtbmV1dHJhbC0zMDAgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTpjdXJzb3ItZGVmYXVsdCBkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdOnBvaW50ZXItZXZlbnRzLW5vbmUgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTpob3ZlcjpjdXJzb3ItZGVmYXVsdCBob3ZlcjpjdXJzb3ItcG9pbnRlciBncm91cFwiLCBSZiA9IFwidy0xMCBoLTEwIHhzOm1heC1tZDpsYW5kc2NhcGU6dy04IHhzOm1heC1tZDpsYW5kc2NhcGU6aC04XCIsIFBmID0gXCJ3LVs3NnB4XSBoLVs0MnB4XVwiLCBIZiA9IFwibXgtYXV0byBncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdKTpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXSk6aG92ZXJdOmJnLW5ldXRyYWwtMzAwIGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdXTpiZy1wcmltYXJ5IGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdXTp0ZXh0LXdoaXRlIGdyb3VwLVs6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpiZy1uZXV0cmFsLTEwMCBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdOmJnLXByaW1hcnkgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyLXNvbGlkIGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudF1dOmJvcmRlci1ibGFjayBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRdXTpib3JkZXIgZGFyazpncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdKTpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXSk6aG92ZXJdOmJnLXdoaXRlLzEwIGRhcms6Z3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyLXdoaXRlIGRhcms6dGV4dC13aGl0ZSBkYXJrOmdyb3VwLVs6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpiZy13aGl0ZS8xMCBkYXJrOmdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdXTp0ZXh0LW5ldXRyYWwtNTAwXCIsIEJmID0gXCJ3LTkgaC05IGxlYWRpbmctOSByb3VuZGVkLVs1MCVdIHRleHQtWzEzcHhdXCIsIFZmID0gXCJ3LVs3MnB4XSBoLTEwIGxlYWRpbmctMTAgcHktWzFweF0gcHgtMC41IHJvdW5kZWQtWzk5OXB4XVwiLCBXZiA9IFwibXgtYXV0byB3LVszMDRweF1cIiwgRmYgPSBcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY29udGVudC1jZW50ZXIgWyY+c3ZnXTp3LTUgWyY+c3ZnXTpoLTUgYWJzb2x1dGUgb3V0bGluZS1ub25lIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHJpZ2h0LTAuNSB0b3AtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiBob3Zlcjp0ZXh0LXByaW1hcnkgZm9jdXM6dGV4dC1wcmltYXJ5IGRhcms6aG92ZXI6dGV4dC1wcmltYXJ5LTQwMCBkYXJrOmZvY3VzOnRleHQtcHJpbWFyeS00MDAgZGFyazp0ZXh0LW5ldXRyYWwtMjAwXCIsIFlmID0gXCJpbmxpbmUtYmxvY2sgcG9pbnRlci1ldmVudHMtbm9uZSBtbC1bM3B4XSBbJj5zdmddOnctNCBbJj5zdmddOmgtNCBbJj5zdmddOmZpbGwtbmV1dHJhbC01MDAgZGFyazpbJj5zdmddOmZpbGwtd2hpdGVcIiwgamYgPSBcInctWzMyOHB4XSBoLVszODBweF0gYmctd2hpdGUgcm91bmRlZC1sZyBzaGFkb3ctWzBweF8ycHhfMTVweF8tM3B4X3JnYmEoMCwwLDAsLjA3KSxfMHB4XzEwcHhfMjBweF8tMnB4X3JnYmEoMCwwLDAsLjA0KV0gei1bMTA2Nl0gZGFyazpiZy16aW5jLTcwMFwiLCBLZiA9IHtcbiAgdGl0bGU6IFwiU2VsZWN0IGRhdGVcIixcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgZGlzYWJsZVBhc3Q6ICExLFxuICBkaXNhYmxlRnV0dXJlOiAhMSxcbiAgbW9udGhzRnVsbDogW1xuICAgIFwiSmFudWFyeVwiLFxuICAgIFwiRmVicnVhcnlcIixcbiAgICBcIk1hcmNoXCIsXG4gICAgXCJBcHJpbFwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5lXCIsXG4gICAgXCJKdWx5XCIsXG4gICAgXCJBdWd1c3RcIixcbiAgICBcIlNlcHRlbWJlclwiLFxuICAgIFwiT2N0b2JlclwiLFxuICAgIFwiTm92ZW1iZXJcIixcbiAgICBcIkRlY2VtYmVyXCJcbiAgXSxcbiAgbW9udGhzU2hvcnQ6IFtcbiAgICBcIkphblwiLFxuICAgIFwiRmViXCIsXG4gICAgXCJNYXJcIixcbiAgICBcIkFwclwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5cIixcbiAgICBcIkp1bFwiLFxuICAgIFwiQXVnXCIsXG4gICAgXCJTZXBcIixcbiAgICBcIk9jdFwiLFxuICAgIFwiTm92XCIsXG4gICAgXCJEZWNcIlxuICBdLFxuICB3ZWVrZGF5c0Z1bGw6IFtcbiAgICBcIlN1bmRheVwiLFxuICAgIFwiTW9uZGF5XCIsXG4gICAgXCJUdWVzZGF5XCIsXG4gICAgXCJXZWRuZXNkYXlcIixcbiAgICBcIlRodXJzZGF5XCIsXG4gICAgXCJGcmlkYXlcIixcbiAgICBcIlNhdHVyZGF5XCJcbiAgXSxcbiAgd2Vla2RheXNTaG9ydDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICB3ZWVrZGF5c05hcnJvdzogW1wiU1wiLCBcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiXSxcbiAgb2tCdG5UZXh0OiBcIk9rXCIsXG4gIGNsZWFyQnRuVGV4dDogXCJDbGVhclwiLFxuICBjYW5jZWxCdG5UZXh0OiBcIkNhbmNlbFwiLFxuICBva0J0bkxhYmVsOiBcIkNvbmZpcm0gc2VsZWN0aW9uXCIsXG4gIGNsZWFyQnRuTGFiZWw6IFwiQ2xlYXIgc2VsZWN0aW9uXCIsXG4gIGNhbmNlbEJ0bkxhYmVsOiBcIkNhbmNlbCBzZWxlY3Rpb25cIixcbiAgbmV4dE1vbnRoTGFiZWw6IFwiTmV4dCBtb250aFwiLFxuICBwcmV2TW9udGhMYWJlbDogXCJQcmV2aW91cyBtb250aFwiLFxuICBuZXh0WWVhckxhYmVsOiBcIk5leHQgeWVhclwiLFxuICBwcmV2WWVhckxhYmVsOiBcIlByZXZpb3VzIHllYXJcIixcbiAgY2hhbmdlTW9udGhJY29uVGVtcGxhdGU6IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTYgaC02XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTUuNzUgMTkuNUw4LjI1IDEybDcuNS03LjVcIiAvPlxuICA8L3N2Zz5cbiAgYCxcbiAgbmV4dE11bHRpWWVhckxhYmVsOiBcIk5leHQgMjQgeWVhcnNcIixcbiAgcHJldk11bHRpWWVhckxhYmVsOiBcIlByZXZpb3VzIDI0IHllYXJzXCIsXG4gIHN3aXRjaFRvTXVsdGlZZWFyVmlld0xhYmVsOiBcIkNob29zZSB5ZWFyIGFuZCBtb250aFwiLFxuICBzd2l0Y2hUb01vbnRoVmlld0xhYmVsOiBcIkNob29zZSBkYXRlXCIsXG4gIHN3aXRjaFRvRGF5Vmlld0xhYmVsOiBcIkNob29zZSBkYXRlXCIsXG4gIHN0YXJ0RGF0ZTogbnVsbCxcbiAgc3RhcnREYXk6IDAsXG4gIGZvcm1hdDogXCJkZC9tbS95eXl5XCIsXG4gIHZpZXc6IFwiZGF5c1wiLFxuICB2aWV3Q2hhbmdlSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy02IGgtNlwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbiAgPC9zdmc+XG4gIGAsXG4gIG1pbjogbnVsbCxcbiAgbWF4OiBudWxsLFxuICBmaWx0ZXI6IG51bGwsXG4gIGlubGluZTogITEsXG4gIHRvZ2dsZUJ1dHRvbjogITAsXG4gIGRpc2FibGVUb2dnbGVCdXR0b246ICExLFxuICBkaXNhYmxlSW5wdXQ6ICExLFxuICBhbmltYXRpb25zOiAhMCxcbiAgY29uZmlybURhdGVPblNlbGVjdDogITEsXG4gIHJlbW92ZU9rQnRuOiAhMSxcbiAgcmVtb3ZlQ2FuY2VsQnRuOiAhMSxcbiAgcmVtb3ZlQ2xlYXJCdG46ICExXG59LCBVZiA9IHtcbiAgdGl0bGU6IFwic3RyaW5nXCIsXG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZGlzYWJsZVBhc3Q6IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlRnV0dXJlOiBcImJvb2xlYW5cIixcbiAgbW9udGhzRnVsbDogXCJhcnJheVwiLFxuICBtb250aHNTaG9ydDogXCJhcnJheVwiLFxuICB3ZWVrZGF5c0Z1bGw6IFwiYXJyYXlcIixcbiAgd2Vla2RheXNTaG9ydDogXCJhcnJheVwiLFxuICB3ZWVrZGF5c05hcnJvdzogXCJhcnJheVwiLFxuICBva0J0blRleHQ6IFwic3RyaW5nXCIsXG4gIGNsZWFyQnRuVGV4dDogXCJzdHJpbmdcIixcbiAgY2FuY2VsQnRuVGV4dDogXCJzdHJpbmdcIixcbiAgb2tCdG5MYWJlbDogXCJzdHJpbmdcIixcbiAgY2xlYXJCdG5MYWJlbDogXCJzdHJpbmdcIixcbiAgY2FuY2VsQnRuTGFiZWw6IFwic3RyaW5nXCIsXG4gIG5leHRNb250aExhYmVsOiBcInN0cmluZ1wiLFxuICBwcmV2TW9udGhMYWJlbDogXCJzdHJpbmdcIixcbiAgbmV4dFllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgcHJldlllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgbmV4dE11bHRpWWVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBwcmV2TXVsdGlZZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNoYW5nZU1vbnRoSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBzd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbDogXCJzdHJpbmdcIixcbiAgc3dpdGNoVG9Nb250aFZpZXdMYWJlbDogXCJzdHJpbmdcIixcbiAgc3dpdGNoVG9EYXlWaWV3TGFiZWw6IFwic3RyaW5nXCIsXG4gIHN0YXJ0RGF0ZTogXCIobnVsbHxzdHJpbmd8ZGF0ZSlcIixcbiAgc3RhcnREYXk6IFwibnVtYmVyXCIsXG4gIGZvcm1hdDogXCJzdHJpbmdcIixcbiAgdmlldzogXCJzdHJpbmdcIixcbiAgdmlld0NoYW5nZUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgbWluOiBcIihudWxsfHN0cmluZ3xkYXRlKVwiLFxuICBtYXg6IFwiKG51bGx8c3RyaW5nfGRhdGUpXCIsXG4gIGZpbHRlcjogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgaW5saW5lOiBcImJvb2xlYW5cIixcbiAgdG9nZ2xlQnV0dG9uOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZVRvZ2dsZUJ1dHRvbjogXCJib29sZWFuXCIsXG4gIGRpc2FibGVJbnB1dDogXCJib29sZWFuXCIsXG4gIGFuaW1hdGlvbnM6IFwiYm9vbGVhblwiLFxuICBjb25maXJtRGF0ZU9uU2VsZWN0OiBcImJvb2xlYW5cIixcbiAgcmVtb3ZlT2tCdG46IFwiYm9vbGVhblwiLFxuICByZW1vdmVDYW5jZWxCdG46IFwiYm9vbGVhblwiLFxuICByZW1vdmVDbGVhckJ0bjogXCJib29sZWFuXCJcbn0sIHpmID0ge1xuICBmYWRlSW46IHBmLFxuICBmYWRlT3V0OiBmZixcbiAgZmFkZUluU2hvcnQ6IF9mLFxuICBmYWRlT3V0U2hvcnQ6IG1mLFxuICBtb2RhbENvbnRhaW5lcjogZ2YsXG4gIGRhdGVwaWNrZXJCYWNrZHJvcDogYmYsXG4gIGRhdGVwaWNrZXJNYWluOiB2ZixcbiAgZGF0ZXBpY2tlckhlYWRlcjogRWYsXG4gIGRhdGVwaWNrZXJUaXRsZTogVGYsXG4gIGRhdGVwaWNrZXJUaXRsZVRleHQ6IENmLFxuICBkYXRlcGlja2VyRGF0ZTogQWYsXG4gIGRhdGVwaWNrZXJEYXRlVGV4dDogeWYsXG4gIGRhdGVwaWNrZXJWaWV3OiB3ZixcbiAgZGF0ZXBpY2tlckRhdGVDb250cm9sczoga2YsXG4gIGRhdGVwaWNrZXJWaWV3Q2hhbmdlQnV0dG9uOiBPZixcbiAgZGF0ZXBpY2tlclZpZXdDaGFuZ2VJY29uOiBZZixcbiAgZGF0ZXBpY2tlckFycm93Q29udHJvbHM6IHhmLFxuICBkYXRlcGlja2VyUHJldmlvdXNCdXR0b246IFNmLFxuICBkYXRlcGlja2VyTmV4dEJ1dHRvbjogRGYsXG4gIGRhdGVwaWNrZXJGb290ZXI6IElmLFxuICBkYXRlcGlja2VyRm9vdGVyQnRuOiAkZixcbiAgZGF0ZXBpY2tlckNsZWFyQnRuOiBMZixcbiAgZGF0ZXBpY2tlckRheUhlYWRpbmc6IE1mLFxuICBkYXRlcGlja2VyQ2VsbDogTmYsXG4gIGRhdGVwaWNrZXJDZWxsU21hbGw6IFJmLFxuICBkYXRlcGlja2VyQ2VsbExhcmdlOiBQZixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50OiBIZixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50U21hbGw6IEJmLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZTogVmYsXG4gIGRhdGVwaWNrZXJUYWJsZTogV2YsXG4gIGRhdGVwaWNrZXJUb2dnbGVCdXR0b246IEZmLFxuICBkYXRlcGlja2VyRHJvcGRvd25Db250YWluZXI6IGpmXG59LCBYZiA9IHtcbiAgZmFkZUluOiBcInN0cmluZ1wiLFxuICBmYWRlT3V0OiBcInN0cmluZ1wiLFxuICBmYWRlSW5TaG9ydDogXCJzdHJpbmdcIixcbiAgZmFkZU91dFNob3J0OiBcInN0cmluZ1wiLFxuICBtb2RhbENvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckJhY2tkcm9wOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyTWFpbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckhlYWRlcjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRpdGxlOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVGl0bGVUZXh0OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRGF0ZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRhdGVUZXh0OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVmlldzogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRhdGVDb250cm9sczogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclZpZXdDaGFuZ2VCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJBcnJvd0NvbnRyb2xzOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyUHJldmlvdXNCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJOZXh0QnV0dG9uOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRm9vdGVyOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRm9vdGVyQnRuOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2xlYXJCdG46IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEYXlIZWFkaW5nOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxTbWFsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxMYXJnZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnRTbWFsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2U6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUYWJsZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRvZ2dsZUJ1dHRvbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgR2cge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2lucHV0ID0gaC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9hY3RpdmVEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5faGVhZGVyWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlck1vbnRoID0gbnVsbCwgdGhpcy5fdmlldyA9IHRoaXMuX29wdGlvbnMudmlldywgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX3RvZ2dsZUJ1dHRvbklkID0gT3QoXCJkYXRlcGlja2VyLXRvZ2dsZS1cIiksIHRoaXMuX2FuaW1hdGlvbnMgPSAhd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKS5tYXRjaGVzICYmIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9ucywgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IHBpKCksIHRoaXMuX2VsZW1lbnQgJiYgSS5zZXREYXRhKHQsIGZzLCB0aGlzKSwgdGhpcy5faW5pdCgpLCB0aGlzLnRvZ2dsZUJ1dHRvbiAmJiB0aGlzLl9vcHRpb25zLmRpc2FibGVUb2dnbGUgJiYgKHRoaXMudG9nZ2xlQnV0dG9uLmRpc2FibGVkID0gXCJ0cnVlXCIpLCB0aGlzLl9vcHRpb25zLmRpc2FibGVJbnB1dCAmJiAodGhpcy5faW5wdXQuZGlzYWJsZWQgPSBcInRydWVcIik7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHBuO1xuICB9XG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShcbiAgICAgIGBbJHtibH09JyR7dGhpcy5fdG9nZ2xlQnV0dG9uSWR9J11gXG4gICAgKSB8fCBoLmZpbmRPbmUoXG4gICAgICBgWyR7dmx9PScke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfSddYFxuICAgICk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgZ2V0IGFjdGl2ZUNlbGwoKSB7XG4gICAgbGV0IHQ7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiICYmICh0ID0gdGhpcy5fZ2V0QWN0aXZlRGF5Q2VsbCgpKSwgdGhpcy5fdmlldyA9PT0gXCJtb250aHNcIiAmJiAodCA9IHRoaXMuX2dldEFjdGl2ZU1vbnRoQ2VsbCgpKSwgdGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiICYmICh0ID0gdGhpcy5fZ2V0QWN0aXZlWWVhckNlbGwoKSksIHQ7XG4gIH1cbiAgZ2V0IGFjdGl2ZURheSgpIHtcbiAgICByZXR1cm4gUSh0aGlzLl9hY3RpdmVEYXRlKTtcbiAgfVxuICBnZXQgYWN0aXZlTW9udGgoKSB7XG4gICAgcmV0dXJuIFkodGhpcy5fYWN0aXZlRGF0ZSk7XG4gIH1cbiAgZ2V0IGFjdGl2ZVllYXIoKSB7XG4gICAgcmV0dXJuIEgodGhpcy5fYWN0aXZlRGF0ZSk7XG4gIH1cbiAgZ2V0IGZpcnN0WWVhckluVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVZZWFyIC0gY3ModGhpcy5fYWN0aXZlRGF0ZSwgbXQpO1xuICB9XG4gIGdldCBsYXN0WWVhckluVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5maXJzdFllYXJJblZpZXcgKyBtdCAtIDE7XG4gIH1cbiAgZ2V0IHZpZXdDaGFuZ2VCdXR0b24oKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShzZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBwcmV2aW91c0J1dHRvbigpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKG5mLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IG5leHRCdXR0b24oKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShvZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBva0J1dHRvbigpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKHJmLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IGNhbmNlbEJ1dHRvbigpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKGFmLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IGNsZWFyQnV0dG9uKCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUobGYsIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgZGF0ZXNDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShjZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCB0b2dnbGVCdXR0b24oKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShkZiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgdXBkYXRlKHQgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoeyAuLi50aGlzLl9vcHRpb25zLCAuLi50IH0pO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICh0ID0ge1xuICAgICAgLi4uS2YsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4ocG4sIHQsIFVmKSwgdC5tYXggJiYgdHlwZW9mIHQubWF4ID09IFwic3RyaW5nXCIgJiYgKHQubWF4ID0gbmV3IERhdGUodC5tYXgpKSwgdC5taW4gJiYgdHlwZW9mIHQubWluID09IFwic3RyaW5nXCIgJiYgKHQubWluID0gbmV3IERhdGUodC5taW4pKSwgdC5zdGFydERheSAmJiB0LnN0YXJ0RGF5ICE9PSAwKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2V0TmV3RGF5c09yZGVyQXJyYXkodCk7XG4gICAgICB0LndlZWtkYXlzTmFycm93ID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi56ZixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTihwbiwgdCwgWGYpLCB0O1xuICB9XG4gIF9nZXRDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZSh0aGlzLl9vcHRpb25zLmNvbnRhaW5lcik7XG4gIH1cbiAgX2dldE5ld0RheXNPcmRlckFycmF5KHQpIHtcbiAgICBjb25zdCBlID0gdC5zdGFydERheSwgaSA9IHQud2Vla2RheXNOYXJyb3c7XG4gICAgcmV0dXJuIGkuc2xpY2UoZSkuY29uY2F0KGkuc2xpY2UoMCwgZSkpO1xuICB9XG4gIF9pbml0KCkge1xuICAgICF0aGlzLnRvZ2dsZUJ1dHRvbiAmJiB0aGlzLl9vcHRpb25zLnRvZ2dsZUJ1dHRvbiAmJiAodGhpcy5fYXBwZW5kVG9nZ2xlQnV0dG9uKCksICh0aGlzLl9pbnB1dC5yZWFkT25seSB8fCB0aGlzLl9pbnB1dC5kaXNhYmxlZCkgJiYgKHRoaXMudG9nZ2xlQnV0dG9uLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIikpLCB0aGlzLl9saXN0ZW5Ub1VzZXJJbnB1dCgpLCB0aGlzLl9saXN0ZW5Ub1RvZ2dsZUNsaWNrKCksIHRoaXMuX2xpc3RlblRvVG9nZ2xlS2V5ZG93bigpO1xuICB9XG4gIF9hcHBlbmRUb2dnbGVCdXR0b24oKSB7XG4gICAgY29uc3QgdCA9IHpwKFxuICAgICAgdGhpcy5fdG9nZ2xlQnV0dG9uSWQsXG4gICAgICB0aGlzLl9jbGFzc2VzLmRhdGVwaWNrZXJUb2dnbGVCdXR0b25cbiAgICApO1xuICAgIHRoaXMuX2VsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIHQpO1xuICB9XG4gIG9wZW4oKSB7XG4gICAgaWYgKHRoaXMuX2lucHV0LnJlYWRPbmx5IHx8IHRoaXMuX2lucHV0LmRpc2FibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWnApO1xuICAgIGlmICh0aGlzLl9pc09wZW4gfHwgdC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3NldEluaXRpYWxEYXRlKCk7XG4gICAgY29uc3QgZSA9IFdwKHRoaXMuX2NsYXNzZXMuZGF0ZXBpY2tlckJhY2tkcm9wKSwgaSA9IFZwKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSxcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGgsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgQmksXG4gICAgICBtdCxcbiAgICAgIEhpLFxuICAgICAgdGhpcy5fdG9nZ2xlQnV0dG9uSWQsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLl9vcHRpb25zLmlubGluZSA/IHRoaXMuX29wZW5Ecm9wZG93bihpKSA6ICh0aGlzLl9vcGVuTW9kYWwoZSwgaSksIHRoaXMuX3Njcm9sbEJhci5oaWRlKCkpLCB0aGlzLl9hbmltYXRpb25zICYmIChwLmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzLl9jbGFzc2VzLmZhZGVJbiksIHAuYWRkQ2xhc3MoZSwgdGhpcy5fY2xhc3Nlcy5mYWRlSW5TaG9ydCkpLCB0aGlzLl9zZXRGb2N1c1RyYXAodGhpcy5jb250YWluZXIpLCB0aGlzLl9saXN0ZW5Ub0RhdGVTZWxlY3Rpb24oKSwgdGhpcy5fYWRkQ29udHJvbHNMaXN0ZW5lcnMoKSwgdGhpcy5fdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCksIHRoaXMuX2xpc3RlblRvRXNjYXBlQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9LZXlib2FyZE5hdmlnYXRpb24oKSwgdGhpcy5fbGlzdGVuVG9EYXRlc0NvbnRhaW5lckZvY3VzKCksIHRoaXMuX2xpc3RlblRvRGF0ZXNDb250YWluZXJCbHVyKCksIHRoaXMuX2FzeW5jRm9jdXNEYXRlc0NvbnRhaW5lcigpLCB0aGlzLl91cGRhdGVWaWV3Q29udHJvbHNBbmRBdHRyaWJ1dGVzKHRoaXMuX3ZpZXcpLCB0aGlzLl9pc09wZW4gPSAhMCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9saXN0ZW5Ub091dHNpZGVDbGljaygpO1xuICAgIH0sIDApO1xuICB9XG4gIF9vcGVuRHJvcGRvd24odCkge1xuICAgIHRoaXMuX3BvcHBlciA9IGplKHRoaXMuX2lucHV0LCB0LCB7XG4gICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tLXN0YXJ0XCJcbiAgICB9KSwgdGhpcy5fZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQodCk7XG4gIH1cbiAgX29wZW5Nb2RhbCh0LCBlKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2dldENvbnRhaW5lcigpO1xuICAgIGkuYXBwZW5kQ2hpbGQodCksIGkuYXBwZW5kQ2hpbGQoZSk7XG4gIH1cbiAgX3NldEZvY3VzVHJhcCh0KSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwID0gbmV3IGJpKHQsIHtcbiAgICAgIGV2ZW50OiBcImtleWRvd25cIixcbiAgICAgIGNvbmRpdGlvbjogKGUpID0+IGUua2V5ID09PSBcIlRhYlwiXG4gICAgfSksIHRoaXMuX2ZvY3VzVHJhcC50cmFwKCk7XG4gIH1cbiAgX2xpc3RlblRvVXNlcklucHV0KCkge1xuICAgIHUub24odGhpcy5faW5wdXQsIFwiaW5wdXRcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZVVzZXJJbnB1dCh0LnRhcmdldC52YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvVG9nZ2xlQ2xpY2soKSB7XG4gICAgdS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBWaSxcbiAgICAgIFdpLFxuICAgICAgKHQpID0+IHtcbiAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKSB7XG4gICAgdS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIFdpLFxuICAgICAgKHQpID0+IHtcbiAgICAgICAgdC5rZXlDb2RlID09PSBsdCAmJiAhdGhpcy5faXNPcGVuICYmIHRoaXMub3BlbigpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2xpc3RlblRvRGF0ZVNlbGVjdGlvbigpIHtcbiAgICB1Lm9uKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZURhdGVTZWxlY3Rpb24odCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZURhdGVTZWxlY3Rpb24odCkge1xuICAgIGNvbnN0IGUgPSB0LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJESVZcIiA/IHQudGFyZ2V0LnBhcmVudE5vZGUuZGF0YXNldCA6IHQudGFyZ2V0LmRhdGFzZXQsIGkgPSB0LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJESVZcIiA/IHQudGFyZ2V0LnBhcmVudE5vZGUgOiB0LnRhcmdldDtcbiAgICBpZiAoZS50ZURhdGUgJiYgdGhpcy5fcGlja0RheShlLnRlRGF0ZSwgaSksIGUudGVNb250aCAmJiBlLnRlWWVhcikge1xuICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGUudGVNb250aCwgMTApLCBvID0gcGFyc2VJbnQoZS50ZVllYXIsIDEwKTtcbiAgICAgIHRoaXMuX3BpY2tNb250aChuLCBvKTtcbiAgICB9XG4gICAgaWYgKGUudGVZZWFyICYmICFlLnRlTW9udGgpIHtcbiAgICAgIGNvbnN0IG4gPSBwYXJzZUludChlLnRlWWVhciwgMTApO1xuICAgICAgdGhpcy5fcGlja1llYXIobik7XG4gICAgfVxuICAgIHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX3VwZGF0ZUhlYWRlckRhdGUoXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tb250aHNTaG9ydCxcbiAgICAgIHRoaXMuX29wdGlvbnMud2Vla2RheXNTaG9ydFxuICAgICk7XG4gIH1cbiAgX3VwZGF0ZUhlYWRlckRhdGUodCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSBoLmZpbmRPbmUoXG4gICAgICBoZixcbiAgICAgIHRoaXMuY29udGFpbmVyXG4gICAgKSwgbyA9IFkodCksIHIgPSBRKHQpLCBhID0gbHModCk7XG4gICAgbi5pbm5lckhUTUwgPSBgJHtpW2FdfSwgJHtlW29dfSAke3J9YDtcbiAgfVxuICBfYWRkQ29udHJvbHNMaXN0ZW5lcnMoKSB7XG4gICAgdS5vbih0aGlzLm5leHRCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdmlldyA9PT0gXCJkYXlzXCIgPyB0aGlzLm5leHRNb250aCgpIDogdGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiID8gdGhpcy5uZXh0WWVhcnMoKSA6IHRoaXMubmV4dFllYXIoKSwgdGhpcy5fdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCk7XG4gICAgfSksIHUub24odGhpcy5wcmV2aW91c0J1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl92aWV3ID09PSBcImRheXNcIiA/IHRoaXMucHJldmlvdXNNb250aCgpIDogdGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiID8gdGhpcy5wcmV2aW91c1llYXJzKCkgOiB0aGlzLnByZXZpb3VzWWVhcigpLCB0aGlzLl91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKTtcbiAgICB9KSwgdS5vbih0aGlzLnZpZXdDaGFuZ2VCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdmlldyA9PT0gXCJkYXlzXCIgPyB0aGlzLl9jaGFuZ2VWaWV3KFwieWVhcnNcIikgOiAodGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiIHx8IHRoaXMuX3ZpZXcgPT09IFwibW9udGhzXCIpICYmIHRoaXMuX2NoYW5nZVZpZXcoXCJkYXlzXCIpO1xuICAgIH0pLCB0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl9saXN0ZW5Ub0Zvb3RlckJ1dHRvbnNDbGljaygpO1xuICB9XG4gIF9saXN0ZW5Ub0Zvb3RlckJ1dHRvbnNDbGljaygpIHtcbiAgICB1Lm9uKHRoaXMub2tCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5oYW5kbGVPaygpKSwgdS5vbih0aGlzLmNhbmNlbEJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLmhhbmRsZUNhbmNlbCgpKSwgdS5vbih0aGlzLmNsZWFyQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHRoaXMuaGFuZGxlQ2xlYXIoKSk7XG4gIH1cbiAgX2xpc3RlblRvT3V0c2lkZUNsaWNrKCkge1xuICAgIHUub24oZG9jdW1lbnQsIFZpLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHQudGFyZ2V0ID09PSB0aGlzLmNvbnRhaW5lciwgaSA9IHRoaXMuY29udGFpbmVyICYmIHRoaXMuY29udGFpbmVyLmNvbnRhaW5zKHQudGFyZ2V0KTtcbiAgICAgICFlICYmICFpICYmIHRoaXMuY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9Fc2NhcGVDbGljaygpIHtcbiAgICB1Lm9uKGRvY3VtZW50LCBcImtleWRvd25cIiwgKHQpID0+IHtcbiAgICAgIHQua2V5Q29kZSA9PT0gSXMgJiYgdGhpcy5faXNPcGVuICYmIHRoaXMuY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9LZXlib2FyZE5hdmlnYXRpb24oKSB7XG4gICAgdS5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImtleWRvd25cIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZUtleWRvd24odCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvRGF0ZXNDb250YWluZXJGb2N1cygpIHtcbiAgICB1Lm9uKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiZm9jdXNcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKHRoaXMuYWN0aXZlQ2VsbCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvRGF0ZXNDb250YWluZXJCbHVyKCkge1xuICAgIHUub24odGhpcy5kYXRlc0NvbnRhaW5lciwgXCJibHVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVLZXlkb3duKHQpIHtcbiAgICB0aGlzLl92aWV3ID09PSBcImRheXNcIiAmJiB0aGlzLl9oYW5kbGVEYXlzVmlld0tleWRvd24odCksIHRoaXMuX3ZpZXcgPT09IFwibW9udGhzXCIgJiYgdGhpcy5faGFuZGxlTW9udGhzVmlld0tleWRvd24odCksIHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiAmJiB0aGlzLl9oYW5kbGVZZWFyc1ZpZXdLZXlkb3duKHQpO1xuICB9XG4gIF9oYW5kbGVEYXlzVmlld0tleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hY3RpdmVEYXRlLCBpID0gdGhpcy5hY3RpdmVDZWxsO1xuICAgIHN3aXRjaCAodC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEllOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gVGUodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gMSA6IC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICRlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gVGUodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gLTEgOiAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHJ0OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gVGUodGhpcy5fYWN0aXZlRGF0ZSwgLTcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IFRlKHRoaXMuX2FjdGl2ZURhdGUsIDcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBUZShcbiAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgICAgIDEgLSBRKHRoaXMuX2FjdGl2ZURhdGUpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IFRlKFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgV24odGhpcy5fYWN0aXZlRGF0ZSkgLSBRKHRoaXMuX2FjdGl2ZURhdGUpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBobjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHVuOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBsdDpcbiAgICAgIGNhc2UgcHM6XG4gICAgICAgIHRoaXMuX3NlbGVjdERhdGUodGhpcy5fYWN0aXZlRGF0ZSksIHRoaXMuX2hhbmRsZURhdGVTZWxlY3Rpb24odCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaShcbiAgICAgIGUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIG10LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heFxuICAgICkgfHwgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIiksIHRoaXMuX3JlbW92ZUhpZ2hsaWdodEZyb21DZWxsKGkpLCB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwodGhpcy5hY3RpdmVDZWxsKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9hc3luY0ZvY3VzRGF0ZXNDb250YWluZXIoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRhdGVzQ29udGFpbmVyLmZvY3VzKCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX2ZvY3VzQWN0aXZlQ2VsbCh0KSB7XG4gICAgdCAmJiB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRcIiwgXCJcIik7XG4gIH1cbiAgX3JlbW92ZUhpZ2hsaWdodEZyb21DZWxsKHQpIHtcbiAgICB0ICYmIHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZFwiKTtcbiAgfVxuICBfZ2V0QWN0aXZlRGF5Q2VsbCgpIHtcbiAgICBjb25zdCB0ID0gaC5maW5kKFwidGRcIiwgdGhpcy5kYXRlc0NvbnRhaW5lcik7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odCkuZmluZCgoaSkgPT4ge1xuICAgICAgY29uc3QgbiA9IEVyKGkuZGF0YXNldC50ZURhdGUpO1xuICAgICAgcmV0dXJuIGRlKG4sIHRoaXMuX2FjdGl2ZURhdGUpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVNb250aHNWaWV3S2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZURhdGUsIGkgPSB0aGlzLmFjdGl2ZUNlbGw7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgSWU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAxIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJGU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcnQ6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAtNCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBVOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgNCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIC10aGlzLmFjdGl2ZU1vbnRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1lOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgMTEgLSB0aGlzLmFjdGl2ZU1vbnRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGhuOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdW46XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGx0OlxuICAgICAgY2FzZSBwczpcbiAgICAgICAgdGhpcy5fc2VsZWN0TW9udGgodGhpcy5hY3RpdmVNb250aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGkoXG4gICAgICBlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICBtdCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXhcbiAgICApIHx8IHRoaXMuX2NoYW5nZVZpZXcoXCJtb250aHNcIiksIHRoaXMuX3JlbW92ZUhpZ2hsaWdodEZyb21DZWxsKGkpLCB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwodGhpcy5hY3RpdmVDZWxsKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9nZXRBY3RpdmVNb250aENlbGwoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZChcInRkXCIsIHRoaXMuZGF0ZXNDb250YWluZXIpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHQpLmZpbmQoKGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBwYXJzZUludChpLmRhdGFzZXQudGVZZWFyLCAxMCksIG8gPSBwYXJzZUludChpLmRhdGFzZXQudGVNb250aCwgMTApO1xuICAgICAgcmV0dXJuIG4gPT09IHRoaXMuYWN0aXZlWWVhciAmJiBvID09PSB0aGlzLmFjdGl2ZU1vbnRoO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVZZWFyc1ZpZXdLZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fYWN0aXZlRGF0ZSwgaSA9IHRoaXMuYWN0aXZlQ2VsbCwgbiA9IDQsIG8gPSAyNDtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSBJZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IDEgOiAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAkZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IC0xIDogMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBydDpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIC1uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCBuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICAtY3ModGhpcy5fYWN0aXZlRGF0ZSwgbylcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1lOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICBvIC0gY3ModGhpcy5fYWN0aXZlRGF0ZSwgbykgLSAxXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBobjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIC1vKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHVuOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBsdDpcbiAgICAgIGNhc2UgcHM6XG4gICAgICAgIHRoaXMuX3NlbGVjdFllYXIodGhpcy5hY3RpdmVZZWFyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaShcbiAgICAgIGUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIG10LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heFxuICAgICkgfHwgdGhpcy5fY2hhbmdlVmlldyhcInllYXJzXCIpLCB0aGlzLl9yZW1vdmVIaWdobGlnaHRGcm9tQ2VsbChpKSwgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKHRoaXMuYWN0aXZlQ2VsbCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfZ2V0QWN0aXZlWWVhckNlbGwoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZChcInRkXCIsIHRoaXMuZGF0ZXNDb250YWluZXIpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHQpLmZpbmQoKGkpID0+IHBhcnNlSW50KGkuZGF0YXNldC50ZVllYXIsIDEwKSA9PT0gdGhpcy5hY3RpdmVZZWFyKTtcbiAgfVxuICBfc2V0SW5pdGlhbERhdGUoKSB7XG4gICAgdGhpcy5faW5wdXQudmFsdWUgPyB0aGlzLl9oYW5kbGVVc2VySW5wdXQodGhpcy5faW5wdXQudmFsdWUpIDogdGhpcy5fb3B0aW9ucy5zdGFydERhdGUgPyB0aGlzLl9hY3RpdmVEYXRlID0gbmV3IERhdGUodGhpcy5fb3B0aW9ucy5zdGFydERhdGUpIDogdGhpcy5fYWN0aXZlRGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGNvbnN0IHQgPSB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgUXApO1xuICAgICF0aGlzLl9pc09wZW4gfHwgdC5kZWZhdWx0UHJldmVudGVkIHx8ICh0aGlzLl9yZW1vdmVEYXRlcGlja2VyTGlzdGVuZXJzKCksIHRoaXMuX2FuaW1hdGlvbnMgJiYgcC5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgPyB0aGlzLl9jbG9zZURyb3Bkb3duKCkgOiB0aGlzLl9jbG9zZU1vZGFsKCksIHRoaXMuX2lzT3BlbiA9ICExLCB0aGlzLl92aWV3ID0gdGhpcy5fb3B0aW9ucy52aWV3LCB0aGlzLnRvZ2dsZUJ1dHRvbiA/IHRoaXMudG9nZ2xlQnV0dG9uLmZvY3VzKCkgOiB0aGlzLl9pbnB1dC5mb2N1cygpKTtcbiAgfVxuICBfY2xvc2VEcm9wZG93bigpIHtcbiAgICBjb25zdCB0ID0gaC5maW5kT25lKGVmKTtcbiAgICB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpLm1hdGNoZXMgJiYgKHQgJiYgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5kZXN0cm95KCkpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdCAmJiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHQpLCB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICB9KSwgdGhpcy5fcmVtb3ZlRm9jdXNUcmFwKCk7XG4gIH1cbiAgX2Nsb3NlTW9kYWwoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZE9uZSh1ZiksIGUgPSBoLmZpbmRPbmUodGYpO1xuICAgICFlIHx8ICF0IHx8ICh0aGlzLl9hbmltYXRpb25zID8gKHAuYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0U2hvcnQpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlUGlja2VyKHQsIGUpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICB9KSkgOiAodGhpcy5fcmVtb3ZlUGlja2VyKHQsIGUpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKSkpO1xuICB9XG4gIF9yZW1vdmVQaWNrZXIodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICBpLnJlbW92ZUNoaWxkKHQpLCBpLnJlbW92ZUNoaWxkKGUpO1xuICB9XG4gIF9yZW1vdmVGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwICYmICh0aGlzLl9mb2N1c1RyYXAuZGlzYWJsZSgpLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsKTtcbiAgfVxuICBfcmVtb3ZlRGF0ZXBpY2tlckxpc3RlbmVycygpIHtcbiAgICB1Lm9mZih0aGlzLm5leHRCdXR0b24sIFwiY2xpY2tcIiksIHUub2ZmKHRoaXMucHJldmlvdXNCdXR0b24sIFwiY2xpY2tcIiksIHUub2ZmKHRoaXMudmlld0NoYW5nZUJ1dHRvbiwgXCJjbGlja1wiKSwgdS5vZmYodGhpcy5va0J1dHRvbiwgXCJjbGlja1wiKSwgdS5vZmYodGhpcy5jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiksIHUub2ZmKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiksIHUub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiY2xpY2tcIiksIHUub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwia2V5ZG93blwiKSwgdS5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJmb2N1c1wiKSwgdS5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJibHVyXCIpLCB1Lm9mZihkb2N1bWVudCwgVmkpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5faXNPcGVuICYmIHRoaXMuY2xvc2UoKSwgdGhpcy5fcmVtb3ZlSW5wdXRBbmRUb2dnbGVMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB0ID0gaC5maW5kT25lKFxuICAgICAgYCMke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfWBcbiAgICApO1xuICAgIHQgJiYgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZCh0KSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGZzKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX2lucHV0ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuX2FjdGl2ZURhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX3ZpZXcgPSBudWxsLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsO1xuICB9XG4gIF9yZW1vdmVJbnB1dEFuZFRvZ2dsZUxpc3RlbmVycygpIHtcbiAgICB1Lm9mZih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiKSwgdS5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgVmksXG4gICAgICBXaVxuICAgICksIHUub2ZmKHRoaXMuX2VsZW1lbnQsIFwia2V5ZG93blwiLCBXaSk7XG4gIH1cbiAgaGFuZGxlT2soKSB7XG4gICAgdGhpcy5fY29uZmlybVNlbGVjdGlvbih0aGlzLl9oZWFkZXJEYXRlKSwgdGhpcy5jbG9zZSgpO1xuICB9XG4gIF9zZWxlY3REYXRlKHQsIGUgPSB0aGlzLmFjdGl2ZUNlbGwpIHtcbiAgICBjb25zdCB7IG1pbjogaSwgbWF4OiBuLCBmaWx0ZXI6IG8sIGRpc2FibGVQYXN0OiByLCBkaXNhYmxlRnV0dXJlOiBhIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIEFzKHQsIGksIG4sIG8sIHIsIGEpIHx8ICh0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpLCB0aGlzLl9hZGRTZWxlY3RlZFN0eWxlcyhlKSwgdGhpcy5fc2VsZWN0ZWREYXRlID0gdCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gSCh0KSwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IFkodCksIHRoaXMuX2hlYWRlckRhdGUgPSB0LCAodGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5vcHRpb25zLmNvbmZpcm1EYXRlT25TZWxlY3QpICYmICh0aGlzLl9jb25maXJtU2VsZWN0aW9uKHQpLCB0aGlzLmNsb3NlKCkpKTtcbiAgfVxuICBfc2VsZWN0WWVhcih0LCBlID0gdGhpcy5hY3RpdmVDZWxsKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpLCB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKSwgdGhpcy5fYWRkU2VsZWN0ZWRTdHlsZXMoZSksIHRoaXMuX2hlYWRlclllYXIgPSB0LCB0aGlzLl9hc3luY0NoYW5nZVZpZXcoXCJtb250aHNcIik7XG4gIH1cbiAgX3NlbGVjdE1vbnRoKHQsIGUgPSB0aGlzLmFjdGl2ZUNlbGwpIHtcbiAgICB0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpLCB0aGlzLl9hZGRTZWxlY3RlZFN0eWxlcyhlKSwgdGhpcy5faGVhZGVyTW9udGggPSB0LCB0aGlzLl9hc3luY0NoYW5nZVZpZXcoXCJkYXlzXCIpO1xuICB9XG4gIF9yZW1vdmVTZWxlY3RlZFN0eWxlcyh0KSB7XG4gICAgdCAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIpO1xuICB9XG4gIF9hZGRTZWxlY3RlZFN0eWxlcyh0KSB7XG4gICAgdCAmJiB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIsIFwiXCIpO1xuICB9XG4gIF9jb25maXJtU2VsZWN0aW9uKHQpIHtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuZm9ybWF0RGF0ZSh0KTtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gZSwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEpwLCB7IGRhdGU6IHQgfSksIHUudHJpZ2dlcih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQ2FuY2VsKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgaGFuZGxlQ2xlYXIoKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlckRhdGUgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5fc2V0SW5pdGlhbERhdGUoKSwgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIiksIHRoaXMuX3VwZGF0ZUhlYWRlckRhdGUoXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tb250aHNTaG9ydCxcbiAgICAgIHRoaXMuX29wdGlvbnMud2Vla2RheXNTaG9ydFxuICAgICk7XG4gIH1cbiAgX3JlbW92ZUN1cnJlbnRTZWxlY3Rpb25TdHlsZXMoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXVwiLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiKTtcbiAgfVxuICBfcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCkge1xuICAgIGNvbnN0IHQgPSBoLmZpbmRPbmUoXG4gICAgICBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXVwiLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXCIpO1xuICB9XG4gIGZvcm1hdERhdGUodCkge1xuICAgIGNvbnN0IGUgPSBRKHQpLCBpID0gdGhpcy5fYWRkTGVhZGluZ1plcm8oUSh0KSksIG4gPSB0aGlzLl9vcHRpb25zLndlZWtkYXlzU2hvcnRbbHModCldLCBvID0gdGhpcy5fb3B0aW9ucy53ZWVrZGF5c0Z1bGxbbHModCldLCByID0gWSh0KSArIDEsIGEgPSB0aGlzLl9hZGRMZWFkaW5nWmVybyhZKHQpICsgMSksIGwgPSB0aGlzLl9vcHRpb25zLm1vbnRoc1Nob3J0W1kodCldLCBjID0gdGhpcy5fb3B0aW9ucy5tb250aHNGdWxsW1kodCldLCBkID0gSCh0KS50b1N0cmluZygpLmxlbmd0aCA9PT0gMiA/IEgodCkgOiBIKHQpLnRvU3RyaW5nKCkuc2xpY2UoMiwgNCksIF8gPSBIKHQpLCBmID0gdGhpcy5fb3B0aW9ucy5mb3JtYXQuc3BsaXQoXG4gICAgICAvKGR7MSw0fXxtezEsNH18eXs0fXx5eXwhLikvZ1xuICAgICk7XG4gICAgbGV0IG0gPSBcIlwiO1xuICAgIHJldHVybiBmLmZvckVhY2goKGcpID0+IHtcbiAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICBjYXNlIFwiZGRkZFwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgbyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZGRcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIGkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtbW1tXCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCBjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1tbVwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgYSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCByKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIF8pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbSArPSBnO1xuICAgIH0pLCBtO1xuICB9XG4gIF9hZGRMZWFkaW5nWmVybyh0KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHQsIDEwKSA8IDEwID8gYDAke3R9YCA6IHQ7XG4gIH1cbiAgX3BpY2tEYXkodCwgZSkge1xuICAgIGNvbnN0IGkgPSBFcih0KSwgeyBtaW46IG4sIG1heDogbywgZmlsdGVyOiByLCBkaXNhYmxlUGFzdDogYSwgZGlzYWJsZUZ1dHVyZTogbCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBBcyhpLCBuLCBvLCByLCBhLCBsKSB8fCAodGhpcy5fYWN0aXZlRGF0ZSA9IGksIHRoaXMuX3NlbGVjdERhdGUoaSwgZSkpO1xuICB9XG4gIF9waWNrWWVhcih0KSB7XG4gICAgY29uc3QgeyBtaW46IGUsIG1heDogaSwgZGlzYWJsZVBhc3Q6IG4sIGRpc2FibGVGdXR1cmU6IG8gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgaWYgKEZuKHQsIGUsIGksIG4sIG8pKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSBEdCh0LCB0aGlzLmFjdGl2ZU1vbnRoLCB0aGlzLmFjdGl2ZURheSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHIsIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IHIsIHRoaXMuX3NlbGVjdFllYXIodCk7XG4gIH1cbiAgX3BpY2tNb250aCh0LCBlKSB7XG4gICAgY29uc3QgeyBtaW46IGksIG1heDogbiwgZGlzYWJsZVBhc3Q6IG8sIGRpc2FibGVGdXR1cmU6IHIgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgaWYgKGdsKHQsIGUsIGksIG4sIG8sIHIpIHx8IEZuKGUsIGksIG4sIG8sIHIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBEdChlLCB0LCB0aGlzLmFjdGl2ZURheSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGEsIHRoaXMuX3NlbGVjdE1vbnRoKHQpO1xuICB9XG4gIG5leHRNb250aCgpIHtcbiAgICBjb25zdCB0ID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgMSksIGUgPSBkcyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9oZWFkZXJEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0LCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGxbdGhpcy5hY3RpdmVNb250aF19ICR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0ga3QoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBwcmV2aW91c01vbnRoKCkge1xuICAgIGNvbnN0IHQgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQ7XG4gICAgY29uc3QgZSA9IGRzKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX2hlYWRlckRhdGUsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5fb3B0aW9ucy5tb250aHNGdWxsW3RoaXMuYWN0aXZlTW9udGhdfSAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IGt0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgbmV4dFllYXIoKSB7XG4gICAgY29uc3QgdCA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0LCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBrdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICBjb25zdCBlID0gaHMoXG4gICAgICB0aGlzLmFjdGl2ZVllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIEJpLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIHByZXZpb3VzWWVhcigpIHtcbiAgICBjb25zdCB0ID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgLTEpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0LCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBrdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICBjb25zdCBlID0gaHMoXG4gICAgICB0aGlzLmFjdGl2ZVllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIEJpLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIG5leHRZZWFycygpIHtcbiAgICBjb25zdCB0ID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgMjQpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0O1xuICAgIGNvbnN0IGUgPSB1cyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgbXQsXG4gICAgICBIaSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuZmlyc3RZZWFySW5WaWV3fSAtICR7dGhpcy5sYXN0WWVhckluVmlld31gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IGt0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgcHJldmlvdXNZZWFycygpIHtcbiAgICBjb25zdCB0ID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgLTI0KTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdDtcbiAgICBjb25zdCBlID0gdXMoXG4gICAgICB0LFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIG10LFxuICAgICAgSGksXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmZpcnN0WWVhckluVmlld30gLSAke3RoaXMubGFzdFllYXJJblZpZXd9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBrdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIF9hc3luY0NoYW5nZVZpZXcodCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY2hhbmdlVmlldyh0KTtcbiAgICB9LCAwKTtcbiAgfVxuICBfY2hhbmdlVmlldyh0KSB7XG4gICAgdGhpcy5fdmlldyA9IHQsIHRoaXMuZGF0ZXNDb250YWluZXIuYmx1cigpLCB0ID09PSBcImRheXNcIiAmJiAodGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBkcyhcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9oZWFkZXJEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApKSwgdCA9PT0gXCJtb250aHNcIiAmJiAodGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBocyhcbiAgICAgIHRoaXMuYWN0aXZlWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGgsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgQmksXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSksIHQgPT09IFwieWVhcnNcIiAmJiAodGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSB1cyhcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgbXQsXG4gICAgICBIaSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5mb2N1cygpLCB0aGlzLl91cGRhdGVWaWV3Q29udHJvbHNBbmRBdHRyaWJ1dGVzKHQpLCB0aGlzLl91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKTtcbiAgfVxuICBfdXBkYXRlVmlld0NvbnRyb2xzQW5kQXR0cmlidXRlcyh0KSB7XG4gICAgdCA9PT0gXCJkYXlzXCIgJiYgKHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuX29wdGlvbnMubW9udGhzRnVsbFt0aGlzLmFjdGl2ZU1vbnRoXX0gJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBrdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbFxuICAgICksIHRoaXMucHJldmlvdXNCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnByZXZNb250aExhYmVsXG4gICAgKSwgdGhpcy5uZXh0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5fb3B0aW9ucy5uZXh0TW9udGhMYWJlbCkpLCB0ID09PSBcIm1vbnRoc1wiICYmICh0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBrdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zd2l0Y2hUb0RheVZpZXdMYWJlbFxuICAgICksIHRoaXMucHJldmlvdXNCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnByZXZZZWFyTGFiZWxcbiAgICApLCB0aGlzLm5leHRCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLl9vcHRpb25zLm5leHRZZWFyTGFiZWwpKSwgdCA9PT0gXCJ5ZWFyc1wiICYmICh0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmZpcnN0WWVhckluVmlld30gLSAke3RoaXMubGFzdFllYXJJblZpZXd9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBrdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zd2l0Y2hUb01vbnRoVmlld0xhYmVsXG4gICAgKSwgdGhpcy5wcmV2aW91c0J1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMucHJldk11bHRpWWVhckxhYmVsXG4gICAgKSwgdGhpcy5uZXh0QnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5uZXh0TXVsdGlZZWFyTGFiZWxcbiAgICApKTtcbiAgfVxuICBfdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCkge1xuICAgIHhwKFxuICAgICAgdGhpcy5fb3B0aW9ucy5kaXNhYmxlRnV0dXJlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICBtdCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXgsXG4gICAgICB0aGlzLmxhc3RZZWFySW5WaWV3LFxuICAgICAgdGhpcy5maXJzdFllYXJJblZpZXdcbiAgICApID8gdGhpcy5uZXh0QnV0dG9uLmRpc2FibGVkID0gITAgOiB0aGlzLm5leHRCdXR0b24uZGlzYWJsZWQgPSAhMSwgU3AoXG4gICAgICB0aGlzLl9vcHRpb25zLmRpc2FibGVQYXN0LFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICBtdCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXgsXG4gICAgICB0aGlzLmxhc3RZZWFySW5WaWV3LFxuICAgICAgdGhpcy5maXJzdFllYXJJblZpZXdcbiAgICApID8gdGhpcy5wcmV2aW91c0J1dHRvbi5kaXNhYmxlZCA9ICEwIDogdGhpcy5wcmV2aW91c0J1dHRvbi5kaXNhYmxlZCA9ICExO1xuICB9XG4gIF9oYW5kbGVVc2VySW5wdXQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXREZWxpbWV0ZXJzKHRoaXMuX29wdGlvbnMuZm9ybWF0KSwgaSA9IHRoaXMuX3BhcnNlRGF0ZSh0LCB0aGlzLl9vcHRpb25zLmZvcm1hdCwgZSk7XG4gICAgd3AoaSkgPyAodGhpcy5fYWN0aXZlRGF0ZSA9IGksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IGksIHRoaXMuX3NlbGVjdGVkWWVhciA9IEgoaSksIHRoaXMuX3NlbGVjdGVkTW9udGggPSBZKGkpLCB0aGlzLl9oZWFkZXJEYXRlID0gaSkgOiAodGhpcy5fYWN0aXZlRGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlck1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyWWVhciA9IG51bGwpO1xuICB9XG4gIF9nZXREZWxpbWV0ZXJzKHQpIHtcbiAgICByZXR1cm4gdC5tYXRjaCgvW14oZG15KV17MSx9L2cpO1xuICB9XG4gIF9wYXJzZURhdGUodCwgZSwgaSkge1xuICAgIGxldCBuO1xuICAgIGlbMF0gIT09IGlbMV0gPyBuID0gaVswXSArIGlbMV0gOiBuID0gaVswXTtcbiAgICBjb25zdCBvID0gbmV3IFJlZ0V4cChgWyR7bn1dYCksIHIgPSB0LnNwbGl0KG8pLCBhID0gZS5zcGxpdChvKSwgbCA9IGUuaW5kZXhPZihcIm1tbVwiKSAhPT0gLTEsIGMgPSBbXTtcbiAgICBmb3IgKGxldCBiID0gMDsgYiA8IGEubGVuZ3RoOyBiKyspXG4gICAgICBhW2JdLmluZGV4T2YoXCJ5eVwiKSAhPT0gLTEgJiYgKGNbMF0gPSB7IHZhbHVlOiByW2JdLCBmb3JtYXQ6IGFbYl0gfSksIGFbYl0uaW5kZXhPZihcIm1cIikgIT09IC0xICYmIChjWzFdID0geyB2YWx1ZTogcltiXSwgZm9ybWF0OiBhW2JdIH0pLCBhW2JdLmluZGV4T2YoXCJkXCIpICE9PSAtMSAmJiBhW2JdLmxlbmd0aCA8PSAyICYmIChjWzJdID0geyB2YWx1ZTogcltiXSwgZm9ybWF0OiBhW2JdIH0pO1xuICAgIGxldCBkO1xuICAgIGUuaW5kZXhPZihcIm1tbW1cIikgIT09IC0xID8gZCA9IHRoaXMuX29wdGlvbnMubW9udGhzRnVsbCA6IGQgPSB0aGlzLl9vcHRpb25zLm1vbnRoc1Nob3J0O1xuICAgIGNvbnN0IF8gPSBOdW1iZXIoY1swXS52YWx1ZSksIGYgPSBsID8gdGhpcy5nZXRNb250aE51bWJlckJ5TW9udGhOYW1lKGNbMV0udmFsdWUsIGQpIDogTnVtYmVyKGNbMV0udmFsdWUpIC0gMSwgbSA9IE51bWJlcihjWzJdLnZhbHVlKTtcbiAgICByZXR1cm4gRHQoXywgZiwgbSk7XG4gIH1cbiAgZ2V0TW9udGhOdW1iZXJCeU1vbnRoTmFtZSh0LCBlKSB7XG4gICAgcmV0dXJuIGUuZmluZEluZGV4KChpKSA9PiBpID09PSB0KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgZnMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IEdmID0gKHtcbiAgZm9ybWF0MjQ6IHMsXG4gIG9rTGFiZWw6IHQsXG4gIGNhbmNlbExhYmVsOiBlLFxuICBoZWFkSUQ6IGksXG4gIGZvb3RlcklEOiBuLFxuICBib2R5SUQ6IG8sXG4gIHBpY2tlcklEOiByLFxuICBjbGVhckxhYmVsOiBhLFxuICBpbmxpbmU6IGwsXG4gIHNob3dDbGVhckJ0bjogYyxcbiAgYW1MYWJlbDogZCxcbiAgcG1MYWJlbDogX1xufSwgZikgPT4ge1xuICBjb25zdCBtID0gYDxkaXYgaWQ9JyR7cn0nIGNsYXNzPScke2YudGltZXBpY2tlcldyYXBwZXJ9JyBkYXRhLXRlLXRpbWVwaWNrZXItd3JhcHBlcj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlckNvbnRhaW5lcn1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyRWxlbWVudHN9XCI+XG4gICAgICAgIDxkaXYgaWQ9JyR7aX0nIGNsYXNzPScke2YudGltZXBpY2tlckhlYWR9JyBzdHlsZT0ncGFkZGluZy1yaWdodDoke3MgPyA1MCA6IDEwfXB4Jz5cbiAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJIZWFkQ29udGVudH0nPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ3VycmVudFdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VyQ3VycmVudEJ1dHRvbn0nIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtdGltZXBpY2tlci1hY3RpdmUgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLWhvdXIgZGF0YS10ZS1yaXBwbGUtaW5pdD4yMTwvYnV0dG9uPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJEb3R9JyBkaXNhYmxlZD46PC9idXR0b24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ3VycmVudEJ1dHRvbldyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9ufScgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLW1pbnV0ZSBkYXRhLXRlLXJpcHBsZS1pbml0PjIxPC9idXR0b24+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICR7cyA/IFwiXCIgOiBgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyTW9kZVdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9XCIke2YudGltZXBpY2tlck1vZGVBbX1cIiB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXRpbWVwaWNrZXItYW0gZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSBkYXRhLXRlLXJpcHBsZS1pbml0PiR7ZH08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCIke2YudGltZXBpY2tlck1vZGVQbX1cIiB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXRpbWVwaWNrZXItcG0gZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSBkYXRhLXRlLXJpcHBsZS1pbml0PiR7X308L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5gfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgJHtsID8gXCJcIiA6IGA8ZGl2IGlkPScke299JyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJDbG9ja1dyYXBwZXJ9JyBkYXRhLXRlLXRpbWVwaWNrZXItY2xvY2std3JhcHBlcj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9JyR7Zi50aW1lcGlja2VyQ2xvY2t9JyBkYXRhLXRlLXRpbWVwaWNrZXItY2xvY2s+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPScke2YudGltZXBpY2tlck1pZGRsZURvdH0nIGRhdGEtdGUtdGltZXBpY2tlci1taWRkbGUtZG90Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJIYW5kUG9pbnRlcn0nIGRhdGEtdGUtdGltZXBpY2tlci1oYW5kLXBvaW50ZXI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJQb2ludGVyQ2lyY2xlfScgZGF0YS10ZS10aW1lcGlja2VyLWNpcmNsZT48L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICR7cyA/ICc8ZGl2IGNsYXNzPVwiJyArIGYudGltZXBpY2tlckNsb2NrSW5uZXIgKyAnXCIgZGF0YS10ZS10aW1lcGlja2VyLWNsb2NrLWlubmVyPjwvZGl2PicgOiBcIlwifVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+YH1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlkPScke259JyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJGb290ZXJXcmFwcGVyfSc+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJGb290ZXJ9XCI+XG4gICAgICAgICR7YyA/IGA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VyRm9vdGVyQnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLWNsZWFyIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHthfTwvYnV0dG9uPmAgOiBcIlwifVxuICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VyRm9vdGVyQnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLWNhbmNlbCB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7ZX08L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlckZvb3RlckJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1zdWJtaXQgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3R9PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5gLCBnID0gYDxkaXYgaWQ9JyR7cn0nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZVdyYXBwZXJ9JyBkYXRhLXRlLXRpbWVwaWNrZXItd3JhcHBlcj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lQ29udGFpbmVyfVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUVsZW1lbnRzfVwiPlxuICAgICAgICAgIDxkaXYgaWQ9JyR7aX0nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZUhlYWR9J1xuICAgICAgICAgIHN0eWxlPSdwYWRkaW5nLXJpZ2h0OjEwcHgnPlxuICAgICAgICAgIDxkaXYgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lSGVhZENvbnRlbnR9Jz5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ3VycmVudFdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUhvdXJXcmFwcGVyfVwiIGRhdGEtdGUtdGltZXBpY2tlci1pbmxpbmUtaG91ci1pY29ucz5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uVXB9XCIgZGF0YS10ZS10aW1lcGlja2VyLWljb24tdXAgZGF0YS10ZS10aW1lcGlja2VyLWljb24taW5saW5lLWhvdXI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnfVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDE1Ljc1bDcuNS03LjUgNy41IDcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgPC9zdmc+ICAgXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVDdXJyZW50QnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLWhvdXIgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQtaW5saW5lIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+MjE8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uRG93bn1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1pbmxpbmUtaG91ciBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1kb3duPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvblN2Z31cIj5cbiAgICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNSBoLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz4gIFxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVEb3R9JyBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudC1pbmxpbmUgZGlzYWJsZWQ+OjwvYnV0dG9uPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ3VycmVudE1pbnV0ZVdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25VcH1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi11cCBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1pbmxpbmUtbWludXRlPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Tdmd9XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTQuNSAxNS43NWw3LjUtNy41IDcuNSA3LjVcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItbWludXRlIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50IGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50LWlubGluZSB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PjIxPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Eb3dufVwiIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWlubGluZS1taW51dGUgZGF0YS10ZS10aW1lcGlja2VyLWljb24tZG93bj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnfVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNSBoLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xOS41IDguMjVsLTcuNSA3LjUtNy41LTcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPiBcbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICR7cyA/IFwiXCIgOiBgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lTW9kZVdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVNb2RlQW19XCIgZGF0YS10ZS10aW1lcGlja2VyLWFtIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyLW1vZGUgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke2R9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lTW9kZVBtfVwiIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyLW1vZGUgZGF0YS10ZS10aW1lcGlja2VyLXBtIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHtffTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVTdWJtaXRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItc3VibWl0IHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt0fTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5gfVxuICAgICAgICAgICAgICAke3MgPyBgPGJ1dHRvbiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVTdWJtaXRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItc3VibWl0IHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt0fTwvYnV0dG9uPmAgOiBcIlwifVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+YDtcbiAgcmV0dXJuIGwgPyBnIDogbTtcbn0sIHFmID0gKHMsIHQsIGUpID0+IHtcbiAgY29uc3QgeyBpY29uU1ZHOiBpIH0gPSBzO1xuICByZXR1cm4gYFxuICA8YnV0dG9uIGlkPVwiJHt0fVwiIHRhYmluZGV4PVwiMFwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7ZS50aW1lcGlja2VyVG9nZ2xlQnV0dG9ufVwiIGRhdGEtdGUtdG9nZ2xlPVwidGltZXBpY2tlclwiIGRhdGEtdGUtdGltZXBpY2tlci10b2dnbGUtYnV0dG9uIGRhdGEtdGUtdGltZXBpY2tlci1pY29uPlxuICAgICR7aX1cbiAgPC9idXR0b24+XG5gO1xufSwgTHMgPSBcImRhdGEtdGUtdGltZXBpY2tlci1kaXNhYmxlZFwiLCBGaSA9IFwiZGF0YS10ZS10aW1lcGlja2VyLWFjdGl2ZVwiLCBmZSA9IChzKSA9PiB7XG4gIGlmIChzID09PSBcIlwiKVxuICAgIHJldHVybjtcbiAgbGV0IHQsIGUsIGksIG47XG4gIHJldHVybiBFbChzKSA/ICh0ID0gcy5nZXRIb3VycygpLCBuID0gdCwgZSA9IHMuZ2V0TWludXRlcygpLCB0ICU9IDEyLCBuID09PSAwICYmIHQgPT09IDAgJiYgKGkgPSBcIkFNXCIpLCB0ID0gdCB8fCAxMiwgaSA9PT0gdm9pZCAwICYmIChpID0gTnVtYmVyKG4pID49IDEyID8gXCJQTVwiIDogXCJBTVwiKSwgZSA9IGUgPCAxMCA/IGAwJHtlfWAgOiBlKSA6IChbdCwgZSwgaV0gPSBSKHMsICExKSwgbiA9IHQsIHQgJT0gMTIsIG4gPT09IDAgJiYgdCA9PT0gMCAmJiAoaSA9IFwiQU1cIiksIHQgPSB0IHx8IDEyLCBpID09PSB2b2lkIDAgJiYgKGkgPSBOdW1iZXIobikgPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpKSwge1xuICAgIGhvdXJzOiB0LFxuICAgIG1pbnV0ZXM6IGUsXG4gICAgYW1PclBtOiBpXG4gIH07XG59LCBFbCA9IChzKSA9PiBzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzKSA9PT0gXCJbb2JqZWN0IERhdGVdXCIgJiYgIU51bWJlci5pc05hTihzKSwgd3IgPSAocykgPT4ge1xuICBpZiAocyA9PT0gXCJcIilcbiAgICByZXR1cm47XG4gIGxldCB0LCBlO1xuICByZXR1cm4gRWwocykgPyAodCA9IHMuZ2V0SG91cnMoKSwgZSA9IHMuZ2V0TWludXRlcygpKSA6IFt0LCBlXSA9IFIocywgITEpLCBlID0gTnVtYmVyKGUpIDwgMTAgPyBgMCR7TnVtYmVyKGUpfWAgOiBlLCB7XG4gICAgaG91cnM6IHQsXG4gICAgbWludXRlczogZVxuICB9O1xufSwgUWYgPSAocywgdCwgZSkgPT4gdS5vbihkb2N1bWVudCwgcywgdCwgKHsgdGFyZ2V0OiBpIH0pID0+IHtcbiAgaWYgKGkuaGFzQXR0cmlidXRlKEZpKSlcbiAgICByZXR1cm47XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodCkuZm9yRWFjaCgobykgPT4ge1xuICAgIG8uaGFzQXR0cmlidXRlKEZpKSAmJiAocC5yZW1vdmVDbGFzcyhvLCBlLm9wYWNpdHkpLCBvLnJlbW92ZUF0dHJpYnV0ZShGaSkpO1xuICB9KSwgcC5hZGRDbGFzcyhpLCBlLm9wYWNpdHkpLCBpLnNldEF0dHJpYnV0ZShGaSwgXCJcIik7XG59KSwga3IgPSAoeyBjbGllbnRYOiBzLCBjbGllbnRZOiB0LCB0b3VjaGVzOiBlIH0sIGksIG4gPSAhMSkgPT4ge1xuICBjb25zdCB7IGxlZnQ6IG8sIHRvcDogciB9ID0gaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgbGV0IGEgPSB7fTtcbiAgcmV0dXJuICFuIHx8ICFlID8gYSA9IHtcbiAgICB4OiBzIC0gbyxcbiAgICB5OiB0IC0gclxuICB9IDogbiAmJiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPiAwICYmIChhID0ge1xuICAgIHg6IGVbMF0uY2xpZW50WCAtIG8sXG4gICAgeTogZVswXS5jbGllbnRZIC0gclxuICB9KSwgYTtcbn0sIFlpID0gKCkgPT4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDIgJiYgL01hY0ludGVsLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgfHwgL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KFxuICBuYXZpZ2F0b3IudXNlckFnZW50XG4pLCBSID0gKHMsIHQgPSAhMCkgPT4gdCA/IHMudmFsdWUucmVwbGFjZSgvOi9naSwgXCIgXCIpLnNwbGl0KFwiIFwiKSA6IHMucmVwbGFjZSgvOi9naSwgXCIgXCIpLnNwbGl0KFwiIFwiKSwgVGwgPSAocywgdCkgPT4ge1xuICBjb25zdCBbZSwgaSwgbl0gPSBSKHMsICExKSwgW28sIHIsIGFdID0gUih0LCAhMSk7XG4gIHJldHVybiBuID09PSBcIlBNXCIgJiYgYSA9PT0gXCJBTVwiIHx8IG4gPT09IGEgJiYgZSA+IG8gfHwgaSA+IHI7XG59LCBDbCA9ICgpID0+IHtcbiAgY29uc3QgcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCB0ID0gcy5nZXRIb3VycygpLCBlID0gcy5nZXRNaW51dGVzKCk7XG4gIHJldHVybiBgJHt0fToke2UgPCAxMCA/IGAwJHtlfWAgOiBlfWA7XG59LCBqdCA9IChzLCB0LCBlKSA9PiB7XG4gIGlmICghdClcbiAgICByZXR1cm4gcztcbiAgbGV0IGkgPSBDbCgpO1xuICByZXR1cm4gZSAmJiAoaSA9IGAke2ZlKGkpLmhvdXJzfToke2ZlKGkpLm1pbnV0ZXN9ICR7ZmUoaSkuYW1PclBtfWApLCAocyAhPT0gXCJcIiAmJiBUbChpLCBzKSB8fCBzID09PSBcIlwiKSAmJiAocyA9IGkpLCBzO1xufSwgS3QgPSAocywgdCwgZSkgPT4ge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHM7XG4gIGxldCBpID0gQ2woKTtcbiAgcmV0dXJuIGUgJiYgKGkgPSBgJHtmZShpKS5ob3Vyc306JHtmZShpKS5taW51dGVzfSAke2ZlKGkpLmFtT3JQbX1gKSwgKHMgIT09IFwiXCIgJiYgIVRsKGksIHMpIHx8IHMgPT09IFwiXCIpICYmIChzID0gaSksIHM7XG59LCBaZiA9ICh7IGZvcm1hdDEyOiBzLCBtYXhUaW1lOiB0LCBtaW5UaW1lOiBlLCBkaXNhYmxlUGFzdDogaSwgZGlzYWJsZUZ1dHVyZTogbiB9LCBvLCByKSA9PiB7XG4gIGNvbnN0IGEgPSBSKG8pWzFdO1xuICBlID0ganQoZSwgaSwgcyksIHQgPSBLdCh0LCBuLCBzKTtcbiAgY29uc3QgW2wsIGMsIGRdID0gUih0LCAhMSksIFtfLCBmLCBtXSA9IFIoZSwgITEpO1xuICBpZiAoZCAhPT0gdm9pZCAwIHx8IG0gIT09IHZvaWQgMClcbiAgICByZXR1cm4gW3IsIGFdO1xuICBpZiAoIShsICE9PSBcIlwiICYmIF8gPT09IFwiXCIgJiYgTnVtYmVyKHIpID4gTnVtYmVyKGwpKSAmJiAhKGwgPT09IFwiXCIgJiYgXyAhPT0gXCJcIiAmJiBjID09PSB2b2lkIDAgJiYgZiAhPT0gXCJcIiAmJiBOdW1iZXIocikgPCBOdW1iZXIoXykpKVxuICAgIHJldHVybiBbciwgYV07XG59LCBPciA9IChzLCB0LCBlLCBpKSA9PiB7XG4gIHMuZm9yRWFjaCgobikgPT4ge1xuICAgIHQgPSB0ID09PSBcIjEyXCIgJiYgaSA/IFwiMFwiIDogdCwgKG4udGV4dENvbnRlbnQgPT09IFwiMDBcIiB8fCBOdW1iZXIobi50ZXh0Q29udGVudCA9PT0gXCIxMlwiICYmIGkgPyBcIjBcIiA6IG4udGV4dENvbnRlbnQpID4gdCkgJiYgKHAuYWRkQ2xhc3MobiwgZS50aXBzRGlzYWJsZWQpLCBuLnNldEF0dHJpYnV0ZShMcywgXCJcIikpO1xuICB9KTtcbn0sIHhyID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgdCA9IHQgPT09IFwiMTJcIiAmJiBpID8gXCIwXCIgOiB0LCBuLnRleHRDb250ZW50ICE9PSBcIjAwXCIgJiYgTnVtYmVyKG4udGV4dENvbnRlbnQgPT09IFwiMTJcIiAmJiBpID8gXCIwXCIgOiBuLnRleHRDb250ZW50KSA8IE51bWJlcih0KSAmJiAocC5hZGRDbGFzcyhuLCBlLnRpcHNEaXNhYmxlZCksIG4uc2V0QXR0cmlidXRlKExzLCBcIlwiKSk7XG4gIH0pO1xufSwgQWwgPSAocywgdCwgZSwgaSkgPT4ge1xuICBpZiAodCA9PT0gXCIxMlwiIHx8IHQgPT09IFwiMjRcIilcbiAgICByZXR1cm47XG4gIGNvbnN0IG4gPSBlID8gMTIgOiAyNDtcbiAgcmV0dXJuIGkgPT09IFwibWF4XCIgPyAoTnVtYmVyKHMpID09PSBuID8gMCA6IE51bWJlcihzKSkgPiBOdW1iZXIodCkgOiAoTnVtYmVyKHMpID09PSBuID8gMCA6IE51bWJlcihzKSkgPCBOdW1iZXIodCk7XG59LCBKZiA9IChzLCB0LCBlLCBpLCBuLCBvKSA9PiB7XG4gIHMuZm9yRWFjaCgocikgPT4ge1xuICAgIChBbChpLCBlLCBvLCBcIm1heFwiKSB8fCBOdW1iZXIoci50ZXh0Q29udGVudCkgPiB0ICYmIE51bWJlcihpKSA9PT0gTnVtYmVyKGUpKSAmJiAocC5hZGRDbGFzcyhyLCBuLnRpcHNEaXNhYmxlZCksIHIuc2V0QXR0cmlidXRlKExzLCBcIlwiKSk7XG4gIH0pO1xufSwgdF8gPSAocywgdCwgZSwgaSwgbiwgbykgPT4ge1xuICBzLmZvckVhY2goKHIpID0+IHtcbiAgICAoQWwoaSwgZSwgbywgXCJtaW5cIikgfHwgTnVtYmVyKHIudGV4dENvbnRlbnQpIDwgdCAmJiBOdW1iZXIoaSkgPT09IE51bWJlcihlKSkgJiYgKHAuYWRkQ2xhc3Mociwgbi50aXBzRGlzYWJsZWQpLCByLnNldEF0dHJpYnV0ZShMcywgXCJcIikpO1xuICB9KTtcbn0sIGVfID0gKHMpID0+IHMuc3RhcnRzV2l0aChcIjBcIikgPyBOdW1iZXIocy5zbGljZSgxKSkgOiBOdW1iZXIocyksIGhpID0gXCJ0aW1lcGlja2VyXCIsIEwgPSBgZGF0YS10ZS0ke2hpfWAsIFNyID0gXCJbZGF0YS10ZS10b2dnbGVdXCIsIF9zID0gYHRlLiR7aGl9YCwgJHQgPSBgLiR7X3N9YCwgTHQgPSBcIi5kYXRhLWFwaVwiLCBEciA9IGBjbGljayR7JHR9JHtMdH1gLCBqaSA9IGBrZXlkb3duJHskdH0ke0x0fWAsIElyID0gYG1vdXNlZG93biR7JHR9JHtMdH1gLCAkciA9IGBtb3VzZXVwJHskdH0ke0x0fWAsIExyID0gYG1vdXNlbW92ZSR7JHR9JHtMdH1gLCBNciA9IGBtb3VzZWxlYXZlJHskdH0ke0x0fWAsIE5yID0gYG1vdXNlb3ZlciR7JHR9JHtMdH1gLCBSciA9IGB0b3VjaG1vdmUkeyR0fSR7THR9YCwgUHIgPSBgdG91Y2hlbmQkeyR0fSR7THR9YCwgSHIgPSBgdG91Y2hzdGFydCR7JHR9JHtMdH1gLCBpXyA9IGBbJHtMfS1hbV1gLCBzXyA9IGBbJHtMfS1wbV1gLCBuXyA9IGBbJHtMfS1mb3JtYXQyNF1gLCBLaSA9IGBbJHtMfS1jdXJyZW50XWAsIFVpID0gYFske0x9LWhvdXItbW9kZV1gLCBvXyA9IGBbJHtMfS10b2dnbGUtYnV0dG9uXWAsIGZuID0gYCR7TH0tY2FuY2VsYCwgQnIgPSBgJHtMfS1jbGVhcmAsIF9uID0gYCR7TH0tc3VibWl0YCwgcl8gPSBgJHtMfS1pY29uYCwgbW4gPSBgJHtMfS1pY29uLXVwYCwgZ24gPSBgJHtMfS1pY29uLWRvd25gLCBhXyA9IGAke0x9LWljb24taW5saW5lLWhvdXJgLCBsXyA9IGAke0x9LWljb24taW5saW5lLW1pbnV0ZWAsIFZyID0gYCR7TH0taW5saW5lLWhvdXItaWNvbnNgLCBjXyA9IGAke0x9LWN1cnJlbnQtaW5saW5lYCwgZF8gPSBcInJlYWRvbmx5XCIsIFdyID0gYCR7TH0taW52YWxpZC1mZWVkYmFja2AsIGJuID0gYCR7TH0taXMtaW52YWxpZGAsIEJ0ID0gYCR7TH0tZGlzYWJsZWRgLCBCID0gYCR7TH0tYWN0aXZlYCwgaF8gPSBgJHtMfS1pbnB1dGAsIGxlID0gYCR7TH0tY2xvY2tgLCBKZSA9IGAke0x9LWNsb2NrLWlubmVyYCwgdm4gPSBgJHtMfS13cmFwcGVyYCwgRnIgPSBgJHtMfS1jbG9jay13cmFwcGVyYCwgemkgPSBgJHtMfS1ob3VyYCwgRW4gPSBgJHtMfS1taW51dGVgLCBYaSA9IGAke0x9LXRpcHMtZWxlbWVudGAsIEsgPSBgJHtMfS10aXBzLWhvdXJzYCwgWCA9IGAke0x9LXRpcHMtbWludXRlc2AsIGF0ID0gYCR7TH0tdGlwcy1pbm5lcmAsIEdpID0gYCR7TH0tdGlwcy1pbm5lci1lbGVtZW50YCwgWXIgPSBgJHtMfS1taWRkbGUtZG90YCwgVG4gPSBgJHtMfS1oYW5kLXBvaW50ZXJgLCBDbiA9IGAke0x9LWNpcmNsZWAsIGpyID0gYCR7TH0tbW9kYWxgLCB1XyA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xMiA2djZoNC41bTQuNSAwYTkgOSAwIDExLTE4IDAgOSA5IDAgMDExOCAwelwiIC8+XG48L3N2Zz5gLCBwXyA9IHtcbiAgYXBwZW5kVmFsaWRhdGlvbkluZm86ICEwLFxuICBib2R5SUQ6IFwiXCIsXG4gIGNhbmNlbExhYmVsOiBcIkNhbmNlbFwiLFxuICBjbGVhckxhYmVsOiBcIkNsZWFyXCIsXG4gIGNsb3NlTW9kYWxPbkJhY2tkcm9wQ2xpY2s6ICEwLFxuICBjbG9zZU1vZGFsT25NaW51dGVzQ2xpY2s6ICExLFxuICBjb250YWluZXI6IFwiYm9keVwiLFxuICBkZWZhdWx0VGltZTogXCJcIixcbiAgZGlzYWJsZWQ6ICExLFxuICBkaXNhYmxlUGFzdDogITEsXG4gIGRpc2FibGVGdXR1cmU6ICExLFxuICBlbmFibGVWYWxpZGF0aW9uOiAhMCxcbiAgZm9jdXNJbnB1dEFmdGVyQXBwcm92ZTogITEsXG4gIGZvb3RlcklEOiBcIlwiLFxuICBmb3JtYXQxMjogITAsXG4gIGZvcm1hdDI0OiAhMSxcbiAgaGVhZElEOiBcIlwiLFxuICBpbmNyZW1lbnQ6ICExLFxuICBpbmxpbmU6ICExLFxuICBpbnZhbGlkTGFiZWw6IFwiSW52YWxpZCBUaW1lIEZvcm1hdFwiLFxuICBtYXhUaW1lOiBcIlwiLFxuICBtaW5UaW1lOiBcIlwiLFxuICBtb2RhbElEOiBcIlwiLFxuICBva0xhYmVsOiBcIk9rXCIsXG4gIG92ZXJmbG93SGlkZGVuOiAhMCxcbiAgcGlja2VySUQ6IFwiXCIsXG4gIHJlYWRPbmx5OiAhMSxcbiAgc2hvd0NsZWFyQnRuOiAhMCxcbiAgc3dpdGNoSG91cnNUb01pbnV0ZXNPbkNsaWNrOiAhMCxcbiAgaWNvblNWRzogdV8sXG4gIHdpdGhJY29uOiAhMCxcbiAgcG1MYWJlbDogXCJQTVwiLFxuICBhbUxhYmVsOiBcIkFNXCIsXG4gIGFuaW1hdGlvbnM6ICEwXG59LCBmXyA9IHtcbiAgYXBwZW5kVmFsaWRhdGlvbkluZm86IFwiYm9vbGVhblwiLFxuICBib2R5SUQ6IFwic3RyaW5nXCIsXG4gIGNhbmNlbExhYmVsOiBcInN0cmluZ1wiLFxuICBjbGVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBjbG9zZU1vZGFsT25CYWNrZHJvcENsaWNrOiBcImJvb2xlYW5cIixcbiAgY2xvc2VNb2RhbE9uTWludXRlc0NsaWNrOiBcImJvb2xlYW5cIixcbiAgY29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBkaXNhYmxlZDogXCJib29sZWFuXCIsXG4gIGRpc2FibGVQYXN0OiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZUZ1dHVyZTogXCJib29sZWFuXCIsXG4gIGVuYWJsZVZhbGlkYXRpb246IFwiYm9vbGVhblwiLFxuICBmb290ZXJJRDogXCJzdHJpbmdcIixcbiAgZm9ybWF0MTI6IFwiYm9vbGVhblwiLFxuICBmb3JtYXQyNDogXCJib29sZWFuXCIsXG4gIGhlYWRJRDogXCJzdHJpbmdcIixcbiAgaW5jcmVtZW50OiBcImJvb2xlYW5cIixcbiAgaW5saW5lOiBcImJvb2xlYW5cIixcbiAgaW52YWxpZExhYmVsOiBcInN0cmluZ1wiLFxuICBtb2RhbElEOiBcInN0cmluZ1wiLFxuICBva0xhYmVsOiBcInN0cmluZ1wiLFxuICBvdmVyZmxvd0hpZGRlbjogXCJib29sZWFuXCIsXG4gIHBpY2tlcklEOiBcInN0cmluZ1wiLFxuICByZWFkT25seTogXCJib29sZWFuXCIsXG4gIHNob3dDbGVhckJ0bjogXCJib29sZWFuXCIsXG4gIHN3aXRjaEhvdXJzVG9NaW51dGVzT25DbGljazogXCJib29sZWFuXCIsXG4gIGRlZmF1bHRUaW1lOiBcIihzdHJpbmd8ZGF0ZXxudW1iZXIpXCIsXG4gIGljb25TVkc6IFwic3RyaW5nXCIsXG4gIHdpdGhJY29uOiBcImJvb2xlYW5cIixcbiAgcG1MYWJlbDogXCJzdHJpbmdcIixcbiAgYW1MYWJlbDogXCJzdHJpbmdcIixcbiAgYW5pbWF0aW9uczogXCJib29sZWFuXCJcbn0sIF9fID0ge1xuICB0aXBzOiBcImFic29sdXRlIHJvdW5kZWQtWzEwMCVdIHctWzMycHhdIGgtWzMycHhdIHRleHQtY2VudGVyIGN1cnNvci1wb2ludGVyIHRleHQtWzEuMXJlbV0gcm91bmRlZC1bMTAwJV0gYmctdHJhbnNwYXJlbnQgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgZm9udC1saWdodCBmb2N1czpvdXRsaW5lLW5vbmUgc2VsZWN0aW9uOmJnLXRyYW5zcGFyZW50XCIsXG4gIHRpcHNBY3RpdmU6IFwidGV4dC13aGl0ZSBiZy1bIzNiNzFjYV0gZm9udC1ub3JtYWxcIixcbiAgdGlwc0Rpc2FibGVkOiBcInRleHQtWyNiM2FmYWZdIHBvaW50ZXItZXZlbnRzLW5vbmUgYmctdHJhbnNwYXJlbnRcIixcbiAgdHJhbnNmb3JtOiBcInRyYW5zaXRpb24tW3RyYW5zZm9ybSxoZWlnaHRdIGVhc2UtaW4tb3V0IGR1cmF0aW9uLVs0MDBtc11cIixcbiAgbW9kYWw6IFwiei1bMTA2NV1cIixcbiAgY2xvY2tBbmltYXRpb246IFwiYW5pbWF0ZS1bc2hvdy11cC1jbG9ja18zNTBtc19saW5lYXJdXCIsXG4gIG9wYWNpdHk6IFwiIW9wYWNpdHktMTAwXCIsXG4gIHRpbWVwaWNrZXJXcmFwcGVyOiBcInRvdWNoLW5vbmUgb3BhY2l0eS0xMDAgei1bMTA2NV0gaW5zZXQtMCBiZy1bIzAwMDAwMDY2XSBoLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgZml4ZWRcIixcbiAgdGltZXBpY2tlckNvbnRhaW5lcjogXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBtYXgtaC1bY2FsYygxMDAlLTY0cHgpXSBvdmVyZmxvdy15LWF1dG8gc2hhZG93LVswXzEwcHhfMTVweF8tM3B4X3JnYmEoMCwwLDAsMC4wNyksMF80cHhfNnB4Xy0ycHhfcmdiYSgwLDAsMCwwLjA1KV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtbGdcIixcbiAgdGltZXBpY2tlckVsZW1lbnRzOiBcImZsZXggZmxleC1jb2wgbWluLXctWzMxMHB4XSBtaW4taC1bMzI1cHhdIGJnLXdoaXRlIHJvdW5kZWQtdC1bMC42cmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWZsZXgtcm93IG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4tdy1bYXV0b10gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi1oLVthdXRvXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6b3ZlcmZsb3cteS1hdXRvIGp1c3RpZnktYXJvdW5kXCIsXG4gIHRpbWVwaWNrZXJIZWFkOiBcImJnLVsjM2I3MWNhXSBkYXJrOmJnLXppbmMtNzAwIGgtWzEwMHB4XSByb3VuZGVkLXQtbGcgcHItWzI0cHhdIHBsLVs1MHB4XSBweS1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtdHItbm9uZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC1ibC1ub25lIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpwLVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cHItWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpoLWF1dG8gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi1oLVszMDVweF0gZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIixcbiAgdGltZXBpY2tlckhlYWRDb250ZW50OiBcIm1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmbGV4LWNvbCBmbGV4IHctZnVsbCBqdXN0aWZ5LWV2ZW5seVwiLFxuICB0aW1lcGlja2VyQ3VycmVudFdyYXBwZXI6IFwiW2RpcmVjdGlvbjpsdHJdIHJ0bDpbZGlyZWN0aW9uOnJ0bF1cIixcbiAgdGltZXBpY2tlckN1cnJlbnRCdXR0b25XcmFwcGVyOiBcInJlbGF0aXZlIGgtZnVsbFwiLFxuICB0aW1lcGlja2VyQ3VycmVudEJ1dHRvbjogXCJ0ZXh0LVszLjc1cmVtXSBmb250LWxpZ2h0IGxlYWRpbmctWzEuMl0gdHJhY2tpbmctWy0wLjAwODMzZW1dIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBwLTAgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnRleHQtNXhsIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmb250LW5vcm1hbCBjdXJzb3ItcG9pbnRlciBob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lIFwiLFxuICB0aW1lcGlja2VyRG90OiBcImZvbnQtbGlnaHQgbGVhZGluZy1bMS4yXSB0cmFja2luZy1bLTAuMDA4MzNlbV0gdGV4dC1bMy43NXJlbV0gb3BhY2l0eS1bLjU0XSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBwLTAgdGV4dC13aGl0ZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC1bM3JlbV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsXCIsXG4gIHRpbWVwaWNrZXJNb2RlV3JhcHBlcjogXCJmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIHRleHQtWzE4cHhdIHRleHQtWyNmZmZmZmY4YV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFqdXN0aWZ5LWFyb3VuZCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWZsZXgtcm93XCIsXG4gIHRpbWVwaWNrZXJNb2RlQW06IFwicC0wIGJnLXRyYW5zcGFyZW50IGJvcmRlci1ub25lIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBjdXJzb3ItcG9pbnRlciBob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lXCIsXG4gIHRpbWVwaWNrZXJNb2RlUG06IFwicC0wIGJnLXRyYW5zcGFyZW50IGJvcmRlci1ub25lIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBjdXJzb3ItcG9pbnRlciBob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lXCIsXG4gIHRpbWVwaWNrZXJDbG9ja1dyYXBwZXI6IFwibWluLXctWzMxMHB4XSBtYXgtdy1bMzI1cHhdIG1pbi1oLVszMDVweF0gb3ZlcmZsb3cteC1oaWRkZW4gaC1mdWxsIGZsZXgganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgaXRlbXMtY2VudGVyIGRhcms6YmctemluYy01MDBcIixcbiAgdGltZXBpY2tlckNsb2NrOiBcInJlbGF0aXZlIHJvdW5kZWQtWzEwMCVdIHctWzI2MHB4XSBoLVsyNjBweF0gY3Vyc29yLWRlZmF1bHQgbXktMCBteC1hdXRvIGJnLVsjMDAwMDAwMTJdIGRhcms6YmctemluYy02MDAvNTBcIixcbiAgdGltZXBpY2tlck1pZGRsZURvdDogXCJ0b3AtMS8yIGxlZnQtMS8yIHctWzZweF0gaC1bNnB4XSAtdHJhbnNsYXRlLXktMS8yIC10cmFuc2xhdGUteC0xLzIgcm91bmRlZC1bNTAlXSBiZy1bIzNiNzFjYV0gYWJzb2x1dGVcIixcbiAgdGltZXBpY2tlckhhbmRQb2ludGVyOiBcImJnLVsjM2I3MWNhXSBib3R0b20tMS8yIGgtMi81IGxlZnQtW2NhbGMoNTAlLTFweCldIHJ0bDohbGVmdC1hdXRvIG9yaWdpbi1bY2VudGVyX2JvdHRvbV8wXSBydGw6IW9yaWdpbi1bNTAlXzUwJV8wXSB3LVsycHhdIGFic29sdXRlXCIsXG4gIHRpbWVwaWNrZXJQb2ludGVyQ2lyY2xlOiBcIi10b3AtWzIxcHhdIC1sZWZ0LVsxNXB4XSB3LVs0cHhdIGJvcmRlci1bMTRweF0gYm9yZGVyLXNvbGlkIGJvcmRlci1bIzNiNzFjYV0gaC1bNHB4XSBib3gtY29udGVudCByb3VuZGVkLVsxMDAlXSBhYnNvbHV0ZVwiLFxuICB0aW1lcGlja2VyQ2xvY2tJbm5lcjogXCJhYnNvbHV0ZSB0b3AtMS8yIGxlZnQtMS8yIC10cmFuc2xhdGUteS0xLzIgLXRyYW5zbGF0ZS14LTEvMiB3LVsxNjBweF0gaC1bMTYwcHhdIHJvdW5kZWQtWzEwMCVdXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJXcmFwcGVyOiBcInJvdW5kZWQtYi1sZyBmbGV4IGp1c3RpZnktYmV0d2VlbiBpdGVtcy1jZW50ZXIgdy1mdWxsIGgtWzU2cHhdIHB4LVsxMnB4XSBiZy13aGl0ZSBkYXJrOmJnLXppbmMtNTAwXCIsXG4gIHRpbWVwaWNrZXJGb290ZXI6IFwidy1mdWxsIGZsZXgganVzdGlmeS1iZXR3ZWVuXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJCdXR0b246IFwidGV4dC1bMC44cmVtXSBtaW4tdy1bNjRweF0gYm94LWJvcmRlciBmb250LW1lZGl1bSBsZWFkaW5nLVs0MHB4XSByb3VuZGVkLVsxMHB4XSB0cmFja2luZy1bMC4xcmVtXSB1cHBlcmNhc2UgdGV4dC1bIzNiNzFjYV0gZGFyazp0ZXh0LXdoaXRlIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tW2JhY2tncm91bmQtY29sb3IsYm94LXNoYWRvdyxib3JkZXJdIGR1cmF0aW9uLVsyNTBtc10gZWFzZS1bY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV0gZGVsYXktWzBtc10gb3V0bGluZS1ub25lIHB5LTAgcHgtWzEwcHhdIGgtWzQwcHhdIG1iLVsxMHB4XSBob3ZlcjpiZy1bIzAwMDAwMDE0XSBmb2N1czpiZy1bIzAwMDAwMDE0XSBmb2N1czpvdXRsaW5lLW5vbmVcIixcbiAgdGltZXBpY2tlcklubGluZVdyYXBwZXI6IFwidG91Y2gtbm9uZSBvcGFjaXR5LTEwMCB6LVsxMDY1XSBpbnNldC0wIGJnLVsjMDAwMDAwNjZdIGgtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCByb3VuZGVkLWxnXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVDb250YWluZXI6IFwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgbWF4LWgtW2NhbGMoMTAwJS02NHB4KV0gb3ZlcmZsb3cteS1hdXRvIHNoYWRvdy1bMF8xMHB4XzE1cHhfLTNweF9yZ2JhKDAsMCwwLDAuMDcpLDBfNHB4XzZweF8tMnB4X3JnYmEoMCwwLDAsMC4wNSldXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVFbGVtZW50czogXCJmbGV4IGZsZXgtY29sIG1pbi1oLVthdXRvXSBtaW4tdy1bMzEwcHhdIGJnLXdoaXRlIHJvdW5kZWQtWzAuNnJlbV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFmbGV4LXJvdyBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC1ibC1sZyBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLXctW2F1dG9dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTo6bWluLWgtW2F1dG9dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpvdmVyZmxvdy15LWF1dG8ganVzdGlmeS1hcm91bmRcIixcbiAgdGltZXBpY2tlcklubGluZUhlYWQ6IFwiYmctWyMzYjcxY2FdIGRhcms6YmctemluYy03MDAgaC1bMTAwcHhdIHJvdW5kZWQtdC1sZyBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC10ci1ub25lIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLWJsLW5vbmUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnAtWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpwci1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmgtYXV0byBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLWgtWzMwNXB4XSBmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBwLTAgcm91bmRlZC1iLWxnXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIZWFkQ29udGVudDogXCJtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6ZmxleC1jb2wgZmxleCB3LWZ1bGwganVzdGlmeS1ldmVubHkgaXRlbXMtY2VudGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIb3VyV3JhcHBlcjogXCJyZWxhdGl2ZSBoLWZ1bGwgIW9wYWNpdHktMTAwXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50TWludXRlV3JhcHBlcjogXCJyZWxhdGl2ZSBoLWZ1bGxcIixcbiAgdGltZXBpY2tlcklubGluZUljb25VcDogXCJhYnNvbHV0ZSBmaWxsLXdoaXRlIC10b3AtWzM1cHhdIG9wYWNpdHktMCBob3ZlcjpvcGFjaXR5LTEwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1bZWFzZV0gY3Vyc29yLXBvaW50ZXIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIGxlZnQtMS8yIHctWzMwcHhdIGgtWzMwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnOiBcImgtNCB3LTRcIixcbiAgdGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b246IFwiZm9udC1saWdodCBsZWFkaW5nLVsxLjJdIHRyYWNraW5nLVstMC4wMDgzM2VtXSB0ZXh0LXdoaXRlIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC01eGwgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsICFvcGFjaXR5LTEwMCBjdXJzb3ItcG9pbnRlciBmb2N1czpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6b3V0bGluZS1ub25lIHRleHQtWzIuNXJlbV0gaG92ZXI6YmctW3Vuc2V0XVwiLFxuICB0aW1lcGlja2VySW5saW5lSWNvbkRvd246IFwiYWJzb2x1dGUgZmlsbC13aGl0ZSAtYm90dG9tLVs0N3B4XSBvcGFjaXR5LTAgaG92ZXI6b3BhY2l0eS0xMDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtW2Vhc2VdIGN1cnNvci1wb2ludGVyIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiBsZWZ0LTEvMiB3LVszMHB4XSBoLVszMHB4XSBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlclwiLFxuICB0aW1lcGlja2VySW5saW5lRG90OiBcImZvbnQtbGlnaHQgbGVhZGluZy1bMS4yXSB0cmFja2luZy1bLTAuMDA4MzNlbV0gb3BhY2l0eS1bLjU0XSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBwLTAgdGV4dC13aGl0ZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC1bM3JlbV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsIHRleHQtWzIuNXJlbV1cIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVXcmFwcGVyOiBcImZsZXgganVzdGlmeS1jZW50ZXIgdGV4dC1bMThweF0gdGV4dC1bI2ZmZmZmZjhhXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWp1c3RpZnktYXJvdW5kIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohZmxleC1yb3dcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVBbTogXCJob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lIHAtMCBiZy10cmFuc3BhcmVudCBib3JkZXItbm9uZSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gY3Vyc29yLXBvaW50ZXIgbXItMiBtbC02XCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlUG06IFwiaG92ZXI6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGZvY3VzOm91dGxpbmUtbm9uZSBwLTAgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGN1cnNvci1wb2ludGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVTdWJtaXRCdXR0b246IFwiaG92ZXI6YmctWyMwMDAwMDAxNF0gZm9jdXM6YmctWyMwMDAwMDAxNF0gZm9jdXM6b3V0bGluZS1ub25lIHRleHQtWzAuOHJlbV0gYm94LWJvcmRlciBmb250LW1lZGl1bSBsZWFkaW5nLVs0MHB4XSB0cmFja2luZy1bLjFyZW1dIHVwcGVyY2FzZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBbdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yXzI1MG1zX2N1YmljLWJlemllcigwLjQsMCwwLjIsMSlfMG1zLGJveC1zaGFkb3dfMjUwbXNfY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV8wbXMsYm9yZGVyXzI1MG1zX2N1YmljLWJlemllcigwLjQsMCwwLjIsMSlfMG1zXSBvdXRsaW5lLW5vbmUgcm91bmRlZC1bMTAwJV0gaC1bNDhweF0gbWluLXctWzQ4cHhdIGlubGluZS1ibG9jayBtbC1bMzBweF0gdGV4dC13aGl0ZSBweS0xIHB4LTIgbWItMFwiLFxuICB0aW1lcGlja2VyVG9nZ2xlQnV0dG9uOiBcImgtNCB3LTQgbWwtYXV0byBhYnNvbHV0ZSBvdXRsaW5lLW5vbmUgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcmlnaHQtMS41IHRvcC0xLzIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxKV0gY3Vyc29yLXBvaW50ZXIgaG92ZXI6dGV4dC1bIzNiNzFjYV0gZm9jdXM6dGV4dC1bIzNiNzFjYV0gZGFyazpob3Zlcjp0ZXh0LVsjM2I3MWNhXSBkYXJrOmZvY3VzOnRleHQtWyMzYjcxY2FdIGRhcms6dGV4dC13aGl0ZVwiXG59LCBtXyA9IHtcbiAgdGlwczogXCJzdHJpbmdcIixcbiAgdGlwc0FjdGl2ZTogXCJzdHJpbmdcIixcbiAgdGlwc0Rpc2FibGVkOiBcInN0cmluZ1wiLFxuICB0cmFuc2Zvcm06IFwic3RyaW5nXCIsXG4gIG1vZGFsOiBcInN0cmluZ1wiLFxuICBjbG9ja0FuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgb3BhY2l0eTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJFbGVtZW50czogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckhlYWQ6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJIZWFkQ29udGVudDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ3VycmVudEJ1dHRvbldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50QnV0dG9uOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyRG90OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyTW9kZVdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJNb2RlQW06IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJNb2RlUG06IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDbG9ja1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDbG9jazogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1pZGRsZURvdDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckhhbmRQb2ludGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyUG9pbnRlckNpcmNsZTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNsb2NrSW5uZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyRm9vdGVyQnV0dG9uOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUVsZW1lbnRzOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSGVhZDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUhlYWRDb250ZW50OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSG91cldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50TWludXRlV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUljb25VcDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUljb25Tdmc6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVDdXJyZW50QnV0dG9uOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSWNvbkRvd246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVEb3Q6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVBbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVQbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZVN1Ym1pdEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlclRvZ2dsZUJ1dHRvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIHFnIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgVHQodGhpcywgXCJfdG9nZ2xlQW1QbVwiLCAodCkgPT4ge1xuICAgICAgdCA9PT0gXCJQTVwiID8gKHRoaXMuX2lzUG1FbmFibGVkID0gITAsIHRoaXMuX2lzQW1FbmFibGVkID0gITEpIDogdCA9PT0gXCJBTVwiICYmICh0aGlzLl9pc1BtRW5hYmxlZCA9ICExLCB0aGlzLl9pc0FtRW5hYmxlZCA9ICEwKTtcbiAgICB9KTtcbiAgICBUdCh0aGlzLCBcIl90b2dnbGVCYWNrZ3JvdW5kQ29sb3JDaXJjbGVcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0aGlzLl9tb2RhbC5xdWVyeVNlbGVjdG9yKGAke3R9WyR7Qn1dYCkgIT09IG51bGwpIHtcbiAgICAgICAgcC5hZGRTdHlsZSh0aGlzLl9jaXJjbGUsIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzE5NzZkMlwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgVHQodGhpcywgXCJfdG9nZ2xlQ2xhc3NBY3RpdmVcIiwgKHQsIHsgdGV4dENvbnRlbnQ6IGUgfSwgaSkgPT4ge1xuICAgICAgY29uc3QgbiA9IFsuLi50XS5maW5kKFxuICAgICAgICAobykgPT4gTnVtYmVyKG8pID09PSBOdW1iZXIoZSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gaS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIGlmICghby5oYXNBdHRyaWJ1dGUoQnQpKSB7XG4gICAgICAgICAgaWYgKG8udGV4dENvbnRlbnQgPT09IG4pIHtcbiAgICAgICAgICAgIHAuYWRkQ2xhc3MobywgdGhpcy5fY2xhc3Nlcy50aXBzQWN0aXZlKSwgby5zZXRBdHRyaWJ1dGUoQiwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHAucmVtb3ZlQ2xhc3MobywgdGhpcy5fY2xhc3Nlcy50aXBzQWN0aXZlKSwgby5yZW1vdmVBdHRyaWJ1dGUoQik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFR0KHRoaXMsIFwiX21ha2VNaW51dGVzRGVncmVlc1wiLCAodCwgZSkgPT4ge1xuICAgICAgY29uc3QgeyBpbmNyZW1lbnQ6IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICByZXR1cm4gdCA8IDAgPyAoZSA9IE1hdGgucm91bmQoMzYwICsgdCAvIDYpICUgNjAsIHQgPSAzNjAgKyBNYXRoLnJvdW5kKHQgLyA2KSAqIDYpIDogKGUgPSBNYXRoLnJvdW5kKHQgLyA2KSAlIDYwLCB0ID0gTWF0aC5yb3VuZCh0IC8gNikgKiA2KSwgaSAmJiAodCA9IE1hdGgucm91bmQodCAvIDMwKSAqIDMwLCBlID0gTWF0aC5yb3VuZCh0IC8gNikgKiA2IC8gNiwgZSA9PT0gNjAgJiYgKGUgPSBcIjAwXCIpKSwgdCA+PSAzNjAgJiYgKHQgPSAwKSwge1xuICAgICAgICBkZWdyZWVzOiB0LFxuICAgICAgICBtaW51dGU6IGUsXG4gICAgICAgIGFkZERlZ3JlZXM6IGkgPyAzMCA6IDZcbiAgICAgIH07XG4gICAgfSk7XG4gICAgVHQodGhpcywgXCJfbWFrZUhvdXJEZWdyZWVzXCIsICh0LCBlLCBpKSA9PiB7XG4gICAgICBpZiAodClcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1RhcmdldElubmVyQ2xhc3ModCkgPyBlIDwgMCA/IChpID0gTWF0aC5yb3VuZCgzNjAgKyBlIC8gMzApICUgMjQsIGUgPSAzNjAgKyBlKSA6IChpID0gTWF0aC5yb3VuZChlIC8gMzApICsgMTIsIGkgPT09IDEyICYmIChpID0gXCIwMFwiKSkgOiBlIDwgMCA/IChpID0gTWF0aC5yb3VuZCgzNjAgKyBlIC8gMzApICUgMTIsIGUgPSAzNjAgKyBlKSA6IChpID0gTWF0aC5yb3VuZChlIC8gMzApICUgMTIsIChpID09PSAwIHx8IGkgPiAxMikgJiYgKGkgPSAxMikpLCBlID49IDM2MCAmJiAoZSA9IDApLCB7XG4gICAgICAgICAgZGVncmVlczogZSxcbiAgICAgICAgICBob3VyOiBpLFxuICAgICAgICAgIGFkZERlZ3JlZXM6IDMwXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgVHQodGhpcywgXCJfbWFrZUlubmVySG91cnNEZWdyZWVzXCIsICh0LCBlKSA9PiAodCA8IDAgPyAoZSA9IE1hdGgucm91bmQoMzYwICsgdCAvIDMwKSAlIDI0LCB0ID0gMzYwICsgdCkgOiAoZSA9IE1hdGgucm91bmQodCAvIDMwKSArIDEyLCBlID09PSAxMiAmJiAoZSA9IFwiMDBcIikpLCB7XG4gICAgICBkZWdyZWVzOiB0LFxuICAgICAgaG91cjogZSxcbiAgICAgIGFkZERlZ3JlZXM6IDMwXG4gICAgfSkpO1xuICAgIFR0KHRoaXMsIFwiX2dldEFwcGVuZENsb2NrXCIsICh0ID0gW10sIGUgPSBgWyR7bGV9XWAsIGkpID0+IHtcbiAgICAgIGxldCB7IG1pblRpbWU6IG4sIG1heFRpbWU6IG8gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBjb25zdCB7IGlubGluZTogciwgZm9ybWF0MTI6IGEsIGRpc2FibGVQYXN0OiBsLCBkaXNhYmxlRnV0dXJlOiBjIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgbiA9IGp0KG4sIGwsIGEpLCBvID0gS3QobywgYywgYSk7XG4gICAgICBjb25zdCBbZCwgXywgZl0gPSBSKFxuICAgICAgICBvLFxuICAgICAgICAhMVxuICAgICAgKSwgW20sIGcsIGJdID0gUihcbiAgICAgICAgbixcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgICAhciAmJiBhICYmIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgJiYgIXRoaXMuX0FNLmhhc0F0dHJpYnV0ZShCKSAmJiAocC5hZGRDbGFzcyh0aGlzLl9QTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fUE0uc2V0QXR0cmlidXRlKEIsIFwiXCIpKTtcbiAgICAgIGNvbnN0IFQgPSBoLmZpbmRPbmUoZSksIEMgPSAzNjAgLyB0Lmxlbmd0aDtcbiAgICAgIGZ1bmN0aW9uIHcoeSkge1xuICAgICAgICByZXR1cm4geSAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICAgIH1cbiAgICAgIGlmIChUID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB2ID0gKFQub2Zmc2V0V2lkdGggLSAzMikgLyAyLCBFID0gKFQub2Zmc2V0SGVpZ2h0IC0gMzIpIC8gMiwgQSA9IHYgLSA0O1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBhICYmICh5ID0gaC5maW5kT25lKFxuICAgICAgICAgIGAke1VpfVske0J9XWBcbiAgICAgICAgKS50ZXh0Q29udGVudCksIHRoaXMuX2hhbmRsZURpc2FibGluZ1RpcHNNaW5UaW1lKFxuICAgICAgICAgIHksXG4gICAgICAgICAgYixcbiAgICAgICAgICBnLFxuICAgICAgICAgIG1cbiAgICAgICAgKSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01heFRpbWUoXG4gICAgICAgICAgeSxcbiAgICAgICAgICBmLFxuICAgICAgICAgIF8sXG4gICAgICAgICAgZFxuICAgICAgICApO1xuICAgICAgfSwgMCksIFsuLi50XS5mb3JFYWNoKCh5LCBTKSA9PiB7XG4gICAgICAgIGNvbnN0IE8gPSB3KFMgKiBDKSwgayA9IE0oXCJzcGFuXCIpLCBEID0gTShcInNwYW5cIik7XG4gICAgICAgIEQuaW5uZXJIVE1MID0geSwgcC5hZGRDbGFzcyhrLCB0aGlzLl9jbGFzc2VzLnRpcHMpLCBrLnNldEF0dHJpYnV0ZShpLCBcIlwiKTtcbiAgICAgICAgY29uc3QgeCA9IGsub2Zmc2V0V2lkdGgsICQgPSBrLm9mZnNldEhlaWdodDtcbiAgICAgICAgcmV0dXJuIHAuYWRkU3R5bGUoaywge1xuICAgICAgICAgIGxlZnQ6IGAke3YgKyBNYXRoLnNpbihPKSAqIEEgLSB4fXB4YCxcbiAgICAgICAgICBib3R0b206IGAke0UgKyBNYXRoLmNvcyhPKSAqIEEgLSAkfXB4YFxuICAgICAgICB9KSwgdC5pbmNsdWRlcyhcIjA1XCIpICYmIGsuc2V0QXR0cmlidXRlKFgsIFwiXCIpLCB0LmluY2x1ZGVzKFwiMTNcIikgPyBELnNldEF0dHJpYnV0ZShHaSwgXCJcIikgOiBELnNldEF0dHJpYnV0ZShYaSwgXCJcIiksIGsuYXBwZW5kQ2hpbGQoRCksIFQuYXBwZW5kQ2hpbGQoayk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZWxlbWVudCAmJiBJLnNldERhdGEodCwgX3MsIHRoaXMpLCB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fY3VycmVudFRpbWUgPSBudWxsLCB0aGlzLl90b2dnbGVCdXR0b25JZCA9IE90KFwidGltZXBpY2tlci10b2dnbGUtXCIpLCB0aGlzLmhvdXJzQXJyYXkgPSBbXG4gICAgICBcIjEyXCIsXG4gICAgICBcIjFcIixcbiAgICAgIFwiMlwiLFxuICAgICAgXCIzXCIsXG4gICAgICBcIjRcIixcbiAgICAgIFwiNVwiLFxuICAgICAgXCI2XCIsXG4gICAgICBcIjdcIixcbiAgICAgIFwiOFwiLFxuICAgICAgXCI5XCIsXG4gICAgICBcIjEwXCIsXG4gICAgICBcIjExXCJcbiAgICBdLCB0aGlzLmlubmVySG91cnMgPSBbXG4gICAgICBcIjAwXCIsXG4gICAgICBcIjEzXCIsXG4gICAgICBcIjE0XCIsXG4gICAgICBcIjE1XCIsXG4gICAgICBcIjE2XCIsXG4gICAgICBcIjE3XCIsXG4gICAgICBcIjE4XCIsXG4gICAgICBcIjE5XCIsXG4gICAgICBcIjIwXCIsXG4gICAgICBcIjIxXCIsXG4gICAgICBcIjIyXCIsXG4gICAgICBcIjIzXCJcbiAgICBdLCB0aGlzLm1pbnV0ZXNBcnJheSA9IFtcbiAgICAgIFwiMDBcIixcbiAgICAgIFwiMDVcIixcbiAgICAgIFwiMTBcIixcbiAgICAgIFwiMTVcIixcbiAgICAgIFwiMjBcIixcbiAgICAgIFwiMjVcIixcbiAgICAgIFwiMzBcIixcbiAgICAgIFwiMzVcIixcbiAgICAgIFwiNDBcIixcbiAgICAgIFwiNDVcIixcbiAgICAgIFwiNTBcIixcbiAgICAgIFwiNTVcIlxuICAgIF0sIHRoaXMuaW5wdXQgPSBoLmZpbmRPbmUoXCJpbnB1dFwiLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5kYXRhV2l0aEljb24gPSB0LmRhdGFzZXQud2l0aEljb24sIHRoaXMuZGF0YVRvZ2dsZSA9IHQuZGF0YXNldC50b2dnbGUsIHRoaXMuY3VzdG9tSWNvbiA9IGguZmluZE9uZShcbiAgICAgIG9fLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX2NoZWNrVG9nZ2xlQnV0dG9uKCksIHRoaXMuaW5wdXRGb3JtYXRTaG93ID0gaC5maW5kT25lKFxuICAgICAgbl8sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5pbnB1dEZvcm1hdCA9IHRoaXMuaW5wdXRGb3JtYXRTaG93ID09PSBudWxsID8gXCJcIiA6IE9iamVjdC52YWx1ZXModGhpcy5pbnB1dEZvcm1hdFNob3cuZGF0YXNldClbMF0sIHRoaXMuZWxlbWVudFRvZ2dsZSA9IGguZmluZE9uZShcbiAgICAgIFNyLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMudG9nZ2xlRWxlbWVudCA9IE9iamVjdC52YWx1ZXMoXG4gICAgICB0LnF1ZXJ5U2VsZWN0b3IoU3IpLmRhdGFzZXRcbiAgICApWzBdLCB0aGlzLl9ob3VyID0gbnVsbCwgdGhpcy5fbWludXRlcyA9IG51bGwsIHRoaXMuX0FNID0gbnVsbCwgdGhpcy5fUE0gPSBudWxsLCB0aGlzLl93cmFwcGVyID0gbnVsbCwgdGhpcy5fbW9kYWwgPSBudWxsLCB0aGlzLl9oYW5kID0gbnVsbCwgdGhpcy5fY2lyY2xlID0gbnVsbCwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5faW50ZXJ2YWwgPSBudWxsLCB0aGlzLl9pbnB1dFZhbHVlID0gdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSAhPT0gXCJcIiA/IHRoaXMuX29wdGlvbnMuZGVmYXVsdFRpbWUgOiB0aGlzLmlucHV0LnZhbHVlLCB0aGlzLl9vcHRpb25zLmZvcm1hdDI0ICYmICh0aGlzLl9vcHRpb25zLmZvcm1hdDEyID0gITEsIHRoaXMuX2N1cnJlbnRUaW1lID0gd3IodGhpcy5faW5wdXRWYWx1ZSkpLCB0aGlzLl9vcHRpb25zLmZvcm1hdDEyICYmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0ID0gITEsIHRoaXMuX2N1cnJlbnRUaW1lID0gZmUodGhpcy5faW5wdXRWYWx1ZSkpLCB0aGlzLl9vcHRpb25zLnJlYWRPbmx5ICYmIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKGRfLCAhMCksIHRoaXMuaW5wdXRGb3JtYXQgPT09IFwidHJ1ZVwiICYmIHRoaXMuaW5wdXRGb3JtYXQgIT09IFwiXCIgJiYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgPSAhMSwgdGhpcy5fb3B0aW9ucy5mb3JtYXQyNCA9ICEwLCB0aGlzLl9jdXJyZW50VGltZSA9IHdyKHRoaXMuX2lucHV0VmFsdWUpKSwgdGhpcy5fYW5pbWF0aW9ucyA9ICF3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpLm1hdGNoZXMgJiYgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25zLCB0aGlzLmluaXQoKSwgdGhpcy5faXNIb3VycyA9ICEwLCB0aGlzLl9pc01pbnV0ZXMgPSAhMSwgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICExLCB0aGlzLl9pc01vdXNlTW92ZSA9ICExLCB0aGlzLl9pc0lubmVyID0gITEsIHRoaXMuX2lzQW1FbmFibGVkID0gITEsIHRoaXMuX2lzUG1FbmFibGVkID0gITEsIHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgJiYgIXRoaXMuX29wdGlvbnMuZGVmYXVsdFRpbWUgJiYgKHRoaXMuX2lzUG1FbmFibGVkID0gITApLCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlID0geyBkZWdyZWVzOiBudWxsIH0sIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBwaSgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBoaTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICBjb25zdCB7IGZvcm1hdDEyOiB0LCBmb3JtYXQyNDogZSwgZW5hYmxlVmFsaWRhdGlvbjogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBsZXQgbiwgbywgcjtcbiAgICBpZiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoaF8sIFwiXCIpLCB0aGlzLl9jdXJyZW50VGltZSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCB7IGhvdXJzOiBhLCBtaW51dGVzOiBsLCBhbU9yUG06IGMgfSA9IHRoaXMuX2N1cnJlbnRUaW1lO1xuICAgICAgbiA9IE51bWJlcihhKSA8IDEwID8gMCA6IFwiXCIsIG8gPSBgJHtufSR7TnVtYmVyKGEpfToke2x9YCwgciA9IGMsIHQgPyB0aGlzLmlucHV0LnZhbHVlID0gYCR7b30gJHtyfWAgOiBlICYmICh0aGlzLmlucHV0LnZhbHVlID0gYCR7b31gKTtcbiAgICB9IGVsc2VcbiAgICAgIG4gPSBcIlwiLCBvID0gXCJcIiwgciA9IFwiXCIsIHRoaXMuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgIHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoID4gMCAmJiB0aGlzLmlucHV0LnZhbHVlICE9PSBcIlwiICYmICh0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShCLCBcIlwiKSwgdS50cmlnZ2VyKHRoaXMuaW5wdXQsIFwiaW5wdXRcIikpLCAhKHRoaXMuX29wdGlvbnMgPT09IG51bGwgJiYgdGhpcy5fZWxlbWVudCA9PT0gbnVsbCkgJiYgKGkgJiYgdGhpcy5fZ2V0VmFsaWRhdGUoXCJrZXlkb3duIGNoYW5nZSBibHVyIGZvY3VzXCIpLCB0aGlzLl9oYW5kbGVPcGVuKCksIHRoaXMuX2xpc3RlblRvVG9nZ2xlS2V5ZG93bigpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3JlbW92ZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQgIT09IG51bGwgJiYgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIF9zKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuaW5wdXQgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsO1xuICAgIH0sIDM1MCksIHUub2ZmKFxuICAgICAgdGhpcy5fZG9jdW1lbnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWBcbiAgICApLCB1Lm9mZihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIGBbZGF0YS10ZS10b2dnbGU9JyR7dGhpcy50b2dnbGVFbGVtZW50fSddYFxuICAgICk7XG4gIH1cbiAgdXBkYXRlKHQgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoeyAuLi50aGlzLl9vcHRpb25zLCAuLi50IH0pO1xuICB9XG4gIC8vIHByaXZhdGVcbiAgX2NoZWNrVG9nZ2xlQnV0dG9uKCkge1xuICAgIHRoaXMuY3VzdG9tSWNvbiA9PT0gbnVsbCAmJiAodGhpcy5kYXRhV2l0aEljb24gIT09IHZvaWQgMCAmJiAodGhpcy5fb3B0aW9ucy53aXRoSWNvbiA9IG51bGwsIHRoaXMuZGF0YVdpdGhJY29uID09PSBcInRydWVcIiAmJiB0aGlzLl9hcHBlbmRUb2dnbGVCdXR0b24odGhpcy5fb3B0aW9ucykpLCB0aGlzLl9vcHRpb25zLndpdGhJY29uICYmIHRoaXMuX2FwcGVuZFRvZ2dsZUJ1dHRvbih0aGlzLl9vcHRpb25zKSk7XG4gIH1cbiAgX2FwcGVuZFRvZ2dsZUJ1dHRvbigpIHtcbiAgICBjb25zdCB0ID0gcWYoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fdG9nZ2xlQnV0dG9uSWQsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLmlucHV0Lmluc2VydEFkamFjZW50SFRNTChcImFmdGVyZW5kXCIsIHQpO1xuICB9XG4gIF9nZXREb21FbGVtZW50cygpIHtcbiAgICB0aGlzLl9ob3VyID0gaC5maW5kT25lKGBbJHt6aX1dYCksIHRoaXMuX21pbnV0ZXMgPSBoLmZpbmRPbmUoYFske0VufV1gKSwgdGhpcy5fQU0gPSBoLmZpbmRPbmUoaV8pLCB0aGlzLl9QTSA9IGguZmluZE9uZShzXyksIHRoaXMuX3dyYXBwZXIgPSBoLmZpbmRPbmUoYFske3ZufV1gKSwgdGhpcy5fbW9kYWwgPSBoLmZpbmRPbmUoYFske2pyfV1gKSwgdGhpcy5faGFuZCA9IGguZmluZE9uZShgWyR7VG59XWApLCB0aGlzLl9jaXJjbGUgPSBoLmZpbmRPbmUoYFske0NufV1gKSwgdGhpcy5fY2xvY2sgPSBoLmZpbmRPbmUoYFske2xlfV1gKSwgdGhpcy5fY2xvY2tJbm5lciA9IGguZmluZE9uZShcbiAgICAgIGBbJHtKZX1dYFxuICAgICk7XG4gIH1cbiAgX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnModCwgZSwgaSwgbiwgbywgcikge1xuICAgIGlmICghZSAmJiAhaSlcbiAgICAgIHJldHVybiAhMDtcbiAgICBjb25zdCB7IGZvcm1hdDI0OiBhLCBmb3JtYXQxMjogbCwgZGlzYWJsZVBhc3Q6IGMsIGRpc2FibGVGdXR1cmU6IGQgfSA9IHRoaXMuX29wdGlvbnMsIHsgX2lzQW1FbmFibGVkOiBfLCBfaXNQbUVuYWJsZWQ6IGYgfSA9IHRoaXMsIG0gPSByLmtleUNvZGUsIGcgPSByLnRhcmdldC5oYXNBdHRyaWJ1dGUoSmUpIHx8IHIudGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdCkgfHwgci50YXJnZXQuaGFzQXR0cmlidXRlKEdpKTtcbiAgICBpID0ganQoaSwgYywgbCksIGUgPSBLdChlLCBkLCBsKSwgdHlwZW9mIGUgIT0gXCJudW1iZXJcIiAmJiAoZSA9IFIoZSwgITEpWzBdKTtcbiAgICBjb25zdCBiID0gZSAhPT0gXCJcIiA/IGUgKiAzMCA6IFwiXCIsIFQgPSBpICE9PSBcIlwiID8gaSAqIDMwIDogXCJcIjtcbiAgICB0IDwgMCAmJiAodCA9IDM2MCArIHQpLCB0ID0gdCA9PT0gMzYwID8gMCA6IHQ7XG4gICAgY29uc3QgQyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IFMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICBgWyR7WGl9XWBcbiAgICAgICksIE8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICBgWyR7R2l9XWBcbiAgICAgICksIGsgPSBlXyh0aGlzLl9ob3VyLmlubmVyVGV4dCk7XG4gICAgICBsZXQgRCwgeCwgJDtcbiAgICAgIHJldHVybiBtID09PSBydCA/IHggPSAxIDogbSA9PT0gVSAmJiAoeCA9IC0xKSwgayA9PT0gMTIgJiYgbSA9PT0gcnQgPyAkID0gMSA6IGsgPT09IDAgJiYgbSA9PT0gcnQgPyAkID0gMTMgOiBrID09PSAwICYmIG0gPT09IFUgPyAkID0gMjMgOiBrID09PSAxMyAmJiBtID09PSBVID8gJCA9IDAgOiBrID09PSAxICYmIG0gPT09IFUgPyAkID0gMTIgOiAkID0gayArIHgsIFMuZm9yRWFjaCgoUCkgPT4ge1xuICAgICAgICBOdW1iZXIoUC50ZXh0Q29udGVudCkgPT09ICQgJiYgKEQgPSBQKTtcbiAgICAgIH0pLCBPLmZvckVhY2goKFApID0+IHtcbiAgICAgICAgTnVtYmVyKFAudGV4dENvbnRlbnQpID09PSAkICYmIChEID0gUCk7XG4gICAgICB9KSwgIUQucGFyZW50RWxlbWVudC5oYXNBdHRyaWJ1dGUoQnQpO1xuICAgIH0sIHcgPSAoKSA9PiB7XG4gICAgICBjb25zdCBTID0gaSAhPT0gXCJcIiAmJiBpID4gMTIgPyAoaSAtIDEyKSAqIDMwIDogXCJcIiwgTyA9IGUgIT09IFwiXCIgJiYgZSA+IDEyID8gKGUgLSAxMikgKiAzMCA6IFwiXCI7XG4gICAgICBpZiAoIShTICYmIHQgPCBTIHx8IE8gJiYgdCA+IE8gfHwgZSAmJiBlIDwgMTIpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgfTtcbiAgICBpZiAoYSAmJiByLnR5cGUgIT09IFwia2V5ZG93blwiICYmIGcpXG4gICAgICByZXR1cm4gdygpO1xuICAgIGlmIChyLnR5cGUgPT09IFwia2V5ZG93blwiKVxuICAgICAgcmV0dXJuIEMoKTtcbiAgICBjb25zdCB2ID0gIW8gfHwgbyA9PT0gXCJQTVwiICYmIGYgfHwgaSAhPT0gXCJcIiAmJiBvID09PSBcIkFNXCIgJiYgXywgRSA9ICFuIHx8IG4gPT09IFwiUE1cIiAmJiBmIHx8IGUgIT09IFwiXCIgJiYgbiA9PT0gXCJBTVwiICYmIF8sIEEgPSAoKSA9PiB7XG4gICAgICBjb25zdCBTID0gVCA9PT0gMzYwICYmIGwgPyAwIDogVDtcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIGlmIChvID09PSBcIlBNXCIgJiYgXyB8fCB2ICYmIHQgPCBTKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgeSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IFMgPSBiID09PSAzNjAgJiYgbCA/IDAgOiBiO1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgaWYgKG4gPT09IFwiQU1cIiAmJiBmIHx8IEUgJiYgdCA+IFMpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9O1xuICAgIHJldHVybiBBKCkgJiYgeSgpO1xuICB9XG4gIF9oYW5kbGVLZXlib2FyZCgpIHtcbiAgICB1Lm9uKHRoaXMuX2RvY3VtZW50LCBqaSwgXCJcIiwgKHQpID0+IHtcbiAgICAgIGxldCBlLCBpLCBuO1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbmNyZW1lbnQ6IG8sXG4gICAgICAgIG1heFRpbWU6IHIsXG4gICAgICAgIG1pblRpbWU6IGEsXG4gICAgICAgIGZvcm1hdDEyOiBsLFxuICAgICAgICBkaXNhYmxlUGFzdDogYyxcbiAgICAgICAgZGlzYWJsZUZ1dHVyZTogZFxuICAgICAgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBsZXQgXyA9IFIoYSwgITEpWzBdLCBmID0gUihyLCAhMSlbMF07XG4gICAgICBjb25zdCBtID0gUihhLCAhMSlbMl0sIGcgPSBSKHIsICExKVsyXTtcbiAgICAgIF8gPSBqdChfLCBjLCBsKSwgZiA9IEt0KGYsIGQsIGwpLCB0eXBlb2YgZiAhPSBcIm51bWJlclwiICYmIChmID0gUihmLCAhMSlbMF0pO1xuICAgICAgY29uc3QgYiA9IGguZmluZE9uZShgWyR7WH1dYCkgPT09IG51bGwsIFQgPSBoLmZpbmRPbmUoYFske2F0fV1gKSAhPT0gbnVsbCwgQyA9IE51bWJlcih0aGlzLl9oYW5kLnN0eWxlLnRyYW5zZm9ybS5yZXBsYWNlKC9bXlxcZC1dL2csIFwiXCIpKSwgdyA9IGguZmluZChcbiAgICAgICAgYFske1h9XWAsXG4gICAgICAgIHRoaXMuX21vZGFsXG4gICAgICApLCB2ID0gaC5maW5kKFxuICAgICAgICBgWyR7S31dYCxcbiAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICksIEUgPSBoLmZpbmQoXG4gICAgICAgIGBbJHthdH1dYCxcbiAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICk7XG4gICAgICBsZXQgQSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyh0LnRhcmdldCwgQywgZSkuaG91cjtcbiAgICAgIGNvbnN0IHsgZGVncmVlczogeSwgYWRkRGVncmVlczogUyB9ID0gdGhpcy5fbWFrZUhvdXJEZWdyZWVzKFxuICAgICAgICB0LnRhcmdldCxcbiAgICAgICAgQyxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICAgIGxldCB7IG1pbnV0ZTogTywgZGVncmVlczogayB9ID0gdGhpcy5fbWFrZU1pbnV0ZXNEZWdyZWVzKEMsIGkpO1xuICAgICAgY29uc3QgRCA9IHRoaXMuX21ha2VNaW51dGVzRGVncmVlcyhcbiAgICAgICAgQyxcbiAgICAgICAgaVxuICAgICAgKS5hZGREZWdyZWVzO1xuICAgICAgbGV0IHsgaG91cjogeCB9ID0gdGhpcy5fbWFrZUlubmVySG91cnNEZWdyZWVzKFxuICAgICAgICBDLFxuICAgICAgICBuXG4gICAgICApO1xuICAgICAgaWYgKHQua2V5Q29kZSA9PT0gSXMpIHtcbiAgICAgICAgY29uc3QgJCA9IGguZmluZE9uZShcbiAgICAgICAgICBgWyR7Zm59XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKTtcbiAgICAgICAgdS50cmlnZ2VyKCQsIFwiY2xpY2tcIik7XG4gICAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgICAgaWYgKFQgJiYgKHQua2V5Q29kZSA9PT0gJGUgJiYgKHRoaXMuX2lzSW5uZXIgPSAhMSwgcC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgICAgIH0pLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgIEEgPiAxMiA/IDEgOiBBXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgdiksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgRSkpLCB0LmtleUNvZGUgPT09IEllICYmICh0aGlzLl9pc0lubmVyID0gITAsIHAuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICAgIH0pLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgIHggPj0gMjQgfHwgeCA9PT0gXCIwMFwiID8gMCA6IHhcbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBFKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgdGhpcy5ob3Vyc0FycmF5LFxuICAgICAgICAgIHRoaXMuX2hvdXIgLSAxLFxuICAgICAgICAgIHZcbiAgICAgICAgKSkpLCB0LmtleUNvZGUgPT09IHJ0KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKFxuICAgICAgICAgICAgeSArIDMwLFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIF8sXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHRcbiAgICAgICAgICApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHAuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3kgKyBTfWRlZylgXG4gICAgICAgICAgfSksIHRoaXMuX2lzSW5uZXIgPyAoeCArPSAxLCB4ID09PSAyNCA/IHggPSAwIDogKHggPT09IDI1IHx8IHggPT09IFwiMDAxXCIpICYmICh4ID0gMTMpLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKHgpLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIEUpKSA6IChBICs9IDEsIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoXG4gICAgICAgICAgICBBID4gMTIgPyAxIDogQVxuICAgICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgdikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0LmtleUNvZGUgPT09IFUpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnMoXG4gICAgICAgICAgICB5IC0gMzAsXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgdFxuICAgICAgICAgICkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgcC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7eSAtIFN9ZGVnKWBcbiAgICAgICAgICB9KSwgdGhpcy5faXNJbm5lciA/ICh4IC09IDEsIHggPT09IDEyID8geCA9IDAgOiB4ID09PSAtMSAmJiAoeCA9IDIzKSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZSh4KSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBFKSkgOiAoQSAtPSAxLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgICAgQSA9PT0gMCA/IDEyIDogQVxuICAgICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgdikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgdC5rZXlDb2RlID09PSBydCAmJiAoayArPSBELCBwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7a31kZWcpYFxuICAgICAgICB9KSwgTyArPSAxLCBvICYmIChPICs9IDQsIE8gPT09IFwiMDAxNFwiICYmIChPID0gNSkpLCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgIE8gPiA1OSA/IDAgOiBPXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgIHRoaXMubWludXRlc0FycmF5LFxuICAgICAgICAgIHRoaXMuX21pbnV0ZXMsXG4gICAgICAgICAgd1xuICAgICAgICApLCB0aGlzLl90b2dnbGVCYWNrZ3JvdW5kQ29sb3JDaXJjbGUoXG4gICAgICAgICAgYFske1h9XWBcbiAgICAgICAgKSksIHQua2V5Q29kZSA9PT0gVSAmJiAoayAtPSBELCBwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7a31kZWcpYFxuICAgICAgICB9KSwgbyA/IE8gLT0gNSA6IE8gLT0gMSwgTyA9PT0gLTEgPyBPID0gNTkgOiBPID09PSAtNSAmJiAoTyA9IDU1KSwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShPKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgdGhpcy5taW51dGVzQXJyYXksXG4gICAgICAgICAgdGhpcy5fbWludXRlcyxcbiAgICAgICAgICB3XG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUJhY2tncm91bmRDb2xvckNpcmNsZShcbiAgICAgICAgICBgWyR7WH1dYFxuICAgICAgICApKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0QWN0aXZlQ2xhc3NUb1RpcHNPbk9wZW4odCwgLi4uZSkge1xuICAgIGlmICghdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdClcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0KSB7XG4gICAgICAgIGNvbnN0IGkgPSBoLmZpbmQoXG4gICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbiA9IGguZmluZChcbiAgICAgICAgICBgWyR7YXR9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChpLCB0KSwgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChuLCB0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFsuLi5lXS5maWx0ZXIoKG4pID0+IChuID09PSBcIlBNXCIgPyAocC5hZGRDbGFzcyh0aGlzLl9QTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fUE0uc2V0QXR0cmlidXRlKEIsIFwiXCIpKSA6IG4gPT09IFwiQU1cIiA/IChwLmFkZENsYXNzKHRoaXMuX0FNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9BTS5zZXRBdHRyaWJ1dGUoQiwgXCJcIikpIDogKHAucmVtb3ZlQ2xhc3ModGhpcy5fQU0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHAucmVtb3ZlQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX0FNLnJlbW92ZUF0dHJpYnV0ZShCKSwgdGhpcy5fUE0ucmVtb3ZlQXR0cmlidXRlKEIpKSwgbikpO1xuICAgICAgICBjb25zdCBpID0gaC5maW5kKFxuICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoaSwgdCk7XG4gICAgICB9XG4gIH1cbiAgX3NldFRpcHNBbmRUaW1lc0RlcGVuZE9uSW5wdXRWYWx1ZSh0LCBlKSB7XG4gICAgY29uc3QgeyBpbmxpbmU6IGksIGZvcm1hdDEyOiBuIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGlmICh0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0KVxuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IFwiMTJcIiwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IFwiMDBcIiwgaSB8fCBwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZVooMGRlZylcIlxuICAgICAgfSksIG4gJiYgKHAuYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShCLCBcIlwiKSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBvID0gdCA+IDEyID8gdCAqIDMwIC0gMzYwIDogdCAqIDMwO1xuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHQsIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBlLCBpIHx8IChwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke299ZGVnKWBcbiAgICAgIH0pLCBwLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzE5NzZkMlwiXG4gICAgICB9KSwgKE51bWJlcih0KSA+IDEyIHx8IHQgPT09IFwiMDBcIikgJiYgcC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKSB7XG4gICAgdS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIGBbZGF0YS10ZS10b2dnbGU9JyR7dGhpcy50b2dnbGVFbGVtZW50fSddYCxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQua2V5Q29kZSA9PT0gbHQgJiYgKHQucHJldmVudERlZmF1bHQoKSwgdS50cmlnZ2VyKHRoaXMuZWxlbWVudFRvZ2dsZSwgXCJjbGlja1wiKSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlT3BlbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgZWUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgYFtkYXRhLXRlLXRvZ2dsZT0nJHt0aGlzLnRvZ2dsZUVsZW1lbnR9J11gLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpID0gcC5nZXREYXRhQXR0cmlidXRlKHRoaXMuaW5wdXQsIFwidG9nZ2xlXCIpICE9PSBudWxsID8gMjAwIDogMDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcC5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgICAgICAgfSksIHRoaXMuZWxlbWVudFRvZ2dsZS5ibHVyKCk7XG4gICAgICAgICAgbGV0IG47XG4gICAgICAgICAgUih0aGlzLmlucHV0KVswXSA9PT0gXCJcIiA/IG4gPSBbXCIxMlwiLCBcIjAwXCIsIFwiUE1cIl0gOiBuID0gUih0aGlzLmlucHV0KTtcbiAgICAgICAgICBjb25zdCB7IG1vZGFsSUQ6IG8sIGlubGluZTogciwgZm9ybWF0MTI6IGEgfSA9IHRoaXMuX29wdGlvbnMsIFtsLCBjLCBkXSA9IG4sIF8gPSBNKFwiZGl2XCIpO1xuICAgICAgICAgIGlmICgoTnVtYmVyKGwpID4gMTIgfHwgbCA9PT0gXCIwMFwiKSAmJiAodGhpcy5faXNJbm5lciA9ICEwKSwgdGhpcy5pbnB1dC5ibHVyKCksIGUudGFyZ2V0LmJsdXIoKSwgXy5pbm5lckhUTUwgPSBHZih0aGlzLl9vcHRpb25zLCB0aGlzLl9jbGFzc2VzKSwgcC5hZGRDbGFzcyhfLCB0aGlzLl9jbGFzc2VzLm1vZGFsKSwgXy5zZXRBdHRyaWJ1dGUoanIsIFwiXCIpLCBfLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIF8uc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgXCItMVwiKSwgXy5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBvKSwgciA/ICh0aGlzLl9wb3BwZXIgPSBqZSh0aGlzLmlucHV0LCBfLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tLXN0YXJ0XCJcbiAgICAgICAgICB9KSwgdC5hcHBlbmRDaGlsZChfKSkgOiAodC5hcHBlbmRDaGlsZChfKSwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSksIHRoaXMuX2dldERvbUVsZW1lbnRzKCksIHRoaXMuX2FuaW1hdGlvbnMgPyB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbigpIDogcC5hZGRDbGFzcyh0aGlzLl93cmFwcGVyLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3BlbihsLCBjLCBkKSwgdGhpcy5fYXBwZW5kVGltZXMoKSwgdGhpcy5fc2V0QWN0aXZlQ2xhc3NUb1RpcHNPbk9wZW4obCwgYywgZCksIHRoaXMuX3NldFRpcHNBbmRUaW1lc0RlcGVuZE9uSW5wdXRWYWx1ZShsLCBjKSwgdGhpcy5pbnB1dC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IGguZmluZChcbiAgICAgICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYSAmJiAocC5hZGRDbGFzcyh0aGlzLl9QTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fUE0uc2V0QXR0cmlidXRlKEIsIFwiXCIpKSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IFwiMTJcIiwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IFwiMDBcIiwgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChcbiAgICAgICAgICAgICAgZixcbiAgICAgICAgICAgICAgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5faGFuZGxlU3dpdGNoVGltZU1vZGUoKSwgdGhpcy5faGFuZGxlT2tCdXR0b24oKSwgdGhpcy5faGFuZGxlQ2xvc2UoKSwgcilcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUhvdmVySW5saW5lQnRuKCksIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tJbmxpbmUoKSwgdGhpcy5faGFuZGxlSW5saW5lQ2xpY2tzKCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVTd2l0Y2hIb3VyTWludXRlKCksIHRoaXMuX2hhbmRsZUNsb2NrQ2xpY2soKSwgdGhpcy5faGFuZGxlS2V5Ym9hcmQoKTtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICBgJHtLaX1bJHtCfV1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcC5hZGRDbGFzcyhmLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCBwLmFkZFN0eWxlKHRoaXMuX2hvdXIsIHtcbiAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICAgICAgICAgIH0pLCBwLmFkZFN0eWxlKHRoaXMuX21pbnV0ZXMsIHtcbiAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IG5ldyBiaSh0aGlzLl93cmFwcGVyLCB7XG4gICAgICAgICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICAgICAgICBjb25kaXRpb246ICh7IGtleTogZiB9KSA9PiBmID09PSBcIlRhYlwiXG4gICAgICAgICAgfSksIHRoaXMuX2ZvY3VzVHJhcC50cmFwKCk7XG4gICAgICAgIH0sIGkpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUlubGluZUNsaWNrcygpIHtcbiAgICBsZXQgdCwgZTtcbiAgICBjb25zdCBpID0gKGYpID0+IHtcbiAgICAgIGxldCBtID0gZjtcbiAgICAgIHJldHVybiBtID4gNTkgPyBtID0gMCA6IG0gPCAwICYmIChtID0gNTkpLCBtO1xuICAgIH0sIG4gPSAoZikgPT4ge1xuICAgICAgbGV0IG0gPSBmO1xuICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgPyAobSA+IDI0ID8gbSA9IDEgOiBtIDwgMCAmJiAobSA9IDIzKSwgbSA+IDIzICYmIChtID0gMCkpIDogKG0gPiAxMiA/IG0gPSAxIDogbSA8IDEgJiYgKG0gPSAxMiksIG0gPiAxMiAmJiAobSA9IDEpKSwgbTtcbiAgICB9LCBvID0gKGYpID0+IHtcbiAgICAgIGNvbnN0IG0gPSBuKGYpO1xuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShtKTtcbiAgICB9LCByID0gKGYpID0+IHtcbiAgICAgIGNvbnN0IG0gPSBpKGYpO1xuICAgICAgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShtKTtcbiAgICB9LCBhID0gKCkgPT4ge1xuICAgICAgdCArPSAxLCBvKHQpO1xuICAgIH0sIGwgPSAoKSA9PiB7XG4gICAgICBlICs9IDEsIHIoZSk7XG4gICAgfSwgYyA9ICgpID0+IHtcbiAgICAgIHQgLT0gMSwgbyh0KTtcbiAgICB9LCBkID0gKCkgPT4ge1xuICAgICAgZSAtPSAxLCByKGUpO1xuICAgIH0sIF8gPSAoZikgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoZiwgMTAwKTtcbiAgICB9O1xuICAgIGVlLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrIG1vdXNlZG93biBtb3VzZXVwIHRvdWNoc3RhcnQgdG91Y2hlbmQgY29udGV4dG1lbnVcIixcbiAgICAgIGBbJHttbn1dLCBbJHtnbn1dYCxcbiAgICAgIChmKSA9PiB7XG4gICAgICAgIHQgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGUgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCk7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0OiBtLCB0eXBlOiBnIH0gPSBmLCBiID0gZyA9PT0gXCJtb3VzZWRvd25cIiB8fCBnID09PSBcInRvdWNoc3RhcnRcIjtcbiAgICAgICAgbS5jbG9zZXN0KGBbJHttbn1dYCkgPyBtLmNsb3Nlc3QoYFske21ufV1gKS5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShWcikgPyBiID8gXyhhKSA6IGcgPT09IFwibW91c2V1cFwiIHx8IGcgPT09IFwidG91Y2hlbmRcIiB8fCBnID09PSBcImNvbnRleHRtZW51XCIgPyBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSA6IGEoKSA6IGIgPyBfKGwpIDogZyA9PT0gXCJtb3VzZXVwXCIgfHwgZyA9PT0gXCJ0b3VjaGVuZFwiIHx8IGcgPT09IFwiY29udGV4dG1lbnVcIiA/IGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpIDogbCgpIDogbS5jbG9zZXN0KGBbJHtnbn1dYCkgJiYgKG0uY2xvc2VzdChgWyR7Z259XWApLnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKFZyKSA/IGIgPyBfKGMpIDogZyA9PT0gXCJtb3VzZXVwXCIgfHwgZyA9PT0gXCJ0b3VjaGVuZFwiID8gY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCkgOiBjKCkgOiBiID8gXyhkKSA6IGcgPT09IFwibW91c2V1cFwiIHx8IGcgPT09IFwidG91Y2hlbmRcIiA/IGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpIDogZCgpKTtcbiAgICAgIH1cbiAgICApLCB1Lm9uKHdpbmRvdywgamksIChmKSA9PiB7XG4gICAgICBjb25zdCBtID0gZi5jb2RlLCBnID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoemkpLCBiID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoXG4gICAgICAgIEVuXG4gICAgICApLCBUID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keTtcbiAgICAgIHN3aXRjaCAodCA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgZSA9IE51bWJlcih0aGlzLl9taW51dGVzLnRleHRDb250ZW50KSwgbSkge1xuICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICAgIGYucHJldmVudERlZmF1bHQoKSwgVCB8fCBnID8gKHRoaXMuX2hvdXIuZm9jdXMoKSwgYSgpKSA6IGIgJiYgbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgICAgZi5wcmV2ZW50RGVmYXVsdCgpLCBUIHx8IGcgPyAodGhpcy5faG91ci5mb2N1cygpLCBjKCkpIDogYiAmJiBkKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNsb3NlKCkge1xuICAgIHUub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGBbJHt2bn1dLCBbJHtmbn1dLCBbJHtCcn1dYCxcbiAgICAgICh7IHRhcmdldDogdCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY2xvc2VNb2RhbE9uQmFja2Ryb3BDbGljazogZSB9ID0gdGhpcy5fb3B0aW9ucywgaSA9ICgpID0+IHtcbiAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICBwLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgICB9KSwgdGhpcy5fYW5pbWF0aW9ucyAmJiB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbighMCksIHRoaXMuX3JlbW92ZU1vZGFsKCksIChuID0gdGhpcy5fZm9jdXNUcmFwKSA9PSBudWxsIHx8IG4uZGlzYWJsZSgpLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsLCB0aGlzLmVsZW1lbnRUb2dnbGUgPyB0aGlzLmVsZW1lbnRUb2dnbGUuZm9jdXMoKSA6IHRoaXMuaW5wdXQgJiYgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodC5oYXNBdHRyaWJ1dGUoQnIpKSB7XG4gICAgICAgICAgdGhpcy5fdG9nZ2xlQW1QbShcIlBNXCIpLCB0aGlzLmlucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoQik7XG4gICAgICAgICAgbGV0IG47XG4gICAgICAgICAgUih0aGlzLmlucHV0KVswXSA9PT0gXCJcIiA/IG4gPSBbXCIxMlwiLCBcIjAwXCIsIFwiUE1cIl0gOiBuID0gUih0aGlzLmlucHV0KTtcbiAgICAgICAgICBjb25zdCBbbywgciwgYV0gPSBuO1xuICAgICAgICAgIHRoaXMuX3NldFRpcHNBbmRUaW1lc0RlcGVuZE9uSW5wdXRWYWx1ZShcIjEyXCIsIFwiMDBcIiksIHRoaXMuX3NldEFjdGl2ZUNsYXNzVG9UaXBzT25PcGVuKG8sIHIsIGEpLCB0aGlzLl9ob3VyLmNsaWNrKCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICh0Lmhhc0F0dHJpYnV0ZShmbikgfHwgdC5oYXNBdHRyaWJ1dGUoX24pIHx8IHQuaGFzQXR0cmlidXRlKHZuKSAmJiBlKSAmJiBpKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBzaG93VmFsdWVJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC52YWx1ZTtcbiAgfVxuICBfaGFuZGxlT2tCdXR0b24oKSB7XG4gICAgZWUub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGBbJHtfbn1dYCxcbiAgICAgICgpID0+IHtcbiAgICAgICAgbGV0IHsgbWF4VGltZTogdCwgbWluVGltZTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvcm1hdDEyOiBpLFxuICAgICAgICAgIGZvcm1hdDI0OiBuLFxuICAgICAgICAgIHJlYWRPbmx5OiBvLFxuICAgICAgICAgIGZvY3VzSW5wdXRBZnRlckFwcHJvdmU6IHIsXG4gICAgICAgICAgZGlzYWJsZVBhc3Q6IGEsXG4gICAgICAgICAgZGlzYWJsZUZ1dHVyZTogbFxuICAgICAgICB9ID0gdGhpcy5fb3B0aW9ucywgYyA9IHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgYCR7VWl9WyR7Qn1dYFxuICAgICAgICApLCBkID0gYCR7dGhpcy5faG91ci50ZXh0Q29udGVudH06JHt0aGlzLl9taW51dGVzLnRleHRDb250ZW50fWAsIF8gPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGYgPSBfID09PSAxMiAmJiBpID8gMCA6IF8sIG0gPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCk7XG4gICAgICAgIGUgPSBqdChlLCBhLCBpKSwgdCA9IEt0KHQsIGwsIGkpO1xuICAgICAgICBsZXQgW2csIGIsIFRdID0gUihcbiAgICAgICAgICB0LFxuICAgICAgICAgICExXG4gICAgICAgICksIFtDLCB3LCB2XSA9IFIoXG4gICAgICAgICAgZSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgICBDID0gQyA9PT0gXCIxMlwiICYmIGkgPyBcIjAwXCIgOiBDLCBnID0gZyA9PT0gXCIxMlwiICYmIGkgPyBcIjAwXCIgOiBnO1xuICAgICAgICBjb25zdCBFID0gZiA8IE51bWJlcihDKSwgQSA9IGYgPiBOdW1iZXIoZyk7XG4gICAgICAgIGxldCB5ID0gITA7XG4gICAgICAgIGMgJiYgKHkgPSBUID09PSBjLnRleHRDb250ZW50KTtcbiAgICAgICAgbGV0IFMgPSAhMDtcbiAgICAgICAgYyAmJiAoUyA9IHYgPT09IGMudGV4dENvbnRlbnQpO1xuICAgICAgICBjb25zdCBPID0gbSA+IGIgJiYgZiA9PT0gTnVtYmVyKGcpLCBrID0gbSA8IHcgJiYgZiA9PT0gTnVtYmVyKEMpO1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoQiwgXCJcIiksIHAuYWRkU3R5bGUodGhpcy5lbGVtZW50VG9nZ2xlLCB7XG4gICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgfSksIHQgIT09IFwiXCIpIHtcbiAgICAgICAgICBpZiAoeSAmJiAoQSB8fCBPKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAoVCA9PT0gXCJBTVwiICYmIGMudGV4dENvbnRlbnQgPT09IFwiUE1cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlICE9PSBcIlwiICYmIChTICYmIChFIHx8IGspIHx8IHYgPT09IFwiUE1cIiAmJiBjLnRleHRDb250ZW50ID09PSBcIkFNXCIpIHx8IFpmKFxuICAgICAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICAgICAgdGhpcy5pbnB1dCxcbiAgICAgICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50XG4gICAgICAgICkgIT09IHZvaWQgMCAmJiAodGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCAmJiB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShibiksICFvICYmIHIgJiYgdGhpcy5pbnB1dC5mb2N1cygpLCBwLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgIH0pLCBuID8gdGhpcy5pbnB1dC52YWx1ZSA9IGQgOiBjID09PSBudWxsID8gdGhpcy5pbnB1dC52YWx1ZSA9IGAke2R9IFBNYCA6IHRoaXMuaW5wdXQudmFsdWUgPSBgJHtkfSAke2MudGV4dENvbnRlbnR9YCwgdGhpcy5fYW5pbWF0aW9ucyAmJiB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbighMCksIHRoaXMuX3JlbW92ZU1vZGFsKCksIHUudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0LnRlLnRpbWVwaWNrZXJcIiksIHUudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0XCIpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVIb3ZlcklubGluZUJ0bigpIHtcbiAgICBlZS5vbihcbiAgICAgIHRoaXMuX21vZGFsLFxuICAgICAgXCJtb3VzZW92ZXIgbW91c2VsZWF2ZVwiLFxuICAgICAgYFske2NffV1gLFxuICAgICAgKHsgdHlwZTogdCwgdGFyZ2V0OiBlIH0pID0+IHtcbiAgICAgICAgY29uc3QgaSA9IGguZmluZChcbiAgICAgICAgICBgWyR7YV99XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbiA9IGguZmluZChcbiAgICAgICAgICBgWyR7bF99XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbyA9IChsLCBjKSA9PiBsLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgcC5hZGRDbGFzcyhkLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCBkLnNldEF0dHJpYnV0ZShCLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcC5yZW1vdmVDbGFzcyhkLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCBkLnJlbW92ZUF0dHJpYnV0ZShCKTtcbiAgICAgICAgfSksIGEgPSBlLmhhc0F0dHJpYnV0ZSh6aSkgPyBpIDogbjtcbiAgICAgICAgbyhhLCB0ID09PSBcIm1vdXNlb3ZlclwiKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVEb2N1bWVudENsaWNrSW5saW5lKCkge1xuICAgIHUub24oZG9jdW1lbnQsIERyLCAoeyB0YXJnZXQ6IHQgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX21vZGFsICYmICF0aGlzLl9tb2RhbC5jb250YWlucyh0KSAmJiAhdC5oYXNBdHRyaWJ1dGUocl8pKSB7XG4gICAgICAgIGlmIChjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgcC5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIlxuICAgICAgICB9KSwgdGhpcy5fcmVtb3ZlTW9kYWwoKSwgIXRoaXMuX2FuaW1hdGlvbnMpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbighMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVN3aXRjaEhvdXJNaW51dGUoKSB7XG4gICAgUWYoXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBLaSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB1Lm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBLaSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBmb3JtYXQyNDogdCB9ID0gdGhpcy5fb3B0aW9ucywgZSA9IGguZmluZChcbiAgICAgICAgICBLaSxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBpID0gaC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIG4gPSBoLmZpbmQoXG4gICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbyA9IGguZmluZChcbiAgICAgICAgICBgWyR7YXR9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgciA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgYSA9IE51bWJlcih0aGlzLl9taW51dGVzLnRleHRDb250ZW50KSwgbCA9IChjLCBkKSA9PiB7XG4gICAgICAgICAgbi5mb3JFYWNoKChmKSA9PiBmLnJlbW92ZSgpKSwgaS5mb3JFYWNoKChmKSA9PiBmLnJlbW92ZSgpKSwgcC5hZGRDbGFzcyh0aGlzLl9oYW5kLCB0aGlzLl9jbGFzc2VzLnRyYW5zZm9ybSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcC5yZW1vdmVDbGFzcyh0aGlzLl9oYW5kLCB0aGlzLl9jbGFzc2VzLnRyYW5zZm9ybSk7XG4gICAgICAgICAgfSwgNDAxKSwgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soYywgYFske2xlfV1gLCBkKTtcbiAgICAgICAgICBjb25zdCBfID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZiA9IGguZmluZChcbiAgICAgICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApLCBtID0gaC5maW5kKFxuICAgICAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKGYsIHIpLCB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKG0sIGEpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKCF0KVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIF8oKTtcbiAgICAgICAgICAgIH0sIDQwMSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmID0gaC5maW5kKFxuICAgICAgICAgICAgICBgWyR7YXR9XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoZiwgciksIF8oKTtcbiAgICAgICAgICAgIH0sIDQwMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICBjLmhhc0F0dHJpYnV0ZShCKSAmJiAoYy5oYXNBdHRyaWJ1dGUoRW4pID8gKHAuYWRkQ2xhc3ModGhpcy5faGFuZCwgdGhpcy5fY2xhc3Nlcy50cmFuc2Zvcm0pLCBwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0aGlzLl9taW51dGVzLnRleHRDb250ZW50ICogNn1kZWcpYCxcbiAgICAgICAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgICAgICAgIH0pLCB0ICYmIG8ubGVuZ3RoID4gMCAmJiBvLmZvckVhY2goKGQpID0+IGQucmVtb3ZlKCkpLCBsKFxuICAgICAgICAgICAgdGhpcy5taW51dGVzQXJyYXksXG4gICAgICAgICAgICBYXG4gICAgICAgICAgKSwgdGhpcy5faG91ci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJcIiwgdGhpcy5fbWludXRlcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIpIDogYy5oYXNBdHRyaWJ1dGUoemkpICYmIChwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0aGlzLl9ob3VyLnRleHRDb250ZW50ICogMzB9ZGVnKWBcbiAgICAgICAgICB9KSwgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpID4gMTIgPyAocC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7dGhpcy5faG91ci50ZXh0Q29udGVudCAqIDMwIC0gMzYwfWRlZylgLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjIxLjUlXCJcbiAgICAgICAgICB9KSwgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpID4gMTIgJiYgcC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgICAgIH0pKSA6IHAuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgICAgICAgfSksIHQgJiYgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICAgICAgICB0aGlzLmlubmVySG91cnMsXG4gICAgICAgICAgICBgWyR7SmV9XWAsXG4gICAgICAgICAgICBhdFxuICAgICAgICAgICksIG8ubGVuZ3RoID4gMCAmJiBvLmZvckVhY2goKGQpID0+IGQucmVtb3ZlKCkpLCBsKFxuICAgICAgICAgICAgdGhpcy5ob3Vyc0FycmF5LFxuICAgICAgICAgICAgS1xuICAgICAgICAgICksIHAuYWRkU3R5bGUodGhpcy5faG91ciwge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICAgICAgICB9KSwgcC5hZGRTdHlsZSh0aGlzLl9taW51dGVzLCB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIlwiXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlRGlzYWJsaW5nVGlwc01heFRpbWUodCwgZSwgaSwgbikge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5tYXhUaW1lICYmICF0aGlzLl9vcHRpb25zLmRpc2FibGVGdXR1cmUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IGguZmluZChcbiAgICAgIGBbJHtLfV1gXG4gICAgKSwgciA9IGguZmluZChcbiAgICAgIGBbJHthdH1dYFxuICAgICksIGEgPSBoLmZpbmQoXG4gICAgICBgWyR7WH1dYFxuICAgICk7XG4gICAgaWYgKCFlIHx8IGUgPT09IHQpIHtcbiAgICAgIE9yKFxuICAgICAgICByLFxuICAgICAgICBuLFxuICAgICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgICApLCBPcihcbiAgICAgICAgbyxcbiAgICAgICAgbixcbiAgICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICAgKSwgSmYoXG4gICAgICAgIGEsXG4gICAgICAgIGksXG4gICAgICAgIG4sXG4gICAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQsXG4gICAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUgPT09IFwiQU1cIiAmJiB0ID09PSBcIlBNXCIgJiYgKG8uZm9yRWFjaCgobCkgPT4ge1xuICAgICAgcC5hZGRDbGFzcyhsLCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIGwuc2V0QXR0cmlidXRlKEJ0LCBcIlwiKTtcbiAgICB9KSwgYS5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBwLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoQnQsIFwiXCIpO1xuICAgIH0pKTtcbiAgfVxuICBfaGFuZGxlRGlzYWJsaW5nVGlwc01pblRpbWUodCwgZSwgaSwgbikge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5taW5UaW1lICYmICF0aGlzLl9vcHRpb25zLmRpc2FibGVQYXN0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSBoLmZpbmQoXG4gICAgICBgWyR7S31dYFxuICAgICksIHIgPSBoLmZpbmQoXG4gICAgICBgWyR7YXR9XWBcbiAgICApLCBhID0gaC5maW5kKFxuICAgICAgYFske1h9XWBcbiAgICApO1xuICAgICFlIHx8IGUgPT09IHQgPyAoeHIoXG4gICAgICBvLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgKSwgeHIoXG4gICAgICByLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgKSwgdF8oXG4gICAgICBhLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50LFxuICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICApKSA6IGUgPT09IFwiUE1cIiAmJiB0ID09PSBcIkFNXCIgJiYgKG8uZm9yRWFjaCgobCkgPT4ge1xuICAgICAgcC5hZGRDbGFzcyhsLCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIGwuc2V0QXR0cmlidXRlKEJ0LCBcIlwiKTtcbiAgICB9KSwgYS5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBwLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoQnQsIFwiXCIpO1xuICAgIH0pKTtcbiAgfVxuICBfaGFuZGxlU3dpdGNoVGltZU1vZGUoKSB7XG4gICAgdS5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgVWksXG4gICAgICAoeyB0YXJnZXQ6IHQgfSkgPT4ge1xuICAgICAgICBsZXQgeyBtYXhUaW1lOiBlLCBtaW5UaW1lOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICBjb25zdCB7IGRpc2FibGVQYXN0OiBuLCBkaXNhYmxlRnV0dXJlOiBvLCBmb3JtYXQxMjogciB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgaSA9IGp0KGksIG4sIHIpLCBlID0gS3QoZSwgbywgcik7XG4gICAgICAgIGNvbnN0IFthLCBsLCBjXSA9IFIoXG4gICAgICAgICAgZSxcbiAgICAgICAgICAhMVxuICAgICAgICApLCBbZCwgXywgZl0gPSBSKFxuICAgICAgICAgIGksXG4gICAgICAgICAgITFcbiAgICAgICAgKSwgbSA9IGguZmluZChcbiAgICAgICAgICBgWyR7S31dYFxuICAgICAgICApLCBnID0gaC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gXG4gICAgICAgICk7XG4gICAgICAgICgoKSA9PiB7XG4gICAgICAgICAgbS5mb3JFYWNoKChUKSA9PiB7XG4gICAgICAgICAgICBwLnJlbW92ZUNsYXNzKFQsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgVC5yZW1vdmVBdHRyaWJ1dGUoQnQpO1xuICAgICAgICAgIH0pLCBnLmZvckVhY2goKFQpID0+IHtcbiAgICAgICAgICAgIHAucmVtb3ZlQ2xhc3MoVCwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBULnJlbW92ZUF0dHJpYnV0ZShCdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCksIHRoaXMuX2hhbmRsZURpc2FibGluZ1RpcHNNaW5UaW1lKFxuICAgICAgICAgIHQudGV4dENvbnRlbnQsXG4gICAgICAgICAgZixcbiAgICAgICAgICBfLFxuICAgICAgICAgIGRcbiAgICAgICAgKSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01heFRpbWUoXG4gICAgICAgICAgdC50ZXh0Q29udGVudCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYVxuICAgICAgICApLCB0aGlzLl90b2dnbGVBbVBtKHQudGV4dENvbnRlbnQpLCB0Lmhhc0F0dHJpYnV0ZShCKSB8fCAoaC5maW5kKFxuICAgICAgICAgIFVpXG4gICAgICAgICkuZm9yRWFjaCgoQykgPT4ge1xuICAgICAgICAgIEMuaGFzQXR0cmlidXRlKEIpICYmIChwLnJlbW92ZUNsYXNzKEMsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIEMucmVtb3ZlQXR0cmlidXRlKEIpKTtcbiAgICAgICAgfSksIHAuYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdC5zZXRBdHRyaWJ1dGUoQiwgXCJcIikpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUNsb2NrQ2xpY2soKSB7XG4gICAgbGV0IHsgbWF4VGltZTogdCwgbWluVGltZTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCB7IGRpc2FibGVQYXN0OiBpLCBkaXNhYmxlRnV0dXJlOiBuLCBmb3JtYXQxMjogbyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBlID0ganQoZSwgaSwgbyksIHQgPSBLdCh0LCBuLCBvKTtcbiAgICBjb25zdCByID0gUih0LCAhMSlbMl0sIGEgPSBSKGUsICExKVsyXSwgbCA9IFIodCwgITEpWzBdLCBjID0gUihlLCAhMSlbMF0sIGQgPSBoLmZpbmRPbmUoXG4gICAgICBgWyR7RnJ9XWBcbiAgICApO1xuICAgIGVlLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBgJHtJcn0gJHskcn0gJHtMcn0gJHtNcn0gJHtOcn0gJHtIcn0gJHtScn0gJHtQcn1gLFxuICAgICAgXCJcIixcbiAgICAgIChfKSA9PiB7XG4gICAgICAgIFlpKCkgfHwgXy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCB7IHR5cGU6IGYsIHRhcmdldDogbSB9ID0gXywgeyBjbG9zZU1vZGFsT25NaW51dGVzQ2xpY2s6IGcsIHN3aXRjaEhvdXJzVG9NaW51dGVzT25DbGljazogYiB9ID0gdGhpcy5fb3B0aW9ucywgVCA9IGguZmluZE9uZShcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApICE9PSBudWxsLCBDID0gaC5maW5kT25lKFxuICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICkgIT09IG51bGwsIHcgPSBoLmZpbmRPbmUoXG4gICAgICAgICAgYFske2F0fV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICkgIT09IG51bGwsIHYgPSBoLmZpbmQoXG4gICAgICAgICAgYFske1h9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgRSA9IGtyKF8sIGQpLCBBID0gZC5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgIGxldCB5ID0gTWF0aC5hdGFuMihFLnkgLSBBLCBFLnggLSBBKTtcbiAgICAgICAgaWYgKFlpKCkpIHtcbiAgICAgICAgICBjb25zdCBEID0ga3IoXywgZCwgITApO1xuICAgICAgICAgIHkgPSBNYXRoLmF0YW4yKEQueSAtIEEsIEQueCAtIEEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBTID0gbnVsbCwgTyA9IG51bGwsIGsgPSBudWxsO1xuICAgICAgICBpZiAoZiA9PT0gXCJtb3VzZWRvd25cIiB8fCBmID09PSBcIm1vdXNlbW92ZVwiIHx8IGYgPT09IFwidG91Y2htb3ZlXCIgfHwgZiA9PT0gXCJ0b3VjaHN0YXJ0XCIpXG4gICAgICAgICAgKGYgPT09IFwibW91c2Vkb3duXCIgfHwgZiA9PT0gXCJ0b3VjaHN0YXJ0XCIgfHwgZiA9PT0gXCJ0b3VjaG1vdmVcIikgJiYgKHRoaXMuX2hhc1RhcmdldElubmVyQ2xhc3MobSkgfHwgbS5oYXNBdHRyaWJ1dGUoRnIpIHx8IG0uaGFzQXR0cmlidXRlKGxlKSB8fCBtLmhhc0F0dHJpYnV0ZShYKSB8fCBtLmhhc0F0dHJpYnV0ZShLKSB8fCBtLmhhc0F0dHJpYnV0ZShDbikgfHwgbS5oYXNBdHRyaWJ1dGUoVG4pIHx8IG0uaGFzQXR0cmlidXRlKFlyKSB8fCBtLmhhc0F0dHJpYnV0ZShYaSkpICYmICh0aGlzLl9pc01vdXNlTW92ZSA9ICEwLCBZaSgpICYmIF8udG91Y2hlcyAmJiAoUyA9IF8udG91Y2hlc1swXS5jbGllbnRYLCBPID0gXy50b3VjaGVzWzBdLmNsaWVudFksIGsgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KFMsIE8pKSk7XG4gICAgICAgIGVsc2UgaWYgKGYgPT09IFwibW91c2V1cFwiIHx8IGYgPT09IFwidG91Y2hlbmRcIikge1xuICAgICAgICAgIGlmICh0aGlzLl9pc01vdXNlTW92ZSA9ICExLCB0aGlzLl9oYXNUYXJnZXRJbm5lckNsYXNzKG0pIHx8IG0uaGFzQXR0cmlidXRlKGxlKSB8fCBtLmhhc0F0dHJpYnV0ZShLKSB8fCBtLmhhc0F0dHJpYnV0ZShDbikgfHwgbS5oYXNBdHRyaWJ1dGUoVG4pIHx8IG0uaGFzQXR0cmlidXRlKFlyKSB8fCBtLmhhc0F0dHJpYnV0ZShYaSkpIHtcbiAgICAgICAgICAgIGlmICgoQyB8fCB3KSAmJiBiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IEQgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPiBsIHx8IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSA8IGM7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0ICYmIGwgIT09IFwiXCIgJiYgYyAhPT0gXCJcIiAmJiBEKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgJiYgYyAhPT0gXCJcIiAmJiBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPCBjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHUudHJpZ2dlcih0aGlzLl9taW51dGVzLCBcImNsaWNrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoVCAmJiBnKSB7XG4gICAgICAgICAgICBjb25zdCBEID0gaC5maW5kT25lKFxuICAgICAgICAgICAgICBgWyR7X259XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdS50cmlnZ2VyKEQsIFwiY2xpY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChUKSB7XG4gICAgICAgICAgbGV0IEQ7XG4gICAgICAgICAgY29uc3QgeCA9IE1hdGgudHJ1bmMoeSAqIDE4MCAvIE1hdGguUEkpICsgOTAsIHsgZGVncmVlczogJCwgbWludXRlOiBQIH0gPSB0aGlzLl9tYWtlTWludXRlc0RlZ3JlZXMoeCwgRCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJNYXhNaW5NaW51dGVzT3B0aW9ucygkLCBQKSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHsgZGVncmVlczogdHQsIG1pbnV0ZTogZXQgfSA9IHRoaXMuX2hhbmRsZXJNYXhNaW5NaW51dGVzT3B0aW9ucygkLCBQKTtcbiAgICAgICAgICBpZiAodGhpcy5faXNNb3VzZU1vdmUpIHtcbiAgICAgICAgICAgIGlmIChwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3R0fWRlZylgXG4gICAgICAgICAgICB9KSwgZXQgPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgeiA9ICgpID0+IGV0ID49IDEwIHx8IGV0ID09PSBcIjAwXCIgPyBldCA6IGAwJHtldH1gO1xuICAgICAgICAgICAgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IHooKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgICAgIHRoaXMubWludXRlc0FycmF5LFxuICAgICAgICAgICAgICB0aGlzLl9taW51dGVzLFxuICAgICAgICAgICAgICB2XG4gICAgICAgICAgICApLCB0aGlzLl90b2dnbGVCYWNrZ3JvdW5kQ29sb3JDaXJjbGUoXG4gICAgICAgICAgICAgIGBbJHtYfV1gXG4gICAgICAgICAgICApLCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLmRlZ3JlZXNNaW51dGVzID0gdHQsIHRoaXMuX29ialdpdGhEYXRhT25DaGFuZ2UubWludXRlcyA9IGV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQyB8fCB3KSB7XG4gICAgICAgICAgbGV0IEQsIHggPSBNYXRoLnRydW5jKHkgKiAxODAgLyBNYXRoLlBJKSArIDkwO1xuICAgICAgICAgIGlmICh4ID0gTWF0aC5yb3VuZCh4IC8gMzApICogMzAsIHAuYWRkU3R5bGUodGhpcy5fY2lyY2xlLCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzE5NzZkMlwiXG4gICAgICAgICAgfSksIHRoaXMuX21ha2VIb3VyRGVncmVlcyhtLCB4LCBEKSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0ICQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoWWkoKSAmJiB4ICYmIGspIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkZWdyZWVzOiBQLCBob3VyOiB0dCB9ID0gdGhpcy5fbWFrZUhvdXJEZWdyZWVzKGssIHgsIEQpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlTW92ZUhhbmQoXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICB0dCxcbiAgICAgICAgICAgICAgICBQXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB7IGRlZ3JlZXM6IFAsIGhvdXI6IHR0IH0gPSB0aGlzLl9tYWtlSG91ckRlZ3JlZXMobSwgeCwgRCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVNb3ZlSGFuZChtLCB0dCwgUCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLmRlZ3JlZXNIb3VycyA9IHgsIHRoaXMuX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnMoXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIF9cbiAgICAgICAgICApICYmICQoKTtcbiAgICAgICAgfVxuICAgICAgICBfLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhc1RhcmdldElubmVyQ2xhc3ModCkge1xuICAgIHJldHVybiB0Lmhhc0F0dHJpYnV0ZShKZSkgfHwgdC5oYXNBdHRyaWJ1dGUoYXQpIHx8IHQuaGFzQXR0cmlidXRlKEdpKTtcbiAgfVxuICBfaGFuZGxlTW92ZUhhbmQodCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSBoLmZpbmQoXG4gICAgICBgWyR7S31dYCxcbiAgICAgIHRoaXMuX21vZGFsXG4gICAgKSwgbyA9IGguZmluZChcbiAgICAgIGBbJHthdH1dYCxcbiAgICAgIHRoaXMuX21vZGFsXG4gICAgKTtcbiAgICB0aGlzLl9pc01vdXNlTW92ZSAmJiAodGhpcy5faGFzVGFyZ2V0SW5uZXJDbGFzcyh0KSA/IHAuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgaGVpZ2h0OiBcIjIxLjUlXCJcbiAgICB9KSA6IHAuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgfSksIHAuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke2l9ZGVnKWBcbiAgICB9KSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IGUgPj0gMTAgfHwgZSA9PT0gXCIwMFwiID8gZSA6IGAwJHtlfWAsIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgbiksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgbyksIHRoaXMuX29ialdpdGhEYXRhT25DaGFuZ2UuaG91ciA9IGUgPj0gMTAgfHwgZSA9PT0gXCIwMFwiID8gZSA6IGAwJHtlfWApO1xuICB9XG4gIF9oYW5kbGVyTWF4TWluTWludXRlc09wdGlvbnModCwgZSkge1xuICAgIGxldCB7IG1heFRpbWU6IGksIG1pblRpbWU6IG4gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgeyBmb3JtYXQxMjogbywgaW5jcmVtZW50OiByLCBkaXNhYmxlUGFzdDogYSwgZGlzYWJsZUZ1dHVyZTogbCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBuID0ganQobiwgYSwgbyksIGkgPSBLdChpLCBsLCBvKTtcbiAgICBjb25zdCBjID0gUihpLCAhMSlbMV0sIGQgPSBSKG4sICExKVsxXSwgXyA9IFIoaSwgITEpWzBdLCBmID0gUihuLCAhMSlbMF0sIG0gPSBmID09PSBcIjEyXCIgJiYgbyA/IFwiMFwiIDogZiwgZyA9IF8gPT09IFwiMTJcIiAmJiBvID8gXCIwXCIgOiBfLCBiID0gUihpLCAhMSlbMl0sIFQgPSBSKG4sICExKVsyXSwgQyA9IGMgIT09IFwiXCIgPyBjICogNiA6IFwiXCIsIHcgPSBkICE9PSBcIlwiID8gZCAqIDYgOiBcIlwiLCB2ID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBFID0gdiA9PT0gMTIgJiYgbyA/IDAgOiB2O1xuICAgIGlmICghYiAmJiAhVCkge1xuICAgICAgaWYgKGkgIT09IFwiXCIgJiYgbiAhPT0gXCJcIikge1xuICAgICAgICBpZiAoTnVtYmVyKGcpID09PSBFICYmIHQgPiBDIHx8IE51bWJlcihtKSA9PT0gRSAmJiB0IDwgdylcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0gZWxzZSBpZiAobiAhPT0gXCJcIiAmJiBFIDw9IE51bWJlcihtKSkge1xuICAgICAgICBpZiAodCA8PSB3IC0gNilcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0gZWxzZSBpZiAoaSAhPT0gXCJcIiAmJiBFID49IE51bWJlcihnKSAmJiB0ID49IEMgKyA2KVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG4gIT09IFwiXCIpIHtcbiAgICAgICAgaWYgKFQgPT09IFwiUE1cIiAmJiB0aGlzLl9pc0FtRW5hYmxlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChUID09PSBcIlBNXCIgJiYgdGhpcy5faXNQbUVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoRSA8IE51bWJlcihtKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAoRSA8PSBOdW1iZXIobSkgJiYgdCA8PSB3IC0gNilcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9IGVsc2UgaWYgKFQgPT09IFwiQU1cIiAmJiB0aGlzLl9pc0FtRW5hYmxlZCkge1xuICAgICAgICAgIGlmIChFIDwgTnVtYmVyKG0pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGlmIChFIDw9IE51bWJlcihtKSAmJiB0IDw9IHcgLSA2KVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpICE9PSBcIlwiKSB7XG4gICAgICAgIGlmIChiID09PSBcIkFNXCIgJiYgdGhpcy5faXNQbUVuYWJsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoYiA9PT0gXCJQTVwiICYmIHRoaXMuX2lzUG1FbmFibGVkKSB7XG4gICAgICAgICAgaWYgKEUgPj0gTnVtYmVyKGcpICYmIHQgPj0gQyArIDYpXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSBcIkFNXCIgJiYgdGhpcy5faXNBbUVuYWJsZWQgJiYgRSA+PSBOdW1iZXIoZykgJiYgdCA+PSBDICsgNilcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHIgJiYgKHQgPSBNYXRoLnJvdW5kKHQgLyAzMCkgKiAzMCksIHQgPCAwID8gdCA9IDM2MCArIHQgOiB0ID49IDM2MCAmJiAodCA9IDApLCB7XG4gICAgICBkZWdyZWVzOiB0LFxuICAgICAgbWludXRlOiBlXG4gICAgfTtcbiAgfVxuICBfcmVtb3ZlTW9kYWwoKSB7XG4gICAgdGhpcy5fYW5pbWF0aW9ucyA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlTW9kYWxFbGVtZW50cygpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICB9LCAzMDApIDogKHRoaXMuX3JlbW92ZU1vZGFsRWxlbWVudHMoKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCkpLCBlZS5vZmYoXG4gICAgICB0aGlzLl9kb2N1bWVudCxcbiAgICAgIGAke0RyfSAke2ppfSAke0lyfSAkeyRyfSAke0xyfSAke01yfSAke05yfSAke0hyfSAke1JyfSAke1ByfWBcbiAgICApLCB1Lm9mZih3aW5kb3csIGppKTtcbiAgfVxuICBfcmVtb3ZlTW9kYWxFbGVtZW50cygpIHtcbiAgICB0aGlzLl9tb2RhbCAmJiB0aGlzLl9tb2RhbC5yZW1vdmUoKTtcbiAgfVxuICBfdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24odCA9ICExKSB7XG4gICAgdCA/IHRoaXMuX3dyYXBwZXIuY2xhc3NMaXN0LmFkZChcImFuaW1hdGUtW2ZhZGUtb3V0XzM1MG1zX2Vhc2UtaW4tb3V0XVwiKSA6ICh0aGlzLl93cmFwcGVyLmNsYXNzTGlzdC5hZGQoXCJhbmltYXRlLVtmYWRlLWluXzM1MG1zX2Vhc2UtaW4tb3V0XVwiKSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgcC5hZGRDbGFzcyh0aGlzLl9jbG9jaywgdGhpcy5fY2xhc3Nlcy5jbG9ja0FuaW1hdGlvbikpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3dyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgXCJhbmltYXRlLVtmYWRlLW91dF8zNTBtc19lYXNlLWluLW91dF1cIixcbiAgICAgICAgXCJhbmltYXRlLVtmYWRlLWluXzM1MG1zX2Vhc2UtaW4tb3V0XVwiXG4gICAgICApO1xuICAgIH0sIDM1MSk7XG4gIH1cbiAgX2FkZEFjdGl2ZUNsYXNzVG9UaXAodCwgZSkge1xuICAgIHQuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgTnVtYmVyKGkudGV4dENvbnRlbnQpID09PSBOdW1iZXIoZSkgJiYgKHAuYWRkQ2xhc3MoaSwgdGhpcy5fY2xhc3Nlcy50aXBzQWN0aXZlKSwgaS5zZXRBdHRyaWJ1dGUoQiwgXCJcIikpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRIb3VyT3JNaW51dGUodCkge1xuICAgIHJldHVybiB0IDwgMTAgPyBgMCR7dH1gIDogdDtcbiAgfVxuICBfYXBwZW5kVGltZXMoKSB7XG4gICAgY29uc3QgeyBmb3JtYXQyNDogdCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAodCkge1xuICAgICAgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgICAgYFske2xlfV1gLFxuICAgICAgICBLXG4gICAgICApLCB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgICAgdGhpcy5pbm5lckhvdXJzLFxuICAgICAgICBgWyR7SmV9XWAsXG4gICAgICAgIGF0XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgIGBbJHtsZX1dYCxcbiAgICAgIEtcbiAgICApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucF8sXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4oaGksIHQsIGZfKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLl9fLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKGhpLCB0LCBtXyksIHQ7XG4gIH1cbiAgX2dldENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKHRoaXMuX29wdGlvbnMuY29udGFpbmVyKTtcbiAgfVxuICBfZ2V0VmFsaWRhdGUodCkge1xuICAgIGNvbnN0IHsgaW52YWxpZExhYmVsOiBlLCBmb3JtYXQyNDogaSwgZm9ybWF0MTI6IG4sIGFwcGVuZFZhbGlkYXRpb25JbmZvOiBvIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGxldCByO1xuICAgIG8gJiYgKHIgPSBNKFwiZGl2XCIpLCByLnNldEF0dHJpYnV0ZShXciwgXCJcIiksIHIuaW5uZXJIVE1MID0gZSksIGVlLm9uKHRoaXMuaW5wdXQsIHQsICh7IHRhcmdldDogYSB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucyA9PT0gbnVsbCB8fCB0aGlzLmlucHV0LnZhbHVlID09PSBcIlwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBsID0gL14oMD9bMS05XXwxWzAxMl0pKDpbMC01XVxcZCkgW0FQYXBdW21NXSQvLCBjID0gL14oWzAxXVxcZHwyWzAtM10pKDpbMC01XVxcZCkkLywgZCA9IGwudGVzdChhLnZhbHVlKTtcbiAgICAgIGlmIChjLnRlc3QoYS52YWx1ZSkgIT09ICEwICYmIGkgfHwgZCAhPT0gITAgJiYgbikge1xuICAgICAgICBvICYmICh0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShibiwgXCJcIiksIHRoaXMuaW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgcixcbiAgICAgICAgICB0aGlzLmlucHV0Lm5leHRTaWJsaW5nXG4gICAgICAgICkpLCBwLmFkZFN0eWxlKGEsIHsgbWFyZ2luQm90dG9tOiAwIH0pLCBwLmFkZFN0eWxlKHIsIHsgYm90dG9tOiBcIi0yM3B4XCIgfSksIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgPSAhMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYm4pLCB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gITE7XG4gICAgICBjb25zdCBmID0gaC5maW5kT25lKFxuICAgICAgICBgWyR7V3J9XWBcbiAgICAgICk7XG4gICAgICBmICE9PSBudWxsICYmIGYucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBfcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuLyohXG4gKiBwZXJmZWN0LXNjcm9sbGJhciB2MS41LjNcbiAqIENvcHlyaWdodCAyMDIxIEh5dW5qZSBKdW4sIE1EQm9vdHN0cmFwIGFuZCBDb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICovXG5mdW5jdGlvbiB4dChzKSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHMpO1xufVxuZnVuY3Rpb24gb3QocywgdCkge1xuICBmb3IgKHZhciBlIGluIHQpIHtcbiAgICB2YXIgaSA9IHRbZV07XG4gICAgdHlwZW9mIGkgPT0gXCJudW1iZXJcIiAmJiAoaSA9IGkgKyBcInB4XCIpLCBzLnN0eWxlW2VdID0gaTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHFpKHMpIHtcbiAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICByZXR1cm4gdC5jbGFzc05hbWUgPSBzLCB0O1xufVxudmFyIEtyID0gdHlwZW9mIEVsZW1lbnQgPCBcInVcIiAmJiAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yKTtcbmZ1bmN0aW9uIHp0KHMsIHQpIHtcbiAgaWYgKCFLcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlbGVtZW50IG1hdGNoaW5nIG1ldGhvZCBzdXBwb3J0ZWRcIik7XG4gIHJldHVybiBLci5jYWxsKHMsIHQpO1xufVxuZnVuY3Rpb24gU2Uocykge1xuICBzLnJlbW92ZSA/IHMucmVtb3ZlKCkgOiBzLnBhcmVudE5vZGUgJiYgcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHMpO1xufVxuZnVuY3Rpb24gVXIocywgdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKFxuICAgIHMuY2hpbGRyZW4sXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIHp0KGUsIHQpO1xuICAgIH1cbiAgKTtcbn1cbnZhciBqID0ge1xuICBtYWluOiBcInBzXCIsXG4gIHJ0bDogXCJwc19fcnRsXCIsXG4gIGVsZW1lbnQ6IHtcbiAgICB0aHVtYjogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHNfX3RodW1iLVwiICsgcztcbiAgICB9LFxuICAgIHJhaWw6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBcInBzX19yYWlsLVwiICsgcztcbiAgICB9LFxuICAgIGNvbnN1bWluZzogXCJwc19fY2hpbGQtLWNvbnN1bWVcIlxuICB9LFxuICBzdGF0ZToge1xuICAgIGZvY3VzOiBcInBzLS1mb2N1c1wiLFxuICAgIGNsaWNraW5nOiBcInBzLS1jbGlja2luZ1wiLFxuICAgIGFjdGl2ZTogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHMtLWFjdGl2ZS1cIiArIHM7XG4gICAgfSxcbiAgICBzY3JvbGxpbmc6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBcInBzLS1zY3JvbGxpbmctXCIgKyBzO1xuICAgIH1cbiAgfVxufSwgeWwgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcbmZ1bmN0aW9uIHdsKHMsIHQpIHtcbiAgdmFyIGUgPSBzLmVsZW1lbnQuY2xhc3NMaXN0LCBpID0gai5zdGF0ZS5zY3JvbGxpbmcodCk7XG4gIGUuY29udGFpbnMoaSkgPyBjbGVhclRpbWVvdXQoeWxbdF0pIDogZS5hZGQoaSk7XG59XG5mdW5jdGlvbiBrbChzLCB0KSB7XG4gIHlsW3RdID0gc2V0VGltZW91dChcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzLmlzQWxpdmUgJiYgcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5zY3JvbGxpbmcodCkpO1xuICAgIH0sXG4gICAgcy5zZXR0aW5ncy5zY3JvbGxpbmdUaHJlc2hvbGRcbiAgKTtcbn1cbmZ1bmN0aW9uIGdfKHMsIHQpIHtcbiAgd2wocywgdCksIGtsKHMsIHQpO1xufVxudmFyIEVpID0gZnVuY3Rpb24odCkge1xuICB0aGlzLmVsZW1lbnQgPSB0LCB0aGlzLmhhbmRsZXJzID0ge307XG59LCBPbCA9IHsgaXNFbXB0eTogeyBjb25maWd1cmFibGU6ICEwIH0gfTtcbkVpLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24odCwgZSkge1xuICB0eXBlb2YgdGhpcy5oYW5kbGVyc1t0XSA+IFwidVwiICYmICh0aGlzLmhhbmRsZXJzW3RdID0gW10pLCB0aGlzLmhhbmRsZXJzW3RdLnB1c2goZSksIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHQsIGUsICExKTtcbn07XG5FaS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24odCwgZSkge1xuICB2YXIgaSA9IHRoaXM7XG4gIHRoaXMuaGFuZGxlcnNbdF0gPSB0aGlzLmhhbmRsZXJzW3RdLmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIGUgJiYgbiAhPT0gZSA/ICEwIDogKGkuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHQsIG4sICExKSwgITEpO1xuICB9KTtcbn07XG5FaS5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIHQgaW4gdGhpcy5oYW5kbGVycylcbiAgICB0aGlzLnVuYmluZCh0KTtcbn07XG5PbC5pc0VtcHR5LmdldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcyA9IHRoaXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmhhbmRsZXJzKS5ldmVyeShcbiAgICBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gcy5oYW5kbGVyc1t0XS5sZW5ndGggPT09IDA7XG4gICAgfVxuICApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVpLnByb3RvdHlwZSwgT2wpO1xudmFyIFVlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xufTtcblVlLnByb3RvdHlwZS5ldmVudEVsZW1lbnQgPSBmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gdGhpcy5ldmVudEVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIGkuZWxlbWVudCA9PT0gdDtcbiAgfSlbMF07XG4gIHJldHVybiBlIHx8IChlID0gbmV3IEVpKHQpLCB0aGlzLmV2ZW50RWxlbWVudHMucHVzaChlKSksIGU7XG59O1xuVWUucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50KHQpLmJpbmQoZSwgaSk7XG59O1xuVWUucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgdmFyIG4gPSB0aGlzLmV2ZW50RWxlbWVudCh0KTtcbiAgbi51bmJpbmQoZSwgaSksIG4uaXNFbXB0eSAmJiB0aGlzLmV2ZW50RWxlbWVudHMuc3BsaWNlKHRoaXMuZXZlbnRFbGVtZW50cy5pbmRleE9mKG4pLCAxKTtcbn07XG5VZS5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC51bmJpbmRBbGwoKTtcbiAgfSksIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xufTtcblVlLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICB2YXIgbiA9IHRoaXMuZXZlbnRFbGVtZW50KHQpLCBvID0gZnVuY3Rpb24ocikge1xuICAgIG4udW5iaW5kKGUsIG8pLCBpKHIpO1xuICB9O1xuICBuLmJpbmQoZSwgbyk7XG59O1xuZnVuY3Rpb24gUWkocykge1xuICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChzKTtcbiAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICByZXR1cm4gdC5pbml0Q3VzdG9tRXZlbnQocywgITEsICExLCB2b2lkIDApLCB0O1xufVxuZnVuY3Rpb24geXMocywgdCwgZSwgaSwgbikge1xuICBpID09PSB2b2lkIDAgJiYgKGkgPSAhMCksIG4gPT09IHZvaWQgMCAmJiAobiA9ICExKTtcbiAgdmFyIG87XG4gIGlmICh0ID09PSBcInRvcFwiKVxuICAgIG8gPSBbXG4gICAgICBcImNvbnRlbnRIZWlnaHRcIixcbiAgICAgIFwiY29udGFpbmVySGVpZ2h0XCIsXG4gICAgICBcInNjcm9sbFRvcFwiLFxuICAgICAgXCJ5XCIsXG4gICAgICBcInVwXCIsXG4gICAgICBcImRvd25cIlxuICAgIF07XG4gIGVsc2UgaWYgKHQgPT09IFwibGVmdFwiKVxuICAgIG8gPSBbXG4gICAgICBcImNvbnRlbnRXaWR0aFwiLFxuICAgICAgXCJjb250YWluZXJXaWR0aFwiLFxuICAgICAgXCJzY3JvbGxMZWZ0XCIsXG4gICAgICBcInhcIixcbiAgICAgIFwibGVmdFwiLFxuICAgICAgXCJyaWdodFwiXG4gICAgXTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihcIkEgcHJvcGVyIGF4aXMgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO1xuICBiXyhzLCBlLCBvLCBpLCBuKTtcbn1cbmZ1bmN0aW9uIGJfKHMsIHQsIGUsIGksIG4pIHtcbiAgdmFyIG8gPSBlWzBdLCByID0gZVsxXSwgYSA9IGVbMl0sIGwgPSBlWzNdLCBjID0gZVs0XSwgZCA9IGVbNV07XG4gIGkgPT09IHZvaWQgMCAmJiAoaSA9ICEwKSwgbiA9PT0gdm9pZCAwICYmIChuID0gITEpO1xuICB2YXIgXyA9IHMuZWxlbWVudDtcbiAgcy5yZWFjaFtsXSA9IG51bGwsIF9bYV0gPCAxICYmIChzLnJlYWNoW2xdID0gXCJzdGFydFwiKSwgX1thXSA+IHNbb10gLSBzW3JdIC0gMSAmJiAocy5yZWFjaFtsXSA9IFwiZW5kXCIpLCB0ICYmIChfLmRpc3BhdGNoRXZlbnQoUWkoXCJwcy1zY3JvbGwtXCIgKyBsKSksIHQgPCAwID8gXy5kaXNwYXRjaEV2ZW50KFFpKFwicHMtc2Nyb2xsLVwiICsgYykpIDogdCA+IDAgJiYgXy5kaXNwYXRjaEV2ZW50KFFpKFwicHMtc2Nyb2xsLVwiICsgZCkpLCBpICYmIGdfKHMsIGwpKSwgcy5yZWFjaFtsXSAmJiAodCB8fCBuKSAmJiBfLmRpc3BhdGNoRXZlbnQoUWkoXCJwcy1cIiArIGwgKyBcIi1yZWFjaC1cIiArIHMucmVhY2hbbF0pKTtcbn1cbmZ1bmN0aW9uIFcocykge1xuICByZXR1cm4gcGFyc2VJbnQocywgMTApIHx8IDA7XG59XG5mdW5jdGlvbiB2XyhzKSB7XG4gIHJldHVybiB6dChzLCBcImlucHV0LFtjb250ZW50ZWRpdGFibGVdXCIpIHx8IHp0KHMsIFwic2VsZWN0LFtjb250ZW50ZWRpdGFibGVdXCIpIHx8IHp0KHMsIFwidGV4dGFyZWEsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHwgenQocywgXCJidXR0b24sW2NvbnRlbnRlZGl0YWJsZV1cIik7XG59XG5mdW5jdGlvbiBFXyhzKSB7XG4gIHZhciB0ID0geHQocyk7XG4gIHJldHVybiBXKHQud2lkdGgpICsgVyh0LnBhZGRpbmdMZWZ0KSArIFcodC5wYWRkaW5nUmlnaHQpICsgVyh0LmJvcmRlckxlZnRXaWR0aCkgKyBXKHQuYm9yZGVyUmlnaHRXaWR0aCk7XG59XG52YXIga2UgPSB7XG4gIGlzV2ViS2l0OiB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiBcIldlYmtpdEFwcGVhcmFuY2VcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gIHN1cHBvcnRzVG91Y2g6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiAoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cgfHwgXCJtYXhUb3VjaFBvaW50c1wiIGluIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCksXG4gIHN1cHBvcnRzSWVQb2ludGVyOiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMsXG4gIGlzQ2hyb21lOiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgL0Nocm9tZS9pLnRlc3QobmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQpXG59O1xuZnVuY3Rpb24gTXQocykge1xuICB2YXIgdCA9IHMuZWxlbWVudCwgZSA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCBpID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcy5jb250YWluZXJXaWR0aCA9IE1hdGgucm91bmQoaS53aWR0aCksIHMuY29udGFpbmVySGVpZ2h0ID0gTWF0aC5yb3VuZChpLmhlaWdodCksIHMuY29udGVudFdpZHRoID0gdC5zY3JvbGxXaWR0aCwgcy5jb250ZW50SGVpZ2h0ID0gdC5zY3JvbGxIZWlnaHQsIHQuY29udGFpbnMocy5zY3JvbGxiYXJYUmFpbCkgfHwgKFVyKHQsIGouZWxlbWVudC5yYWlsKFwieFwiKSkuZm9yRWFjaChcbiAgICBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gU2Uobik7XG4gICAgfVxuICApLCB0LmFwcGVuZENoaWxkKHMuc2Nyb2xsYmFyWFJhaWwpKSwgdC5jb250YWlucyhzLnNjcm9sbGJhcllSYWlsKSB8fCAoVXIodCwgai5lbGVtZW50LnJhaWwoXCJ5XCIpKS5mb3JFYWNoKFxuICAgIGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBTZShuKTtcbiAgICB9XG4gICksIHQuYXBwZW5kQ2hpbGQocy5zY3JvbGxiYXJZUmFpbCkpLCAhcy5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFggJiYgcy5jb250YWluZXJXaWR0aCArIHMuc2V0dGluZ3Muc2Nyb2xsWE1hcmdpbk9mZnNldCA8IHMuY29udGVudFdpZHRoID8gKHMuc2Nyb2xsYmFyWEFjdGl2ZSA9ICEwLCBzLnJhaWxYV2lkdGggPSBzLmNvbnRhaW5lcldpZHRoIC0gcy5yYWlsWE1hcmdpbldpZHRoLCBzLnJhaWxYUmF0aW8gPSBzLmNvbnRhaW5lcldpZHRoIC8gcy5yYWlsWFdpZHRoLCBzLnNjcm9sbGJhclhXaWR0aCA9IHpyKFxuICAgIHMsXG4gICAgVyhzLnJhaWxYV2lkdGggKiBzLmNvbnRhaW5lcldpZHRoIC8gcy5jb250ZW50V2lkdGgpXG4gICksIHMuc2Nyb2xsYmFyWExlZnQgPSBXKFxuICAgIChzLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIHQuc2Nyb2xsTGVmdCkgKiAocy5yYWlsWFdpZHRoIC0gcy5zY3JvbGxiYXJYV2lkdGgpIC8gKHMuY29udGVudFdpZHRoIC0gcy5jb250YWluZXJXaWR0aClcbiAgKSkgOiBzLnNjcm9sbGJhclhBY3RpdmUgPSAhMSwgIXMuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxZICYmIHMuY29udGFpbmVySGVpZ2h0ICsgcy5zZXR0aW5ncy5zY3JvbGxZTWFyZ2luT2Zmc2V0IDwgcy5jb250ZW50SGVpZ2h0ID8gKHMuc2Nyb2xsYmFyWUFjdGl2ZSA9ICEwLCBzLnJhaWxZSGVpZ2h0ID0gcy5jb250YWluZXJIZWlnaHQgLSBzLnJhaWxZTWFyZ2luSGVpZ2h0LCBzLnJhaWxZUmF0aW8gPSBzLmNvbnRhaW5lckhlaWdodCAvIHMucmFpbFlIZWlnaHQsIHMuc2Nyb2xsYmFyWUhlaWdodCA9IHpyKFxuICAgIHMsXG4gICAgVyhzLnJhaWxZSGVpZ2h0ICogcy5jb250YWluZXJIZWlnaHQgLyBzLmNvbnRlbnRIZWlnaHQpXG4gICksIHMuc2Nyb2xsYmFyWVRvcCA9IFcoXG4gICAgZSAqIChzLnJhaWxZSGVpZ2h0IC0gcy5zY3JvbGxiYXJZSGVpZ2h0KSAvIChzLmNvbnRlbnRIZWlnaHQgLSBzLmNvbnRhaW5lckhlaWdodClcbiAgKSkgOiBzLnNjcm9sbGJhcllBY3RpdmUgPSAhMSwgcy5zY3JvbGxiYXJYTGVmdCA+PSBzLnJhaWxYV2lkdGggLSBzLnNjcm9sbGJhclhXaWR0aCAmJiAocy5zY3JvbGxiYXJYTGVmdCA9IHMucmFpbFhXaWR0aCAtIHMuc2Nyb2xsYmFyWFdpZHRoKSwgcy5zY3JvbGxiYXJZVG9wID49IHMucmFpbFlIZWlnaHQgLSBzLnNjcm9sbGJhcllIZWlnaHQgJiYgKHMuc2Nyb2xsYmFyWVRvcCA9IHMucmFpbFlIZWlnaHQgLSBzLnNjcm9sbGJhcllIZWlnaHQpLCBUXyh0LCBzKSwgcy5zY3JvbGxiYXJYQWN0aXZlID8gdC5jbGFzc0xpc3QuYWRkKGouc3RhdGUuYWN0aXZlKFwieFwiKSkgOiAodC5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuYWN0aXZlKFwieFwiKSksIHMuc2Nyb2xsYmFyWFdpZHRoID0gMCwgcy5zY3JvbGxiYXJYTGVmdCA9IDAsIHQuc2Nyb2xsTGVmdCA9IHMuaXNSdGwgPT09ICEwID8gcy5jb250ZW50V2lkdGggOiAwKSwgcy5zY3JvbGxiYXJZQWN0aXZlID8gdC5jbGFzc0xpc3QuYWRkKGouc3RhdGUuYWN0aXZlKFwieVwiKSkgOiAodC5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuYWN0aXZlKFwieVwiKSksIHMuc2Nyb2xsYmFyWUhlaWdodCA9IDAsIHMuc2Nyb2xsYmFyWVRvcCA9IDAsIHQuc2Nyb2xsVG9wID0gMCk7XG59XG5mdW5jdGlvbiB6cihzLCB0KSB7XG4gIHJldHVybiBzLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCAmJiAodCA9IE1hdGgubWF4KHQsIHMuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoKSksIHMuc2V0dGluZ3MubWF4U2Nyb2xsYmFyTGVuZ3RoICYmICh0ID0gTWF0aC5taW4odCwgcy5zZXR0aW5ncy5tYXhTY3JvbGxiYXJMZW5ndGgpKSwgdDtcbn1cbmZ1bmN0aW9uIFRfKHMsIHQpIHtcbiAgdmFyIGUgPSB7IHdpZHRoOiB0LnJhaWxYV2lkdGggfSwgaSA9IE1hdGguZmxvb3Iocy5zY3JvbGxUb3ApO1xuICB0LmlzUnRsID8gZS5sZWZ0ID0gdC5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBzLnNjcm9sbExlZnQgKyB0LmNvbnRhaW5lcldpZHRoIC0gdC5jb250ZW50V2lkdGggOiBlLmxlZnQgPSBzLnNjcm9sbExlZnQsIHQuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPyBlLmJvdHRvbSA9IHQuc2Nyb2xsYmFyWEJvdHRvbSAtIGkgOiBlLnRvcCA9IHQuc2Nyb2xsYmFyWFRvcCArIGksIG90KHQuc2Nyb2xsYmFyWFJhaWwsIGUpO1xuICB2YXIgbiA9IHsgdG9wOiBpLCBoZWlnaHQ6IHQucmFpbFlIZWlnaHQgfTtcbiAgdC5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID8gdC5pc1J0bCA/IG4ucmlnaHQgPSB0LmNvbnRlbnRXaWR0aCAtICh0Lm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIHMuc2Nyb2xsTGVmdCkgLSB0LnNjcm9sbGJhcllSaWdodCAtIHQuc2Nyb2xsYmFyWU91dGVyV2lkdGggLSA5IDogbi5yaWdodCA9IHQuc2Nyb2xsYmFyWVJpZ2h0IC0gcy5zY3JvbGxMZWZ0IDogdC5pc1J0bCA/IG4ubGVmdCA9IHQubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgcy5zY3JvbGxMZWZ0ICsgdC5jb250YWluZXJXaWR0aCAqIDIgLSB0LmNvbnRlbnRXaWR0aCAtIHQuc2Nyb2xsYmFyWUxlZnQgLSB0LnNjcm9sbGJhcllPdXRlcldpZHRoIDogbi5sZWZ0ID0gdC5zY3JvbGxiYXJZTGVmdCArIHMuc2Nyb2xsTGVmdCwgb3QodC5zY3JvbGxiYXJZUmFpbCwgbiksIG90KHQuc2Nyb2xsYmFyWCwge1xuICAgIGxlZnQ6IHQuc2Nyb2xsYmFyWExlZnQsXG4gICAgd2lkdGg6IHQuc2Nyb2xsYmFyWFdpZHRoIC0gdC5yYWlsQm9yZGVyWFdpZHRoXG4gIH0pLCBvdCh0LnNjcm9sbGJhclksIHtcbiAgICB0b3A6IHQuc2Nyb2xsYmFyWVRvcCxcbiAgICBoZWlnaHQ6IHQuc2Nyb2xsYmFyWUhlaWdodCAtIHQucmFpbEJvcmRlcllXaWR0aFxuICB9KTtcbn1cbmZ1bmN0aW9uIENfKHMpIHtcbiAgcy5lbGVtZW50LCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJZLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pLCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJZUmFpbCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCAtIHMuc2Nyb2xsYmFyWVJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wLCBpID0gZSA+IHMuc2Nyb2xsYmFyWVRvcCA/IDEgOiAtMTtcbiAgICBzLmVsZW1lbnQuc2Nyb2xsVG9wICs9IGkgKiBzLmNvbnRhaW5lckhlaWdodCwgTXQocyksIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pLCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJYLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pLCBzLmV2ZW50LmJpbmQocy5zY3JvbGxiYXJYUmFpbCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gdC5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCAtIHMuc2Nyb2xsYmFyWFJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCwgaSA9IGUgPiBzLnNjcm9sbGJhclhMZWZ0ID8gMSA6IC0xO1xuICAgIHMuZWxlbWVudC5zY3JvbGxMZWZ0ICs9IGkgKiBzLmNvbnRhaW5lcldpZHRoLCBNdChzKSwgdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBBXyhzKSB7XG4gIFhyKHMsIFtcbiAgICBcImNvbnRhaW5lcldpZHRoXCIsXG4gICAgXCJjb250ZW50V2lkdGhcIixcbiAgICBcInBhZ2VYXCIsXG4gICAgXCJyYWlsWFdpZHRoXCIsXG4gICAgXCJzY3JvbGxiYXJYXCIsXG4gICAgXCJzY3JvbGxiYXJYV2lkdGhcIixcbiAgICBcInNjcm9sbExlZnRcIixcbiAgICBcInhcIixcbiAgICBcInNjcm9sbGJhclhSYWlsXCJcbiAgXSksIFhyKHMsIFtcbiAgICBcImNvbnRhaW5lckhlaWdodFwiLFxuICAgIFwiY29udGVudEhlaWdodFwiLFxuICAgIFwicGFnZVlcIixcbiAgICBcInJhaWxZSGVpZ2h0XCIsXG4gICAgXCJzY3JvbGxiYXJZXCIsXG4gICAgXCJzY3JvbGxiYXJZSGVpZ2h0XCIsXG4gICAgXCJzY3JvbGxUb3BcIixcbiAgICBcInlcIixcbiAgICBcInNjcm9sbGJhcllSYWlsXCJcbiAgXSk7XG59XG5mdW5jdGlvbiBYcihzLCB0KSB7XG4gIHZhciBlID0gdFswXSwgaSA9IHRbMV0sIG4gPSB0WzJdLCBvID0gdFszXSwgciA9IHRbNF0sIGEgPSB0WzVdLCBsID0gdFs2XSwgYyA9IHRbN10sIGQgPSB0WzhdLCBfID0gcy5lbGVtZW50LCBmID0gbnVsbCwgbSA9IG51bGwsIGcgPSBudWxsO1xuICBmdW5jdGlvbiBiKHcpIHtcbiAgICB3LnRvdWNoZXMgJiYgdy50b3VjaGVzWzBdICYmICh3W25dID0gdy50b3VjaGVzWzBdLnBhZ2VZKSwgX1tsXSA9IGYgKyBnICogKHdbbl0gLSBtKSwgd2wocywgYyksIE10KHMpLCB3LnN0b3BQcm9wYWdhdGlvbigpLCB3LnR5cGUuc3RhcnRzV2l0aChcInRvdWNoXCIpICYmIHcuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMSAmJiB3LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZnVuY3Rpb24gVCgpIHtcbiAgICBrbChzLCBjKSwgc1tkXS5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuY2xpY2tpbmcpLCBzLmV2ZW50LnVuYmluZChzLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIEModywgdikge1xuICAgIGYgPSBfW2xdLCB2ICYmIHcudG91Y2hlcyAmJiAod1tuXSA9IHcudG91Y2hlc1swXS5wYWdlWSksIG0gPSB3W25dLCBnID0gKHNbaV0gLSBzW2VdKSAvIChzW29dIC0gc1thXSksIHYgPyBzLmV2ZW50LmJpbmQocy5vd25lckRvY3VtZW50LCBcInRvdWNobW92ZVwiLCBiKSA6IChzLmV2ZW50LmJpbmQocy5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBiKSwgcy5ldmVudC5vbmNlKHMub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIFQpLCB3LnByZXZlbnREZWZhdWx0KCkpLCBzW2RdLmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5jbGlja2luZyksIHcuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgcy5ldmVudC5iaW5kKHNbcl0sIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHcpIHtcbiAgICBDKHcpO1xuICB9KSwgcy5ldmVudC5iaW5kKHNbcl0sIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbih3KSB7XG4gICAgQyh3LCAhMCk7XG4gIH0pO1xufVxuZnVuY3Rpb24geV8ocykge1xuICB2YXIgdCA9IHMuZWxlbWVudCwgZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB6dCh0LCBcIjpob3ZlclwiKTtcbiAgfSwgaSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB6dChzLnNjcm9sbGJhclgsIFwiOmZvY3VzXCIpIHx8IHp0KHMuc2Nyb2xsYmFyWSwgXCI6Zm9jdXNcIik7XG4gIH07XG4gIGZ1bmN0aW9uIG4obywgcikge1xuICAgIHZhciBhID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCk7XG4gICAgaWYgKG8gPT09IDApIHtcbiAgICAgIGlmICghcy5zY3JvbGxiYXJZQWN0aXZlKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAoYSA9PT0gMCAmJiByID4gMCB8fCBhID49IHMuY29udGVudEhlaWdodCAtIHMuY29udGFpbmVySGVpZ2h0ICYmIHIgPCAwKVxuICAgICAgICByZXR1cm4gIXMuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICB9XG4gICAgdmFyIGwgPSB0LnNjcm9sbExlZnQ7XG4gICAgaWYgKHIgPT09IDApIHtcbiAgICAgIGlmICghcy5zY3JvbGxiYXJYQWN0aXZlKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAobCA9PT0gMCAmJiBvIDwgMCB8fCBsID49IHMuY29udGVudFdpZHRoIC0gcy5jb250YWluZXJXaWR0aCAmJiBvID4gMClcbiAgICAgICAgcmV0dXJuICFzLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICBzLmV2ZW50LmJpbmQocy5vd25lckRvY3VtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24obykge1xuICAgIGlmICghKG8uaXNEZWZhdWx0UHJldmVudGVkICYmIG8uaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgby5kZWZhdWx0UHJldmVudGVkKSAmJiAhKCFlKCkgJiYgIWkoKSkpIHtcbiAgICAgIHZhciByID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA/IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBzLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIGlmIChyLnRhZ05hbWUgPT09IFwiSUZSQU1FXCIpXG4gICAgICAgICAgciA9IHIuY29udGVudERvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKDsgci5zaGFkb3dSb290OyApXG4gICAgICAgICAgICByID0gci5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmICh2XyhyKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYSA9IDAsIGwgPSAwO1xuICAgICAgc3dpdGNoIChvLndoaWNoKSB7XG4gICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgby5tZXRhS2V5ID8gYSA9IC1zLmNvbnRlbnRXaWR0aCA6IG8uYWx0S2V5ID8gYSA9IC1zLmNvbnRhaW5lcldpZHRoIDogYSA9IC0zMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBsID0gcy5jb250ZW50SGVpZ2h0IDogby5hbHRLZXkgPyBsID0gcy5jb250YWluZXJIZWlnaHQgOiBsID0gMzA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgby5tZXRhS2V5ID8gYSA9IHMuY29udGVudFdpZHRoIDogby5hbHRLZXkgPyBhID0gcy5jb250YWluZXJXaWR0aCA6IGEgPSAzMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBsID0gLXMuY29udGVudEhlaWdodCA6IG8uYWx0S2V5ID8gbCA9IC1zLmNvbnRhaW5lckhlaWdodCA6IGwgPSAtMzA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgby5zaGlmdEtleSA/IGwgPSBzLmNvbnRhaW5lckhlaWdodCA6IGwgPSAtcy5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgbCA9IHMuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgIGwgPSAtcy5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgbCA9IHMuY29udGVudEhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICBsID0gLXMuY29udGVudEhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWCAmJiBhICE9PSAwIHx8IHMuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxZICYmIGwgIT09IDAgfHwgKHQuc2Nyb2xsVG9wIC09IGwsIHQuc2Nyb2xsTGVmdCArPSBhLCBNdChzKSwgbihhLCBsKSAmJiBvLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB3XyhzKSB7XG4gIHZhciB0ID0gcy5lbGVtZW50O1xuICBmdW5jdGlvbiBlKHIsIGEpIHtcbiAgICB2YXIgbCA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCBjID0gdC5zY3JvbGxUb3AgPT09IDAsIGQgPSBsICsgdC5vZmZzZXRIZWlnaHQgPT09IHQuc2Nyb2xsSGVpZ2h0LCBfID0gdC5zY3JvbGxMZWZ0ID09PSAwLCBmID0gdC5zY3JvbGxMZWZ0ICsgdC5vZmZzZXRXaWR0aCA9PT0gdC5zY3JvbGxXaWR0aCwgbTtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSkgPiBNYXRoLmFicyhyKSA/IG0gPSBjIHx8IGQgOiBtID0gXyB8fCBmLCBtID8gIXMuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbiA6ICEwO1xuICB9XG4gIGZ1bmN0aW9uIGkocikge1xuICAgIHZhciBhID0gci5kZWx0YVgsIGwgPSAtMSAqIHIuZGVsdGFZO1xuICAgIHJldHVybiAodHlwZW9mIGEgPiBcInVcIiB8fCB0eXBlb2YgbCA+IFwidVwiKSAmJiAoYSA9IC0xICogci53aGVlbERlbHRhWCAvIDYsIGwgPSByLndoZWVsRGVsdGFZIC8gNiksIHIuZGVsdGFNb2RlICYmIHIuZGVsdGFNb2RlID09PSAxICYmIChhICo9IDEwLCBsICo9IDEwKSwgYSAhPT0gYSAmJiBsICE9PSBsICYmIChhID0gMCwgbCA9IHIud2hlZWxEZWx0YSksIHIuc2hpZnRLZXkgPyBbLWwsIC1hXSA6IFthLCBsXTtcbiAgfVxuICBmdW5jdGlvbiBuKHIsIGEsIGwpIHtcbiAgICBpZiAoIWtlLmlzV2ViS2l0ICYmIHQucXVlcnlTZWxlY3RvcihcInNlbGVjdDpmb2N1c1wiKSlcbiAgICAgIHJldHVybiAhMDtcbiAgICBpZiAoIXQuY29udGFpbnMocikpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yICh2YXIgYyA9IHI7IGMgJiYgYyAhPT0gdDsgKSB7XG4gICAgICBpZiAoYy5jbGFzc0xpc3QuY29udGFpbnMoai5lbGVtZW50LmNvbnN1bWluZykpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHZhciBkID0geHQoYyk7XG4gICAgICBpZiAobCAmJiBkLm92ZXJmbG93WS5tYXRjaCgvKHNjcm9sbHxhdXRvKS8pKSB7XG4gICAgICAgIHZhciBfID0gYy5zY3JvbGxIZWlnaHQgLSBjLmNsaWVudEhlaWdodDtcbiAgICAgICAgaWYgKF8gPiAwICYmIChjLnNjcm9sbFRvcCA+IDAgJiYgbCA8IDAgfHwgYy5zY3JvbGxUb3AgPCBfICYmIGwgPiAwKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBpZiAoYSAmJiBkLm92ZXJmbG93WC5tYXRjaCgvKHNjcm9sbHxhdXRvKS8pKSB7XG4gICAgICAgIHZhciBmID0gYy5zY3JvbGxXaWR0aCAtIGMuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmIChmID4gMCAmJiAoYy5zY3JvbGxMZWZ0ID4gMCAmJiBhIDwgMCB8fCBjLnNjcm9sbExlZnQgPCBmICYmIGEgPiAwKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBjID0gYy5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gbyhyKSB7XG4gICAgdmFyIGEgPSBpKHIpLCBsID0gYVswXSwgYyA9IGFbMV07XG4gICAgaWYgKCFuKHIudGFyZ2V0LCBsLCBjKSkge1xuICAgICAgdmFyIGQgPSAhMTtcbiAgICAgIHMuc2V0dGluZ3MudXNlQm90aFdoZWVsQXhlcyA/IHMuc2Nyb2xsYmFyWUFjdGl2ZSAmJiAhcy5zY3JvbGxiYXJYQWN0aXZlID8gKGMgPyB0LnNjcm9sbFRvcCAtPSBjICogcy5zZXR0aW5ncy53aGVlbFNwZWVkIDogdC5zY3JvbGxUb3AgKz0gbCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCwgZCA9ICEwKSA6IHMuc2Nyb2xsYmFyWEFjdGl2ZSAmJiAhcy5zY3JvbGxiYXJZQWN0aXZlICYmIChsID8gdC5zY3JvbGxMZWZ0ICs9IGwgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQgOiB0LnNjcm9sbExlZnQgLT0gYyAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCwgZCA9ICEwKSA6ICh0LnNjcm9sbFRvcCAtPSBjICogcy5zZXR0aW5ncy53aGVlbFNwZWVkLCB0LnNjcm9sbExlZnQgKz0gbCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCksIE10KHMpLCBkID0gZCB8fCBlKGwsIGMpLCBkICYmICFyLmN0cmxLZXkgJiYgKHIuc3RvcFByb3BhZ2F0aW9uKCksIHIucHJldmVudERlZmF1bHQoKSk7XG4gICAgfVxuICB9XG4gIHR5cGVvZiB3aW5kb3cub253aGVlbCA8IFwidVwiID8gcy5ldmVudC5iaW5kKHQsIFwid2hlZWxcIiwgbykgOiB0eXBlb2Ygd2luZG93Lm9ubW91c2V3aGVlbCA8IFwidVwiICYmIHMuZXZlbnQuYmluZCh0LCBcIm1vdXNld2hlZWxcIiwgbyk7XG59XG5mdW5jdGlvbiBrXyhzKSB7XG4gIGlmICgha2Uuc3VwcG9ydHNUb3VjaCAmJiAha2Uuc3VwcG9ydHNJZVBvaW50ZXIpXG4gICAgcmV0dXJuO1xuICB2YXIgdCA9IHMuZWxlbWVudDtcbiAgZnVuY3Rpb24gZShnLCBiKSB7XG4gICAgdmFyIFQgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKSwgQyA9IHQuc2Nyb2xsTGVmdCwgdyA9IE1hdGguYWJzKGcpLCB2ID0gTWF0aC5hYnMoYik7XG4gICAgaWYgKHYgPiB3KSB7XG4gICAgICBpZiAoYiA8IDAgJiYgVCA9PT0gcy5jb250ZW50SGVpZ2h0IC0gcy5jb250YWluZXJIZWlnaHQgfHwgYiA+IDAgJiYgVCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZID09PSAwICYmIGIgPiAwICYmIGtlLmlzQ2hyb21lO1xuICAgIH0gZWxzZSBpZiAodyA+IHYgJiYgKGcgPCAwICYmIEMgPT09IHMuY29udGVudFdpZHRoIC0gcy5jb250YWluZXJXaWR0aCB8fCBnID4gMCAmJiBDID09PSAwKSlcbiAgICAgIHJldHVybiAhMDtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgZnVuY3Rpb24gaShnLCBiKSB7XG4gICAgdC5zY3JvbGxUb3AgLT0gYiwgdC5zY3JvbGxMZWZ0IC09IGcsIE10KHMpO1xuICB9XG4gIHZhciBuID0ge30sIG8gPSAwLCByID0ge30sIGEgPSBudWxsO1xuICBmdW5jdGlvbiBsKGcpIHtcbiAgICByZXR1cm4gZy50YXJnZXRUb3VjaGVzID8gZy50YXJnZXRUb3VjaGVzWzBdIDogZztcbiAgfVxuICBmdW5jdGlvbiBjKGcpIHtcbiAgICByZXR1cm4gZy5wb2ludGVyVHlwZSAmJiBnLnBvaW50ZXJUeXBlID09PSBcInBlblwiICYmIGcuYnV0dG9ucyA9PT0gMCA/ICExIDogISEoZy50YXJnZXRUb3VjaGVzICYmIGcudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEgfHwgZy5wb2ludGVyVHlwZSAmJiBnLnBvaW50ZXJUeXBlICE9PSBcIm1vdXNlXCIgJiYgZy5wb2ludGVyVHlwZSAhPT0gZy5NU1BPSU5URVJfVFlQRV9NT1VTRSk7XG4gIH1cbiAgZnVuY3Rpb24gZChnKSB7XG4gICAgaWYgKGMoZykpIHtcbiAgICAgIHZhciBiID0gbChnKTtcbiAgICAgIG4ucGFnZVggPSBiLnBhZ2VYLCBuLnBhZ2VZID0gYi5wYWdlWSwgbyA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpLCBhICE9PSBudWxsICYmIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF8oZywgYiwgVCkge1xuICAgIGlmICghdC5jb250YWlucyhnKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKHZhciBDID0gZzsgQyAmJiBDICE9PSB0OyApIHtcbiAgICAgIGlmIChDLmNsYXNzTGlzdC5jb250YWlucyhqLmVsZW1lbnQuY29uc3VtaW5nKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgdmFyIHcgPSB4dChDKTtcbiAgICAgIGlmIChUICYmIHcub3ZlcmZsb3dZLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIHYgPSBDLnNjcm9sbEhlaWdodCAtIEMuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAodiA+IDAgJiYgKEMuc2Nyb2xsVG9wID4gMCAmJiBUIDwgMCB8fCBDLnNjcm9sbFRvcCA8IHYgJiYgVCA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChiICYmIHcub3ZlcmZsb3dYLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIEUgPSBDLnNjcm9sbFdpZHRoIC0gQy5jbGllbnRXaWR0aDtcbiAgICAgICAgaWYgKEUgPiAwICYmIChDLnNjcm9sbExlZnQgPiAwICYmIGIgPCAwIHx8IEMuc2Nyb2xsTGVmdCA8IEUgJiYgYiA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIEMgPSBDLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBmKGcpIHtcbiAgICBpZiAoYyhnKSkge1xuICAgICAgdmFyIGIgPSBsKGcpLCBUID0geyBwYWdlWDogYi5wYWdlWCwgcGFnZVk6IGIucGFnZVkgfSwgQyA9IFQucGFnZVggLSBuLnBhZ2VYLCB3ID0gVC5wYWdlWSAtIG4ucGFnZVk7XG4gICAgICBpZiAoXyhnLnRhcmdldCwgQywgdykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGkoQywgdyksIG4gPSBUO1xuICAgICAgdmFyIHYgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSwgRSA9IHYgLSBvO1xuICAgICAgRSA+IDAgJiYgKHIueCA9IEMgLyBFLCByLnkgPSB3IC8gRSwgbyA9IHYpLCBlKEMsIHcpICYmIGcucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbSgpIHtcbiAgICBzLnNldHRpbmdzLnN3aXBlRWFzaW5nICYmIChjbGVhckludGVydmFsKGEpLCBhID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghci54ICYmICFyLnkpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHIueCkgPCAwLjAxICYmIE1hdGguYWJzKHIueSkgPCAwLjAxKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghcy5lbGVtZW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGkoci54ICogMzAsIHIueSAqIDMwKSwgci54ICo9IDAuOCwgci55ICo9IDAuODtcbiAgICB9LCAxMCkpO1xuICB9XG4gIGtlLnN1cHBvcnRzVG91Y2ggPyAocy5ldmVudC5iaW5kKHQsIFwidG91Y2hzdGFydFwiLCBkKSwgcy5ldmVudC5iaW5kKHQsIFwidG91Y2htb3ZlXCIsIGYpLCBzLmV2ZW50LmJpbmQodCwgXCJ0b3VjaGVuZFwiLCBtKSkgOiBrZS5zdXBwb3J0c0llUG9pbnRlciAmJiAod2luZG93LlBvaW50ZXJFdmVudCA/IChzLmV2ZW50LmJpbmQodCwgXCJwb2ludGVyZG93blwiLCBkKSwgcy5ldmVudC5iaW5kKHQsIFwicG9pbnRlcm1vdmVcIiwgZiksIHMuZXZlbnQuYmluZCh0LCBcInBvaW50ZXJ1cFwiLCBtKSkgOiB3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgKHMuZXZlbnQuYmluZCh0LCBcIk1TUG9pbnRlckRvd25cIiwgZCksIHMuZXZlbnQuYmluZCh0LCBcIk1TUG9pbnRlck1vdmVcIiwgZiksIHMuZXZlbnQuYmluZCh0LCBcIk1TUG9pbnRlclVwXCIsIG0pKSk7XG59XG52YXIgT18gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVyczogW1wiY2xpY2stcmFpbFwiLCBcImRyYWctdGh1bWJcIiwgXCJrZXlib2FyZFwiLCBcIndoZWVsXCIsIFwidG91Y2hcIl0sXG4gICAgbWF4U2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICAgIG1pblNjcm9sbGJhckxlbmd0aDogbnVsbCxcbiAgICBzY3JvbGxpbmdUaHJlc2hvbGQ6IDFlMyxcbiAgICBzY3JvbGxYTWFyZ2luT2Zmc2V0OiAwLFxuICAgIHNjcm9sbFlNYXJnaW5PZmZzZXQ6IDAsXG4gICAgc3VwcHJlc3NTY3JvbGxYOiAhMSxcbiAgICBzdXBwcmVzc1Njcm9sbFk6ICExLFxuICAgIHN3aXBlRWFzaW5nOiAhMCxcbiAgICB1c2VCb3RoV2hlZWxBeGVzOiAhMSxcbiAgICB3aGVlbFByb3BhZ2F0aW9uOiAhMCxcbiAgICB3aGVlbFNwZWVkOiAxXG4gIH07XG59LCB4XyA9IHtcbiAgXCJjbGljay1yYWlsXCI6IENfLFxuICBcImRyYWctdGh1bWJcIjogQV8sXG4gIGtleWJvYXJkOiB5XyxcbiAgd2hlZWw6IHdfLFxuICB0b3VjaDoga19cbn0sIFRpID0gZnVuY3Rpb24odCwgZSkge1xuICB2YXIgaSA9IHRoaXM7XG4gIGlmIChlID09PSB2b2lkIDAgJiYgKGUgPSB7fSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpKSwgIXQgfHwgIXQubm9kZU5hbWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm8gZWxlbWVudCBpcyBzcGVjaWZpZWQgdG8gaW5pdGlhbGl6ZSBQZXJmZWN0U2Nyb2xsYmFyXCIpO1xuICB0aGlzLmVsZW1lbnQgPSB0LCB0LmNsYXNzTGlzdC5hZGQoai5tYWluKSwgdGhpcy5zZXR0aW5ncyA9IE9fKCk7XG4gIGZvciAodmFyIG4gaW4gZSlcbiAgICB0aGlzLnNldHRpbmdzW25dID0gZVtuXTtcbiAgdGhpcy5jb250YWluZXJXaWR0aCA9IG51bGwsIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gbnVsbCwgdGhpcy5jb250ZW50V2lkdGggPSBudWxsLCB0aGlzLmNvbnRlbnRIZWlnaHQgPSBudWxsO1xuICB2YXIgbyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5mb2N1cyk7XG4gIH0sIHIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuZm9jdXMpO1xuICB9O1xuICB0aGlzLmlzUnRsID0geHQodCkuZGlyZWN0aW9uID09PSBcInJ0bFwiLCB0aGlzLmlzUnRsID09PSAhMCAmJiB0LmNsYXNzTGlzdC5hZGQoai5ydGwpLCB0aGlzLmlzTmVnYXRpdmVTY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYyA9IHQuc2Nyb2xsTGVmdCwgZCA9IG51bGw7XG4gICAgcmV0dXJuIHQuc2Nyb2xsTGVmdCA9IC0xLCBkID0gdC5zY3JvbGxMZWZ0IDwgMCwgdC5zY3JvbGxMZWZ0ID0gYywgZDtcbiAgfSgpLCB0aGlzLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCA9IHRoaXMuaXNOZWdhdGl2ZVNjcm9sbCA/IHQuc2Nyb2xsV2lkdGggLSB0LmNsaWVudFdpZHRoIDogMCwgdGhpcy5ldmVudCA9IG5ldyBVZSgpLCB0aGlzLm93bmVyRG9jdW1lbnQgPSB0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQsIHRoaXMuc2Nyb2xsYmFyWFJhaWwgPSBxaShqLmVsZW1lbnQucmFpbChcInhcIikpLCB0LmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWFJhaWwpLCB0aGlzLnNjcm9sbGJhclggPSBxaShqLmVsZW1lbnQudGh1bWIoXCJ4XCIpKSwgdGhpcy5zY3JvbGxiYXJYUmFpbC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclgpLCB0aGlzLnNjcm9sbGJhclguc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclgsIFwiZm9jdXNcIiwgbyksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclgsIFwiYmx1clwiLCByKSwgdGhpcy5zY3JvbGxiYXJYQWN0aXZlID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJYV2lkdGggPSBudWxsLCB0aGlzLnNjcm9sbGJhclhMZWZ0ID0gbnVsbDtcbiAgdmFyIGEgPSB4dCh0aGlzLnNjcm9sbGJhclhSYWlsKTtcbiAgdGhpcy5zY3JvbGxiYXJYQm90dG9tID0gcGFyc2VJbnQoYS5ib3R0b20sIDEwKSwgaXNOYU4odGhpcy5zY3JvbGxiYXJYQm90dG9tKSA/ICh0aGlzLmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tID0gITEsIHRoaXMuc2Nyb2xsYmFyWFRvcCA9IFcoYS50b3ApKSA6IHRoaXMuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPSAhMCwgdGhpcy5yYWlsQm9yZGVyWFdpZHRoID0gVyhhLmJvcmRlckxlZnRXaWR0aCkgKyBXKGEuYm9yZGVyUmlnaHRXaWR0aCksIG90KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCB0aGlzLnJhaWxYTWFyZ2luV2lkdGggPSBXKGEubWFyZ2luTGVmdCkgKyBXKGEubWFyZ2luUmlnaHQpLCBvdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSksIHRoaXMucmFpbFhXaWR0aCA9IG51bGwsIHRoaXMucmFpbFhSYXRpbyA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWVJhaWwgPSBxaShqLmVsZW1lbnQucmFpbChcInlcIikpLCB0LmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWVJhaWwpLCB0aGlzLnNjcm9sbGJhclkgPSBxaShqLmVsZW1lbnQudGh1bWIoXCJ5XCIpKSwgdGhpcy5zY3JvbGxiYXJZUmFpbC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclkpLCB0aGlzLnNjcm9sbGJhclkuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclksIFwiZm9jdXNcIiwgbyksIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclksIFwiYmx1clwiLCByKSwgdGhpcy5zY3JvbGxiYXJZQWN0aXZlID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZSGVpZ2h0ID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZVG9wID0gbnVsbDtcbiAgdmFyIGwgPSB4dCh0aGlzLnNjcm9sbGJhcllSYWlsKTtcbiAgdGhpcy5zY3JvbGxiYXJZUmlnaHQgPSBwYXJzZUludChsLnJpZ2h0LCAxMCksIGlzTmFOKHRoaXMuc2Nyb2xsYmFyWVJpZ2h0KSA/ICh0aGlzLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPSAhMSwgdGhpcy5zY3JvbGxiYXJZTGVmdCA9IFcobC5sZWZ0KSkgOiB0aGlzLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPSAhMCwgdGhpcy5zY3JvbGxiYXJZT3V0ZXJXaWR0aCA9IHRoaXMuaXNSdGwgPyBFXyh0aGlzLnNjcm9sbGJhclkpIDogbnVsbCwgdGhpcy5yYWlsQm9yZGVyWVdpZHRoID0gVyhsLmJvcmRlclRvcFdpZHRoKSArIFcobC5ib3JkZXJCb3R0b21XaWR0aCksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCB0aGlzLnJhaWxZTWFyZ2luSGVpZ2h0ID0gVyhsLm1hcmdpblRvcCkgKyBXKGwubWFyZ2luQm90dG9tKSwgb3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcIlwiIH0pLCB0aGlzLnJhaWxZSGVpZ2h0ID0gbnVsbCwgdGhpcy5yYWlsWVJhdGlvID0gbnVsbCwgdGhpcy5yZWFjaCA9IHtcbiAgICB4OiB0LnNjcm9sbExlZnQgPD0gMCA/IFwic3RhcnRcIiA6IHQuc2Nyb2xsTGVmdCA+PSB0aGlzLmNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGFpbmVyV2lkdGggPyBcImVuZFwiIDogbnVsbCxcbiAgICB5OiB0LnNjcm9sbFRvcCA8PSAwID8gXCJzdGFydFwiIDogdC5zY3JvbGxUb3AgPj0gdGhpcy5jb250ZW50SGVpZ2h0IC0gdGhpcy5jb250YWluZXJIZWlnaHQgPyBcImVuZFwiIDogbnVsbFxuICB9LCB0aGlzLmlzQWxpdmUgPSAhMCwgdGhpcy5zZXR0aW5ncy5oYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4geF9bY10oaSk7XG4gIH0pLCB0aGlzLmxhc3RTY3JvbGxUb3AgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKSwgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IHQuc2Nyb2xsTGVmdCwgdGhpcy5ldmVudC5iaW5kKHRoaXMuZWxlbWVudCwgXCJzY3JvbGxcIiwgZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBpLm9uU2Nyb2xsKGMpO1xuICB9KSwgTXQodGhpcyk7XG59O1xuVGkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlzQWxpdmUgJiYgKHRoaXMubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ID0gdGhpcy5pc05lZ2F0aXZlU2Nyb2xsID8gdGhpcy5lbGVtZW50LnNjcm9sbFdpZHRoIC0gdGhpcy5lbGVtZW50LmNsaWVudFdpZHRoIDogMCwgb3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCB0aGlzLnJhaWxYTWFyZ2luV2lkdGggPSBXKHh0KHRoaXMuc2Nyb2xsYmFyWFJhaWwpLm1hcmdpbkxlZnQpICsgVyh4dCh0aGlzLnNjcm9sbGJhclhSYWlsKS5tYXJnaW5SaWdodCksIHRoaXMucmFpbFlNYXJnaW5IZWlnaHQgPSBXKHh0KHRoaXMuc2Nyb2xsYmFyWVJhaWwpLm1hcmdpblRvcCkgKyBXKHh0KHRoaXMuc2Nyb2xsYmFyWVJhaWwpLm1hcmdpbkJvdHRvbSksIG90KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJub25lXCIgfSksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJub25lXCIgfSksIE10KHRoaXMpLCB5cyh0aGlzLCBcInRvcFwiLCAwLCAhMSwgITApLCB5cyh0aGlzLCBcImxlZnRcIiwgMCwgITEsICEwKSwgb3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcIlwiIH0pLCBvdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSkpO1xufTtcblRpLnByb3RvdHlwZS5vblNjcm9sbCA9IGZ1bmN0aW9uKHQpIHtcbiAgdGhpcy5pc0FsaXZlICYmIChNdCh0aGlzKSwgeXModGhpcywgXCJ0b3BcIiwgdGhpcy5lbGVtZW50LnNjcm9sbFRvcCAtIHRoaXMubGFzdFNjcm9sbFRvcCksIHlzKFxuICAgIHRoaXMsXG4gICAgXCJsZWZ0XCIsXG4gICAgdGhpcy5lbGVtZW50LnNjcm9sbExlZnQgLSB0aGlzLmxhc3RTY3JvbGxMZWZ0XG4gICksIHRoaXMubGFzdFNjcm9sbFRvcCA9IE1hdGguZmxvb3IodGhpcy5lbGVtZW50LnNjcm9sbFRvcCksIHRoaXMubGFzdFNjcm9sbExlZnQgPSB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCk7XG59O1xuVGkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pc0FsaXZlICYmICh0aGlzLmV2ZW50LnVuYmluZEFsbCgpLCBTZSh0aGlzLnNjcm9sbGJhclgpLCBTZSh0aGlzLnNjcm9sbGJhclkpLCBTZSh0aGlzLnNjcm9sbGJhclhSYWlsKSwgU2UodGhpcy5zY3JvbGxiYXJZUmFpbCksIHRoaXMucmVtb3ZlUHNDbGFzc2VzKCksIHRoaXMuZWxlbWVudCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWSA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWFJhaWwgPSBudWxsLCB0aGlzLnNjcm9sbGJhcllSYWlsID0gbnVsbCwgdGhpcy5pc0FsaXZlID0gITEpO1xufTtcblRpLnByb3RvdHlwZS5yZW1vdmVQc0NsYXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMuZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICF0Lm1hdGNoKC9ecHMoWy1fXS4rfCkkLyk7XG4gIH0pLmpvaW4oXCIgXCIpO1xufTtcbmNvbnN0IFNfID0ge1xuICB0aHJlc2hvbGQ6IDEwLFxuICBkaXJlY3Rpb246IFwiYWxsXCJcbn07XG5jbGFzcyBEXyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAuLi5TXyxcbiAgICAgIC4uLmVcbiAgICB9O1xuICB9XG4gIGhhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0KTtcbiAgfVxuICBoYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIGlmICghdGhpcy5fc3RhcnRQb3NpdGlvbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCksIGkgPSB7XG4gICAgICB4OiBlLnggLSB0aGlzLl9zdGFydFBvc2l0aW9uLngsXG4gICAgICB5OiBlLnkgLSB0aGlzLl9zdGFydFBvc2l0aW9uLnlcbiAgICB9LCBuID0gdGhpcy5fZ2V0RGlyZWN0aW9uKGkpO1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmRpcmVjdGlvbiA9PT0gXCJhbGxcIikge1xuICAgICAgaWYgKG4ueS52YWx1ZSA8IHRoaXMuX29wdGlvbnMudGhyZXNob2xkICYmIG4ueC52YWx1ZSA8IHRoaXMuX29wdGlvbnMudGhyZXNob2xkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gbi55LnZhbHVlID4gbi54LnZhbHVlID8gbi55LmRpcmVjdGlvbiA6IG4ueC5kaXJlY3Rpb247XG4gICAgICB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYHN3aXBlJHtyfWApLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJzd2lwZVwiLCB7IGRpcmVjdGlvbjogciB9KSwgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0aGlzLl9vcHRpb25zLmRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgfHwgdGhpcy5fb3B0aW9ucyA9PT0gXCJyaWdodFwiID8gXCJ4XCIgOiBcInlcIjtcbiAgICBuW29dLmRpcmVjdGlvbiA9PT0gdGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gJiYgbltvXS52YWx1ZSA+IHRoaXMuX29wdGlvbnMudGhyZXNob2xkICYmICh1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYHN3aXBlJHtuW29dLmRpcmVjdGlvbn1gKSwgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGwpO1xuICB9XG4gIGhhbmRsZVRvdWNoRW5kKCkge1xuICAgIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsO1xuICB9XG4gIF9nZXRDb29yZGluYXRlcyh0KSB7XG4gICAgY29uc3QgW2VdID0gdC50b3VjaGVzO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBlLmNsaWVudFgsXG4gICAgICB5OiBlLmNsaWVudFlcbiAgICB9O1xuICB9XG4gIF9nZXREaXJlY3Rpb24odCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB7XG4gICAgICAgIGRpcmVjdGlvbjogdC54IDwgMCA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICB2YWx1ZTogTWF0aC5hYnModC54KVxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgZGlyZWN0aW9uOiB0LnkgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIsXG4gICAgICAgIHZhbHVlOiBNYXRoLmFicyh0LnkpXG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgSV8ge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0gXCJzd2lwZVwiLCBpID0ge30pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZXZlbnQgPSBlLCB0aGlzLnN3aXBlID0gbmV3IERfKHQsIGkpLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciA9IHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQuYmluZCh0aGlzKSwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciA9IHRoaXMuX2hhbmRsZVRvdWNoTW92ZS5iaW5kKHRoaXMpLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVUb3VjaEVuZC5iaW5kKHRoaXMpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciksIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl90b3VjaE1vdmVIYW5kbGVyKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hTdGFydCh0KVxuICAgICksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hNb3ZlKHQpXG4gICAgKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hFbmQodCkpO1xuICB9XG4gIF9oYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaFN0YXJ0KHQpO1xuICB9XG4gIF9oYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoTW92ZSh0KTtcbiAgfVxuICBfaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoRW5kKHQpO1xuICB9XG59XG5jb25zdCAkXyA9IFwiZ3JvdXAvcHMgb3ZlcmZsb3ctaGlkZGVuIFtvdmVyZmxvdy1hbmNob3I6bm9uZV0gW292ZXJmbG93LXN0eWxlOm5vbmVdIHRvdWNoLW5vbmVcIiwgTF8gPSBcImdyb3VwL3ggYWJzb2x1dGUgYm90dG9tLTAgIXRvcC1hdXRvIGgtWzE1cHhdIGhpZGRlbiBvcGFjaXR5LTAgW3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvcl8uMnNfbGluZWFyLF9vcGFjaXR5Xy4yc19saW5lYXJdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGdyb3VwLVsmLnBzLS1hY3RpdmUteF0vcHM6YmxvY2sgZ3JvdXAtWyYucHMtLWFjdGl2ZS14XS9wczpiZy10cmFuc3BhcmVudCBncm91cC1ob3Zlci9wczpvcGFjaXR5LTYwIGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktNjAgZ3JvdXAtWyYucHMtLXNjcm9sbGluZy14XS9wczpvcGFjaXR5LTYwIGhvdmVyOiFvcGFjaXR5LTkwIGhvdmVyOmJnLVsjZWVlXSBmb2N1czohb3BhY2l0eS05MCBmb2N1czpiZy1bI2VlZV0gWyYucHMtLWNsaWNraW5nXTohb3BhY2l0eS05MCBbJi5wcy0tY2xpY2tpbmddOmJnLVsjZWVlXSBvdXRsaW5lLW5vbmVcIiwgTV8gPSBcImFic29sdXRlIGJvdHRvbS1bMnB4XSByb3VuZGVkLW1kIGgtMS41IG9wYWNpdHktMCBncm91cC1ob3Zlci9wczpvcGFjaXR5LTEwMCBncm91cC1mb2N1cy9wczpvcGFjaXR5LTEwMCBncm91cC1hY3RpdmUvcHM6b3BhY2l0eS0xMDAgYmctWyNhYWFdIFt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3JfLjJzX2xpbmVhcixfaGVpZ2h0Xy4yc19lYXNlLWluLW91dF0gZ3JvdXAtaG92ZXIveDpiZy1bIzk5OV0gZ3JvdXAtaG92ZXIveDpoLVsxMXB4XSBncm91cC1mb2N1cy94OmJnLVsjOTk5XSBncm91cC1mb2N1cy94OmgtWzExcHhdIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veDpiZy1bIzk5OV0gZ3JvdXAtWyYucHMtLWNsaWNraW5nXS94OmgtWzExcHhdIG91dGxpbmUtbm9uZVwiLCBOXyA9IFwiZ3JvdXAveSBhYnNvbHV0ZSByaWdodC0wICFsZWZ0LWF1dG8gdy1bMTVweF0gaGlkZGVuIG9wYWNpdHktMCBbdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yXy4yc19saW5lYXIsX29wYWNpdHlfLjJzX2xpbmVhcl0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZ3JvdXAtWyYucHMtLWFjdGl2ZS15XS9wczpibG9jayBncm91cC1bJi5wcy0tYWN0aXZlLXldL3BzOmJnLXRyYW5zcGFyZW50IGdyb3VwLWhvdmVyL3BzOm9wYWNpdHktNjAgZ3JvdXAtZm9jdXMvcHM6b3BhY2l0eS02MCBncm91cC1bJi5wcy0tc2Nyb2xsaW5nLXldL3BzOm9wYWNpdHktNjAgaG92ZXI6IW9wYWNpdHktOTAgaG92ZXI6YmctWyNlZWVdIGZvY3VzOiFvcGFjaXR5LTkwIGZvY3VzOmJnLVsjZWVlXSBbJi5wcy0tY2xpY2tpbmddOiFvcGFjaXR5LTkwIFsmLnBzLS1jbGlja2luZ106YmctWyNlZWVdIG91dGxpbmUtbm9uZVwiLCBSXyA9IFwiYWJzb2x1dGUgcmlnaHQtWzJweF0gcm91bmRlZC1tZCB3LTEuNSBvcGFjaXR5LTAgZ3JvdXAtaG92ZXIvcHM6b3BhY2l0eS0xMDAgZ3JvdXAtZm9jdXMvcHM6b3BhY2l0eS0xMDAgZ3JvdXAtYWN0aXZlL3BzOm9wYWNpdHktMTAwIGJnLVsjYWFhXSBbdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yXy4yc19saW5lYXIsX3dpZHRoXy4yc19lYXNlLWluLW91dF0gZ3JvdXAtaG92ZXIveTpiZy1bIzk5OV0gZ3JvdXAtaG92ZXIveTp3LVsxMXB4XSBncm91cC1mb2N1cy95OmJnLVsjOTk5XSBncm91cC1mb2N1cy95OnctWzExcHhdIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veTpiZy1bIzk5OV0gZ3JvdXAtWyYucHMtLWNsaWNraW5nXS95OnctWzExcHhdIG91dGxpbmUtbm9uZVwiLCBQXyA9IChzID0gZG9jdW1lbnQpID0+IHtcbiAgW1xuICAgIHsgcHM6IFwicHNfX3JhaWwteFwiLCB0ZTogTF8gfSxcbiAgICB7IHBzOiBcInBzX19yYWlsLXlcIiwgdGU6IE5fIH0sXG4gICAgeyBwczogXCJwc19fdGh1bWIteFwiLCB0ZTogTV8gfSxcbiAgICB7IHBzOiBcInBzX190aHVtYi15XCIsIHRlOiBSXyB9XG4gIF0uZm9yRWFjaCgoZSkgPT4ge1xuICAgIHAuYWRkQ2xhc3MoXG4gICAgICBoLmZpbmRPbmUoYC4ke2UucHN9YCwgcyksXG4gICAgICBlLnRlXG4gICAgKSwgcC5yZW1vdmVDbGFzcyhcbiAgICAgIGguZmluZE9uZShgLiR7ZS5wc31gLCBzKSxcbiAgICAgIGUucHNcbiAgICApO1xuICB9KSwgcC5hZGRDbGFzcyhzLCAkXyksIHAucmVtb3ZlQ2xhc3MocywgXCJwc1wiKTtcbn0sIEdyID0gXCJzaWRlbmF2XCIsIFppID0gXCJ0ZS5zaWRlbmF2XCIsIEhfID0gXCJkYXRhLXRlLXNpZGVuYXYtcm90YXRlLWljb24tcmVmXCIsIEFuID0gXCJbZGF0YS10ZS1zaWRlbmF2LXRvZ2dsZS1yZWZdXCIsIEJfID0gXCJbZGF0YS10ZS1jb2xsYXBzZS1pbml0XVwiLCBWXyA9ICdbZGF0YS10ZS1zaWRlbmF2LXNsaW09XCJ0cnVlXCJdJywgV18gPSAnW2RhdGEtdGUtc2lkZW5hdi1zbGltPVwiZmFsc2VcIl0nLCBGXyA9IFwiW2RhdGEtdGUtc2lkZW5hdi1tZW51LXJlZl1cIiwgQ2UgPSBcIltkYXRhLXRlLXNpZGVuYXYtY29sbGFwc2UtcmVmXVwiLCB0aSA9IFwiW2RhdGEtdGUtc2lkZW5hdi1saW5rLXJlZl1cIiwgWV8gPSBGKCkgPyAxMDAgOiAtMTAwLCBqXyA9IEYoKSA/IC0xMDAgOiAxMDAsIEtfID0ge1xuICBzaWRlbmF2QWNjb3JkaW9uOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2QmFja2Ryb3A6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZCYWNrZHJvcENsYXNzOiBcIihudWxsfHN0cmluZylcIixcbiAgc2lkZW5hdkNsb3NlT25Fc2M6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZDb2xvcjogXCIoc3RyaW5nKVwiLFxuICBzaWRlbmF2Q29udGVudDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHNpZGVuYXZFeHBhbmRhYmxlOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2RXhwYW5kT25Ib3ZlcjogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkZvY3VzVHJhcDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkhpZGRlbjogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdk1vZGU6IFwiKHN0cmluZylcIixcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50T3ZlcjogXCIobnVsbHxzdHJpbmd8bnVtYmVyKVwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlOiBcIihudWxsfHN0cmluZ3xudW1iZXIpXCIsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2g6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnRTbTogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludE1kOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50TGc6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnRYbDogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludDJ4bDogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2U2Nyb2xsQ29udGFpbmVyOiBcIihudWxsfHN0cmluZylcIixcbiAgc2lkZW5hdlNsaW06IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZTbGltQ29sbGFwc2VkOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2U2xpbVdpZHRoOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZQb3NpdGlvbjogXCIoc3RyaW5nKVwiLFxuICBzaWRlbmF2UmlnaHQ6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb246IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdldpZHRoOiBcIihudW1iZXIpXCJcbn0sIFVfID0ge1xuICBzaWRlbmF2QWNjb3JkaW9uOiAhMSxcbiAgc2lkZW5hdkJhY2tkcm9wOiAhMCxcbiAgc2lkZW5hdkJhY2tkcm9wQ2xhc3M6IG51bGwsXG4gIHNpZGVuYXZDbG9zZU9uRXNjOiAhMCxcbiAgc2lkZW5hdkNvbG9yOiBcInByaW1hcnlcIixcbiAgc2lkZW5hdkNvbnRlbnQ6IG51bGwsXG4gIHNpZGVuYXZFeHBhbmRhYmxlOiAhMCxcbiAgc2lkZW5hdkV4cGFuZE9uSG92ZXI6ICExLFxuICBzaWRlbmF2Rm9jdXNUcmFwOiAhMCxcbiAgc2lkZW5hdkhpZGRlbjogITAsXG4gIHNpZGVuYXZNb2RlOiBcIm92ZXJcIixcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50T3ZlcjogbnVsbCxcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZTogbnVsbCxcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaDogbnVsbCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRTbTogNjQwLFxuICBzaWRlbmF2QnJlYWtwb2ludE1kOiA3NjgsXG4gIHNpZGVuYXZCcmVha3BvaW50TGc6IDEwMjQsXG4gIHNpZGVuYXZCcmVha3BvaW50WGw6IDEyODAsXG4gIHNpZGVuYXZCcmVha3BvaW50MnhsOiAxNTM2LFxuICBzaWRlbmF2U2Nyb2xsQ29udGFpbmVyOiBudWxsLFxuICBzaWRlbmF2U2xpbTogITEsXG4gIHNpZGVuYXZTbGltQ29sbGFwc2VkOiAhMSxcbiAgc2lkZW5hdlNsaW1XaWR0aDogNzcsXG4gIHNpZGVuYXZQb3NpdGlvbjogXCJmaXhlZFwiLFxuICBzaWRlbmF2UmlnaHQ6ICExLFxuICBzaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uOiAzMDAsXG4gIHNpZGVuYXZXaWR0aDogMjQwXG59O1xuY2xhc3Mgbmkge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30pIHtcbiAgICBUdCh0aGlzLCBcIl9hZGRCYWNrZHJvcE9uSW5pdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9vcHRpb25zLnNpZGVuYXZIaWRkZW4gfHwgKHRoaXMuX2JhY2tkcm9wLnNob3coKSwgdS5vZmYodGhpcy5fZWxlbWVudCwgXCJ0cmFuc2l0aW9uZW5kXCIsIHRoaXMuX2FkZEJhY2tkcm9wT25Jbml0KSk7XG4gICAgfSk7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSBlLCB0aGlzLl9JRCA9IE90KFwiXCIpLCB0aGlzLl9jb250ZW50ID0gbnVsbCwgdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZSA9IG51bGwsIHRoaXMuX3NsaW1Db2xsYXBzZWQgPSAhMSwgdGhpcy5fYWN0aXZlTm9kZSA9IG51bGwsIHRoaXMuX3RlbXBTbGltID0gITEsIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCksIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGwsIHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIgPSBudWxsLCB0aGlzLl90b3VjaCA9IG51bGwsIHRoaXMuX3NldE1vZGVGcm9tQnJlYWtwb2ludHMoKSwgdGhpcy5lc2NIYW5kbGVyID0gKGkpID0+IHtcbiAgICAgIGkua2V5Q29kZSA9PT0gSXMgJiYgdGhpcy50b2dnbGVyICYmIFN0KHRoaXMudG9nZ2xlcikgJiYgKHRoaXMuX3VwZGF0ZSghMSksIHUub2ZmKHdpbmRvdywgXCJrZXlkb3duXCIsIHRoaXMuZXNjSGFuZGxlcikpO1xuICAgIH0sIHRoaXMuaGFzaEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVFbGVtZW50cygpO1xuICAgIH0sIHQgJiYgKEkuc2V0RGF0YSh0LCBaaSwgdGhpcyksIHRoaXMuX3NldHVwKCkpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wICYmICF0aGlzLm9wdGlvbnMuc2lkZW5hdkhpZGRlbiAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHUub24odGhpcy5fZWxlbWVudCwgXCJ0cmFuc2l0aW9uZW5kXCIsIHRoaXMuX2FkZEJhY2tkcm9wT25Jbml0KSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEdyO1xuICB9XG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24gPT09IFwiZml4ZWRcIilcbiAgICAgIHJldHVybiBoLmZpbmRPbmUoXCJib2R5XCIpO1xuICAgIGNvbnN0IHQgPSAoZSkgPT4gIWUucGFyZW50Tm9kZSB8fCBlLnBhcmVudE5vZGUgPT09IGRvY3VtZW50ID8gZSA6IGUucGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IGUucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoXCJyZWxhdGl2ZVwiKSA/IGUucGFyZW50Tm9kZSA6IHQoZS5wYXJlbnROb2RlKTtcbiAgICByZXR1cm4gdCh0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgaXNWaXNpYmxlKCkge1xuICAgIGxldCB0ID0gMCwgZSA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uICE9PSBcImZpeGVkXCIpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHQgPSBuLngsIGUgPSBuLnggKyBuLndpZHRoO1xuICAgIH1cbiAgICBjb25zdCB7IHg6IGkgfSA9IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQgPyBNYXRoLmFicyhpIC0gZSkgPiAxMCA6IE1hdGguYWJzKGkgLSB0KSA8IDEwO1xuICB9XG4gIGdldCBsaW5rcygpIHtcbiAgICByZXR1cm4gaC5maW5kKHRpLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgbmF2aWdhdGlvbigpIHtcbiAgICByZXR1cm4gaC5maW5kKEZfLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgLi4uVV8sXG4gICAgICAuLi5wLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udGhpcy5fb3B0aW9uc1xuICAgIH07XG4gICAgcmV0dXJuIE4oR3IsIHQsIEtfKSwgdDtcbiAgfVxuICBnZXQgc2lkZW5hdlN0eWxlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogYCR7dGhpcy53aWR0aH1weGAsXG4gICAgICBoZWlnaHQ6IHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IFwiMTAwdmhcIiA6IFwiMTAwJVwiLFxuICAgICAgcG9zaXRpb246IHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24sXG4gICAgICB0cmFuc2l0aW9uOiBgYWxsICR7dGhpcy50cmFuc2l0aW9uRHVyYXRpb259IGxpbmVhcmBcbiAgICB9O1xuICB9XG4gIGdldCB0b2dnbGVyKCkge1xuICAgIHJldHVybiBoLmZpbmQoQW4pLmZpbmQoXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBjb25zdCBpID0gcC5nZXREYXRhQXR0cmlidXRlKGUsIFwidGFyZ2V0XCIpO1xuICAgICAgICByZXR1cm4gaC5maW5kT25lKGkpID09PSB0aGlzLl9lbGVtZW50O1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0IHRyYW5zaXRpb25EdXJhdGlvbigpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLnNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb24gLyAxZTN9c2A7XG4gIH1cbiAgZ2V0IHRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0ID8gal8gOiBZXztcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaW1Db2xsYXBzZWQgPyB0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW1XaWR0aCA6IHRoaXMub3B0aW9ucy5zaWRlbmF2V2lkdGg7XG4gIH1cbiAgZ2V0IGlzQmFja2Ryb3BWaXNpYmxlKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2JhY2tkcm9wLl9lbGVtZW50O1xuICB9XG4gIC8vIFB1YmxpY1xuICBjaGFuZ2VNb2RlKHQpIHtcbiAgICB0aGlzLl9zZXRNb2RlKHQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdS5vZmYod2luZG93LCBcImtleWRvd25cIiwgdGhpcy5lc2NIYW5kbGVyKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIHUub2ZmKHdpbmRvdywgXCJoYXNoY2hhbmdlXCIsIHRoaXMuaGFzaEhhbmRsZXIpLCB0aGlzLl90b3VjaC5kaXNwb3NlKCksIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBaaSksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy5fZW1pdEV2ZW50cyghMSksIHRoaXMuX3VwZGF0ZSghMSksIHRoaXMuX29wdGlvbnMuc2lkZW5hdkJhY2tkcm9wICYmIHRoaXMuaXNCYWNrZHJvcFZpc2libGUgJiYgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xuICB9XG4gIHNob3coKSB7XG4gICAgdGhpcy5fZW1pdEV2ZW50cyghMCksIHRoaXMuX3VwZGF0ZSghMCksIHRoaXMuX29wdGlvbnMuc2lkZW5hdkJhY2tkcm9wICYmIHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMuX2JhY2tkcm9wLnNob3coKTtcbiAgfVxuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5fZW1pdEV2ZW50cyghdGhpcy5pc1Zpc2libGUpLCB0aGlzLl91cGRhdGUoIXRoaXMuaXNWaXNpYmxlKTtcbiAgfVxuICB0b2dnbGVTbGltKCkge1xuICAgIHRoaXMuX3NldFNsaW0oIXRoaXMuX3NsaW1Db2xsYXBzZWQpO1xuICB9XG4gIHVwZGF0ZSh0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IHQsIHRoaXMuX3NldHVwKCk7XG4gIH1cbiAgZ2V0QnJlYWtwb2ludCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybUJyZWFrcG9pbnRWYWx1ZXNUb09iamVjdCgpW3RdO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAodS5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgQW4sXG4gICAgICBuaS50b2dnbGVTaWRlbmF2KClcbiAgICApLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF90cmFuc2Zvcm1CcmVha3BvaW50VmFsdWVzVG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNtOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnRTbSxcbiAgICAgIG1kOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnRNZCxcbiAgICAgIGxnOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnRMZyxcbiAgICAgIHhsOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnRYbCxcbiAgICAgIFwiMnhsXCI6IHRoaXMub3B0aW9ucy5zaWRlbmF2QnJlYWtwb2ludDJ4bFxuICAgIH07XG4gIH1cbiAgX3NldE1vZGVGcm9tQnJlYWtwb2ludHMoKSB7XG4gICAgY29uc3QgdCA9IHdpbmRvdy5pbm5lcldpZHRoLCBlID0gdGhpcy5fdHJhbnNmb3JtQnJlYWtwb2ludFZhbHVlc1RvT2JqZWN0KCk7XG4gICAgaWYgKHQgPT09IHZvaWQgMCB8fCAhZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyID09IFwibnVtYmVyXCIgPyB0IC0gdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXIgOiB0IC0gZVt0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50T3Zlcl0sIG4gPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGUgPT0gXCJudW1iZXJcIiA/IHQgLSB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZSA6IHQgLSBlW3RoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlXSwgbyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaCA9PSBcIm51bWJlclwiID8gdCAtIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoIDogdCAtIGVbdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2hdLCByID0gKGwsIGMpID0+IGwgLSBjIDwgMCA/IC0xIDogYyAtIGwgPCAwID8gMSA6IDAsIGEgPSBbaSwgbiwgb10uZmlsdGVyKChsKSA9PiBsICE9IG51bGwgJiYgbCA+PSAwKS5zb3J0KHIpWzBdO1xuICAgIGkgPiAwICYmIGkgPT09IGEgPyAodGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9IFwib3ZlclwiLCB0aGlzLl9vcHRpb25zLnNpZGVuYXZIaWRkZW4gPSAhMCkgOiBuID4gMCAmJiBuID09PSBhID8gdGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9IFwic2lkZVwiIDogbyA+IDAgJiYgbyA9PT0gYSAmJiAodGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9IFwicHVzaFwiKTtcbiAgfVxuICBfY29sbGFwc2VJdGVtcygpIHtcbiAgICB0aGlzLm5hdmlnYXRpb24uZm9yRWFjaCgodCkgPT4ge1xuICAgICAgaC5maW5kKENlLCB0KS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIFV0LmdldEluc3RhbmNlKGkpLmhpZGUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9nZXRPZmZzZXRWYWx1ZSh0LCB7IGluZGV4OiBlLCBwcm9wZXJ0eTogaSwgb2Zmc2V0czogbiB9KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuX2dldFB4VmFsdWUoXG4gICAgICB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlW2VdW25baV0ucHJvcGVydHldXG4gICAgKSwgciA9IHQgPyBuW2ldLnZhbHVlIDogMDtcbiAgICByZXR1cm4gbyArIHI7XG4gIH1cbiAgX2dldFByb3BlcnR5KC4uLnQpIHtcbiAgICByZXR1cm4gdC5tYXAoKGUsIGkpID0+IGkgPT09IDAgPyBlIDogZVswXS50b1VwcGVyQ2FzZSgpLmNvbmNhdChlLnNsaWNlKDEpKSkuam9pbihcIlwiKTtcbiAgfVxuICBfZ2V0UHhWYWx1ZSh0KSB7XG4gICAgcmV0dXJuIHQgPyBwYXJzZUZsb2F0KHQpIDogMDtcbiAgfVxuICBfaGFuZGxlU3dpcGUodCwgZSkge1xuICAgIGUgJiYgdGhpcy5fc2xpbUNvbGxhcHNlZCAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW0gJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZFeHBhbmRhYmxlID8gdGhpcy50b2dnbGVTbGltKCkgOiBlIHx8ICh0aGlzLl9zbGltQ29sbGFwc2VkIHx8ICF0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW0gfHwgIXRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kYWJsZSA/IHRoaXMudG9nZ2xlciAmJiBTdCh0aGlzLnRvZ2dsZXIpICYmIHRoaXMudG9nZ2xlKCkgOiB0aGlzLnRvZ2dsZVNsaW0oKSk7XG4gIH1cbiAgX2lzQWN0aXZlKHQsIGUpIHtcbiAgICByZXR1cm4gZSA/IGUgPT09IHQgOiB0LmF0dHJpYnV0ZXMuaHJlZiA/IG5ldyBVUkwodCwgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWYgPT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmIDogITE7XG4gIH1cbiAgX2lzQWxsVG9CZUNvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gaC5maW5kKFxuICAgICAgQl8sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKS5maWx0ZXIoXG4gICAgICAoaSkgPT4gaS5nZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIpID09PSBcInRydWVcIlxuICAgICkubGVuZ3RoID09PSAwO1xuICB9XG4gIF9pc0FsbENvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gaC5maW5kKENlLCB0aGlzLl9lbGVtZW50KS5maWx0ZXIoXG4gICAgICAodCkgPT4gU3QodClcbiAgICApLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcENsYXNzID8gdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcENsYXNzLnNwbGl0KFwiIFwiKSA6IHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24gPyBbXG4gICAgICBcIm9wYWNpdHktNTBcIixcbiAgICAgIFwidHJhbnNpdGlvbi1hbGxcIixcbiAgICAgIFwiZHVyYXRpb24tMzAwXCIsXG4gICAgICBcImVhc2UtaW4tb3V0XCIsXG4gICAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uLFxuICAgICAgXCJ0b3AtMFwiLFxuICAgICAgXCJsZWZ0LTBcIixcbiAgICAgIFwiei01MFwiLFxuICAgICAgXCJiZy1ibGFjay8xMFwiLFxuICAgICAgXCJkYXJrOmJnLWJsYWNrLTYwXCIsXG4gICAgICBcInctZnVsbFwiLFxuICAgICAgXCJoLWZ1bGxcIixcbiAgICAgIHRoaXMuX2VsZW1lbnQuaWRcbiAgICBdIDogbnVsbDtcbiAgICByZXR1cm4gbmV3IGxvKHtcbiAgICAgIGlzVmlzaWJsZTogdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCxcbiAgICAgIGlzQW5pbWF0ZWQ6ICEwLFxuICAgICAgcm9vdEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgIGJhY2tkcm9wQ2xhc3NlczogdCxcbiAgICAgIGNsaWNrQ2FsbGJhY2s6ICgpID0+IHRoaXMuaGlkZSgpXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZUJhY2tkcm9wKHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIikge1xuICAgICAgdCA/IHRoaXMuX2JhY2tkcm9wLnNob3coKSA6IHRoaXMuaXNCYWNrZHJvcFZpc2libGUgJiYgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzQmFja2Ryb3BWaXNpYmxlICYmIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgfVxuICBfc2V0dXAoKSB7XG4gICAgdGhpcy5fc2V0dXBUb3VjaCgpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkZvY3VzVHJhcCAmJiB0aGlzLl9zZXR1cEZvY3VzVHJhcCgpLCB0aGlzLl9zZXR1cENvbGxhcHNlKCksIHRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbSAmJiB0aGlzLl9zZXR1cFNsaW0oKSwgdGhpcy5fc2V0dXBJbml0aWFsU3R5bGluZygpLCB0aGlzLl9zZXR1cFNjcm9sbGluZygpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbnRlbnQgJiYgdGhpcy5fc2V0dXBDb250ZW50KCksIHRoaXMuX3NldHVwQWN0aXZlU3RhdGUoKSwgdGhpcy5fc2V0dXBSaXBwbGVFZmZlY3QoKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZIaWRkZW4gfHwgdGhpcy5fdXBkYXRlT2Zmc2V0cyghMCwgITApLCB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMuX3NldFRhYmluZGV4KCEwKTtcbiAgfVxuICBfc2V0dXBBY3RpdmVTdGF0ZSgpIHtcbiAgICB0aGlzLl9zZXRBY3RpdmVFbGVtZW50cygpLCB0aGlzLmxpbmtzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHUub24odCwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLl9zZXRBY3RpdmVFbGVtZW50cyh0KSksIHUub24odCwgXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICAgIGUua2V5Q29kZSA9PT0gbHQgJiYgdGhpcy5fc2V0QWN0aXZlRWxlbWVudHModCk7XG4gICAgICB9KTtcbiAgICB9KSwgdS5vbih3aW5kb3csIFwiaGFzaGNoYW5nZVwiLCB0aGlzLmhhc2hIYW5kbGVyKTtcbiAgfVxuICBfc2V0dXBDb2xsYXBzZSgpIHtcbiAgICB0aGlzLm5hdmlnYXRpb24uZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgaC5maW5kKENlLCB0KS5mb3JFYWNoKFxuICAgICAgICAobiwgbykgPT4gdGhpcy5fc2V0dXBDb2xsYXBzZUxpc3QoeyBsaXN0OiBuLCBpbmRleDogbywgbWVudTogdCwgbWVudUluZGV4OiBlIH0pXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIF9nZW5lcmF0ZUNvbGxwYXNlSUQodCwgZSkge1xuICAgIHJldHVybiBgc2lkZW5hdi1jb2xsYXBzZS0ke3RoaXMuX0lEfS0ke2V9LSR7dH1gO1xuICB9XG4gIF9zZXR1cENvbGxhcHNlTGlzdCh7IGxpc3Q6IHQsIGluZGV4OiBlLCBtZW51OiBpLCBtZW51SW5kZXg6IG4gfSkge1xuICAgIGNvbnN0IG8gPSB0aGlzLl9nZW5lcmF0ZUNvbGxwYXNlSUQoZSwgbik7XG4gICAgdC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBvKSwgdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWNvbGxhcHNlLWl0ZW1cIiwgXCJcIik7XG4gICAgY29uc3QgW3JdID0gaC5wcmV2KHQsIHRpKTtcbiAgICBwLnNldERhdGFBdHRyaWJ1dGUociwgXCJjb2xsYXBzZS1pbml0XCIsIFwiXCIpLCByLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke299YCksIHIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImJ1dHRvblwiKTtcbiAgICBjb25zdCBhID0gVXQuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IFV0KHQsIHtcbiAgICAgIHRvZ2dsZTogITEsXG4gICAgICBwYXJlbnQ6IHRoaXMub3B0aW9ucy5zaWRlbmF2QWNjb3JkaW9uID8gaSA6IHRcbiAgICB9KTtcbiAgICAodC5kYXRhc2V0LnRlU2lkZW5hdlN0YXRlU2hvdyA9PT0gXCJcIiB8fCB0LmRhdGFzZXQudGVDb2xsYXBzZVNob3cgPT09IFwiXCIpICYmIHRoaXMuX3JvdGF0ZUFycm93KHIsICExKSwgdS5vbihyLCBcImNsaWNrXCIsIChsKSA9PiB7XG4gICAgICB0aGlzLl90b2dnbGVDYXRlZ29yeShsLCBhLCB0KSwgdGhpcy5fdGVtcFNsaW0gJiYgdGhpcy5faXNBbGxUb0JlQ29sbGFwc2VkKCkgJiYgKHRoaXMuX3NldFNsaW0oITApLCB0aGlzLl90ZW1wU2xpbSA9ICExKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwLnVwZGF0ZSgpO1xuICAgIH0pLCB1Lm9uKFxuICAgICAgdCxcbiAgICAgIFwic2hvdy50ZS5jb2xsYXBzZVwiLFxuICAgICAgKCkgPT4gdGhpcy5fcm90YXRlQXJyb3cociwgITEpXG4gICAgKSwgdS5vbihcbiAgICAgIHQsXG4gICAgICBcImhpZGUudGUuY29sbGFwc2VcIixcbiAgICAgICgpID0+IHRoaXMuX3JvdGF0ZUFycm93KHIsICEwKVxuICAgICksIHUub24odCwgXCJzaG93bi50ZS5jb2xsYXBzZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMuX2ZvY3VzVHJhcCAmJiB0aGlzLl9mb2N1c1RyYXAudXBkYXRlKCk7XG4gICAgfSksIHUub24odCwgXCJoaWRkZW4udGUuY29sbGFwc2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdGVtcFNsaW0gJiYgdGhpcy5faXNBbGxDb2xsYXBzZWQoKSAmJiAodGhpcy5fc2V0U2xpbSghMCksIHRoaXMuX3RlbXBTbGltID0gITEpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMuX2ZvY3VzVHJhcCAmJiB0aGlzLl9mb2N1c1RyYXAudXBkYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwQ29udGVudCgpIHtcbiAgICB0aGlzLl9jb250ZW50ID0gaC5maW5kKHRoaXMub3B0aW9ucy5zaWRlbmF2Q29udGVudCksIHRoaXMuX2NvbnRlbnQuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IFtcbiAgICAgICAgXCIhcFwiLFxuICAgICAgICBcIiFtXCIsXG4gICAgICAgIFwiIXB4XCIsXG4gICAgICAgIFwiIXBsXCIsXG4gICAgICAgIFwiIXByXCIsXG4gICAgICAgIFwiIW14XCIsXG4gICAgICAgIFwiIW1sXCIsXG4gICAgICAgIFwiIW1yXCIsXG4gICAgICAgIFwiIS1wXCIsXG4gICAgICAgIFwiIS1tXCIsXG4gICAgICAgIFwiIS1weFwiLFxuICAgICAgICBcIiEtcGxcIixcbiAgICAgICAgXCIhLXByXCIsXG4gICAgICAgIFwiIS1teFwiLFxuICAgICAgICBcIiEtbWxcIixcbiAgICAgICAgXCIhLW1yXCJcbiAgICAgIF07XG4gICAgICBbLi4udC5jbGFzc0xpc3RdLmZpbHRlcihcbiAgICAgICAgKG4pID0+IGUuZmluZEluZGV4KChvKSA9PiBuLmluY2x1ZGVzKG8pKSA+PSAwXG4gICAgICApLmZvckVhY2goKG4pID0+IHQuY2xhc3NMaXN0LnJlbW92ZShuKSk7XG4gICAgfSksIHRoaXMuX2luaXRpYWxDb250ZW50U3R5bGUgPSB0aGlzLl9jb250ZW50Lm1hcCgodCkgPT4ge1xuICAgICAgY29uc3QgeyBwYWRkaW5nTGVmdDogZSwgcGFkZGluZ1JpZ2h0OiBpLCBtYXJnaW5MZWZ0OiBuLCBtYXJnaW5SaWdodDogbywgdHJhbnNpdGlvbjogciB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodCk7XG4gICAgICByZXR1cm4geyBwYWRkaW5nTGVmdDogZSwgcGFkZGluZ1JpZ2h0OiBpLCBtYXJnaW5MZWZ0OiBuLCBtYXJnaW5SaWdodDogbywgdHJhbnNpdGlvbjogciB9O1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cEZvY3VzVHJhcCgpIHtcbiAgICB0aGlzLl9mb2N1c1RyYXAgPSBuZXcgYmkoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAge1xuICAgICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICAgIGNvbmRpdGlvbjogKHQpID0+IHQua2V5Q29kZSA9PT0gZmksXG4gICAgICAgIG9ubHlWaXNpYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIHRoaXMudG9nZ2xlclxuICAgICk7XG4gIH1cbiAgX3NldHVwSW5pdGlhbFN0eWxpbmcoKSB7XG4gICAgdGhpcy5fc2V0Q29sb3IoKSwgcC5zdHlsZSh0aGlzLl9lbGVtZW50LCB0aGlzLnNpZGVuYXZTdHlsZSk7XG4gIH1cbiAgX3NldHVwU2Nyb2xsaW5nKCkge1xuICAgIGxldCB0ID0gdGhpcy5fZWxlbWVudDtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZTY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHQgPSBoLmZpbmRPbmUoXG4gICAgICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2U2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICB0aGlzLl9lbGVtZW50XG4gICAgICApO1xuICAgICAgY29uc3QgaSA9IHRjKHQucGFyZW50Tm9kZS5jaGlsZHJlbikuZmlsdGVyKFxuICAgICAgICAobikgPT4gbiAhPT0gdFxuICAgICAgKS5yZWR1Y2UoKG4sIG8pID0+IG4gKyBvLmNsaWVudEhlaWdodCwgMCk7XG4gICAgICBwLnN0eWxlKHQsIHtcbiAgICAgICAgbWF4SGVpZ2h0OiBgY2FsYygxMDAlIC0gJHtpfXB4KWAsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyID0gbmV3IFRpKHQsIHtcbiAgICAgIHN1cHByZXNzU2Nyb2xsWDogITAsXG4gICAgICBoYW5kbGVyczogW1wiY2xpY2stcmFpbFwiLCBcImRyYWctdGh1bWJcIiwgXCJ3aGVlbFwiLCBcInRvdWNoXCJdXG4gICAgfSksIFBfKHQpO1xuICB9XG4gIF9zZXR1cFNsaW0oKSB7XG4gICAgdGhpcy5fc2xpbUNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbUNvbGxhcHNlZCwgdGhpcy5fdG9nZ2xlU2xpbURpc3BsYXkodGhpcy5fc2xpbUNvbGxhcHNlZCksIHRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kT25Ib3ZlciAmJiAodGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zbGltQ29sbGFwc2VkICYmIHRoaXMuX3NldFNsaW0oITEpO1xuICAgIH0pLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3NsaW1Db2xsYXBzZWQgfHwgdGhpcy5fc2V0U2xpbSghMCk7XG4gICAgfSkpO1xuICB9XG4gIF9zZXR1cFJpcHBsZUVmZmVjdCgpIHtcbiAgICB0aGlzLmxpbmtzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGxldCBlID0gQ3MuZ2V0SW5zdGFuY2UodCksIGkgPSB0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbG9yO1xuICAgICAgaWYgKGUgJiYgZS5fb3B0aW9ucy5zaWRlbmF2Q29sb3IgIT09IHRoaXMub3B0aW9ucy5zaWRlbmF2Q29sb3IpXG4gICAgICAgIGUuZGlzcG9zZSgpO1xuICAgICAgZWxzZSBpZiAoZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgKGxvY2FsU3RvcmFnZS50aGVtZSA9PT0gXCJkYXJrXCIgfHwgIShcInRoZW1lXCIgaW4gbG9jYWxTdG9yYWdlKSAmJiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcykgJiYgKGkgPSBcIndoaXRlXCIpLCBlID0gbmV3IENzKHQsIHsgcmlwcGxlQ29sb3I6IGkgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwVG91Y2goKSB7XG4gICAgdGhpcy5fdG91Y2ggPSBuZXcgSV8odGhpcy5fZWxlbWVudCwgXCJzd2lwZVwiLCB7IHRocmVzaG9sZDogMjAgfSksIHRoaXMuX3RvdWNoLmluaXQoKSwgdS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcInN3aXBlbGVmdFwiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVN3aXBlKHQsIHRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQpXG4gICAgKSwgdS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcInN3aXBlcmlnaHRcIixcbiAgICAgICh0KSA9PiB0aGlzLl9oYW5kbGVTd2lwZSh0LCAhdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodClcbiAgICApO1xuICB9XG4gIF9zZXRBY3RpdmUodCwgZSkge1xuICAgIHQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zaWRlYmFyLXN0YXRlLWFjdGl2ZVwiLCBcIlwiKSwgdGhpcy5fYWN0aXZlTm9kZSAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZWJhci1zdGF0ZS1hY3RpdmVcIiksIHRoaXMuX2FjdGl2ZU5vZGUgPSB0O1xuICAgIGNvbnN0IFtpXSA9IGgucGFyZW50cyhcbiAgICAgIHRoaXMuX2FjdGl2ZU5vZGUsXG4gICAgICBDZVxuICAgICk7XG4gICAgaWYgKCFpKSB7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVDYXRlZ29yeSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbbl0gPSBoLnByZXYoaSwgdGkpO1xuICAgIHRoaXMuX3NldEFjdGl2ZUNhdGVnb3J5KG4pLCAhZSAmJiAhdGhpcy5fc2xpbUNvbGxhcHNlZCAmJiBVdC5nZXRJbnN0YW5jZShpKS5zaG93KCk7XG4gIH1cbiAgX3NldEFjdGl2ZUNhdGVnb3J5KHQpIHtcbiAgICB0aGlzLm5hdmlnYXRpb24uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaC5maW5kKENlLCBlKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IFtvXSA9IGgucHJldihuLCB0aSk7XG4gICAgICAgIG8gIT09IHQgPyBvLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZW5hdi1zdGF0ZS1hY3RpdmVcIikgOiBvLnNldEF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZW5hdi1zdGF0ZS1hY3RpdmVcIiwgXCJcIik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfc2V0QWN0aXZlRWxlbWVudHModCkge1xuICAgIHRoaXMubmF2aWdhdGlvbi5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBoLmZpbmQodGksIGUpLmZpbHRlcigobikgPT4gaC5uZXh0KG4sIENlKS5sZW5ndGggPT09IDApLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgdGhpcy5faXNBY3RpdmUobiwgdCkgJiYgbiAhPT0gdGhpcy5fYWN0aXZlTm9kZSAmJiB0aGlzLl9zZXRBY3RpdmUobiwgdCk7XG4gICAgICB9KTtcbiAgICB9KSwgdCAmJiB0aGlzLl91cGRhdGVGb2N1cyh0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgX3NldENvbG9yKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBcInByaW1hcnlcIixcbiAgICAgIFwic2Vjb25kYXJ5XCIsXG4gICAgICBcInN1Y2Nlc3NcIixcbiAgICAgIFwiaW5mb1wiLFxuICAgICAgXCJ3YXJuaW5nXCIsXG4gICAgICBcImRhbmdlclwiLFxuICAgICAgXCJsaWdodFwiLFxuICAgICAgXCJkYXJrXCJcbiAgICBdLCB7IHNpZGVuYXZDb2xvcjogZSB9ID0gdGhpcy5vcHRpb25zLCBpID0gdC5pbmNsdWRlcyhlKSA/IGUgOiBcInByaW1hcnlcIjtcbiAgICB0LmZvckVhY2goKG4pID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgc2lkZW5hdi0ke259YCk7XG4gICAgfSksIHAuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgYHNpZGVuYXYtJHtpfWApO1xuICB9XG4gIF9zZXRDb250ZW50T2Zmc2V0cyh0LCBlLCBpKSB7XG4gICAgdGhpcy5fY29udGVudC5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICBjb25zdCByID0gdGhpcy5fZ2V0T2Zmc2V0VmFsdWUodCwge1xuICAgICAgICBpbmRleDogbyxcbiAgICAgICAgcHJvcGVydHk6IFwicGFkZGluZ1wiLFxuICAgICAgICBvZmZzZXRzOiBlXG4gICAgICB9KSwgYSA9IHRoaXMuX2dldE9mZnNldFZhbHVlKHQsIHtcbiAgICAgICAgaW5kZXg6IG8sXG4gICAgICAgIHByb3BlcnR5OiBcIm1hcmdpblwiLFxuICAgICAgICBvZmZzZXRzOiBlXG4gICAgICB9KSwgbCA9IHt9O1xuICAgICAgaWYgKGkgfHwgKGwudHJhbnNpdGlvbiA9IGBhbGwgJHt0aGlzLnRyYW5zaXRpb25EdXJhdGlvbn0gbGluZWFyYCksIGxbZS5wYWRkaW5nLnByb3BlcnR5XSA9IGAke3J9cHhgLCBsW2UubWFyZ2luLnByb3BlcnR5XSA9IGAke2F9cHhgLCBwLnN0eWxlKG4sIGwpLCAhIXQpIHtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBwLnN0eWxlKG4sIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRoaXMuX2luaXRpYWxDb250ZW50U3R5bGVbb10udHJhbnNpdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1Lm9uKG4sIFwidHJhbnNpdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgcC5zdHlsZShuLCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlW29dLnRyYW5zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3NldE1vZGUodCkge1xuICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSAhPT0gdCAmJiAodGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9IHQsIHRoaXMuX3VwZGF0ZSh0aGlzLmlzVmlzaWJsZSkpO1xuICB9XG4gIF9zZXRTbGltKHQpIHtcbiAgICBjb25zdCBlID0gdCA/IFtcImNvbGxhcHNlXCIsIFwiY29sbGFwc2VkXCJdIDogW1wiZXhwYW5kXCIsIFwiZXhwYW5kZWRcIl07XG4gICAgdGhpcy5fdHJpZ2dlckV2ZW50cyguLi5lKSwgdCAmJiB0aGlzLl9jb2xsYXBzZUl0ZW1zKCksIHRoaXMuX3NsaW1Db2xsYXBzZWQgPSB0LCB0aGlzLl90b2dnbGVTbGltRGlzcGxheSh0KSwgcC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7IHdpZHRoOiBgJHt0aGlzLndpZHRofXB4YCB9KSwgdGhpcy5fdXBkYXRlT2Zmc2V0cyh0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgX3NldFRhYmluZGV4KHQpIHtcbiAgICB0aGlzLmxpbmtzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUudGFiSW5kZXggPSB0ID8gMCA6IC0xO1xuICAgIH0pO1xuICB9XG4gIF9lbWl0RXZlbnRzKHQpIHtcbiAgICBjb25zdCBlID0gdCA/IFtcInNob3dcIiwgXCJzaG93blwiXSA6IFtcImhpZGVcIiwgXCJoaWRkZW5cIl07XG4gICAgdGhpcy5fdHJpZ2dlckV2ZW50cyguLi5lKTtcbiAgfVxuICBfcm90YXRlQXJyb3codCwgZSkge1xuICAgIGNvbnN0IFtpXSA9IGguY2hpbGRyZW4odCwgYFske0hffV1gKTtcbiAgICBpICYmIChlID8gcC5yZW1vdmVDbGFzcyhpLCBcInJvdGF0ZS0xODBcIikgOiBwLmFkZENsYXNzKGksIFwicm90YXRlLTE4MFwiKSk7XG4gIH1cbiAgX3RvZ2dsZUNhdGVnb3J5KHQsIGUpIHtcbiAgICB0LnByZXZlbnREZWZhdWx0KCksIGUudG9nZ2xlKCksIHRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZFeHBhbmRhYmxlICYmICh0aGlzLl90ZW1wU2xpbSA9ICEwLCB0aGlzLl9zZXRTbGltKCExKSk7XG4gIH1cbiAgX3RvZ2dsZVNsaW1EaXNwbGF5KHQpIHtcbiAgICBjb25zdCBlID0gaC5maW5kKFxuICAgICAgVl8sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaSA9IGguZmluZChcbiAgICAgIFdfLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIG4gPSAoKSA9PiB7XG4gICAgICBlLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgcC5zdHlsZShvLCB7XG4gICAgICAgICAgZGlzcGxheTogdGhpcy5fc2xpbUNvbGxhcHNlZCA/IFwidW5zZXRcIiA6IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSksIGkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBwLnN0eWxlKG8sIHtcbiAgICAgICAgICBkaXNwbGF5OiB0aGlzLl9zbGltQ29sbGFwc2VkID8gXCJub25lXCIgOiBcInVuc2V0XCJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHQgPyBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gbigpLFxuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb25cbiAgICApIDogbigpO1xuICB9XG4gIGFzeW5jIF90cmlnZ2VyRXZlbnRzKHQsIGUpIHtcbiAgICB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYCR7dH0udGUuc2lkZW5hdmApLCBlICYmIGF3YWl0IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke2V9LnRlLnNpZGVuYXZgKTtcbiAgICB9LCB0aGlzLm9wdGlvbnMuc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbiArIDUpO1xuICB9XG4gIF91cGRhdGUodCkge1xuICAgIHRoaXMudG9nZ2xlciAmJiB0aGlzLl91cGRhdGVUb2dnbGVyQXJpYSh0KSwgdGhpcy5fdXBkYXRlRGlzcGxheSh0KSwgdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLl91cGRhdGVCYWNrZHJvcCh0KSwgdGhpcy5fdXBkYXRlT2Zmc2V0cyh0KSwgdCAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdkNsb3NlT25Fc2MgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlICE9PSBcInNpZGVcIiAmJiB1Lm9uKHdpbmRvdywgXCJrZXlkb3duXCIsIHRoaXMuZXNjSGFuZGxlciksIHRoaXMub3B0aW9ucy5zaWRlbmF2Rm9jdXNUcmFwICYmIHRoaXMuX3VwZGF0ZUZvY3VzKHQpO1xuICB9XG4gIF91cGRhdGVEaXNwbGF5KHQpIHtcbiAgICBjb25zdCBlID0gdCA/IDAgOiB0aGlzLnRyYW5zbGF0aW9uO1xuICAgIHAuc3R5bGUodGhpcy5fZWxlbWVudCwge1xuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2V9JSlgXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZUZvY3VzKHQpIHtcbiAgICBpZiAodGhpcy5fc2V0VGFiaW5kZXgodCksIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZGb2N1c1RyYXApIHtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcC50cmFwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvY3VzVHJhcC5kaXNhYmxlKCk7XG4gICAgfVxuICAgIHRoaXMuX2ZvY3VzVHJhcC5kaXNhYmxlKCk7XG4gIH1cbiAgX3VwZGF0ZU9mZnNldHModCwgZSA9ICExKSB7XG4gICAgY29uc3QgW2ksIG5dID0gdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodCA/IFtcInJpZ2h0XCIsIFwibGVmdFwiXSA6IFtcImxlZnRcIiwgXCJyaWdodFwiXSwgbyA9IHtcbiAgICAgIHByb3BlcnR5OiB0aGlzLl9nZXRQcm9wZXJ0eShcInBhZGRpbmdcIiwgaSksXG4gICAgICB2YWx1ZTogdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiA/IDAgOiB0aGlzLndpZHRoXG4gICAgfSwgciA9IHtcbiAgICAgIHByb3BlcnR5OiB0aGlzLl9nZXRQcm9wZXJ0eShcIm1hcmdpblwiLCBuKSxcbiAgICAgIHZhbHVlOiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwicHVzaFwiID8gLTEgKiB0aGlzLndpZHRoIDogMFxuICAgIH07XG4gICAgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwidXBkYXRlLnRlLnNpZGVuYXZcIiwge1xuICAgICAgbWFyZ2luOiByLFxuICAgICAgcGFkZGluZzogb1xuICAgIH0pLCB0aGlzLl9jb250ZW50ICYmICh0aGlzLl9jb250ZW50LmNsYXNzTmFtZSA9IFwiXCIsIHRoaXMuX3NldENvbnRlbnRPZmZzZXRzKHQsIHsgcGFkZGluZzogbywgbWFyZ2luOiByIH0sIGUpKTtcbiAgfVxuICBfdXBkYXRlVG9nZ2xlckFyaWEodCkge1xuICAgIHRoaXMudG9nZ2xlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIHQpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgdG9nZ2xlU2lkZW5hdigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29uc3QgZSA9IGguY2xvc2VzdCh0LnRhcmdldCwgQW4pLCBpID0gcC5nZXREYXRhQXR0cmlidXRlcyhlKS50YXJnZXQ7XG4gICAgICBoLmZpbmQoaSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICAobmkuZ2V0SW5zdGFuY2UobikgfHwgbmV3IG5pKG4pKS50b2dnbGUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gSS5nZXREYXRhKHRoaXMsIFppKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgbmkodGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgWmkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IFluID0gXCJzdGVwcGVyXCIsIG1zID0gXCJ0ZS5zdGVwcGVyXCIsIE1zID0gYC4ke21zfWAsIENpID0gYGRhdGEtdGUtJHtZbn1gLCBvaSA9IFwiaG9yaXpvbnRhbFwiLCB5dCA9IFwidmVydGljYWxcIiwgel8gPSB7XG4gIHN0ZXBwZXJUeXBlOiBcInN0cmluZ1wiLFxuICBzdGVwcGVyTGluZWFyOiBcImJvb2xlYW5cIixcbiAgc3RlcHBlck5vRWRpdGFibGU6IFwiYm9vbGVhblwiLFxuICBzdGVwcGVyQWN0aXZlOiBcInN0cmluZ1wiLFxuICBzdGVwcGVyQ29tcGxldGVkOiBcInN0cmluZ1wiLFxuICBzdGVwcGVySW52YWxpZDogXCJzdHJpbmdcIixcbiAgc3RlcHBlckRpc2FibGVkOiBcInN0cmluZ1wiLFxuICBzdGVwcGVyVmVydGljYWxCcmVha3BvaW50OiBcIm51bWJlclwiLFxuICBzdGVwcGVyTW9iaWxlQnJlYWtwb2ludDogXCJudW1iZXJcIixcbiAgc3RlcHBlck1vYmlsZUJhckJyZWFrcG9pbnQ6IFwibnVtYmVyXCJcbn0sIFhfID0ge1xuICBzdGVwcGVyVHlwZTogb2ksXG4gIHN0ZXBwZXJMaW5lYXI6ICExLFxuICBzdGVwcGVyTm9FZGl0YWJsZTogITEsXG4gIHN0ZXBwZXJBY3RpdmU6IFwiXCIsXG4gIHN0ZXBwZXJDb21wbGV0ZWQ6IFwiXCIsXG4gIHN0ZXBwZXJJbnZhbGlkOiBcIlwiLFxuICBzdGVwcGVyRGlzYWJsZWQ6IFwiXCIsXG4gIHN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQ6IDAsXG4gIHN0ZXBwZXJNb2JpbGVCcmVha3BvaW50OiAwLFxuICBzdGVwcGVyTW9iaWxlQmFyQnJlYWtwb2ludDogNFxufSwgcXIgPSBgbW91c2Vkb3duJHtNc31gLCBRciA9IGBrZXlkb3duJHtNc31gLCBHXyA9IGBrZXl1cCR7TXN9YCwgWnIgPSBgcmVzaXplJHtNc31gLCBWdCA9IGBbJHtDaX0tc3RlcC1yZWZdYCwgRyA9IGBbJHtDaX0taGVhZC1yZWZdYCwgSnIgPSBgWyR7Q2l9LWhlYWQtdGV4dC1yZWZdYCwgSmkgPSBgWyR7Q2l9LWhlYWQtaWNvbi1yZWZdYCwgc3QgPSBgWyR7Q2l9LWNvbnRlbnQtcmVmXWA7XG5jbGFzcyBRZyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fZWxlbWVudEhlaWdodCA9IDAsIHRoaXMuX3N0ZXBzID0gaC5maW5kKGAke1Z0fWAsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9jdXJyZW50VmlldyA9IFwiXCIsIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCA9IDAsIHRoaXMuX3ZlcnRpY2FsU3RlcHBlclN0eWxlcyA9IFtdLCB0aGlzLl9lbGVtZW50ICYmIChJLnNldERhdGEodCwgbXMsIHRoaXMpLCB0aGlzLl9pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBZbjtcbiAgfVxuICBnZXQgYWN0aXZlU3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlcHNbdGhpcy5fYWN0aXZlU3RlcEluZGV4XTtcbiAgfVxuICBnZXQgYWN0aXZlU3RlcEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVTdGVwSW5kZXg7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdS5vZmYodCwgcXIpLCB1Lm9mZih0LCBRcik7XG4gICAgfSksIHUub2ZmKHdpbmRvdywgWnIpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgbXMpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBjaGFuZ2VTdGVwKHQpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwKHQpO1xuICB9XG4gIG5leHRTdGVwKCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXAodGhpcy5fYWN0aXZlU3RlcEluZGV4ICsgMSk7XG4gIH1cbiAgcHJldmlvdXNTdGVwKCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXAodGhpcy5fYWN0aXZlU3RlcEluZGV4IC0gMSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gaC5maW5kKGAke1Z0fWAsIHRoaXMuX2VsZW1lbnQpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uc2V0QXR0cmlidXRlKFwiZGF0YS10ZVwiLCBcImFjdGl2ZS1zdGVwXCIpLCBlID0gaC5maW5kKFxuICAgICAgYCR7SnJ9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBpID0gaC5maW5kKFxuICAgICAgYCR7Sml9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHN3aXRjaCAodCA/ICh0aGlzLl9hY3RpdmVTdGVwSW5kZXggPSB0aGlzLl9zdGVwcy5pbmRleE9mKHQpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCJmb250LW1lZGl1bVwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtcHJpbWFyeS03MDBcIikpIDogKGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiZm9udC1tZWRpdW1cIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiF0ZXh0LXByaW1hcnktNzAwXCIpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKSksIHRoaXMuX2JpbmRNb3VzZURvd24oKSwgdGhpcy5fYmluZEtleXNOYXZpZ2F0aW9uKCksIHRoaXMuX29wdGlvbnMuc3RlcHBlclR5cGUpIHtcbiAgICAgIGNhc2UgeXQ6XG4gICAgICAgIHRoaXMuX3RvZ2dsZVZlcnRpY2FsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5fdG9nZ2xlSG9yaXpvbnRhbCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgKHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCB8fCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJNb2JpbGVCcmVha3BvaW50KSAmJiB0aGlzLl90b2dnbGVTdGVwcGVyVmlldygpLCB0aGlzLl9iaW5kUmVzaXplKCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5YXyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTihZbiwgdCwgel8pLCB0O1xuICB9XG4gIF9iaW5kTW91c2VEb3duKCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBoLmZpbmRPbmUoYCR7R31gLCB0KTtcbiAgICAgIHUub24oZSwgcXIsIChpKSA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSBoLnBhcmVudHMoaS50YXJnZXQsIGAke1Z0fWApWzBdLCBvID0gdGhpcy5fc3RlcHMuaW5kZXhPZihuKTtcbiAgICAgICAgaS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl90b2dnbGVTdGVwKG8pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRSZXNpemUoKSB7XG4gICAgdS5vbih3aW5kb3csIFpyLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jdXJyZW50VmlldyA9PT0geXQgJiYgdGhpcy5fc2V0U2luZ2xlU3RlcEhlaWdodCh0aGlzLmFjdGl2ZVN0ZXApLCB0aGlzLl9jdXJyZW50VmlldyA9PT0gb2kgJiYgdGhpcy5fc2V0SGVpZ2h0KHRoaXMuYWN0aXZlU3RlcCksICh0aGlzLl9vcHRpb25zLnN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQgfHwgdGhpcy5fb3B0aW9ucy5zdGVwcGVyTW9iaWxlQnJlYWtwb2ludCkgJiYgdGhpcy5fdG9nZ2xlU3RlcHBlclZpZXcoKTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlU3RlcHBlclZpZXcoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCA8IHdpbmRvdy5pbm5lcldpZHRoLCBlID0gdGhpcy5fb3B0aW9ucy5zdGVwcGVyVmVydGljYWxCcmVha3BvaW50ID4gd2luZG93LmlubmVyV2lkdGgsIGkgPSB0aGlzLl9vcHRpb25zLnN0ZXBwZXJNb2JpbGVCcmVha3BvaW50ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdCAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0gb2kgJiYgdGhpcy5fdG9nZ2xlSG9yaXpvbnRhbCgpLCBlICYmICFpICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB5dCAmJiAodGhpcy5fc3RlcHMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgY29uc3QgbyA9IGguZmluZE9uZShgJHtzdH1gLCBuKTtcbiAgICAgIHRoaXMuX3Jlc2V0U3RlcHBlckhlaWdodCgpLCB0aGlzLl9zaG93RWxlbWVudChvKTtcbiAgICB9KSwgdGhpcy5fdG9nZ2xlVmVydGljYWwoKSk7XG4gIH1cbiAgX3RvZ2dsZVN0ZXAodCkge1xuICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAhPT0gdCAmJiAodGhpcy5fb3B0aW9ucy5zdGVwcGVyTm9FZGl0YWJsZSAmJiB0aGlzLl90b2dnbGVEaXNhYmxlZCgpLCB0aGlzLl9zaG93RWxlbWVudChcbiAgICAgIGguZmluZE9uZShgJHtzdH1gLCB0aGlzLl9zdGVwc1t0XSlcbiAgICApLCB0aGlzLl90b2dnbGVBY3RpdmUodCksIHQgPiB0aGlzLl9hY3RpdmVTdGVwSW5kZXggJiYgdGhpcy5fdG9nZ2xlQ29tcGxldGVkKHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCksIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBvaSA/IHRoaXMuX2FuaW1hdGVIb3Jpem9udGFsU3RlcCh0KSA6ICh0aGlzLl9hbmltYXRlVmVydGljYWxTdGVwKHQpLCB0aGlzLl9zZXRTaW5nbGVTdGVwSGVpZ2h0KHRoaXMuX3N0ZXBzW3RdKSksIHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChcbiAgICAgIGguZmluZE9uZShgJHtHfWAsIHRoaXMuYWN0aXZlU3RlcCksXG4gICAgICBoLmZpbmRPbmUoYCR7R31gLCB0aGlzLl9zdGVwc1t0XSlcbiAgICApLCB0aGlzLl9hY3RpdmVTdGVwSW5kZXggPSB0LCB0aGlzLl9zdGVwc1t0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLnNldEF0dHJpYnV0ZShcImRhdGEtdGVcIiwgXCJhY3RpdmUtc3RlcFwiKSwgdGhpcy5fc3RlcHMuZm9yRWFjaCgoZSwgaSkgPT4ge1xuICAgICAgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdICE9PSBpICYmIGUucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZVwiKTtcbiAgICB9KSk7XG4gIH1cbiAgX3Jlc2V0U3RlcHBlckhlaWdodCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gIH1cbiAgX3NldFN0ZXBzSGVpZ2h0KCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBoLmZpbmRPbmUoYCR7c3R9YCwgdCksIGkgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKTtcbiAgICAgIHRoaXMuX3ZlcnRpY2FsU3RlcHBlclN0eWxlcy5wdXNoKHtcbiAgICAgICAgcGFkZGluZ1RvcDogcGFyc2VGbG9hdChpLnBhZGRpbmdUb3ApLFxuICAgICAgICBwYWRkaW5nQm90dG9tOiBwYXJzZUZsb2F0KGkucGFkZGluZ0JvdHRvbSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbiA9IGUuc2Nyb2xsSGVpZ2h0O1xuICAgICAgZS5zdHlsZS5oZWlnaHQgPSBgJHtufXB4YDtcbiAgICB9KTtcbiAgfVxuICBfc2V0U2luZ2xlU3RlcEhlaWdodCh0KSB7XG4gICAgY29uc3QgZSA9IGguZmluZE9uZShgJHtzdH1gLCB0KSwgaSA9IHRoaXMuYWN0aXZlU3RlcCA9PT0gdCwgbiA9IHRoaXMuX3N0ZXBzLmluZGV4T2YodCk7XG4gICAgbGV0IG87XG4gICAgaSA/IChlLnN0eWxlLmhlaWdodCA9IFwiXCIsIG8gPSBlLnNjcm9sbEhlaWdodCkgOiBvID0gZS5zY3JvbGxIZWlnaHQgKyB0aGlzLl92ZXJ0aWNhbFN0ZXBwZXJTdHlsZXNbbl0ucGFkZGluZ1RvcCArIHRoaXMuX3ZlcnRpY2FsU3RlcHBlclN0eWxlc1tuXS5wYWRkaW5nQm90dG9tLCBlLnN0eWxlLmhlaWdodCA9IGAke299cHhgO1xuICB9XG4gIF90b2dnbGVWZXJ0aWNhbCgpIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IHl0LCB0aGlzLl9zZXRTdGVwc0hlaWdodCgpLCB0aGlzLl9oaWRlSW5hY3RpdmVTdGVwcygpO1xuICB9XG4gIF90b2dnbGVIb3Jpem9udGFsKCkge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0gb2ksIHRoaXMuX3NldEhlaWdodCh0aGlzLmFjdGl2ZVN0ZXApLCB0aGlzLl9oaWRlSW5hY3RpdmVTdGVwcygpO1xuICB9XG4gIF90b2dnbGVTdGVwcGVyQ2xhc3MoKSB7XG4gICAgaC5maW5kT25lKFxuICAgICAgXCJbZGF0YS10ZS1zdGVwcGVyLXR5cGVdXCIsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSAhPT0gbnVsbCAmJiB0aGlzLl9zdGVwcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBoLmZpbmRPbmUoYCR7c3R9YCwgZSkuY2xhc3NMaXN0LnJlbW92ZShcIiFteS0wXCIpLCBoLmZpbmRPbmUoYCR7c3R9YCwgZSkuY2xhc3NMaXN0LnJlbW92ZShcIiFweS0wXCIpLCBoLmZpbmRPbmUoYCR7c3R9YCwgZSkuY2xhc3NMaXN0LnJlbW92ZShcIiFoLTBcIik7XG4gICAgfSk7XG4gIH1cbiAgX3RvZ2dsZVN0ZXBDbGFzcyh0LCBlLCBpKSB7XG4gICAgaSAmJiB0aGlzLl9zdGVwc1t0XS5jbGFzc0xpc3RbZV0oaSk7XG4gIH1cbiAgX2JpbmRLZXlzTmF2aWdhdGlvbigpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoXG4gICAgICAhMSxcbiAgICAgIGguZmluZE9uZShgJHtHfWAsIHRoaXMuYWN0aXZlU3RlcClcbiAgICApLCB0aGlzLl9zdGVwcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5maW5kT25lKGAke0d9YCwgdCk7XG4gICAgICB1Lm9uKGUsIFFyLCAoaSkgPT4ge1xuICAgICAgICBjb25zdCBuID0gaC5wYXJlbnRzKFxuICAgICAgICAgIGkuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBgJHtWdH1gXG4gICAgICAgIClbMF0sIG8gPSBoLm5leHQobiwgYCR7VnR9YClbMF0sIHIgPSBoLnByZXYobiwgYCR7VnR9YClbMF0sIGEgPSBoLmZpbmRPbmUoXG4gICAgICAgICAgYCR7R31gLFxuICAgICAgICAgIG5cbiAgICAgICAgKSwgbCA9IGguZmluZE9uZShcbiAgICAgICAgICBgJHtHfWAsXG4gICAgICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgICAgICk7XG4gICAgICAgIGxldCBjID0gbnVsbCwgZCA9IG51bGw7XG4gICAgICAgIGlmIChvICYmIChjID0gaC5maW5kT25lKGAke0d9YCwgbykpLCByICYmIChkID0gaC5maW5kT25lKGAke0d9YCwgcikpLCBpLmtleUNvZGUgPT09IEllICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB5dCAmJiAoZCA/ICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgZCksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgZCksIGQuZm9jdXMoKSkgOiBjICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgYyksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgYyksIGMuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09ICRlICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB5dCAmJiAoYyA/ICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgYyksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgYyksIGMuZm9jdXMoKSkgOiBkICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgZCksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgZCksIGQuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09IFUgJiYgdGhpcy5fY3VycmVudFZpZXcgPT09IHl0ICYmIChpLnByZXZlbnREZWZhdWx0KCksIGMgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBjKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBjKSwgYy5mb2N1cygpKSksIGkua2V5Q29kZSA9PT0gcnQgJiYgdGhpcy5fY3VycmVudFZpZXcgPT09IHl0ICYmIChpLnByZXZlbnREZWZhdWx0KCksIGQgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBkKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBkKSwgZC5mb2N1cygpKSksIGkua2V5Q29kZSA9PT0gTGUpIHtcbiAgICAgICAgICBjb25zdCBfID0gaC5maW5kT25lKFxuICAgICAgICAgICAgYCR7R31gLFxuICAgICAgICAgICAgdGhpcy5fc3RlcHNbMF1cbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBfKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBfKSwgXy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpLmtleUNvZGUgPT09IE1lKSB7XG4gICAgICAgICAgY29uc3QgXyA9IHRoaXMuX3N0ZXBzW3RoaXMuX3N0ZXBzLmxlbmd0aCAtIDFdLCBmID0gaC5maW5kT25lKGAke0d9YCwgXyk7XG4gICAgICAgICAgdGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGYpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIGYpLCBmLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgKGkua2V5Q29kZSA9PT0gbHQgfHwgaS5rZXlDb2RlID09PSBwcykgJiYgKGkucHJldmVudERlZmF1bHQoKSwgdGhpcy5jaGFuZ2VTdGVwKHRoaXMuX3N0ZXBzLmluZGV4T2YobikpKSwgaS5rZXlDb2RlID09PSBmaSAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGwpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsICExKSwgbC5mb2N1cygpKTtcbiAgICAgIH0pLCB1Lm9uKGUsIEdfLCAoaSkgPT4ge1xuICAgICAgICBjb25zdCBuID0gaC5wYXJlbnRzKFxuICAgICAgICAgIGkuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBgJHtWdH1gXG4gICAgICAgIClbMF0sIG8gPSBoLmZpbmRPbmUoXG4gICAgICAgICAgYCR7R31gLFxuICAgICAgICAgIG5cbiAgICAgICAgKSwgciA9IGguZmluZE9uZShcbiAgICAgICAgICBgJHtHfWAsXG4gICAgICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgICAgICk7XG4gICAgICAgIGkua2V5Q29kZSA9PT0gZmkgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChvLCByKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyghMSwgciksIHIuZm9jdXMoKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlU3RlcFRhYkluZGV4KHQsIGUpIHtcbiAgICB0ICYmIHQuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgLTEpLCBlICYmIGUuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgMCk7XG4gIH1cbiAgX3RvZ2dsZU91dGxpbmVTdHlsZXModCwgZSkge1xuICAgIHQgJiYgKHQuc3R5bGUub3V0bGluZSA9IFwiXCIpLCBlICYmIChlLnN0eWxlLm91dGxpbmUgPSBcInJldmVydFwiKTtcbiAgfVxuICBfdG9nZ2xlRGlzYWJsZWQoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZChgJHtHfWAsIHRoaXMuX2VsZW1lbnQpLCBlID0gaC5maW5kKFxuICAgICAgYCR7Sml9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHRbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiY29sb3ItWyM4NTg1ODVdXCIpLCB0W3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcImN1cnNvci1kZWZhdWx0XCIpLCBlW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiFiZy1bIzg1ODU4NV1cIiksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwiYWRkXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJEaXNhYmxlZFxuICAgICk7XG4gIH1cbiAgX3RvZ2dsZUFjdGl2ZSh0KSB7XG4gICAgY29uc3QgZSA9IGguZmluZChcbiAgICAgIGAke0pyfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaSA9IGguZmluZChcbiAgICAgIGAke0ppfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBlW3RdLmNsYXNzTGlzdC5hZGQoXCJmb250LW1lZGl1bVwiKSwgaVt0XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RdLmNsYXNzTGlzdC5hZGQoXCIhdGV4dC1wcmltYXJ5LTcwMFwiKSwgaVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIWJnLXN1Y2Nlc3MtMTAwXCIpLCBpW3RdLmNsYXNzTGlzdC5yZW1vdmUoXCIhdGV4dC1zdWNjZXNzLTcwMFwiKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoXCJmb250LW1lZGl1bVwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgXCIhdGV4dC1wcmltYXJ5LTcwMFwiXG4gICAgKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKHQsIFwiYWRkXCIsIHRoaXMuX29wdGlvbnMuc3RlcHBlckFjdGl2ZSksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwicmVtb3ZlXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJBY3RpdmVcbiAgICApO1xuICB9XG4gIF90b2dnbGVDb21wbGV0ZWQodCkge1xuICAgIGNvbnN0IGUgPSBoLmZpbmQoXG4gICAgICBgJHtKaX1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgZVt0XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXN1Y2Nlc3MtMTAwXCIpLCBlW3RdLmNsYXNzTGlzdC5hZGQoXCIhdGV4dC1zdWNjZXNzLTcwMFwiKSwgZVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIWJnLWRhbmdlci0xMDBcIiksIGVbdF0uY2xhc3NMaXN0LnJlbW92ZShcIiF0ZXh0LWRhbmdlci03MDBcIiksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyh0LCBcImFkZFwiLCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJDb21wbGV0ZWQpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3ModCwgXCJyZW1vdmVcIiwgdGhpcy5fb3B0aW9ucy5zdGVwcGVySW52YWxpZCk7XG4gIH1cbiAgX2hpZGVJbmFjdGl2ZVN0ZXBzKCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZVwiKSB8fCB0aGlzLl9oaWRlRWxlbWVudChoLmZpbmRPbmUoYCR7c3R9YCwgdCkpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRIZWlnaHQodCkge1xuICAgIGNvbnN0IGUgPSBoLmZpbmRPbmUoYCR7c3R9YCwgdCksIGkgPSBnZXRDb21wdXRlZFN0eWxlKGUpLCBuID0gaC5maW5kT25lKGAke0d9YCwgdCksIG8gPSBnZXRDb21wdXRlZFN0eWxlKG4pLCByID0gZS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KGkubWFyZ2luVG9wKSArIHBhcnNlRmxvYXQoaS5tYXJnaW5Cb3R0b20pLCBhID0gbi5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KG8ubWFyZ2luVG9wKSArIHBhcnNlRmxvYXQoby5tYXJnaW5Cb3R0b20pO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7YSArIHJ9cHhgO1xuICB9XG4gIF9oaWRlRWxlbWVudCh0KSB7XG4gICAgIWgucGFyZW50cyhcbiAgICAgIHQsXG4gICAgICBgJHtWdH1gXG4gICAgKVswXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlXCIpICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSB5dCB8fCAodC5jbGFzc0xpc3QuYWRkKFwiIW15LTBcIiksIHQuY2xhc3NMaXN0LmFkZChcIiFweS0wXCIpLCB0LmNsYXNzTGlzdC5hZGQoXCIhaC0wXCIpKTtcbiAgfVxuICBfc2hvd0VsZW1lbnQodCkge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID09PSB5dCA/ICh0LmNsYXNzTGlzdC5yZW1vdmUoXCIhbXktMFwiKSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwiIXB5LTBcIiksIHQuY2xhc3NMaXN0LnJlbW92ZShcIiFoLTBcIikpIDogdC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICB9XG4gIF9hbmltYXRlSG9yaXpvbnRhbFN0ZXAodCkge1xuICAgIGNvbnN0IGUgPSB0ID4gdGhpcy5fYWN0aXZlU3RlcEluZGV4LCBpID0gaC5maW5kT25lKFxuICAgICAgYCR7c3R9YCxcbiAgICAgIHRoaXMuX3N0ZXBzW3RdXG4gICAgKSwgbiA9IGguZmluZE9uZShcbiAgICAgIGAke3N0fWAsXG4gICAgICB0aGlzLmFjdGl2ZVN0ZXBcbiAgICApO1xuICAgIGxldCBvLCByO1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKGQsIF8pID0+IHtcbiAgICAgIGNvbnN0IGYgPSBoLmZpbmRPbmUoYCR7c3R9YCwgZCk7XG4gICAgICBfICE9PSB0ICYmIF8gIT09IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAmJiB0aGlzLl9oaWRlRWxlbWVudChmKTtcbiAgICB9KTtcbiAgICBjb25zdCBhID0gXCJ0cmFuc2xhdGUteC1bMTUwJV1cIiwgbCA9IFwiLXRyYW5zbGF0ZS14LVsxNTAlXVwiLCBjID0gXCJ0cmFuc2xhdGUtMFwiO1xuICAgIGUgPyAociA9IGwsIG8gPSBjLCBpLmNsYXNzTGlzdC5yZW1vdmUoXCJ0cmFuc2xhdGUteC1bMTUwJV1cIiksIGkuY2xhc3NMaXN0LnJlbW92ZShcIi10cmFuc2xhdGUteC1bMTUwJV1cIikpIDogKHIgPSBhLCBvID0gYywgaS5jbGFzc0xpc3QucmVtb3ZlKFwiLXRyYW5zbGF0ZS14LVsxNTAlXVwiKSwgaS5jbGFzc0xpc3QucmVtb3ZlKFwidHJhbnNsYXRlLXgtWzE1MCVdXCIpKSwgbi5jbGFzc0xpc3QuYWRkKHIpLCBpLmNsYXNzTGlzdC5hZGQobyksIHRoaXMuX3NldEhlaWdodCh0aGlzLl9zdGVwc1t0XSk7XG4gIH1cbiAgX2FuaW1hdGVWZXJ0aWNhbFN0ZXAodCkge1xuICAgIGNvbnN0IGUgPSBoLmZpbmRPbmUoXG4gICAgICBgJHtzdH1gLFxuICAgICAgdGhpcy5fc3RlcHNbdF1cbiAgICApLCBpID0gaC5maW5kT25lKFxuICAgICAgYCR7c3R9YCxcbiAgICAgIHRoaXMuYWN0aXZlU3RlcFxuICAgICk7XG4gICAgdGhpcy5faGlkZUVsZW1lbnQoaSksIHRoaXMuX3Nob3dFbGVtZW50KGUpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBtcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgdGEgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIHRzID0gXCJkYXRhLXRlLWlucHV0LXNlbGVjdGVkXCIsIGVhID0gXCJkYXRhLXRlLWlucHV0LW11bHRpcGxlLWFjdGl2ZVwiLCBpYSA9IFwiW2RhdGEtdGUtZm9ybS1jaGVjay1pbnB1dF1cIjtcbmNsYXNzIHNhIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSwgbiwgbywgciwgYSwgbCwgYywgZCwgXykge1xuICAgIHRoaXMuaWQgPSB0LCB0aGlzLm5hdGl2ZU9wdGlvbiA9IGUsIHRoaXMubXVsdGlwbGUgPSBpLCB0aGlzLnZhbHVlID0gbiwgdGhpcy5sYWJlbCA9IG8sIHRoaXMuc2VsZWN0ZWQgPSByLCB0aGlzLmRpc2FibGVkID0gYSwgdGhpcy5oaWRkZW4gPSBsLCB0aGlzLnNlY29uZGFyeVRleHQgPSBjLCB0aGlzLmdyb3VwSWQgPSBkLCB0aGlzLmljb24gPSBfLCB0aGlzLm5vZGUgPSBudWxsLCB0aGlzLmFjdGl2ZSA9ICExO1xuICB9XG4gIHNlbGVjdCgpIHtcbiAgICB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0TXVsdGlwbGUoKSA6IHRoaXMuX3NlbGVjdFNpbmdsZSgpO1xuICB9XG4gIF9zZWxlY3RTaW5nbGUoKSB7XG4gICAgdGhpcy5zZWxlY3RlZCB8fCAodGhpcy5ub2RlLnNldEF0dHJpYnV0ZSh0cywgXCJcIiksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEwKSwgdGhpcy5zZWxlY3RlZCA9ICEwLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMCkpO1xuICB9XG4gIF9zZWxlY3RNdWx0aXBsZSgpIHtcbiAgICBpZiAoIXRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIGNvbnN0IHQgPSBoLmZpbmRPbmUoXG4gICAgICAgIGlhLFxuICAgICAgICB0aGlzLm5vZGVcbiAgICAgICk7XG4gICAgICB0LmNoZWNrZWQgPSAhMCwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSh0cywgXCJcIiksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEwKSwgdGhpcy5zZWxlY3RlZCA9ICEwLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMCk7XG4gICAgfVxuICB9XG4gIGRlc2VsZWN0KCkge1xuICAgIHRoaXMubXVsdGlwbGUgPyB0aGlzLl9kZXNlbGVjdE11bHRpcGxlKCkgOiB0aGlzLl9kZXNlbGVjdFNpbmdsZSgpO1xuICB9XG4gIF9kZXNlbGVjdFNpbmdsZSgpIHtcbiAgICB0aGlzLnNlbGVjdGVkICYmICh0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKHRzKSwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITEpLCB0aGlzLnNlbGVjdGVkID0gITEsIHRoaXMubmF0aXZlT3B0aW9uICYmICh0aGlzLm5hdGl2ZU9wdGlvbi5zZWxlY3RlZCA9ICExKSk7XG4gIH1cbiAgX2Rlc2VsZWN0TXVsdGlwbGUoKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIGNvbnN0IHQgPSBoLmZpbmRPbmUoXG4gICAgICAgIGlhLFxuICAgICAgICB0aGlzLm5vZGVcbiAgICAgICk7XG4gICAgICB0LmNoZWNrZWQgPSAhMSwgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSh0cyksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKSwgdGhpcy5zZWxlY3RlZCA9ICExLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMSk7XG4gICAgfVxuICB9XG4gIHNldE5vZGUodCkge1xuICAgIHRoaXMubm9kZSA9IHQ7XG4gIH1cbiAgc2V0QWN0aXZlU3R5bGVzKCkge1xuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoZWEsIFwiXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZSA9ICEwLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKHRhLCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQWN0aXZlU3R5bGVzKCkge1xuICAgIHRoaXMuYWN0aXZlICYmICh0aGlzLmFjdGl2ZSA9ICExLCB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKHRhKSksIHRoaXMubXVsdGlwbGUgJiYgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShlYSk7XG4gIH1cbn1cbmNsYXNzIHFfIHtcbiAgY29uc3RydWN0b3IodCA9ICExKSB7XG4gICAgdGhpcy5fbXVsdGlwbGUgPSB0LCB0aGlzLl9zZWxlY3Rpb25zID0gW107XG4gIH1cbiAgc2VsZWN0KHQpIHtcbiAgICB0aGlzLl9tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdGlvbnMucHVzaCh0KSA6IHRoaXMuX3NlbGVjdGlvbnMgPSBbdF07XG4gIH1cbiAgZGVzZWxlY3QodCkge1xuICAgIGlmICh0aGlzLl9tdWx0aXBsZSkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX3NlbGVjdGlvbnMuZmluZEluZGV4KFxuICAgICAgICAoaSkgPT4gdCA9PT0gaVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbnMuc3BsaWNlKGUsIDEpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5fc2VsZWN0aW9ucyA9IFtdO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3NlbGVjdGlvbnMgPSBbXTtcbiAgfVxuICBnZXQgc2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zWzBdO1xuICB9XG4gIGdldCBzZWxlY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zO1xuICB9XG4gIGdldCBsYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uc1swXSAmJiB0aGlzLnNlbGVjdGlvbi5sYWJlbDtcbiAgfVxuICBnZXQgbGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zLm1hcCgodCkgPT4gdC5sYWJlbCkuam9pbihcIiwgXCIpO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25zWzBdICYmIHRoaXMuc2VsZWN0aW9uLnZhbHVlO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnMubWFwKCh0KSA9PiB0LnZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gam4ocykge1xuICByZXR1cm4gcy5maWx0ZXIoKHQpID0+ICF0LmRpc2FibGVkKS5ldmVyeSgodCkgPT4gdC5zZWxlY3RlZCk7XG59XG5jb25zdCBRXyA9IFwiZGF0YS10ZS1zZWxlY3QtZm9ybS1vdXRsaW5lLXJlZlwiLCBaXyA9IFwiZGF0YS10ZS1zZWxlY3Qtd3JhcHBlci1yZWZcIiwgSl8gPSBcImRhdGEtdGUtc2VsZWN0LWlucHV0LXJlZlwiLCB0bSA9IFwiZGF0YS10ZS1zZWxlY3QtY2xlYXItYnRuLXJlZlwiLCBlbSA9IFwiZGF0YS10ZS1zZWxlY3QtZHJvcGRvd24tY29udGFpbmVyLXJlZlwiLCBpbSA9IFwiZGF0YS10ZS1zZWxlY3QtZHJvcGRvd24tcmVmXCIsIHNtID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb25zLXdyYXBwZXItcmVmXCIsIG5tID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb25zLWxpc3QtcmVmXCIsIG9tID0gXCJkYXRhLXRlLXNlbGVjdC1pbnB1dC1maWx0ZXItcmVmXCIsIHhsID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tcmVmXCIsIHJtID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tYWxsLXJlZlwiLCBhbSA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLXRleHQtcmVmXCIsIGxtID0gXCJkYXRhLXRlLWZvcm0tY2hlY2staW5wdXRcIiwgY20gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1yZWZcIiwgZG0gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1sYWJlbC1yZWZcIiwgU2wgPSBcImRhdGEtdGUtc2VsZWN0LXNlbGVjdGVkXCIsIGhtID0gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSA4LjI1bC03LjUgNy41LTcuNS03LjVcIiAvPlxuPC9zdmc+XG5gLCB1bSA9IChzKSA9PiB7XG4gIHMuY29kZSA9PT0gXCJUYWJcIiB8fCBzLmNvZGUgPT09IFwiRXNjXCIgfHwgcy5wcmV2ZW50RGVmYXVsdCgpO1xufTtcbmZ1bmN0aW9uIGVzKHMsIHQsIGUsIGksIG4pIHtcbiAgdC5zZWxlY3RTaXplID09PSBcImRlZmF1bHRcIiAmJiBwLmFkZENsYXNzKHMsIGUpLCB0LnNlbGVjdFNpemUgPT09IFwic21cIiAmJiBwLmFkZENsYXNzKHMsIGkpLCB0LnNlbGVjdFNpemUgPT09IFwibGdcIiAmJiBwLmFkZENsYXNzKHMsIG4pO1xufVxuZnVuY3Rpb24gcG0ocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBzKSwgbi5zZXRBdHRyaWJ1dGUoWl8sIFwiXCIpO1xuICBjb25zdCBvID0gTShcImRpdlwiKTtcbiAgby5zZXRBdHRyaWJ1dGUoUV8sIFwiXCIpLCBwLmFkZENsYXNzKG8sIGkuZm9ybU91dGxpbmUpO1xuICBjb25zdCByID0gTShcImlucHV0XCIpLCBhID0gdC5zZWxlY3RGaWx0ZXIgPyBcImNvbWJvYm94XCIgOiBcImxpc3Rib3hcIiwgbCA9IHQubXVsdGlwbGUgPyBcInRydWVcIiA6IFwiZmFsc2VcIiwgYyA9IHQuZGlzYWJsZWQgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgci5zZXRBdHRyaWJ1dGUoSl8sIFwiXCIpLCBwLmFkZENsYXNzKHIsIGkuc2VsZWN0SW5wdXQpLCBlcyhcbiAgICByLFxuICAgIHQsXG4gICAgaS5zZWxlY3RJbnB1dFNpemVEZWZhdWx0LFxuICAgIGkuc2VsZWN0SW5wdXRTaXplU20sXG4gICAgaS5zZWxlY3RJbnB1dFNpemVMZ1xuICApLCB0LnNlbGVjdEZvcm1XaGl0ZSAmJiBwLmFkZENsYXNzKHIsIGkuc2VsZWN0SW5wdXRXaGl0ZSksIHIuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHRcIiksIHIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBhKSwgci5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiLCBsKSwgci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsIGMpLCByLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgXCJ0cnVlXCIpLCByLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgITEpLCB0LnRhYkluZGV4ICYmIHIuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgdC50YWJJbmRleCksIHQuZGlzYWJsZWQgJiYgci5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSwgdC5zZWxlY3RQbGFjZWhvbGRlciAhPT0gXCJcIiAmJiByLnNldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIsIHQuc2VsZWN0UGxhY2Vob2xkZXIpLCB0LnNlbGVjdFZhbGlkYXRpb24gPyAocC5hZGRTdHlsZShyLCB7XG4gICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcIm5vbmVcIixcbiAgICBcImNhcmV0LWNvbG9yXCI6IFwidHJhbnNwYXJlbnRcIlxuICB9KSwgcC5hZGRTdHlsZShvLCB7IGN1cnNvcjogXCJwb2ludGVyXCIgfSkpIDogci5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCBcInRydWVcIiksIHQuc2VsZWN0VmFsaWRhdGlvbiAmJiAoci5zZXRBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiLCBcInRydWVcIiksIHIuc2V0QXR0cmlidXRlKFwiYXJpYS1yZXF1aXJlZFwiLCBcInRydWVcIiksIHIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdW0pKTtcbiAgY29uc3QgZCA9IE0oXCJkaXZcIik7XG4gIHAuYWRkQ2xhc3MoZCwgaS5zZWxlY3RWYWxpZGF0aW9uVmFsaWQpO1xuICBjb25zdCBfID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgYCR7dC5zZWxlY3RWYWxpZEZlZWRiYWNrfWBcbiAgKTtcbiAgZC5hcHBlbmRDaGlsZChfKTtcbiAgY29uc3QgZiA9IE0oXCJkaXZcIik7XG4gIHAuYWRkQ2xhc3MoZiwgaS5zZWxlY3RWYWxpZGF0aW9uSW52YWxpZCk7XG4gIGNvbnN0IG0gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcbiAgICBgJHt0LnNlbGVjdEludmFsaWRGZWVkYmFja31gXG4gICk7XG4gIGYuYXBwZW5kQ2hpbGQobSk7XG4gIGNvbnN0IGcgPSBNKFwic3BhblwiKTtcbiAgZy5zZXRBdHRyaWJ1dGUodG0sIFwiXCIpLCBwLmFkZENsYXNzKGcsIGkuc2VsZWN0Q2xlYXJCdG4pLCBlcyhcbiAgICBnLFxuICAgIHQsXG4gICAgaS5zZWxlY3RDbGVhckJ0bkRlZmF1bHQsXG4gICAgaS5zZWxlY3RDbGVhckJ0blNtLFxuICAgIGkuc2VsZWN0Q2xlYXJCdG5MZ1xuICApLCB0LnNlbGVjdEZvcm1XaGl0ZSAmJiBwLmFkZENsYXNzKGcsIGkuc2VsZWN0Q2xlYXJCdG5XaGl0ZSk7XG4gIGNvbnN0IGIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIuKclVwiKTtcbiAgZy5hcHBlbmRDaGlsZChiKSwgZy5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gIGNvbnN0IFQgPSBNKFwic3BhblwiKTtcbiAgcmV0dXJuIHAuYWRkQ2xhc3MoVCwgaS5zZWxlY3RBcnJvdyksIGVzKFxuICAgIFQsXG4gICAgdCxcbiAgICBpLnNlbGVjdEFycm93RGVmYXVsdCxcbiAgICBpLnNlbGVjdEFycm93U20sXG4gICAgaS5zZWxlY3RBcnJvd0xnXG4gICksIHQuc2VsZWN0Rm9ybVdoaXRlICYmIHAuYWRkQ2xhc3MoVCwgaS5zZWxlY3RBcnJvd1doaXRlKSwgVC5pbm5lckhUTUwgPSBobSwgby5hcHBlbmRDaGlsZChyKSwgZSAmJiAocC5hZGRDbGFzcyhlLCBpLnNlbGVjdExhYmVsKSwgZXMoXG4gICAgZSxcbiAgICB0LFxuICAgIGkuc2VsZWN0TGFiZWxTaXplRGVmYXVsdCxcbiAgICBpLnNlbGVjdExhYmVsU2l6ZVNtLFxuICAgIGkuc2VsZWN0TGFiZWxTaXplTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgcC5hZGRDbGFzcyhlLCBpLnNlbGVjdExhYmVsV2hpdGUpLCBvLmFwcGVuZENoaWxkKGUpKSwgdC5zZWxlY3RWYWxpZGF0aW9uICYmIChvLmFwcGVuZENoaWxkKGQpLCBvLmFwcGVuZENoaWxkKGYpKSwgdC5zZWxlY3RDbGVhckJ1dHRvbiAmJiBvLmFwcGVuZENoaWxkKGcpLCBvLmFwcGVuZENoaWxkKFQpLCBuLmFwcGVuZENoaWxkKG8pLCBuO1xufVxuZnVuY3Rpb24gbmEocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICBjb25zdCBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbC5zZXRBdHRyaWJ1dGUoZW0sIFwiXCIpLCBwLmFkZENsYXNzKGwsIGEuc2VsZWN0RHJvcGRvd25Db250YWluZXIpLCBsLnNldEF0dHJpYnV0ZShcImlkXCIsIGAke3N9YCksIGwuc3R5bGUud2lkdGggPSBgJHtlfXB4YDtcbiAgY29uc3QgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGMuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCksIGMuc2V0QXR0cmlidXRlKGltLCBcIlwiKSwgcC5hZGRDbGFzcyhjLCBhLmRyb3Bkb3duKTtcbiAgY29uc3QgZCA9IE0oXCJkaXZcIik7XG4gIGQuc2V0QXR0cmlidXRlKHNtLCBcIlwiKSwgcC5hZGRDbGFzcyhkLCBhLm9wdGlvbnNXcmFwcGVyKSwgcC5hZGRDbGFzcyhkLCBhLm9wdGlvbnNXcmFwcGVyU2Nyb2xsYmFyKSwgZC5zdHlsZS5tYXhIZWlnaHQgPSBgJHtpfXB4YDtcbiAgY29uc3QgXyA9IERsKFxuICAgIG8sXG4gICAgbixcbiAgICB0LFxuICAgIGFcbiAgKTtcbiAgcmV0dXJuIGQuYXBwZW5kQ2hpbGQoXyksIHQuc2VsZWN0RmlsdGVyICYmIGMuYXBwZW5kQ2hpbGQoXG4gICAgZm0odC5zZWxlY3RTZWFyY2hQbGFjZWhvbGRlciwgYSlcbiAgKSwgYy5hcHBlbmRDaGlsZChkKSwgciAmJiBjLmFwcGVuZENoaWxkKHIpLCBsLmFwcGVuZENoaWxkKGMpLCBsO1xufVxuZnVuY3Rpb24gRGwocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0gTShcImRpdlwiKTtcbiAgbi5zZXRBdHRyaWJ1dGUobm0sIFwiXCIpLCBwLmFkZENsYXNzKG4sIGkub3B0aW9uc0xpc3QpO1xuICBsZXQgbztcbiAgcmV0dXJuIGUubXVsdGlwbGUgPyBvID0gbW0oXG4gICAgcyxcbiAgICB0LFxuICAgIGUsXG4gICAgaVxuICApIDogbyA9IF9tKHMsIGUsIGkpLCBvLmZvckVhY2goKHIpID0+IHtcbiAgICBuLmFwcGVuZENoaWxkKHIpO1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIGZtKHMsIHQpIHtcbiAgY29uc3QgZSA9IE0oXCJkaXZcIik7XG4gIHAuYWRkQ2xhc3MoZSwgdC5pbnB1dEdyb3VwKTtcbiAgY29uc3QgaSA9IE0oXCJpbnB1dFwiKTtcbiAgcmV0dXJuIGkuc2V0QXR0cmlidXRlKG9tLCBcIlwiKSwgcC5hZGRDbGFzcyhpLCB0LnNlbGVjdEZpbHRlcklucHV0KSwgaS5wbGFjZWhvbGRlciA9IHMsIGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInNlYXJjaGJveFwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dFwiKSwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbn1cbmZ1bmN0aW9uIF9tKHMsIHQsIGUpIHtcbiAgcmV0dXJuIElsKHMsIHQsIGUpO1xufVxuZnVuY3Rpb24gbW0ocywgdCwgZSwgaSkge1xuICBsZXQgbiA9IG51bGw7XG4gIGUuc2VsZWN0QWxsICYmIChuID0gZ20oXG4gICAgdCxcbiAgICBzLFxuICAgIGUsXG4gICAgaVxuICApKTtcbiAgY29uc3QgbyA9IElsKHMsIGUsIGkpO1xuICByZXR1cm4gbiA/IFtuLCAuLi5vXSA6IG87XG59XG5mdW5jdGlvbiBJbChzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBbXTtcbiAgcmV0dXJuIHMuZm9yRWFjaCgobikgPT4ge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICBuLFxuICAgICAgXCJvcHRpb25zXCJcbiAgICApKSB7XG4gICAgICBjb25zdCByID0gVG0obiwgdCwgZSk7XG4gICAgICBpLnB1c2gocik7XG4gICAgfSBlbHNlXG4gICAgICBpLnB1c2goJGwobiwgdCwgZSkpO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIGdtKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IGpuKHQpLCBvID0gTShcImRpdlwiKTtcbiAgcmV0dXJuIG8uc2V0QXR0cmlidXRlKHhsLCBcIlwiKSwgcC5hZGRDbGFzcyhvLCBpLnNlbGVjdE9wdGlvbiksIG8uc2V0QXR0cmlidXRlKHJtLCBcIlwiKSwgcC5hZGRTdHlsZShvLCB7XG4gICAgaGVpZ2h0OiBgJHtlLnNlbGVjdE9wdGlvbkhlaWdodH1weGBcbiAgfSksIG8uc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKSwgby5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIG4pLCBuICYmIG8uc2V0QXR0cmlidXRlKFNsLCBcIlwiKSwgby5hcHBlbmRDaGlsZChMbChzLCBlLCBpKSksIHMuc2V0Tm9kZShvKSwgbztcbn1cbmZ1bmN0aW9uICRsKHMsIHQsIGUpIHtcbiAgaWYgKHMubm9kZSlcbiAgICByZXR1cm4gcy5ub2RlO1xuICBjb25zdCBpID0gTShcImRpdlwiKTtcbiAgcmV0dXJuIGkuc2V0QXR0cmlidXRlKHhsLCBcIlwiKSwgcC5hZGRDbGFzcyhpLCBlLnNlbGVjdE9wdGlvbiksIHAuYWRkU3R5bGUoaSwge1xuICAgIGhlaWdodDogYCR7dC5zZWxlY3RPcHRpb25IZWlnaHR9cHhgXG4gIH0pLCBwLnNldERhdGFBdHRyaWJ1dGUoaSwgXCJpZFwiLCBzLmlkKSwgaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpLCBpLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgcy5zZWxlY3RlZCksIGkuc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLCBzLmRpc2FibGVkKSwgcy5zZWxlY3RlZCAmJiBpLnNldEF0dHJpYnV0ZShTbCwgXCJcIiksIHMuZGlzYWJsZWQgJiYgaS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRcIiwgITApLCBzLmhpZGRlbiAmJiBwLmFkZENsYXNzKGksIFwiaGlkZGVuXCIpLCBpLmFwcGVuZENoaWxkKExsKHMsIHQsIGUpKSwgcy5pY29uICYmIGkuYXBwZW5kQ2hpbGQoRW0ocywgZSkpLCBzLnNldE5vZGUoaSksIGk7XG59XG5mdW5jdGlvbiBMbChzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBNKFwic3BhblwiKTtcbiAgaS5zZXRBdHRyaWJ1dGUoYW0sIFwiXCIpLCBwLmFkZENsYXNzKGksIGUuc2VsZWN0T3B0aW9uVGV4dCk7XG4gIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzLmxhYmVsKTtcbiAgcmV0dXJuIHQubXVsdGlwbGUgJiYgaS5hcHBlbmRDaGlsZCh2bShzLCBlKSksIGkuYXBwZW5kQ2hpbGQobiksIChzLnNlY29uZGFyeVRleHQgfHwgdHlwZW9mIHMuc2Vjb25kYXJ5VGV4dCA9PSBcIm51bWJlclwiKSAmJiBpLmFwcGVuZENoaWxkKFxuICAgIGJtKHMuc2Vjb25kYXJ5VGV4dCwgZSlcbiAgKSwgaTtcbn1cbmZ1bmN0aW9uIGJtKHMsIHQpIHtcbiAgY29uc3QgZSA9IE0oXCJzcGFuXCIpO1xuICBwLmFkZENsYXNzKGUsIHQuc2VsZWN0T3B0aW9uU2Vjb25kYXJ5VGV4dCk7XG4gIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzKTtcbiAgcmV0dXJuIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG59XG5mdW5jdGlvbiB2bShzLCB0KSB7XG4gIGNvbnN0IGUgPSBNKFwiaW5wdXRcIik7XG4gIGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImNoZWNrYm94XCIpLCBwLmFkZENsYXNzKGUsIHQuZm9ybUNoZWNrSW5wdXQpLCBlLnNldEF0dHJpYnV0ZShsbSwgXCJcIik7XG4gIGNvbnN0IGkgPSBNKFwibGFiZWxcIik7XG4gIHJldHVybiBzLnNlbGVjdGVkICYmIGUuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCAhMCksIHMuZGlzYWJsZWQgJiYgZS5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCAhMCksIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG59XG5mdW5jdGlvbiBFbShzLCB0KSB7XG4gIGNvbnN0IGUgPSBNKFwic3BhblwiKSwgaSA9IE0oXCJpbWdcIik7XG4gIHJldHVybiBwLmFkZENsYXNzKGksIHQuc2VsZWN0T3B0aW9uSWNvbiksIGkuc3JjID0gcy5pY29uLCBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gVG0ocywgdCwgZSkge1xuICBjb25zdCBpID0gTShcImRpdlwiKTtcbiAgaS5zZXRBdHRyaWJ1dGUoY20sIFwiXCIpLCBwLmFkZENsYXNzKGksIGUuc2VsZWN0T3B0aW9uR3JvdXApLCBpLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJncm91cFwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBzLmlkKSwgcy5oaWRkZW4gJiYgcC5hZGRDbGFzcyhpLCBcImhpZGRlblwiKTtcbiAgY29uc3QgbiA9IE0oXCJsYWJlbFwiKTtcbiAgcmV0dXJuIG4uc2V0QXR0cmlidXRlKGRtLCBcIlwiKSwgcC5hZGRDbGFzcyhuLCBlLnNlbGVjdE9wdGlvbkdyb3VwTGFiZWwpLCBwLmFkZFN0eWxlKG4sIHsgaGVpZ2h0OiBgJHt0LnNlbGVjdE9wdGlvbkhlaWdodH1weGAgfSksIG4uc2V0QXR0cmlidXRlKFwiZm9yXCIsIHMuaWQpLCBuLnRleHRDb250ZW50ID0gcy5sYWJlbCwgaS5hcHBlbmRDaGlsZChuKSwgcy5vcHRpb25zLmZvckVhY2goKG8pID0+IHtcbiAgICBpLmFwcGVuZENoaWxkKCRsKG8sIHQsIGUpKTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiBDbShzLCB0KSB7XG4gIGNvbnN0IGUgPSBNKFwiZGl2XCIpO1xuICByZXR1cm4gZS5pbm5lckhUTUwgPSBzLCBwLmFkZENsYXNzKGUsIHQuc2VsZWN0TGFiZWwpLCBwLmFkZENsYXNzKGUsIHQuc2VsZWN0RmFrZVZhbHVlKSwgZTtcbn1cbmNvbnN0IHluID0gXCJzZWxlY3RcIiwgcmkgPSBcInRlLnNlbGVjdFwiLCBBaSA9IGAuJHtyaX1gLCBBbSA9IGBjbG9zZSR7QWl9YCwgeW0gPSBgb3BlbiR7QWl9YCwgb2EgPSBgb3B0aW9uU2VsZWN0JHtBaX1gLCByYSA9IGBvcHRpb25EZXNlbGVjdCR7QWl9YCwgd20gPSBgdmFsdWVDaGFuZ2Uke0FpfWAsIGttID0gXCJjaGFuZ2VcIiwgYWEgPSBcImRhdGEtdGUtc2VsZWN0LWluaXRcIiwgTWwgPSBcImRhdGEtdGUtc2VsZWN0LW5vLXJlc3VsdHMtcmVmXCIsIGxhID0gXCJkYXRhLXRlLXNlbGVjdC1vcGVuXCIsIHEgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIFd0ID0gXCJkYXRhLXRlLWlucHV0LWZvY3VzZWRcIiwgd24gPSBcImRhdGEtdGUtaW5wdXQtZGlzYWJsZWRcIiwgT20gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1sYWJlbC1yZWZcIiwgeG0gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1hbGwtcmVmXCIsIGVpID0gXCJkYXRhLXRlLXNlbGVjdC1zZWxlY3RlZFwiLCBTbSA9IFwiW2RhdGEtdGUtc2VsZWN0LWxhYmVsLXJlZl1cIiwgY2EgPSBcIltkYXRhLXRlLXNlbGVjdC1pbnB1dC1yZWZdXCIsIERtID0gXCJbZGF0YS10ZS1zZWxlY3QtaW5wdXQtZmlsdGVyLXJlZl1cIiwgSW0gPSBcIltkYXRhLXRlLXNlbGVjdC1kcm9wZG93bi1yZWZdXCIsICRtID0gXCJbZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy13cmFwcGVyLXJlZl1cIiwgZGEgPSBcIltkYXRhLXRlLXNlbGVjdC1vcHRpb25zLWxpc3QtcmVmXVwiLCBMbSA9IFwiW2RhdGEtdGUtc2VsZWN0LW9wdGlvbi1yZWZdXCIsIE1tID0gXCJbZGF0YS10ZS1zZWxlY3QtY2xlYXItYnRuLXJlZl1cIiwgTm0gPSBcIltkYXRhLXRlLXNlbGVjdC1jdXN0b20tY29udGVudC1yZWZdXCIsIFJtID0gYFske01sfV1gLCBoYSA9IFwiW2RhdGEtdGUtc2VsZWN0LWZvcm0tb3V0bGluZS1yZWZdXCIsIFBtID0gXCJbZGF0YS10ZS1zZWxlY3QtdG9nZ2xlXVwiLCBrbiA9IFwiW2RhdGEtdGUtaW5wdXQtbm90Y2gtcmVmXVwiLCBIbSA9IDIwMCwgQm0gPSB7XG4gIHNlbGVjdEF1dG9TZWxlY3Q6ICExLFxuICBzZWxlY3RDb250YWluZXI6IFwiYm9keVwiLFxuICBzZWxlY3RDbGVhckJ1dHRvbjogITEsXG4gIGRpc2FibGVkOiAhMSxcbiAgc2VsZWN0RGlzcGxheWVkTGFiZWxzOiA1LFxuICBzZWxlY3RGb3JtV2hpdGU6ICExLFxuICBtdWx0aXBsZTogITEsXG4gIHNlbGVjdE9wdGlvbnNTZWxlY3RlZExhYmVsOiBcIm9wdGlvbnMgc2VsZWN0ZWRcIixcbiAgc2VsZWN0T3B0aW9uSGVpZ2h0OiAzOCxcbiAgc2VsZWN0QWxsOiAhMCxcbiAgc2VsZWN0QWxsTGFiZWw6IFwiU2VsZWN0IGFsbFwiLFxuICBzZWxlY3RTZWFyY2hQbGFjZWhvbGRlcjogXCJTZWFyY2guLi5cIixcbiAgc2VsZWN0U2l6ZTogXCJkZWZhdWx0XCIsXG4gIHNlbGVjdFZpc2libGVPcHRpb25zOiA1LFxuICBzZWxlY3RGaWx0ZXI6ICExLFxuICBzZWxlY3RGaWx0ZXJEZWJvdW5jZTogMzAwLFxuICBzZWxlY3ROb1Jlc3VsdFRleHQ6IFwiTm8gcmVzdWx0c1wiLFxuICBzZWxlY3RWYWxpZGF0aW9uOiAhMSxcbiAgc2VsZWN0VmFsaWRGZWVkYmFjazogXCJWYWxpZFwiLFxuICBzZWxlY3RJbnZhbGlkRmVlZGJhY2s6IFwiSW52YWxpZFwiLFxuICBzZWxlY3RQbGFjZWhvbGRlcjogXCJcIlxufSwgVm0gPSB7XG4gIHNlbGVjdEF1dG9TZWxlY3Q6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnV0dG9uOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZWQ6IFwiYm9vbGVhblwiLFxuICBzZWxlY3REaXNwbGF5ZWRMYWJlbHM6IFwibnVtYmVyXCIsXG4gIHNlbGVjdEZvcm1XaGl0ZTogXCJib29sZWFuXCIsXG4gIG11bHRpcGxlOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0T3B0aW9uc1NlbGVjdGVkTGFiZWw6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbkhlaWdodDogXCJudW1iZXJcIixcbiAgc2VsZWN0QWxsOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0QWxsTGFiZWw6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFNlYXJjaFBsYWNlaG9sZGVyOiBcInN0cmluZ1wiLFxuICBzZWxlY3RTaXplOiBcInN0cmluZ1wiLFxuICBzZWxlY3RWaXNpYmxlT3B0aW9uczogXCJudW1iZXJcIixcbiAgc2VsZWN0RmlsdGVyOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0RmlsdGVyRGVib3VuY2U6IFwibnVtYmVyXCIsXG4gIHNlbGVjdE5vUmVzdWx0VGV4dDogXCJzdHJpbmdcIixcbiAgc2VsZWN0VmFsaWRhdGlvbjogXCJib29sZWFuXCIsXG4gIHNlbGVjdFZhbGlkRmVlZGJhY2s6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEludmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgc2VsZWN0UGxhY2Vob2xkZXI6IFwic3RyaW5nXCJcbn0sIFdtID0ge1xuICBkcm9wZG93bjogXCJyZWxhdGl2ZSBvdXRsaW5lLW5vbmUgbWluLXctWzEwMHB4XSBtLTAgc2NhbGUtWzAuOF0gb3BhY2l0eS0wIGJnLXdoaXRlIHNoYWRvdy1bMF8ycHhfNXB4XzBfcmdiYSgwLDAsMCwwLjE2KSxfMF8ycHhfMTBweF8wX3JnYmEoMCwwLDAsMC4xMildIHRyYW5zaXRpb24gZHVyYXRpb24tMjAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhdGEtW3RlLXNlbGVjdC1vcGVuXTpzY2FsZS0xMDAgZGF0YS1bdGUtc2VsZWN0LW9wZW5dOm9wYWNpdHktMTAwIGRhcms6YmctemluYy03MDBcIixcbiAgZm9ybUNoZWNrSW5wdXQ6IFwicmVsYXRpdmUgZmxvYXQtbGVmdCBtdC1bMC4xNXJlbV0gbXItWzhweF0gaC1bMS4xMjVyZW1dIHctWzEuMTI1cmVtXSBhcHBlYXJhbmNlLW5vbmUgcm91bmRlZC1bMC4yNXJlbV0gYm9yZGVyLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1uZXV0cmFsLTMwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBvdXRsaW5lLW5vbmUgYmVmb3JlOnBvaW50ZXItZXZlbnRzLW5vbmUgYmVmb3JlOmFic29sdXRlIGJlZm9yZTpoLVswLjg3NXJlbV0gYmVmb3JlOnctWzAuODc1cmVtXSBiZWZvcmU6c2NhbGUtMCBiZWZvcmU6cm91bmRlZC1mdWxsIGJlZm9yZTpiZy10cmFuc3BhcmVudCBiZWZvcmU6b3BhY2l0eS0wIGJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfdHJhbnNwYXJlbnRdIGJlZm9yZTpjb250ZW50LVsnJ10gY2hlY2tlZDpib3JkZXItcHJpbWFyeSBkYXJrOmNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgY2hlY2tlZDpiZy1wcmltYXJ5IGRhcms6Y2hlY2tlZDpiZy1wcmltYXJ5IGNoZWNrZWQ6YmVmb3JlOm9wYWNpdHktWzAuMTZdIGNoZWNrZWQ6YWZ0ZXI6YWJzb2x1dGUgY2hlY2tlZDphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDphZnRlcjotbXQtcHggY2hlY2tlZDphZnRlcjpibG9jayBjaGVja2VkOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmFmdGVyOmJvcmRlci10LTAgY2hlY2tlZDphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgY2hlY2tlZDphZnRlcjpjb250ZW50LVsnJ10gaG92ZXI6Y3Vyc29yLXBvaW50ZXIgaG92ZXI6YmVmb3JlOm9wYWNpdHktWzAuMDRdIGhvdmVyOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBmb2N1czpzaGFkb3ctbm9uZSBmb2N1czp0cmFuc2l0aW9uLVtib3JkZXItY29sb3JfMC4yc10gZm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBmb2N1czpiZWZvcmU6b3BhY2l0eS1bMC4xMl0gZm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGRhcms6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDI1NSwyNTUsMjU1LDAuNCldIGZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGZvY3VzOmFmdGVyOmFic29sdXRlIGZvY3VzOmFmdGVyOnotWzFdIGZvY3VzOmFmdGVyOmJsb2NrIGZvY3VzOmFmdGVyOmgtWzAuODc1cmVtXSBmb2N1czphZnRlcjp3LVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6cm91bmRlZC1bMC4xMjVyZW1dIGZvY3VzOmFmdGVyOmNvbnRlbnQtWycnXSBjaGVja2VkOmZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgY2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGRhcms6Y2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gY2hlY2tlZDpmb2N1czphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjotbXQtcHggY2hlY2tlZDpmb2N1czphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm91bmRlZC1ub25lIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJnLXRyYW5zcGFyZW50XCIsXG4gIGZvcm1PdXRsaW5lOiBcInJlbGF0aXZlXCIsXG4gIGluaXRpYWxpemVkOiBcImhpZGRlblwiLFxuICBpbnB1dEdyb3VwOiBcImZsZXggaXRlbXMtY2VudGVyIHdoaXRlc3BhY2Utbm93cmFwIHAtMi41IHRleHQtY2VudGVyIHRleHQtYmFzZSBmb250LW5vcm1hbCBsZWFkaW5nLVsxLjZdIHRleHQtZ3JheS03MDAgZGFyazpiZy16aW5jLTgwMCBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwXCIsXG4gIG5vUmVzdWx0OiBcImZsZXggaXRlbXMtY2VudGVyIHB4LTRcIixcbiAgb3B0aW9uc0xpc3Q6IFwibGlzdC1ub25lIG0tMCBwLTBcIixcbiAgb3B0aW9uc1dyYXBwZXI6IFwib3ZlcmZsb3cteS1hdXRvXCIsXG4gIG9wdGlvbnNXcmFwcGVyU2Nyb2xsYmFyOiBcIlsmOjotd2Via2l0LXNjcm9sbGJhcl06dy0xIFsmOjotd2Via2l0LXNjcm9sbGJhcl06aC0xIFsmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b25dOmJsb2NrIFsmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b25dOmgtMCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXTpiZy10cmFuc3BhcmVudCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOmJnLXRyYW5zcGFyZW50IFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06cm91bmRlZC1ub25lIFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06IFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06cm91bmRlZC1sIFsmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYl06aC1bNTBweF0gWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iXTpiZy1bIzk5OV0gWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iXTpyb3VuZGVkXCIsXG4gIHNlbGVjdEFycm93OiBcImFic29sdXRlIHJpZ2h0LTMgdGV4dC1bMC44cmVtXSBjdXJzb3ItcG9pbnRlciBwZWVyLWZvY3VzOnRleHQtcHJpbWFyeSBwZWVyLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnRleHQtcHJpbWFyeSBncm91cC1kYXRhLVt0ZS13YXMtdmFsaWRhdGVkXS92YWxpZGF0aW9uOnBlZXItdmFsaWQ6dGV4dC1ncmVlbi02MDAgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLWludmFsaWQ6dGV4dC1bcmdiKDIyMCw3NiwxMDApXSB3LTUgaC01XCIsXG4gIHNlbGVjdEFycm93V2hpdGU6IFwidGV4dC1ncmF5LTUwIHBlZXItZm9jdXM6IXRleHQtd2hpdGUgcGVlci1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTohdGV4dC13aGl0ZVwiLFxuICBzZWxlY3RBcnJvd0RlZmF1bHQ6IFwidG9wLTJcIixcbiAgc2VsZWN0QXJyb3dMZzogXCJ0b3AtWzEzcHhdXCIsXG4gIHNlbGVjdEFycm93U206IFwidG9wLTFcIixcbiAgc2VsZWN0Q2xlYXJCdG46IFwiYWJzb2x1dGUgdG9wLTIgcmlnaHQtOSB0ZXh0LWJsYWNrIGN1cnNvci1wb2ludGVyIGZvY3VzOnRleHQtcHJpbWFyeSBvdXRsaW5lLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwXCIsXG4gIHNlbGVjdENsZWFyQnRuV2hpdGU6IFwiIXRleHQtZ3JheS01MFwiLFxuICBzZWxlY3RDbGVhckJ0bkRlZmF1bHQ6IFwidG9wLTIgdGV4dC1iYXNlXCIsXG4gIHNlbGVjdENsZWFyQnRuTGc6IFwidG9wLVsxMXB4XSB0ZXh0LWJhc2VcIixcbiAgc2VsZWN0Q2xlYXJCdG5TbTogXCJ0b3AtMSB0ZXh0LVswLjhyZW1dXCIsXG4gIHNlbGVjdERyb3Bkb3duQ29udGFpbmVyOiBcInotWzEwNzBdXCIsXG4gIHNlbGVjdEZha2VWYWx1ZTogXCJ0cmFuc2Zvcm0tbm9uZSBoaWRkZW4gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpibG9ja1wiLFxuICBzZWxlY3RGaWx0ZXJJbnB1dDogXCJyZWxhdGl2ZSBtLTAgYmxvY2sgdy1mdWxsIG1pbi13LTAgZmxleC1hdXRvIHJvdW5kZWQgYm9yZGVyIGJvcmRlci1zb2xpZCBib3JkZXItZ3JheS0zMDAgYmctdHJhbnNwYXJlbnQgYmctY2xpcC1wYWRkaW5nIHB4LTMgcHktMS41IHRleHQtYmFzZSBmb250LW5vcm1hbCB0ZXh0LWdyYXktNzAwIHRyYW5zaXRpb24gZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0IG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGZvY3VzOmJvcmRlci1wcmltYXJ5IGZvY3VzOnRleHQtZ3JheS03MDAgZm9jdXM6c2hhZG93LXRlLXByaW1hcnkgZm9jdXM6b3V0bGluZS1ub25lIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBsYWNlaG9sZGVyOnRleHQtZ3JheS0yMDBcIixcbiAgc2VsZWN0SW5wdXQ6IFwicGVlciBibG9jayBtaW4taC1bYXV0b10gdy1mdWxsIHJvdW5kZWQgYm9yZGVyLTAgYmctdHJhbnNwYXJlbnQgb3V0bGluZS1ub25lIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBmb2N1czpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOnBsYWNlaG9sZGVyOm9wYWNpdHktMTAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBsYWNlaG9sZGVyOnRleHQtZ3JheS0yMDAgWyY6bm90KFtkYXRhLXRlLWlucHV0LXBsYWNlaG9sZGVyLWFjdGl2ZV0pXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTAgY3Vyc29yLXBvaW50ZXIgZGF0YS1bdGUtaW5wdXQtZGlzYWJsZWRdOmJnLVsjZTllY2VmXSBkYXRhLVt0ZS1pbnB1dC1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjptYi00IGRhcms6ZGF0YS1bdGUtaW5wdXQtZGlzYWJsZWRdOmJnLXppbmMtNjAwXCIsXG4gIHNlbGVjdElucHV0V2hpdGU6IFwiIXRleHQtZ3JheS01MFwiLFxuICBzZWxlY3RJbnB1dFNpemVEZWZhdWx0OiBcInB5LVswLjMycmVtXSBweC0zIGxlYWRpbmctWzEuNl1cIixcbiAgc2VsZWN0SW5wdXRTaXplTGc6IFwicHktWzAuMzJyZW1dIHB4LTMgbGVhZGluZy1bMi4xNV1cIixcbiAgc2VsZWN0SW5wdXRTaXplU206IFwicHktWzAuMzNyZW1dIHB4LTMgdGV4dC14cyBsZWFkaW5nLVsxLjVdXCIsXG4gIHNlbGVjdExhYmVsOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG9wLTAgbGVmdC0zIG1iLTAgbWF4LXctWzkwJV0gb3JpZ2luLVswXzBdIHRydW5jYXRlIHRleHQtZ3JheS01MDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2Utb3V0IHBlZXItZm9jdXM6c2NhbGUtWzAuOF0gcGVlci1mb2N1czp0ZXh0LXByaW1hcnkgcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOnNjYWxlLVswLjhdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBlZXItZm9jdXM6dGV4dC1ncmF5LTIwMCBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOnNjYWxlLVswLjhdIGRhcms6cGVlci1mb2N1czp0ZXh0LXByaW1hcnlcIixcbiAgc2VsZWN0TGFiZWxXaGl0ZTogXCIhdGV4dC1ncmF5LTUwXCIsXG4gIHNlbGVjdExhYmVsU2l6ZURlZmF1bHQ6IFwicHQtWzAuMzdyZW1dIGxlYWRpbmctWzEuNl0gcGVlci1mb2N1czotdHJhbnNsYXRlLXktWzAuOXJlbV0gcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC45cmVtXSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC45cmVtXVwiLFxuICBzZWxlY3RMYWJlbFNpemVMZzogXCJwdC1bMC4zN3JlbV0gbGVhZGluZy1bMi4xNV0gcGVlci1mb2N1czotdHJhbnNsYXRlLXktWzEuMTVyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzEuMTVyZW1dIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVsxLjE1cmVtXVwiLFxuICBzZWxlY3RMYWJlbFNpemVTbTogXCJwdC1bMC4zN3JlbV0gdGV4dC14cyBsZWFkaW5nLVsxLjVdIHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVswLjc1cmVtXSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVswLjc1cmVtXSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC43NXJlbV1cIixcbiAgc2VsZWN0T3B0aW9uOiBcImZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiB3LWZ1bGwgcHgtNCB0cnVuY2F0ZSB0ZXh0LWdyYXktNzAwIGJnLXRyYW5zcGFyZW50IHNlbGVjdC1ub25lIGN1cnNvci1wb2ludGVyIGRhdGEtW3RlLWlucHV0LW11bHRpcGxlLWFjdGl2ZV06YmctYmxhY2svNSBob3ZlcjpbJjpub3QoW2RhdGEtdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF0pXTpiZy1ibGFjay81IGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06YmctYmxhY2svNSBkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLXNlbGVjdGVkXTpkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJnLWJsYWNrLzUgZGF0YS1bdGUtc2VsZWN0LXNlbGVjdGVkXTpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTpjdXJzb3ItZGVmYXVsdCBkYXRhLVt0ZS1zZWxlY3Qtc2VsZWN0ZWRdOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOnRleHQtZ3JheS00MDAgZGF0YS1bdGUtc2VsZWN0LXNlbGVjdGVkXTpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTpiZy10cmFuc3BhcmVudCBkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLXNlbGVjdGVkXTpiZy1ibGFjay9bMC4wMl0gZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06dGV4dC1ncmF5LTQwMCBkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTpjdXJzb3ItZGVmYXVsdCBncm91cC1kYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWdyb3VwLXJlZl0vb3B0OnBsLTcgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6aG92ZXI6WyY6bm90KFtkYXRhLXRlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdKV06Ymctd2hpdGUvMzAgZGFyazpkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJnLXdoaXRlLzMwIGRhcms6ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1zZWxlY3RlZF06ZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy13aGl0ZS8zMCBkYXJrOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOnRleHQtZ3JheS00MDAgZGFyazpkYXRhLVt0ZS1pbnB1dC1tdWx0aXBsZS1hY3RpdmVdOmJnLXdoaXRlLzMwXCIsXG4gIHNlbGVjdE9wdGlvbkdyb3VwOiBcImdyb3VwL29wdFwiLFxuICBzZWxlY3RPcHRpb25Hcm91cExhYmVsOiBcImZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIHctZnVsbCBweC00IHRydW5jYXRlIGJnLXRyYW5zcGFyZW50IHRleHQtYmxhY2svNTAgc2VsZWN0LW5vbmUgZGFyazp0ZXh0LWdyYXktMzAwXCIsXG4gIHNlbGVjdE9wdGlvbkljb246IFwidy03IGgtNyByb3VuZGVkLWZ1bGxcIixcbiAgc2VsZWN0T3B0aW9uU2Vjb25kYXJ5VGV4dDogXCJibG9jayB0ZXh0LVswLjhyZW1dIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktMzAwXCIsXG4gIHNlbGVjdE9wdGlvblRleHQ6IFwiZ3JvdXBcIixcbiAgc2VsZWN0VmFsaWRhdGlvblZhbGlkOiBcImhpZGRlbiBhYnNvbHV0ZSAtbXQtMyB3LWF1dG8gdGV4dC1zbSB0ZXh0LWdyZWVuLTYwMCBjdXJzb3ItcG9pbnRlciBncm91cC1kYXRhLVt0ZS13YXMtdmFsaWRhdGVkXS92YWxpZGF0aW9uOnBlZXItdmFsaWQ6YmxvY2tcIixcbiAgc2VsZWN0VmFsaWRhdGlvbkludmFsaWQ6IFwiaGlkZGVuIGFic29sdXRlIC1tdC0zIHctYXV0byB0ZXh0LXNtIHRleHQtW3JnYigyMjAsNzYsMTAwKV0gY3Vyc29yLXBvaW50ZXIgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLWludmFsaWQ6YmxvY2tcIlxufSwgRm0gPSB7XG4gIGRyb3Bkb3duOiBcInN0cmluZ1wiLFxuICBmb3JtQ2hlY2tJbnB1dDogXCJzdHJpbmdcIixcbiAgZm9ybU91dGxpbmU6IFwic3RyaW5nXCIsXG4gIGluaXRpYWxpemVkOiBcInN0cmluZ1wiLFxuICBpbnB1dEdyb3VwOiBcInN0cmluZ1wiLFxuICBub1Jlc3VsdDogXCJzdHJpbmdcIixcbiAgb3B0aW9uc0xpc3Q6IFwic3RyaW5nXCIsXG4gIG9wdGlvbnNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBvcHRpb25zV3JhcHBlclNjcm9sbGJhcjogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3c6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEFycm93RGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3dMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3dTbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG46IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnRuRGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG5MZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG5TbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0RHJvcGRvd25Db250YWluZXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEZha2VWYWx1ZTogXCJzdHJpbmdcIixcbiAgc2VsZWN0RmlsdGVySW5wdXQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdElucHV0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dFNpemVEZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dFNpemVMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW5wdXRTaXplU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdExhYmVsOiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbFNpemVEZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbFNpemVMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0TGFiZWxTaXplU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbjogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uR3JvdXA6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbkdyb3VwTGFiZWw6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbkljb246IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvblNlY29uZGFyeVRleHQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvblRleHQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBObCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fb3B0aW9uc1RvUmVuZGVyID0gdGhpcy5fZ2V0T3B0aW9uc1RvUmVuZGVyKHQpLCB0aGlzLl9wbGFpbk9wdGlvbnMgPSB0aGlzLl9nZXRQbGFpbk9wdGlvbnModGhpcy5fb3B0aW9uc1RvUmVuZGVyKSwgdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA9IG51bGwsIHRoaXMuX3NlbGVjdGlvbk1vZGVsID0gbmV3IHFfKHRoaXMubXVsdGlwbGUpLCB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCA9IC0xLCB0aGlzLl9hY3RpdmVPcHRpb24gPSBudWxsLCB0aGlzLl93cmFwcGVySWQgPSBPdChcInNlbGVjdC13cmFwcGVyLVwiKSwgdGhpcy5fZHJvcGRvd25Db250YWluZXJJZCA9IE90KFwic2VsZWN0LWRyb3Bkb3duLWNvbnRhaW5lci1cIiksIHRoaXMuX3NlbGVjdEFsbElkID0gT3QoXCJzZWxlY3QtYWxsLVwiKSwgdGhpcy5fZGVib3VuY2VUaW1lb3V0SWQgPSBudWxsLCB0aGlzLl9kcm9wZG93bkhlaWdodCA9IHRoaXMuX2NvbmZpZy5zZWxlY3RPcHRpb25IZWlnaHQgKiB0aGlzLl9jb25maWcuc2VsZWN0VmlzaWJsZU9wdGlvbnMsIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2lucHV0ID0gbnVsbCwgdGhpcy5fbGFiZWwgPSBoLm5leHQodGhpcy5fZWxlbWVudCwgU20pWzBdLCB0aGlzLl9ub3RjaCA9IG51bGwsIHRoaXMuX2Zha2VWYWx1ZSA9IG51bGwsIHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID0gITEsIHRoaXMuX2N1c3RvbUNvbnRlbnQgPSBoLm5leHQoXG4gICAgICB0LFxuICAgICAgTm1cbiAgICApWzBdLCB0aGlzLl90b2dnbGVCdXR0b24gPSBudWxsLCB0aGlzLl9lbGVtZW50VG9nZ2xlID0gbnVsbCwgdGhpcy5fd3JhcHBlciA9IG51bGwsIHRoaXMuX2lucHV0RWwgPSBudWxsLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciA9IG51bGwsIHRoaXMuX2NvbnRhaW5lciA9IG51bGwsIHRoaXMuX3NlbGVjdEFsbE9wdGlvbiA9IG51bGwsIHRoaXMuX2luaXQoKSwgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGwsIHRoaXMuX2lzT3BlbiA9ICExLCB0aGlzLl9hZGRNdXRhdGlvbk9ic2VydmVyKCksIHRoaXMuX2VsZW1lbnQgJiYgSS5zZXREYXRhKHQsIHJpLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHluO1xuICB9XG4gIGdldCBmaWx0ZXJJbnB1dCgpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKFxuICAgICAgRG0sXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lclxuICAgICk7XG4gIH1cbiAgZ2V0IGRyb3Bkb3duKCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUoSW0sIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKTtcbiAgfVxuICBnZXQgb3B0aW9uc0xpc3QoKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShcbiAgICAgIGRhLFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJcbiAgICApO1xuICB9XG4gIGdldCBvcHRpb25zV3JhcHBlcigpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKFxuICAgICAgJG0sXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lclxuICAgICk7XG4gIH1cbiAgZ2V0IGNsZWFyQnV0dG9uKCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUoTW0sIHRoaXMuX3dyYXBwZXIpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID8gdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA6IHRoaXMuX3BsYWluT3B0aW9ucztcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC52YWx1ZXMgOiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC52YWx1ZTtcbiAgfVxuICBnZXQgbXVsdGlwbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5tdWx0aXBsZTtcbiAgfVxuICBnZXQgaGFzU2VsZWN0QWxsKCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGxlICYmIHRoaXMuX2NvbmZpZy5zZWxlY3RBbGw7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gMDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLkJtLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShcIm11bHRpcGxlXCIpICYmICh0Lm11bHRpcGxlID0gITApLCB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpICYmICh0LmRpc2FibGVkID0gITApLCB0aGlzLl9lbGVtZW50LnRhYkluZGV4ICYmICh0LnRhYkluZGV4ID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiKSksIE4oeW4sIHQsIFZtKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLldtLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKHluLCB0LCBGbSksIHQ7XG4gIH1cbiAgX2dldE9wdGlvbnNUb1JlbmRlcih0KSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHJldHVybiB0LmNoaWxkTm9kZXMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgaWYgKG4ubm9kZU5hbWUgPT09IFwiT1BUR1JPVVBcIikge1xuICAgICAgICBjb25zdCBvID0ge1xuICAgICAgICAgIGlkOiBPdChcImdyb3VwLVwiKSxcbiAgICAgICAgICBsYWJlbDogbi5sYWJlbCxcbiAgICAgICAgICBkaXNhYmxlZDogbi5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSxcbiAgICAgICAgICBoaWRkZW46IG4uaGFzQXR0cmlidXRlKFwiaGlkZGVuXCIpLFxuICAgICAgICAgIG9wdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIG4uY2hpbGROb2Rlcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgICAgYS5ub2RlTmFtZSA9PT0gXCJPUFRJT05cIiAmJiBvLm9wdGlvbnMucHVzaChcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU9wdGlvbk9iamVjdChhLCBvKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pLCBlLnB1c2gobyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbi5ub2RlTmFtZSA9PT0gXCJPUFRJT05cIiAmJiBlLnB1c2godGhpcy5fY3JlYXRlT3B0aW9uT2JqZWN0KG4pKTtcbiAgICB9KSwgZTtcbiAgfVxuICBfZ2V0UGxhaW5PcHRpb25zKHQpIHtcbiAgICBpZiAoIWguZmluZE9uZShcIm9wdGdyb3VwXCIsIHRoaXMuX2VsZW1lbnQpKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgaSA9IFtdO1xuICAgIHJldHVybiB0LmZvckVhY2goKG4pID0+IHtcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgICAgbixcbiAgICAgICAgXCJvcHRpb25zXCJcbiAgICAgICkgPyBuLm9wdGlvbnMuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICBpLnB1c2gocik7XG4gICAgICB9KSA6IGkucHVzaChuKTtcbiAgICB9KSwgaTtcbiAgfVxuICBfY3JlYXRlT3B0aW9uT2JqZWN0KHQsIGUgPSB7fSkge1xuICAgIGNvbnN0IGkgPSBPdChcIm9wdGlvbi1cIiksIG4gPSBlLmlkID8gZS5pZCA6IG51bGwsIG8gPSBlLmRpc2FibGVkID8gZS5kaXNhYmxlZCA6ICExLCByID0gdC5zZWxlY3RlZCB8fCB0Lmhhc0F0dHJpYnV0ZShlaSksIGEgPSB0Lmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpIHx8IG8sIGwgPSB0Lmhhc0F0dHJpYnV0ZShcImhpZGRlblwiKSB8fCBlICYmIGUuaGlkZGVuLCBjID0gdGhpcy5tdWx0aXBsZSwgZCA9IHQudmFsdWUsIF8gPSB0LmxhYmVsLCBmID0gcC5nZXREYXRhQXR0cmlidXRlKFxuICAgICAgdCxcbiAgICAgIFwic2VsZWN0U2Vjb25kYXJ5VGV4dFwiXG4gICAgKSwgbSA9IHAuZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInNlbGVjdC1pY29uXCIpO1xuICAgIHJldHVybiBuZXcgc2EoXG4gICAgICBpLFxuICAgICAgdCxcbiAgICAgIGMsXG4gICAgICBkLFxuICAgICAgXyxcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbCxcbiAgICAgIGYsXG4gICAgICBuLFxuICAgICAgbVxuICAgICk7XG4gIH1cbiAgX2dldE5hdmlnYXRpb25PcHRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMuZmlsdGVyKChlKSA9PiAhZS5oaWRkZW4pO1xuICAgIHJldHVybiB0aGlzLmhhc1NlbGVjdEFsbCA/IFt0aGlzLl9zZWxlY3RBbGxPcHRpb24sIC4uLnRdIDogdDtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9yZW5kZXJNYXRlcmlhbFdyYXBwZXIoKSwgdGhpcy5fd3JhcHBlciA9IGguZmluZE9uZShgIyR7dGhpcy5fd3JhcHBlcklkfWApLCB0aGlzLl9pbnB1dCA9IGguZmluZE9uZShjYSwgdGhpcy5fd3JhcHBlciksIHRoaXMuX2NvbmZpZy5kaXNhYmxlZCAmJiB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUod24sIFwiXCIpO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuc2VsZWN0Q29udGFpbmVyO1xuICAgIHQgPT09IFwiYm9keVwiID8gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuYm9keSA6IHRoaXMuX2NvbnRhaW5lciA9IGguZmluZE9uZSh0KSwgdGhpcy5faW5pdE91dGxpbmVJbnB1dCgpLCB0aGlzLl9zZXREZWZhdWx0U2VsZWN0aW9ucygpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX2FwcGVuZEZha2VWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpLCB0aGlzLl9iaW5kQ29tcG9uZW50RXZlbnRzKCksIHRoaXMuaGFzU2VsZWN0QWxsICYmICh0aGlzLl9zZWxlY3RBbGxPcHRpb24gPSB0aGlzLl9jcmVhdGVTZWxlY3RBbGxPcHRpb24oKSksIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyID0gbmEoXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkLFxuICAgICAgdGhpcy5fY29uZmlnLFxuICAgICAgdGhpcy5faW5wdXQub2Zmc2V0V2lkdGgsXG4gICAgICB0aGlzLl9kcm9wZG93bkhlaWdodCxcbiAgICAgIHRoaXMuX3NlbGVjdEFsbE9wdGlvbixcbiAgICAgIHRoaXMuX29wdGlvbnNUb1JlbmRlcixcbiAgICAgIHRoaXMuX2N1c3RvbUNvbnRlbnQsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSwgdGhpcy5fbGlzdGVuVG9Gb2N1c0NoYW5nZSgpO1xuICB9XG4gIF9yZW5kZXJNYXRlcmlhbFdyYXBwZXIoKSB7XG4gICAgY29uc3QgdCA9IHBtKFxuICAgICAgdGhpcy5fd3JhcHBlcklkLFxuICAgICAgdGhpcy5fY29uZmlnLFxuICAgICAgdGhpcy5fbGFiZWwsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsIHRoaXMuX2VsZW1lbnQpLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaW5pdGlhbGl6ZWQpLCB0LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9pbml0T3V0bGluZUlucHV0KCkge1xuICAgIGNvbnN0IHQgPSBoLmZpbmRPbmUoXG4gICAgICBoYSxcbiAgICAgIHRoaXMuX3dyYXBwZXJcbiAgICApO1xuICAgIG5ldyBWKHQsIHtcbiAgICAgIGlucHV0Rm9ybVdoaXRlOiB0aGlzLl9jb25maWcuc2VsZWN0Rm9ybVdoaXRlXG4gICAgfSkuaW5pdCgpLCB0aGlzLl9ub3RjaCA9IGguZmluZE9uZShrbiwgdGhpcy5fd3JhcHBlcik7XG4gIH1cbiAgX2JpbmRDb21wb25lbnRFdmVudHMoKSB7XG4gICAgdGhpcy5fbGlzdGVuVG9Db21wb25lbnRLZXlkb3duKCksIHRoaXMuX2xpc3RlblRvV3JhcHBlckNsaWNrKCksIHRoaXMuX2xpc3RlblRvQ2xlYXJCdG5DbGljaygpLCB0aGlzLl9saXN0ZW5Ub0NsZWFyQnRuS2V5ZG93bigpO1xuICB9XG4gIF9zZXREZWZhdWx0U2VsZWN0aW9ucygpIHtcbiAgICB0aGlzLm9wdGlvbnMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5zZWxlY3RlZCAmJiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QodCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvQ29tcG9uZW50S2V5ZG93bigpIHtcbiAgICB1Lm9uKHRoaXMuX3dyYXBwZXIsIFwia2V5ZG93blwiLCB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVLZXlkb3duKHQpIHtcbiAgICB0aGlzLl9pc09wZW4gJiYgIXRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgPyB0aGlzLl9oYW5kbGVPcGVuS2V5ZG93bih0KSA6IHRoaXMuX2hhbmRsZUNsb3NlZEtleWRvd24odCk7XG4gIH1cbiAgX2hhbmRsZU9wZW5LZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdC5rZXlDb2RlLCBpID0gZSA9PT0gSXMgfHwgZSA9PT0gcnQgJiYgdC5hbHRLZXkgfHwgZSA9PT0gZmk7XG4gICAgaWYgKGUgPT09IGZpICYmIHRoaXMuX2NvbmZpZy5zZWxlY3RBdXRvU2VsZWN0ICYmICF0aGlzLm11bHRpcGxlICYmIHRoaXMuX2hhbmRsZUF1dG9TZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKSwgaSkge1xuICAgICAgdGhpcy5jbG9zZSgpLCB0aGlzLl9pbnB1dC5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGUpIHtcbiAgICAgIGNhc2UgVTpcbiAgICAgICAgdGhpcy5fc2V0TmV4dE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcnQ6XG4gICAgICAgIHRoaXMuX3NldFByZXZpb3VzT3B0aW9uQWN0aXZlKCksIHRoaXMuX3Njcm9sbFRvT3B0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZTpcbiAgICAgICAgdGhpcy5fc2V0Rmlyc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1lOlxuICAgICAgICB0aGlzLl9zZXRMYXN0T3B0aW9uQWN0aXZlKCksIHRoaXMuX3Njcm9sbFRvT3B0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBsdDpcbiAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9hY3RpdmVPcHRpb24gJiYgKHRoaXMuaGFzU2VsZWN0QWxsICYmIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID09PSAwID8gdGhpcy5faGFuZGxlU2VsZWN0QWxsKCkgOiB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9oYW5kbGVDbG9zZWRLZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdC5rZXlDb2RlO1xuICAgIGlmIChlID09PSBsdCAmJiB0LnByZXZlbnREZWZhdWx0KCksIChlID09PSBsdCB8fCBlID09PSBVICYmIHQuYWx0S2V5IHx8IGUgPT09IFUgJiYgdGhpcy5tdWx0aXBsZSkgJiYgdGhpcy5vcGVuKCksIHRoaXMubXVsdGlwbGUpXG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSBVOlxuICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHJ0OlxuICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSBVOlxuICAgICAgICAgIHRoaXMuX3NldE5leHRPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgcnQ6XG4gICAgICAgICAgdGhpcy5fc2V0UHJldmlvdXNPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGU6XG4gICAgICAgICAgdGhpcy5fc2V0Rmlyc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTWU6XG4gICAgICAgICAgdGhpcy5fc2V0TGFzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9zY3JvbGxUb09wdGlvbih0KSB7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBlO1xuICAgIGNvbnN0IGkgPSB0aGlzLm9wdGlvbnMuZmlsdGVyKChkKSA9PiAhZC5oaWRkZW4pO1xuICAgIHRoaXMuaGFzU2VsZWN0QWxsID8gZSA9IGkuaW5kZXhPZih0KSArIDEgOiBlID0gaS5pbmRleE9mKHQpO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9nZXROdW1iZXJPZkdyb3Vwc0JlZm9yZU9wdGlvbihlKSwgbyA9IGUgKyBuLCByID0gdGhpcy5vcHRpb25zV3JhcHBlciwgYSA9IHIub2Zmc2V0SGVpZ2h0LCBsID0gdGhpcy5fY29uZmlnLnNlbGVjdE9wdGlvbkhlaWdodCwgYyA9IHIuc2Nyb2xsVG9wO1xuICAgIGlmIChlID4gLTEpIHtcbiAgICAgIGNvbnN0IGQgPSBvICogbCwgXyA9IGQgKyBsID4gYyArIGE7XG4gICAgICBkIDwgYyA/IHIuc2Nyb2xsVG9wID0gZCA6IF8gPyByLnNjcm9sbFRvcCA9IGQgLSBhICsgbCA6IHIuc2Nyb2xsVG9wID0gYztcbiAgICB9XG4gIH1cbiAgX2dldE51bWJlck9mR3JvdXBzQmVmb3JlT3B0aW9uKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLmZpbHRlcigocikgPT4gIXIuaGlkZGVuKSwgaSA9IHRoaXMuX29wdGlvbnNUb1JlbmRlci5maWx0ZXIoKHIpID0+ICFyLmhpZGRlbiksIG4gPSB0aGlzLmhhc1NlbGVjdEFsbCA/IHQgLSAxIDogdDtcbiAgICBsZXQgbyA9IDA7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPD0gbjsgcisrKVxuICAgICAgZVtyXS5ncm91cElkICYmIGlbb10gJiYgaVtvXS5pZCAmJiBlW3JdLmdyb3VwSWQgPT09IGlbb10uaWQgJiYgbysrO1xuICAgIHJldHVybiBvO1xuICB9XG4gIF9zZXROZXh0T3B0aW9uQWN0aXZlKCkge1xuICAgIGxldCB0ID0gdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggKyAxO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpO1xuICAgIGlmIChlW3RdKSB7XG4gICAgICBmb3IgKDsgZVt0XS5kaXNhYmxlZDsgKVxuICAgICAgICBpZiAodCArPSAxLCAhZVt0XSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl91cGRhdGVBY3RpdmVPcHRpb24oZVt0XSwgdCk7XG4gICAgfVxuICB9XG4gIF9zZXRQcmV2aW91c09wdGlvbkFjdGl2ZSgpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4IC0gMTtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKTtcbiAgICBpZiAoZVt0XSkge1xuICAgICAgZm9yICg7IGVbdF0uZGlzYWJsZWQ7IClcbiAgICAgICAgaWYgKHQgLT0gMSwgIWVbdF0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKGVbdF0sIHQpO1xuICAgIH1cbiAgfVxuICBfc2V0Rmlyc3RPcHRpb25BY3RpdmUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCk7XG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKGVbMF0sIDApO1xuICB9XG4gIF9zZXRMYXN0T3B0aW9uQWN0aXZlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpLCBlID0gdC5sZW5ndGggLSAxO1xuICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZU9wdGlvbih0W2VdLCBlKTtcbiAgfVxuICBfdXBkYXRlQWN0aXZlT3B0aW9uKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fYWN0aXZlT3B0aW9uO1xuICAgIGkgJiYgaS5yZW1vdmVBY3RpdmVTdHlsZXMoKSwgdC5zZXRBY3RpdmVTdHlsZXMoKSwgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPSBlLCB0aGlzLl9hY3RpdmVPcHRpb24gPSB0O1xuICB9XG4gIF9saXN0ZW5Ub1dyYXBwZXJDbGljaygpIHtcbiAgICB1Lm9uKHRoaXMuX3dyYXBwZXIsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9DbGVhckJ0bkNsaWNrKCkge1xuICAgIHUub24odGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpLCB0aGlzLl9oYW5kbGVDbGVhcigpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0NsZWFyQnRuS2V5ZG93bigpIHtcbiAgICB1Lm9uKHRoaXMuY2xlYXJCdXR0b24sIFwia2V5ZG93blwiLCAodCkgPT4ge1xuICAgICAgdC5rZXlDb2RlID09PSBsdCAmJiAodGhpcy5faGFuZGxlQ2xlYXIoKSwgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2xlYXIoKSB7XG4gICAgaWYgKHRoaXMubXVsdGlwbGUpXG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpLCB0aGlzLl9kZXNlbGVjdEFsbE9wdGlvbnModGhpcy5vcHRpb25zKSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb247XG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpLCB0LmRlc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQobnVsbCksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpO1xuICB9XG4gIF9saXN0ZW5Ub09wdGlvbnNDbGljaygpIHtcbiAgICB1Lm9uKHRoaXMub3B0aW9uc1dyYXBwZXIsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0LnRhcmdldC5oYXNBdHRyaWJ1dGUoXG4gICAgICAgIE9tXG4gICAgICApKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldCA6IGguY2xvc2VzdCh0LnRhcmdldCwgTG0pO1xuICAgICAgaWYgKGkuaGFzQXR0cmlidXRlKHhtKSkge1xuICAgICAgICB0aGlzLl9oYW5kbGVTZWxlY3RBbGwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbyA9IGkuZGF0YXNldC50ZUlkLCByID0gdGhpcy5vcHRpb25zLmZpbmQoKGEpID0+IGEuaWQgPT09IG8pO1xuICAgICAgciAmJiAhci5kaXNhYmxlZCAmJiB0aGlzLl9oYW5kbGVTZWxlY3Rpb24ocik7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdEFsbCgpIHtcbiAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0ZWQgPyAodGhpcy5fZGVzZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5kZXNlbGVjdCgpKSA6ICh0aGlzLl9zZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5zZWxlY3QoKSksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQodGhpcy52YWx1ZSksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpO1xuICB9XG4gIF9zZWxlY3RBbGxPcHRpb25zKHQpIHtcbiAgICB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgICFlLnNlbGVjdGVkICYmICFlLmRpc2FibGVkICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QoZSksIGUuc2VsZWN0KCkpO1xuICAgIH0pO1xuICB9XG4gIF9kZXNlbGVjdEFsbE9wdGlvbnModCkge1xuICAgIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5zZWxlY3RlZCAmJiAhZS5kaXNhYmxlZCAmJiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoZSksIGUuZGVzZWxlY3QoKSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5tdWx0aXBsZSA/ICh0aGlzLl9oYW5kbGVNdWx0aVNlbGVjdGlvbih0KSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSkgOiB0aGlzLl9oYW5kbGVTaW5nbGVTZWxlY3Rpb24odCksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKTtcbiAgfVxuICBfaGFuZGxlQXV0b1NlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5fc2luZ2xlT3B0aW9uU2VsZWN0KHQpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCk7XG4gIH1cbiAgX2hhbmRsZVNpbmdsZVNlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5fc2luZ2xlT3B0aW9uU2VsZWN0KHQpLCB0aGlzLmNsb3NlKCksIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gIH1cbiAgX3NpbmdsZU9wdGlvblNlbGVjdCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnNbMF07XG4gICAgZSAmJiBlICE9PSB0ICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdChlKSwgZS5kZXNlbGVjdCgpLCBlLm5vZGUuc2V0QXR0cmlidXRlKGVpLCAhMSksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCByYSwge1xuICAgICAgdmFsdWU6IGUudmFsdWVcbiAgICB9KSksICghZSB8fCBlICYmIHQgIT09IGUpICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QodCksIHQuc2VsZWN0KCksIHQubm9kZS5zZXRBdHRyaWJ1dGUoZWksICEwKSwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIG9hLCB7XG4gICAgICB2YWx1ZTogdC52YWx1ZVxuICAgIH0pLCB0aGlzLl9lbWl0VmFsdWVDaGFuZ2VFdmVudCh0aGlzLnZhbHVlKSwgdGhpcy5fZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCkpO1xuICB9XG4gIF9oYW5kbGVNdWx0aVNlbGVjdGlvbih0KSB7XG4gICAgdC5zZWxlY3RlZCA/ICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdCh0KSwgdC5kZXNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKGVpLCAhMSksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCByYSwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSkgOiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHQpLCB0LnNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKGVpLCAhMCksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBvYSwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHRoaXMudmFsdWUpLCB0aGlzLl9lbWl0TmF0aXZlQ2hhbmdlRXZlbnQoKTtcbiAgfVxuICBfZW1pdFZhbHVlQ2hhbmdlRXZlbnQodCkge1xuICAgIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB3bSwgeyB2YWx1ZTogdCB9KTtcbiAgfVxuICBfZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCkge1xuICAgIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBrbSk7XG4gIH1cbiAgX3VwZGF0ZUlucHV0VmFsdWUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5sYWJlbHMgOiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5sYWJlbDtcbiAgICBsZXQgZTtcbiAgICB0aGlzLm11bHRpcGxlICYmIHRoaXMuX2NvbmZpZy5zZWxlY3REaXNwbGF5ZWRMYWJlbHMgIT09IC0xICYmIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gdGhpcy5fY29uZmlnLnNlbGVjdERpc3BsYXllZExhYmVscyA/IGUgPSBgJHt0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zLmxlbmd0aH0gJHt0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uc1NlbGVjdGVkTGFiZWx9YCA6IGUgPSB0LCAhdGhpcy5tdWx0aXBsZSAmJiAhdGhpcy5faXNTZWxlY3Rpb25WYWxpZCh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24pID8gdGhpcy5faW5wdXQudmFsdWUgPSBcIlwiIDogdGhpcy5faXNMYWJlbEVtcHR5KHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbikgPyB0aGlzLl9pbnB1dC52YWx1ZSA9IFwiIFwiIDogZSA/IHRoaXMuX2lucHV0LnZhbHVlID0gZSA6IHRoaXMubXVsdGlwbGUgfHwgIXRoaXMuX29wdGlvbnNUb1JlbmRlclswXSA/IHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiA6IHRoaXMuX2lucHV0LnZhbHVlID0gdGhpcy5fb3B0aW9uc1RvUmVuZGVyWzBdLmxhYmVsO1xuICB9XG4gIF9pc1NlbGVjdGlvblZhbGlkKHQpIHtcbiAgICByZXR1cm4gISh0ICYmICh0LmRpc2FibGVkIHx8IHQudmFsdWUgPT09IFwiXCIpKTtcbiAgfVxuICBfaXNMYWJlbEVtcHR5KHQpIHtcbiAgICByZXR1cm4gISEodCAmJiB0LmxhYmVsID09PSBcIlwiKTtcbiAgfVxuICBfYXBwZW5kRmFrZVZhbHVlKCkge1xuICAgIGlmICghdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLl9tdWx0aXBsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uLmxhYmVsO1xuICAgIHRoaXMuX2Zha2VWYWx1ZSA9IENtKHQsIHRoaXMuX2NsYXNzZXMpLCBoLmZpbmRPbmUoXG4gICAgICBoYSxcbiAgICAgIHRoaXMuX3dyYXBwZXJcbiAgICApLmFwcGVuZENoaWxkKHRoaXMuX2Zha2VWYWx1ZSk7XG4gIH1cbiAgX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKGFhKSwgZSA9IHRoaXMuX2lucHV0LnZhbHVlICE9PSBcIlwiO1xuICAgIHRoaXMuX2xhYmVsICYmICh0ICYmIChlIHx8IHRoaXMuX2lzT3BlbiB8fCB0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSkgPyAodGhpcy5fbGFiZWwuc2V0QXR0cmlidXRlKHEsIFwiXCIpLCB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUocSwgXCJcIikpIDogKHRoaXMuX2xhYmVsLnJlbW92ZUF0dHJpYnV0ZShxKSwgdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKHEsIFwiXCIpKSk7XG4gIH1cbiAgX3VwZGF0ZUxhYmVsUG9zaXRpb25XaGlsZUNsb3NpbmcoKSB7XG4gICAgdGhpcy5fbGFiZWwgJiYgKHRoaXMuX2lucHV0LnZhbHVlICE9PSBcIlwiIHx8IHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID8gKHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZShxLCBcIlwiKSwgdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKHEsIFwiXCIpKSA6ICh0aGlzLl9sYWJlbC5yZW1vdmVBdHRyaWJ1dGUocSksIHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShxKSkpO1xuICB9XG4gIF91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpIHtcbiAgICB0aGlzLl9mYWtlVmFsdWUgJiYgKHRoaXMuX2lucHV0LnZhbHVlID09PSBcIlwiICYmIHRoaXMuX2Zha2VWYWx1ZS5pbm5lckhUTUwgIT09IFwiXCIgPyAodGhpcy5faXNGYWtlVmFsdWVBY3RpdmUgPSAhMCwgdGhpcy5fZmFrZVZhbHVlLnNldEF0dHJpYnV0ZShxLCBcIlwiKSkgOiAodGhpcy5faXNGYWtlVmFsdWVBY3RpdmUgPSAhMSwgdGhpcy5fZmFrZVZhbHVlLnJlbW92ZUF0dHJpYnV0ZShxKSkpO1xuICB9XG4gIF91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSB7XG4gICAgaWYgKCF0aGlzLmNsZWFyQnV0dG9uKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbiB8fCB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zLmxlbmd0aCA+IDAgPyBwLmFkZFN0eWxlKHRoaXMuY2xlYXJCdXR0b24sIHsgZGlzcGxheTogXCJibG9ja1wiIH0pIDogcC5hZGRTdHlsZSh0aGlzLmNsZWFyQnV0dG9uLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pO1xuICB9XG4gIF91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2VsZWN0QWxsT3B0aW9uLnNlbGVjdGVkLCBlID0gam4odGhpcy5vcHRpb25zKTtcbiAgICAhZSAmJiB0ID8gdGhpcy5fc2VsZWN0QWxsT3B0aW9uLmRlc2VsZWN0KCkgOiBlICYmICF0ICYmIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5zZWxlY3QoKTtcbiAgfVxuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5faXNPcGVuID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCk7XG4gIH1cbiAgb3BlbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29uZmlnLmRpc2FibGVkLCBlID0gdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHltKTtcbiAgICB0aGlzLl9pc09wZW4gfHwgdCB8fCBlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX29wZW5Ecm9wZG93bigpLCB0aGlzLl91cGRhdGVEcm9wZG93bldpZHRoKCksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCksIHRoaXMuX3Njcm9sbFRvT3B0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbiksIHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgJiYgKHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5maWx0ZXJJbnB1dC5mb2N1cygpO1xuICAgIH0sIDApLCB0aGlzLl9saXN0ZW5Ub1NlbGVjdFNlYXJjaCgpLCB0aGlzLl9saXN0ZW5Ub0Ryb3Bkb3duS2V5ZG93bigpKSwgdGhpcy5fbGlzdGVuVG9PcHRpb25zQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9XaW5kb3dSZXNpemUoKSwgdGhpcy5faXNPcGVuID0gITAsIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fc2V0SW5wdXRBY3RpdmVTdHlsZXMoKSk7XG4gIH1cbiAgX29wZW5Ecm9wZG93bigpIHtcbiAgICB0aGlzLl9wb3BwZXIgPSBqZSh0aGlzLl9pbnB1dCwgdGhpcy5fZHJvcGRvd25Db250YWluZXIsIHtcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b20tc3RhcnRcIixcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAxXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pLCB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZHJvcGRvd25Db250YWluZXIpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZHJvcGRvd24uc2V0QXR0cmlidXRlKGxhLCBcIlwiKTtcbiAgICB9LCAwKTtcbiAgfVxuICBfdXBkYXRlRHJvcGRvd25XaWR0aCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5faW5wdXQub2Zmc2V0V2lkdGg7XG4gICAgcC5hZGRTdHlsZSh0aGlzLl9kcm9wZG93bkNvbnRhaW5lciwgeyB3aWR0aDogYCR7dH1weGAgfSk7XG4gIH1cbiAgX3NldEZpcnN0QWN0aXZlT3B0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpLCBlID0gdGhpcy5fYWN0aXZlT3B0aW9uO1xuICAgIGUgJiYgZS5yZW1vdmVBY3RpdmVTdHlsZXMoKTtcbiAgICBjb25zdCBpID0gdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnNbMF0gOiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb247XG4gICAgaSA/ICh0aGlzLl9hY3RpdmVPcHRpb24gPSBpLCBpLnNldEFjdGl2ZVN0eWxlcygpLCB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCA9IHQuZmluZEluZGV4KFxuICAgICAgKG4pID0+IG4gPT09IGlcbiAgICApKSA6ICh0aGlzLl9hY3RpdmVPcHRpb24gPSBudWxsLCB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCA9IC0xKTtcbiAgfVxuICBfc2V0SW5wdXRBY3RpdmVTdHlsZXMoKSB7XG4gICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKFd0LCBcIlwiKSwgaC5maW5kT25lKGtuLCB0aGlzLl93cmFwcGVyKS5zZXRBdHRyaWJ1dGUoXG4gICAgICBXdCxcbiAgICAgIFwiXCJcbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub1dpbmRvd1Jlc2l6ZSgpIHtcbiAgICB1Lm9uKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5faGFuZGxlV2luZG93UmVzaXplLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVXaW5kb3dSZXNpemUoKSB7XG4gICAgdGhpcy5fZHJvcGRvd25Db250YWluZXIgJiYgdGhpcy5fdXBkYXRlRHJvcGRvd25XaWR0aCgpO1xuICB9XG4gIF9saXN0ZW5Ub1NlbGVjdFNlYXJjaCgpIHtcbiAgICB0aGlzLmZpbHRlcklucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHQudGFyZ2V0LnZhbHVlLCBpID0gdGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlckRlYm91bmNlO1xuICAgICAgdGhpcy5fZGVib3VuY2VGaWx0ZXIoZSwgaSk7XG4gICAgfSk7XG4gIH1cbiAgX2RlYm91bmNlRmlsdGVyKHQsIGUpIHtcbiAgICB0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCAmJiBjbGVhclRpbWVvdXQodGhpcy5fZGVib3VuY2VUaW1lb3V0SWQpLCB0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZmlsdGVyT3B0aW9ucyh0KTtcbiAgICB9LCBlKTtcbiAgfVxuICBfZmlsdGVyT3B0aW9ucyh0KSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHRoaXMuX29wdGlvbnNUb1JlbmRlci5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBjb25zdCByID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgICBvLFxuICAgICAgICBcIm9wdGlvbnNcIlxuICAgICAgKSwgYSA9ICFyICYmIG8ubGFiZWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0LnRvTG93ZXJDYXNlKCkpLCBsID0ge307XG4gICAgICByICYmIChsLmxhYmVsID0gby5sYWJlbCwgbC5vcHRpb25zID0gdGhpcy5fZmlsdGVyKHQsIG8ub3B0aW9ucyksIGwub3B0aW9ucy5sZW5ndGggPiAwICYmIGUucHVzaChsKSksIGEgJiYgZS5wdXNoKG8pO1xuICAgIH0pO1xuICAgIGNvbnN0IGkgPSB0aGlzLl9jb25maWcuc2VsZWN0Tm9SZXN1bHRUZXh0ICE9PSBcIlwiLCBuID0gZS5sZW5ndGggIT09IDA7XG4gICAgaWYgKG4pXG4gICAgICB0aGlzLl91cGRhdGVPcHRpb25zTGlzdFRlbXBsYXRlKGUpLCB0aGlzLl9wb3BwZXIuZm9yY2VVcGRhdGUoKSwgdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA9IHRoaXMuX2dldFBsYWluT3B0aW9ucyhlKSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKTtcbiAgICBlbHNlIGlmICghbiAmJiBpKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5fZ2V0Tm9SZXN1bHRUZW1wbGF0ZSgpO1xuICAgICAgdGhpcy5vcHRpb25zV3JhcHBlci5pbm5lckhUTUwgPSBvO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IGguZmluZE9uZShkYSwgdGhpcy5fZHJvcGRvd25Db250YWluZXIpIHx8IGguZmluZE9uZShSbSwgdGhpcy5fZHJvcGRvd25Db250YWluZXIpLCBpID0gRGwoXG4gICAgICB0LFxuICAgICAgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLFxuICAgICAgdGhpcy5fY29uZmlnLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5vcHRpb25zV3JhcHBlci5yZW1vdmVDaGlsZChlKSwgdGhpcy5vcHRpb25zV3JhcHBlci5hcHBlbmRDaGlsZChpKTtcbiAgfVxuICBfZ2V0Tm9SZXN1bHRUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMubm9SZXN1bHR9XCIgJHtNbH0gc3R5bGU9XCJoZWlnaHQ6ICR7dGhpcy5fY29uZmlnLnNlbGVjdE9wdGlvbkhlaWdodH1weFwiPiR7dGhpcy5fY29uZmlnLnNlbGVjdE5vUmVzdWx0VGV4dH08L2Rpdj5gO1xuICB9XG4gIF9maWx0ZXIodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGUuZmlsdGVyKFxuICAgICAgKG4pID0+IG4ubGFiZWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhpKVxuICAgICk7XG4gIH1cbiAgX2xpc3RlblRvRHJvcGRvd25LZXlkb3duKCkge1xuICAgIHUub24oXG4gICAgICB0aGlzLmRyb3Bkb3duLFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICB0aGlzLl9oYW5kbGVPcGVuS2V5ZG93bi5iaW5kKHRoaXMpXG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSB7XG4gICAgdGhpcy5fb3V0c2lkZUNsaWNrID0gdGhpcy5faGFuZGxlT3V0U2lkZUNsaWNrLmJpbmQodGhpcyksIHUub24oZG9jdW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fb3V0c2lkZUNsaWNrKTtcbiAgfVxuICBfbGlzdGVuVG9Gb2N1c0NoYW5nZSh0ID0gITApIHtcbiAgICBpZiAodCA9PT0gITEpIHtcbiAgICAgIHUucmVtb3ZlKFxuICAgICAgICB0aGlzLl9pbnB1dCxcbiAgICAgICAgXCJmb2N1c1wiLFxuICAgICAgICAoKSA9PiB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUoV3QsIFwiXCIpXG4gICAgICApLCB1LnJlbW92ZShcbiAgICAgICAgdGhpcy5faW5wdXQsXG4gICAgICAgIFwiYmx1clwiLFxuICAgICAgICAoKSA9PiB0aGlzLl9ub3RjaC5yZW1vdmVBdHRyaWJ1dGUoV3QpXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1Lm9uKFxuICAgICAgdGhpcy5faW5wdXQsXG4gICAgICBcImZvY3VzXCIsXG4gICAgICAoKSA9PiB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUoV3QsIFwiXCIpXG4gICAgKSwgdS5vbihcbiAgICAgIHRoaXMuX2lucHV0LFxuICAgICAgXCJibHVyXCIsXG4gICAgICAoKSA9PiB0aGlzLl9ub3RjaC5yZW1vdmVBdHRyaWJ1dGUoV3QpXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlT3V0U2lkZUNsaWNrKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fd3JhcHBlciAmJiB0aGlzLl93cmFwcGVyLmNvbnRhaW5zKHQudGFyZ2V0KSwgaSA9IHQudGFyZ2V0ID09PSB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciwgbiA9IHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyICYmIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLmNvbnRhaW5zKHQudGFyZ2V0KTtcbiAgICBsZXQgbztcbiAgICB0aGlzLl90b2dnbGVCdXR0b24gfHwgKHRoaXMuX2VsZW1lbnRUb2dnbGUgPSBoLmZpbmQoUG0pKSwgdGhpcy5fZWxlbWVudFRvZ2dsZSAmJiB0aGlzLl9lbGVtZW50VG9nZ2xlLmZvckVhY2goKHIpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBwLmdldERhdGFBdHRyaWJ1dGUoXG4gICAgICAgIHIsXG4gICAgICAgIFwic2VsZWN0LXRvZ2dsZVwiXG4gICAgICApO1xuICAgICAgKGEgPT09IHRoaXMuX2VsZW1lbnQuaWQgfHwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoYSkpICYmICh0aGlzLl90b2dnbGVCdXR0b24gPSByLCBvID0gdGhpcy5fdG9nZ2xlQnV0dG9uLmNvbnRhaW5zKHQudGFyZ2V0KSk7XG4gICAgfSksICFlICYmICFpICYmICFuICYmICFvICYmIHRoaXMuY2xvc2UoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCB0ID0gdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEFtKTtcbiAgICAhdGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlciAmJiB0aGlzLmhhc1NlbGVjdEFsbCAmJiAodGhpcy5fcmVzZXRGaWx0ZXJTdGF0ZSgpLCB0aGlzLl91cGRhdGVPcHRpb25zTGlzdFRlbXBsYXRlKHRoaXMuX29wdGlvbnNUb1JlbmRlciksIHRoaXMuX2NvbmZpZy5tdWx0aXBsZSAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpKSwgdGhpcy5fcmVtb3ZlRHJvcGRvd25FdmVudHMoKSwgdGhpcy5kcm9wZG93bi5yZW1vdmVBdHRyaWJ1dGUobGEpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUF0dHJpYnV0ZShXdCksIHRoaXMuX2lucHV0LmJsdXIoKSwgaC5maW5kT25lKGtuLCB0aGlzLl93cmFwcGVyKS5yZW1vdmVBdHRyaWJ1dGUoXG4gICAgICAgIFd0XG4gICAgICApLCB0aGlzLl9sYWJlbCAmJiAhdGhpcy5oYXNTZWxlY3Rpb24gJiYgKHRoaXMuX2xhYmVsLnJlbW92ZUF0dHJpYnV0ZShxKSwgdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKHEsIFwiXCIpLCB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUocSksIHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShxKSksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb25XaGlsZUNsb3NpbmcoKTtcbiAgICB9LCAwKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fZHJvcGRvd25Db250YWluZXIucGFyZW50Tm9kZSA9PT0gdGhpcy5fY29udGFpbmVyICYmIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9kcm9wZG93bkNvbnRhaW5lciksIHRoaXMuX3BvcHBlci5kZXN0cm95KCksIHRoaXMuX2lzT3BlbiA9ICExLCB1Lm9mZih0aGlzLmRyb3Bkb3duLCBcInRyYW5zaXRpb25lbmRcIik7XG4gICAgfSwgSG0pKTtcbiAgfVxuICBfcmVzZXRGaWx0ZXJTdGF0ZSgpIHtcbiAgICB0aGlzLmZpbHRlcklucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA9IG51bGw7XG4gIH1cbiAgX3JlbW92ZURyb3Bkb3duRXZlbnRzKCkge1xuICAgIHUub2ZmKGRvY3VtZW50LCBcImNsaWNrXCIsIHRoaXMuX291dHNpZGVDbGljayksIHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgJiYgdS5vZmYodGhpcy5kcm9wZG93biwgXCJrZXlkb3duXCIpLCB1Lm9mZih0aGlzLm9wdGlvbnNXcmFwcGVyLCBcImNsaWNrXCIpO1xuICB9XG4gIF9hZGRNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICB0aGlzLl93cmFwcGVyICYmICh0aGlzLl91cGRhdGVTZWxlY3Rpb25zKCksIHRoaXMuX3VwZGF0ZURpc2FibGVkU3RhdGUoKSk7XG4gICAgfSksIHRoaXMuX29ic2VydmVNdXRhdGlvbk9ic2VydmVyKCk7XG4gIH1cbiAgX3VwZGF0ZVNlbGVjdGlvbnMoKSB7XG4gICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyID0gdGhpcy5fZ2V0T3B0aW9uc1RvUmVuZGVyKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9wbGFpbk9wdGlvbnMgPSB0aGlzLl9nZXRQbGFpbk9wdGlvbnModGhpcy5fb3B0aW9uc1RvUmVuZGVyKSwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKSwgdGhpcy5fc2V0RGVmYXVsdFNlbGVjdGlvbnMoKSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuZmlsdGVyICYmIHRoaXMuZmlsdGVySW5wdXQgJiYgdGhpcy5maWx0ZXJJbnB1dC52YWx1ZTtcbiAgICB0aGlzLl9pc09wZW4gJiYgIXQgPyAodGhpcy5fdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZSh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpKSA6IHRoaXMuX2lzT3BlbiAmJiB0ID8gKHRoaXMuX2ZpbHRlck9wdGlvbnModGhpcy5maWx0ZXJJbnB1dC52YWx1ZSksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCkpIDogdGhpcy5fZHJvcGRvd25Db250YWluZXIgPSBuYShcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVySWQsXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9pbnB1dC5vZmZzZXRXaWR0aCxcbiAgICAgIHRoaXMuX2Ryb3Bkb3duSGVpZ2h0LFxuICAgICAgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLFxuICAgICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyLFxuICAgICAgdGhpcy5fY3VzdG9tQ29udGVudCxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICB9XG4gIF91cGRhdGVEaXNhYmxlZFN0YXRlKCkge1xuICAgIGNvbnN0IHQgPSBoLmZpbmRPbmUoY2EsIHRoaXMuX3dyYXBwZXIpO1xuICAgIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPyAodGhpcy5fY29uZmlnLmRpc2FibGVkID0gITAsIHQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIiksIHQuc2V0QXR0cmlidXRlKHduLCBcIlwiKSkgOiAodGhpcy5fY29uZmlnLmRpc2FibGVkID0gITEsIHQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHQucmVtb3ZlQXR0cmlidXRlKHduKSk7XG4gIH1cbiAgX29ic2VydmVNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgJiYgdGhpcy5fbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIGF0dHJpYnV0ZXM6ICEwLFxuICAgICAgY2hpbGRMaXN0OiAhMCxcbiAgICAgIGNoYXJhY3RlckRhdGE6ICEwLFxuICAgICAgc3VidHJlZTogITBcbiAgICB9KTtcbiAgfVxuICBfZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyICYmICh0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKSwgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGwpO1xuICB9XG4gIF9jcmVhdGVTZWxlY3RBbGxPcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3NlbGVjdEFsbElkLCBlID0gbnVsbCwgaSA9ICEwLCBuID0gXCJzZWxlY3QtYWxsXCIsIG8gPSB0aGlzLl9jb25maWcuc2VsZWN0QWxsTGFiZWwsIHIgPSBqbih0aGlzLm9wdGlvbnMpLCBhID0gITEsIGwgPSAhMSwgYyA9IG51bGwsIGQgPSBudWxsLCBfID0gbnVsbDtcbiAgICByZXR1cm4gbmV3IHNhKFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIG8sXG4gICAgICByLFxuICAgICAgYSxcbiAgICAgIGwsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIF9cbiAgICApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ29tcG9uZW50RXZlbnRzKCksIHRoaXMuX2Rlc3Ryb3lNYXRlcmlhbFNlbGVjdCgpLCB0aGlzLl9saXN0ZW5Ub0ZvY3VzQ2hhbmdlKCExKSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHJpKTtcbiAgfVxuICBfcmVtb3ZlQ29tcG9uZW50RXZlbnRzKCkge1xuICAgIHUub2ZmKHRoaXMuaW5wdXQsIFwiY2xpY2tcIiksIHUub2ZmKHRoaXMud3JhcHBlciwgdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKSwgdS5vZmYodGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiKSwgdS5vZmYodGhpcy5jbGVhckJ1dHRvbiwgXCJrZXlkb3duXCIpLCB1Lm9mZih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgfVxuICBfZGVzdHJveU1hdGVyaWFsU2VsZWN0KCkge1xuICAgIHRoaXMuX2lzT3BlbiAmJiB0aGlzLmNsb3NlKCksIHRoaXMuX2Rlc3Ryb3lNYXRlcmlhbFRlbXBsYXRlKCk7XG4gIH1cbiAgX2Rlc3Ryb3lNYXRlcmlhbFRlbXBsYXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl93cmFwcGVyLnBhcmVudE5vZGUsIGUgPSBoLmZpbmQoXCJsYWJlbFwiLCB0aGlzLl93cmFwcGVyKTtcbiAgICB0LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpLCBlLmZvckVhY2goKGkpID0+IHtcbiAgICAgIHQuYXBwZW5kQ2hpbGQoaSk7XG4gICAgfSksIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgaS5yZW1vdmVBdHRyaWJ1dGUocSk7XG4gICAgfSksIHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5pbml0aWFsaXplZCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQWN0aXZlU3R5bGVzKGFhKSwgdC5yZW1vdmVDaGlsZCh0aGlzLl93cmFwcGVyKTtcbiAgfVxuICBzZXRWYWx1ZSh0KSB7XG4gICAgdGhpcy5vcHRpb25zLmZpbHRlcigoaSkgPT4gaS5zZWxlY3RlZCkuZm9yRWFjaCgoaSkgPT4gaS5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMSksIEFycmF5LmlzQXJyYXkodCkgPyB0LmZvckVhY2goKGkpID0+IHtcbiAgICAgIHRoaXMuX3NlbGVjdEJ5VmFsdWUoaSk7XG4gICAgfSkgOiB0aGlzLl9zZWxlY3RCeVZhbHVlKHQpLCB0aGlzLl91cGRhdGVTZWxlY3Rpb25zKCk7XG4gIH1cbiAgX3NlbGVjdEJ5VmFsdWUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbnMuZmluZChcbiAgICAgIChpKSA9PiBpLnZhbHVlID09PSB0XG4gICAgKTtcbiAgICByZXR1cm4gZSA/IChlLm5hdGl2ZU9wdGlvbi5zZWxlY3RlZCA9ICEwLCAhMCkgOiAhMTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBJLmdldERhdGEodGhpcywgcmkpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBObCh0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCByaSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgWW0gPSAocykgPT4ge1xuICBBYSgoKSA9PiB7XG4gICAgY29uc3QgdCA9IENhKCk7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBzLk5BTUUsIGkgPSB0LmZuW2VdO1xuICAgICAgdC5mbltlXSA9IHMualF1ZXJ5SW50ZXJmYWNlLCB0LmZuW2VdLkNvbnN0cnVjdG9yID0gcywgdC5mbltlXS5ub0NvbmZsaWN0ID0gKCkgPT4gKHQuZm5bZV0gPSBpLCBzLmpRdWVyeUludGVyZmFjZSk7XG4gICAgfVxuICB9KTtcbn0sIGptID0gKHMsIHQpID0+IHtcbiAgdS5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9YCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKSwgcy5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnRvZ2dsZSgpO1xuICAgIH1cbiAgKTtcbn0sIEttID0gKHMsIHQpID0+IHtcbiAgdS5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9LmRhdGEtYXBpYCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgdWUodGhpcykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS5zaG93KCk7XG4gICAgfVxuICApO1xufSwgVW0gPSAocywgdCkgPT4ge1xuICB1Lm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX0uZGF0YS1hcGlgLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgY29uc3QgaSA9IFh0KHRoaXMpO1xuICAgICAgaWYgKFtcIkFcIiwgXCJBUkVBXCJdLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLCB1ZSh0aGlzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdS5vbmUoaSwgcy5FVkVOVF9ISURERU4sICgpID0+IHtcbiAgICAgICAgU3QodGhpcykgJiYgdGhpcy5mb2N1cygpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBuID0gaC5maW5kT25lKHMuT1BFTl9TRUxFQ1RPUik7XG4gICAgICBuICYmIG4gIT09IGkgJiYgcy5nZXRJbnN0YW5jZShuKS5oaWRlKCksIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKS50b2dnbGUodGhpcyk7XG4gICAgfVxuICApO1xufSwgem0gPSAocywgdCkgPT4ge1xuICB1Lm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX1gLFxuICAgIHQsXG4gICAgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGkgPSBlLnRhcmdldC5jbG9zZXN0KHQpO1xuICAgICAgcy5nZXRPckNyZWF0ZUluc3RhbmNlKGkpLnRvZ2dsZSgpO1xuICAgIH1cbiAgKTtcbn0sIFhtID0gKHMsIHQpID0+IHtcbiAgdS5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9YCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGNvbnN0IGkgPSBYdCh0aGlzKTtcbiAgICAgIFtcIkFcIiwgXCJBUkVBXCJdLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLCB1Lm9uZShpLCBzLkVWRU5UX1NIT1csIChyKSA9PiB7XG4gICAgICAgIHIuZGVmYXVsdFByZXZlbnRlZCB8fCB1Lm9uZShpLCBzLkVWRU5UX0hJRERFTiwgKCkgPT4ge1xuICAgICAgICAgIFN0KHRoaXMpICYmIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG4gPSBoLmZpbmRPbmUoXG4gICAgICAgIGBbJHtzLk9QRU5fU0VMRUNUT1J9PVwidHJ1ZVwiXWBcbiAgICAgICk7XG4gICAgICBuICYmIHMuZ2V0SW5zdGFuY2UobikuaGlkZSgpLCBzLmdldE9yQ3JlYXRlSW5zdGFuY2UoaSkudG9nZ2xlKHRoaXMpO1xuICAgIH1cbiAgKTtcbn0sIEdtID0gKHMsIHQpID0+IHtcbiAgdS5vbmUoXG4gICAgZG9jdW1lbnQsXG4gICAgXCJtb3VzZWRvd25cIixcbiAgICB0LFxuICAgIHMuYXV0b0luaXRpYWwobmV3IHMoKSlcbiAgKTtcbn0sIHFtID0gKHMsIHQpID0+IHtcbiAgdS5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9LmRhdGEtYXBpYCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIChlLnRhcmdldC50YWdOYW1lID09PSBcIkFcIiB8fCBlLmRlbGVnYXRlVGFyZ2V0ICYmIGUuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSA9PT0gXCJBXCIpICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGkgPSBYbih0aGlzKTtcbiAgICAgIGguZmluZChpKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShvLCB7IHRvZ2dsZTogITEgfSkudG9nZ2xlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICk7XG59LCBGdCA9IHtcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGNvbG9yOiBcInJnYigxMDIsMTAyLDEwMilcIlxuICAgICAgfVxuICAgIH1cbiAgfVxufSwgZ3MgPSB7XG4gIGxpbmU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5GdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuMClcIixcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAyLFxuICAgICAgICAgIHRlbnNpb246IDBcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfSxcbiAgICAgIHRvb2x0aXBzOiB7XG4gICAgICAgIGludGVyc2VjdDogITEsXG4gICAgICAgIG1vZGU6IFwiaW5kZXhcIlxuICAgICAgfSxcbiAgICAgIGRhdGFzZXRzOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiBcInJlZFwiXG4gICAgICB9LFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMCxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMSxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBib3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICBkcmF3Qm9yZGVyOiAhMSxcbiAgICAgICAgICAgIHplcm9MaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IFsyXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJhcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLkZ0LFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9LFxuICAgICAgdG9vbHRpcHM6IHtcbiAgICAgICAgaW50ZXJzZWN0OiAhMSxcbiAgICAgICAgbW9kZTogXCJpbmRleFwiXG4gICAgICB9LFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMCxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMCxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBib3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICBkcmF3Qm9yZGVyOiAhMSxcbiAgICAgICAgICAgIHplcm9MaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IFsyXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBpZToge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLkZ0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgYXJjOiB7IGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZG91Z2hudXQ6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5GdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGFyYzogeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIiB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvbGFyQXJlYToge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLkZ0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgYXJjOiB7IGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC41KVwiIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmFkYXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5GdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIixcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAyXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjYXR0ZXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5GdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIixcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAyLFxuICAgICAgICAgIHRlbnNpb246IDBcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC41KVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfSxcbiAgICAgIHRvb2x0aXBzOiB7XG4gICAgICAgIGludGVyc2VjdDogITEsXG4gICAgICAgIG1vZGU6IFwiaW5kZXhcIlxuICAgICAgfSxcbiAgICAgIGRhdGFzZXRzOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiBcInJlZFwiXG4gICAgICB9LFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMCxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMSxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBib3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICBkcmF3Qm9yZGVyOiAhMSxcbiAgICAgICAgICAgIHplcm9MaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IFsyXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJ1YmJsZToge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLkZ0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC41KVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59LCBRbSA9IChzLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSAobykgPT4gb1swXSA9PT0gXCJ7XCIgJiYgb1tvLmxlbmd0aCAtIDFdID09PSBcIn1cIiB8fCBvWzBdID09PSBcIltcIiAmJiBvW28ubGVuZ3RoIC0gMV0gPT09IFwiXVwiLCBpID0gKG8pID0+IHR5cGVvZiBvICE9IFwic3RyaW5nXCIgPyBvIDogZShvKSA/IEpTT04ucGFyc2Uoby5yZXBsYWNlKC8nL2csICdcIicpKSA6IG8sIG4gPSAobykgPT4ge1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgaWYgKGEubWF0Y2goL2RhdGFzZXQuKi8pKSB7XG4gICAgICAgIGNvbnN0IGwgPSBhLnNsaWNlKDcsIDgpLnRvTG93ZXJDYXNlKCkuY29uY2F0KGEuc2xpY2UoOCkpO1xuICAgICAgICByW2xdID0gaShvW2FdKTtcbiAgICAgIH1cbiAgICB9KSwgcjtcbiAgfTtcbiAgaC5maW5kKHQpLmZvckVhY2goKG8pID0+IHtcbiAgICBpZiAocC5nZXREYXRhQXR0cmlidXRlKG8sIFwiY2hhcnRcIikgIT09IFwiYnViYmxlXCIgJiYgcC5nZXREYXRhQXR0cmlidXRlKG8sIFwiY2hhcnRcIikgIT09IFwic2NhdHRlclwiKSB7XG4gICAgICBjb25zdCByID0gcC5nZXREYXRhQXR0cmlidXRlcyhvKSwgYSA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRhdGFzZXRzOiBbbihyKV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByLmNoYXJ0ICYmIChhLnR5cGUgPSByLmNoYXJ0KSwgci5sYWJlbHMgJiYgKGEuZGF0YS5sYWJlbHMgPSBKU09OLnBhcnNlKHIubGFiZWxzLnJlcGxhY2UoLycvZywgJ1wiJykpKSwgbmV3IHMobywge1xuICAgICAgICAuLi5hLFxuICAgICAgICAuLi5nc1thLnR5cGVdXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xufSwgYWkgPSB7XG4gIGFsZXJ0OiB7XG4gICAgbmFtZTogXCJBbGVydFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWFsZXJ0LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBhbmltYXRpb246IHtcbiAgICBuYW1lOiBcIkFuaW1hdGVcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1hbmltYXRpb24taW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGNhcm91c2VsOiB7XG4gICAgbmFtZTogXCJDYXJvdXNlbFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNhcm91c2VsLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBjaGlwczoge1xuICAgIG5hbWU6IFwiQ2hpcHNJbnB1dFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNoaXBzLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBjaGlwOiB7XG4gICAgbmFtZTogXCJDaGlwXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtY2hpcC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgZGF0ZXBpY2tlcjoge1xuICAgIG5hbWU6IFwiRGF0ZXBpY2tlclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWRhdGVwaWNrZXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGlucHV0OiB7XG4gICAgbmFtZTogXCJJbnB1dFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWlucHV0LXdyYXBwZXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHNjcm9sbHNweToge1xuICAgIG5hbWU6IFwiU2Nyb2xsU3B5XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtc3B5PSdzY3JvbGwnXVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc2VsZWN0OiB7XG4gICAgbmFtZTogXCJTZWxlY3RcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1zZWxlY3QtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHNpZGVuYXY6IHtcbiAgICBuYW1lOiBcIlNpZGVuYXZcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1zaWRlbmF2LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBzdGVwcGVyOiB7XG4gICAgbmFtZTogXCJTdGVwcGVyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtc3RlcHBlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgdGltZXBpY2tlcjoge1xuICAgIG5hbWU6IFwiVGltZXBpY2tlclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRpbWVwaWNrZXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHRvYXN0OiB7XG4gICAgbmFtZTogXCJUb2FzdFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvYXN0LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICAvLyBhZHZhbmNlZEluaXRzXG4gIGNoYXJ0OiB7XG4gICAgbmFtZTogXCJDaGFydFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNoYXJ0XVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgYWR2YW5jZWQ6IFFtXG4gIH0sXG4gIC8vIHRvZ2dsZXJzXG4gIGJ1dHRvbjoge1xuICAgIG5hbWU6IFwiQnV0dG9uXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdidXR0b24nXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IHptXG4gIH0sXG4gIGNvbGxhcHNlOiB7XG4gICAgbmFtZTogXCJDb2xsYXBzZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogcW1cbiAgfSxcbiAgZHJvcGRvd246IHtcbiAgICBuYW1lOiBcIkRyb3Bkb3duXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBqbVxuICB9LFxuICBtb2RhbDoge1xuICAgIG5hbWU6IFwiTW9kYWxcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J21vZGFsJ11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBYbVxuICB9LFxuICByaXBwbGU6IHtcbiAgICBuYW1lOiBcIlJpcHBsZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXJpcHBsZS1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IEdtXG4gIH0sXG4gIG9mZmNhbnZhczoge1xuICAgIG5hbWU6IFwiT2ZmY2FudmFzXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtb2ZmY2FudmFzLXRvZ2dsZV1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBVbVxuICB9LFxuICB0YWI6IHtcbiAgICBuYW1lOiBcIlRhYlwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvZ2dsZT0ndGFiJ10sIFtkYXRhLXRlLXRvZ2dsZT0ncGlsbCddLCBbZGF0YS10ZS10b2dnbGU9J2xpc3QnXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IEttXG4gIH1cbn0sIFptID0gKHMpID0+IGFpW3MuTkFNRV0gfHwgbnVsbCwgSm0gPSAocykgPT4ge1xuICBpZiAoIXMgfHwgW10uaW5jbHVkZXMocy5OQU1FKSlcbiAgICByZXR1cm47XG4gIFtdLnB1c2gocy5OQU1FKTtcbiAgY29uc3QgdCA9IFptKHMpLCBlID0gKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaXNUb2dnbGVyKSB8fCAhMTtcbiAgaWYgKFltKHMpLCB0ICE9IG51bGwgJiYgdC5hZHZhbmNlZCkge1xuICAgIHQgPT0gbnVsbCB8fCB0LmFkdmFuY2VkKHMsIHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuc2VsZWN0b3IpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZSkge1xuICAgIHQgPT0gbnVsbCB8fCB0LmNhbGxiYWNrKHMsIHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuc2VsZWN0b3IpO1xuICAgIHJldHVybjtcbiAgfVxuICBoLmZpbmQodCA9PSBudWxsID8gdm9pZCAwIDogdC5zZWxlY3RvcikuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGxldCBuID0gcy5nZXRJbnN0YW5jZShpKTtcbiAgICBuIHx8IChuID0gbmV3IHMoaSkpO1xuICB9KTtcbn0sIHRnID0gKHMpID0+IHtcbiAgcy5mb3JFYWNoKCh0KSA9PiBKbSh0KSk7XG59LCBlZyA9IChzLCB0ID0gITEpID0+IHtcbiAgY29uc3QgZSA9IE9iamVjdC5rZXlzKGFpKS5tYXAoKGkpID0+IHtcbiAgICBpZiAoISFkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoYWlbaV0uc2VsZWN0b3IpKSB7XG4gICAgICBjb25zdCBvID0gc1thaVtpXS5uYW1lXTtcbiAgICAgIHJldHVybiAhbyAmJiAhW10uaW5jbHVkZXMoaSkgJiYgdCAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgIGBQbGVhc2UgaW1wb3J0ICR7YWlbaV0ubmFtZX0gZnJvbSBcInR3LWVsZW1lbnRzXCIgcGFja2FnZSBhbmQgYWRkIGl0IHRvIGEgb2JqZWN0IHBhcmFtZXRlciBpbnNpZGUgXCJpbml0VEVcIiBmdW5jdGlvbmBcbiAgICAgICksIG87XG4gICAgfVxuICB9KTtcbiAgdGcoZSk7XG59LCBpZyA9ICh7IGlucHV0SUQ6IHMsIGxhYmVsVGV4dDogdCB9LCBlKSA9PiAoZWcoeyBJbnB1dDogViB9LCAhMSksIGA8ZGl2IGRhdGEtdGUtY2hpcHMtaW5wdXQtd3JhcHBlciBkYXRhLXRlLWlucHV0LXdyYXBwZXItaW5pdCBjbGFzcz1cIiR7ZS5jaGlwc0lucHV0V3JhcHBlcn1cIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBjbGFzcz1cIiR7ZS5jaGlwc0lucHV0fVwiXG4gICAgICAgICAgaWQ9XCIke3N9XCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIkV4YW1wbGUgbGFiZWxcIiAvPlxuICAgICAgICA8bGFiZWxcbiAgICAgICAgICBmb3I9XCIke3N9XCJcbiAgICAgICAgICBjbGFzcz1cIiR7ZS5jaGlwc0xhYmVsfVwiXG4gICAgICAgICAgPiR7dH1cbiAgICAgICAgPC9sYWJlbD5cblxuICAgICAgICA8ZGl2IGRhdGEtdGUtaW5wdXQtbm90Y2gtcmVmIGNsYXNzPVwiJHtlLmNoaXBzTm90Y2hlc1dyYXBwZXJ9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke2UuY2hpcHNOb3RjaGVzTGVhZGluZ31cIiBkYXRhLXRlLWlucHV0LW5vdGNoLWxlYWRpbmctcmVmIHN0eWxlPVwid2lkdGg6IDlweDtcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7ZS5jaGlwc05vdGNoZXNNaWRkbGV9XCIgZGF0YS10ZS1pbnB1dC1ub3RjaC1taWRkbGUtcmVmIHN0eWxlPVwid2lkdGg6IDg3LjJweDtcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7ZS5jaGlwc05vdGNoZXNUcmFpbGluZ31cIiBkYXRhLXRlLWlucHV0LW5vdGNoLXRyYWlsaW5nLXJlZj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PmApLCBzZyA9ICh7IHRleHQ6IHMsIGljb25TVkc6IHQgfSwgZSkgPT4gYDxkaXYgZGF0YS10ZS1jaGlwLWluaXQgZGF0YS10ZS1yaXBwbGUtaW5pdCBjbGFzcz1cIiR7ZS5jaGlwRWxlbWVudH1cIj5cbiAgICA8c3BhbiBkYXRhLXRlLWNoaXAtdGV4dD4ke3N9PC9zcGFuPiBcbiAgICAgIDxzcGFuIGRhdGEtdGUtY2hpcC1jbG9zZSBjbGFzcz1cIiR7ZS5jaGlwQ2xvc2VJY29ufVwiPlxuICAgICAgICAke3R9XG4gICAgICA8L3NwYW4+XG4gIDwvZGl2PmAsIGJzID0gXCJjaGlwXCIsIG5nID0gYHRlLiR7YnN9YCwgUmwgPSBcImRhdGEtdGUtY2hpcC1jbG9zZVwiLCBPbiA9IGBbJHtSbH1dYCwgb2cgPSBcImRlbGV0ZS50ZS5jaGlwc1wiLCByZyA9IFwic2VsZWN0LnRlLmNoaXBcIiwgYWcgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTMgaC0zXCI+IDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNiAxOEwxOCA2TTYgNmwxMiAxMlwiIC8+PC9zdmc+JywgbGcgPSB7XG4gIHRleHQ6IFwic3RyaW5nXCIsXG4gIGNsb3NlSWNvbjogXCJib29sZWFuXCIsXG4gIGltZzogXCJvYmplY3RcIixcbiAgaWNvblNWRzogXCJzdHJpbmdcIlxufSwgY2cgPSB7XG4gIHRleHQ6IFwiXCIsXG4gIGNsb3NlSWNvbjogITEsXG4gIGltZzogeyBwYXRoOiBcIlwiLCBhbHQ6IFwiXCIgfSxcbiAgaWNvblNWRzogYWdcbn0sIGRnID0ge1xuICBpY29uOiBcImZsb2F0LXJpZ2h0IHBsLVs4cHhdIHRleHQtWzE2cHhdIG9wYWNpdHktWy41M10gY3Vyc29yLXBvaW50ZXIgZmlsbC1bI2FmYWZhZl0gaG92ZXI6dGV4dC1bIzhiOGI4Yl0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0XCIsXG4gIGNoaXBFbGVtZW50OiBcImZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlciBoLVszMnB4XSBsZWFkaW5nLWxvb3NlIHB5LVs1cHhdIHB4LVsxMnB4XSBtci00IG15LVs1cHhdIHRleHQtWzEzcHhdIGZvbnQtbm9ybWFsIHRleHQtWyM0ZjRmNGZdIGN1cnNvci1wb2ludGVyIGJnLVsjZWNlZmYxXSBkYXJrOnRleHQtd2hpdGUgZGFyazpiZy1uZXV0cmFsLTYwMCByb3VuZGVkLVsxNnB4XSB0cmFuc2l0aW9uLVtvcGFjaXR5XSBkdXJhdGlvbi0zMDAgZWFzZS1saW5lYXIgW3dvcmQtd3JhcDogYnJlYWstd29yZF0gc2hhZG93LW5vbmUgbm9ybWFsLWNhc2UgaG92ZXI6IXNoYWRvdy1ub25lIGFjdGl2ZTpiZy1bI2NhY2ZkMV0gaW5saW5lLWJsb2NrIGZvbnQtbWVkaXVtIGxlYWRpbmctbm9ybWFsIHRleHQtWyM0ZjRmNGZdIHRleHQtY2VudGVyIG5vLXVuZGVybGluZSBhbGlnbi1taWRkbGUgY3Vyc29yLXBvaW50ZXIgc2VsZWN0LW5vbmUgYm9yZGVyLVsuMTI1cmVtXSBib3JkZXItc29saWQgYm9yZGVyLXRyYW5zcGFyZW50IHB5LTEuNSBweC0zIHRleHQteHMgcm91bmRlZFwiLFxuICBjaGlwQ2xvc2VJY29uOiBcInctNCBmbG9hdC1yaWdodCBwbC1bOHB4XSB0ZXh0LVsxNnB4XSBvcGFjaXR5LVsuNTNdIGN1cnNvci1wb2ludGVyIGZpbGwtWyNhZmFmYWZdIGhvdmVyOmZpbGwtWyM4YjhiOGJdIGRhcms6ZmlsbC1ncmF5LTQwMCBkYXJrOmhvdmVyOmZpbGwtZ3JheS0xMDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0XCJcbn0sIGhnID0ge1xuICBpY29uOiBcInN0cmluZ1wiLFxuICBjaGlwRWxlbWVudDogXCJzdHJpbmdcIixcbiAgY2hpcENsb3NlSWNvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIGlpIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBicztcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9hcHBlbmRDbG9zZUljb24oKSwgdGhpcy5faGFuZGxlRGVsZXRlKCksIHRoaXMuX2hhbmRsZVRleHRDaGlwKCksIHRoaXMuX2hhbmRsZUNsaWNrT25DaGlwKCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHUub2ZmKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIik7XG4gIH1cbiAgYXBwZW5kQ2hpcCgpIHtcbiAgICBjb25zdCB7IHRleHQ6IHQsIGNsb3NlSWNvbjogZSwgaWNvblNWRzogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICByZXR1cm4gc2coeyB0ZXh0OiB0LCBjbG9zZUljb246IGUsIGljb25TVkc6IGkgfSwgdGhpcy5fY2xhc3Nlcyk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfYXBwZW5kQ2xvc2VJY29uKHQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgaWYgKCEoaC5maW5kKE9uLCB0aGlzLl9lbGVtZW50KS5sZW5ndGggPiAwKSAmJiB0aGlzLl9vcHRpb25zLmNsb3NlSWNvbikge1xuICAgICAgY29uc3QgZSA9IE0oXCJzcGFuXCIpO1xuICAgICAgZS5jbGFzc0xpc3QgPSB0aGlzLl9jbGFzc2VzLmljb24sIGUuc2V0QXR0cmlidXRlKFJsKSwgZS5pbm5lckhUTUwgPSB0aGlzLl9vcHRpb25zLmljb25TVkcsIHQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYmVmb3JlZW5kXCIsIGUpO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlQ2xpY2tPbkNoaXAoKSB7XG4gICAgdS5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCB7IHRleHRDb250ZW50OiBlIH0gPSB0LnRhcmdldCwgaSA9IHt9O1xuICAgICAgaS50YWcgPSBlLnRyaW0oKSwgdS50cmlnZ2VyKHJnLCB7IGV2ZW50OiB0LCBvYmo6IGkgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZURlbGV0ZSgpIHtcbiAgICBoLmZpbmQoXG4gICAgICBPbixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLmxlbmd0aCAhPT0gMCAmJiB1Lm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgT24sICgpID0+IHtcbiAgICAgIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBvZyksIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVRleHRDaGlwKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuaW5uZXJUZXh0ID09PSBcIlwiICYmICh0aGlzLl9lbGVtZW50LmlubmVyVGV4dCA9IHRoaXMuX29wdGlvbnMudGV4dCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLmNnLFxuICAgICAgLi4ucC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBOKGJzLCBlLCBsZyksIGU7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5kZyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTihicywgdCwgaGcpLCB0O1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBuZyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgdWkgPSBcImNoaXBzXCIsIHlpID0gYGRhdGEtdGUtJHt1aX1gLCB1YSA9IGB0ZS4ke3VpfWAsIHVnID0gYCR7eWl9LWluaXRgLCBmdCA9IGAke3lpfS1hY3RpdmVgLCBwYSA9IGAke3lpfS1pbml0aWFsYCwgUGwgPSBgJHt5aX0tcGxhY2Vob2xkZXJgLCBwZyA9IGAke3lpfS1pbnB1dC13cmFwcGVyYCwgS24gPSBcImRhdGEtdGUtY2hpcC1pbml0XCIsIEhsID0gXCJkYXRhLXRlLWNoaXAtY2xvc2VcIiwgQmwgPSBcImRhdGEtdGUtY2hpcC10ZXh0XCIsIGZnID0gYFske2Z0fV1gLCBVbiA9IGBbJHtLbn1dYCwgX2cgPSBgJHtVbn0ke2ZnfWAsIHhuID0gYFske0hsfV1gLCBtZyA9IGBbJHtwZ31dYCwgZ2cgPSBgWyR7Qmx9XWAsIGJnID0gYFske1BsfV1gLCB2ZyA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1sZWFkaW5nLXJlZlwiLCBFZyA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1taWRkbGUtcmVmXCIsIFRnID0gYFske3ZnfV1gLCBDZyA9IGBbJHtFZ31dYCwgQWUgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIFNuID0gXCJbZGF0YS10ZS1pbnB1dC1ub3RjaC1yZWZdXCIsIEFnID0gXCJhZGQudGUuY2hpcHNcIiwgeWcgPSBcImFycm93RG93bi50ZS5jaGlwc1wiLCB3ZyA9IFwiYXJyb3dMZWZ0LnRlLmNoaXBzXCIsIGtnID0gXCJhcnJvd1JpZ2h0LnRlLmNoaXBzXCIsIE9nID0gXCJhcnJvd1VwLnRlLmNoaXBzXCIsIGZhID0gXCJkZWxldGUudGUuY2hpcHNcIiwgX2EgPSBcInNlbGVjdC50ZS5jaGlwc1wiLCB4ZyA9IHtcbiAgaW5wdXRJRDogXCJzdHJpbmdcIixcbiAgcGFyZW50U2VsZWN0b3I6IFwic3RyaW5nXCIsXG4gIGluaXRpYWxWYWx1ZXM6IFwiYXJyYXlcIixcbiAgZWRpdGFibGU6IFwiYm9vbGVhblwiLFxuICBsYWJlbFRleHQ6IFwic3RyaW5nXCJcbn0sIFNnID0ge1xuICBpbnB1dElEOiBPdChcImNoaXBzLWlucHV0LVwiKSxcbiAgcGFyZW50U2VsZWN0b3I6IFwiXCIsXG4gIGluaXRpYWxWYWx1ZXM6IFt7IHRhZzogXCJpbml0MVwiIH0sIHsgdGFnOiBcImluaXQyXCIgfV0sXG4gIGVkaXRhYmxlOiAhMSxcbiAgbGFiZWxUZXh0OiBcIkV4YW1wbGUgbGFiZWxcIlxufSwgRGcgPSB7XG4gIG9wYWNpdHk6IFwib3BhY2l0eS0wXCIsXG4gIGlucHV0V3JhcHBlclBhZGRpbmc6IFwicC1bNXB4XVwiLFxuICB0cmFuc2l0aW9uOiBcInRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxKV1cIixcbiAgY29udGVudEVkaXRhYmxlOiBcIm91dGxpbmUtbm9uZSAhYm9yZGVyLVszcHhdICFib3JkZXItc29saWQgIWJvcmRlci1bI2IyYjNiNF1cIixcbiAgY2hpcHNJbnB1dFdyYXBwZXI6IFwicmVsYXRpdmUgZmxleCBpdGVtcy1jZW50ZXIgZmxleC13cmFwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxKV1cIixcbiAgY2hpcHNJbnB1dDogXCJwZWVyIGJsb2NrIG1pbi1oLVthdXRvXSB3LVsxNTBweF0gcm91bmRlZCBib3JkZXItMCBiZy10cmFuc3BhcmVudCBweS1bMC4zMnJlbV0gcHgtMyBsZWFkaW5nLVsxLjZdIG91dGxpbmUtbm9uZSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgZm9jdXM6cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwIFsmOm5vdChbZGF0YS10ZS1pbnB1dC1wbGFjZWhvbGRlci1hY3RpdmVdKV06cGxhY2Vob2xkZXI6b3BhY2l0eS0wXCIsXG4gIGNoaXBzTGFiZWw6IFwicG9pbnRlci1ldmVudHMtbm9uZSBhYnNvbHV0ZSB0b3AtMCBsZWZ0LTMgbWItMCBtYXgtdy1bOTAlXSBvcmlnaW4tWzBfMF0gdHJ1bmNhdGUgcHQtWzAuMzdyZW1dIGxlYWRpbmctWzEuNl0gdGV4dC1ncmF5LTUwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1vdXQgcGVlci1mb2N1czotdHJhbnNsYXRlLXktWzAuOXJlbV0gcGVlci1mb2N1czpzY2FsZS1bMC44XSBwZWVyLWZvY3VzOnRleHQtcHJpbWFyeSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVswLjlyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwZWVyLWZvY3VzOnRleHQtZ3JheS0yMDBcIixcbiAgY2hpcHNOb3RjaGVzV3JhcHBlcjogXCJncm91cCBmbGV4IGFic29sdXRlIGxlZnQtMCB0b3AtMCB3LWZ1bGwgbWF4LXctZnVsbCBoLWZ1bGwgdGV4dC1sZWZ0IHBvaW50ZXItZXZlbnRzLW5vbmVcIixcbiAgY2hpcHNOb3RjaGVzTGVhZGluZzogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbGVmdC0wIHRvcC0wIGgtZnVsbCB3LTIgYm9yZGVyLXItMCByb3VuZGVkLWwtWzAuMjVyZW1dIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1yLTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItci0wIGJvcmRlci1ncmF5LTMwMCBkYXJrOmJvcmRlci1ncmF5LTYwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWy0xcHhfMF8wXyMzYjcxY2EsXzBfMXB4XzBfMF8jM2I3MWNhLF8wXy0xcHhfMF8wXyMzYjcxY2FdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCIsXG4gIGNoaXBzTm90Y2hlc01pZGRsZTogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZ3Jvdy0wIHNocmluay0wIGJhc2lzLWF1dG8gdy1hdXRvIG1heC13LVtjYWxjKDEwMCUtMXJlbSldIGgtZnVsbCBib3JkZXItci0wIGJvcmRlci1sLTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXgtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci14LTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItdCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItc29saWQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItc29saWQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXQtdHJhbnNwYXJlbnQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItdC10cmFuc3BhcmVudCBib3JkZXItZ3JheS0zMDAgZGFyazpib3JkZXItZ3JheS02MDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVswXzFweF8wXzBfIzNiNzFjYV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXByaW1hcnlcIixcbiAgY2hpcHNOb3RjaGVzVHJhaWxpbmc6IFwicG9pbnRlci1ldmVudHMtbm9uZSBib3JkZXIgYm9yZGVyLXNvbGlkIGJveC1ib3JkZXIgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGdyb3cgaC1mdWxsIGJvcmRlci1sLTAgcm91bmRlZC1yLVswLjI1cmVtXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItbC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLWwtMCBib3JkZXItZ3JheS0zMDAgZGFyazpib3JkZXItZ3JheS02MDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVsxcHhfMF8wXyMzYjcxY2EsXzBfLTFweF8wXzBfIzNiNzFjYSxfMF8xcHhfMF8wXyMzYjcxY2FdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCJcbn0sIElnID0ge1xuICBvcGFjaXR5OiBcInN0cmluZ1wiLFxuICBpbnB1dFdyYXBwZXJQYWRkaW5nOiBcInN0cmluZ1wiLFxuICB0cmFuc2l0aW9uOiBcInN0cmluZ1wiLFxuICBjb250ZW50RWRpdGFibGU6IFwic3RyaW5nXCIsXG4gIGNoaXBzSW5wdXRXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBjaGlwc0lucHV0OiBcInN0cmluZ1wiLFxuICBjaGlwc0xhYmVsOiBcInN0cmluZ1wiLFxuICBjaGlwc05vdGNoZXNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBjaGlwc05vdGNoZXNMZWFkaW5nOiBcInN0cmluZ1wiLFxuICBjaGlwc05vdGNoZXNNaWRkbGU6IFwic3RyaW5nXCIsXG4gIGNoaXBzTm90Y2hlc1RyYWlsaW5nOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgWmcgZXh0ZW5kcyBpaSB7XG4gIGNvbnN0cnVjdG9yKGUsIGkgPSB7fSwgbikge1xuICAgIHN1cGVyKGUsIGkpO1xuICAgIFR0KHRoaXMsIFwiX2hhbmRsZUJsdXJJbnB1dFwiLCAoeyB0YXJnZXQ6IGUgfSkgPT4ge1xuICAgICAgZS52YWx1ZS5sZW5ndGggPiAwICYmIHRoaXMuX2hhbmRsZUNyZWF0ZUNoaXAoZSwgZS52YWx1ZSksIHRoaXMuYWxsQ2hpcHMubGVuZ3RoID4gMCA/IChlLnNldEF0dHJpYnV0ZShmdCwgXCJcIiksIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKEFlLCBcIlwiKSwgaC5maW5kT25lKFxuICAgICAgICBTbixcbiAgICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXG4gICAgICApLnNldEF0dHJpYnV0ZShBZSwgXCJcIiksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICAgKSkgOiAoZS5yZW1vdmVBdHRyaWJ1dGUoZnQpLCB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShBZSksIGguZmluZE9uZShcbiAgICAgICAgU24sXG4gICAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZVxuICAgICAgKS5yZW1vdmVBdHRyaWJ1dGUoQWUpLCB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICAgICkpLCB0aGlzLmFsbENoaXBzLmZvckVhY2goKGkpID0+IGkucmVtb3ZlQXR0cmlidXRlKGZ0KSk7XG4gICAgfSk7XG4gICAgdGhpcy5fZWxlbWVudCA9IGUsIHRoaXMuX2xhYmVsID0gbnVsbCwgdGhpcy5fbGFiZWxXaWR0aCA9IDAsIHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IDAsIHRoaXMuX25vdGNoTGVhZGluZyA9IG51bGwsIHRoaXMuX25vdGNoTWlkZGxlID0gbnVsbCwgdGhpcy5fZWxlbWVudCAmJiBJLnNldERhdGEoZSwgdWEsIHRoaXMpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGkpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhuKSwgdGhpcy5udW1iZXJDbGlja3MgPSAwLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gdWk7XG4gIH1cbiAgZ2V0IGFjdGl2ZUNoaXAoKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShfZywgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGlucHV0KCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUoXCJpbnB1dFwiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgYWxsQ2hpcHMoKSB7XG4gICAgcmV0dXJuIGguZmluZChVbiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGNoaXBzSW5wdXRXcmFwcGVyKCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUobWcsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX3NldENoaXBzQ2xhc3MoKSwgdGhpcy5fYXBwZW5kSW5wdXRUb0VsZW1lbnQoUGwpLCB0aGlzLl9oYW5kbGVJbml0aWFsVmFsdWUoKSwgdGhpcy5faGFuZGxlSW5wdXRUZXh0KCksIHRoaXMuX2hhbmRsZUtleWJvYXJkKCksIHRoaXMuX2hhbmRsZUNoaXBzT25TZWxlY3QoKSwgdGhpcy5faGFuZGxlRWRpdGFibGUoKSwgdGhpcy5faGFuZGxlQ2hpcHNGb2N1cygpLCB0aGlzLl9oYW5kbGVDbGlja3NPbkNoaXBzKCksIHRoaXMuX2dldExhYmVsRGF0YSgpLCB0aGlzLl9nZXRMYWJlbFdpZHRoKCksIHRoaXMuX2dldE5vdGNoRGF0YSgpLCB0aGlzLl9hcHBseU5vdGNoKCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Tm90Y2hEYXRhKCkge1xuICAgIHRoaXMuX25vdGNoTWlkZGxlID0gaC5maW5kT25lKFxuICAgICAgQ2csXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gaC5maW5kT25lKFxuICAgICAgVGcsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgfVxuICBfZ2V0TGFiZWxEYXRhKCkge1xuICAgIHRoaXMuX2xhYmVsID0gaC5maW5kT25lKFwibGFiZWxcIiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX2dldExhYmVsV2lkdGgoKSB7XG4gICAgdGhpcy5fbGFiZWxXaWR0aCA9IHRoaXMuX2xhYmVsLmNsaWVudFdpZHRoICogMC44ICsgODtcbiAgfVxuICBfYXBwbHlOb3RjaCgpIHtcbiAgICB0aGlzLl9ub3RjaE1pZGRsZS5zdHlsZS53aWR0aCA9IGAke3RoaXMuX2xhYmVsV2lkdGh9cHhgLCB0aGlzLl9ub3RjaExlYWRpbmcuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9sYWJlbE1hcmdpbkxlZnQgKyA5fXB4YCwgdGhpcy5fbGFiZWwgIT09IG51bGwgJiYgKHRoaXMuX2xhYmVsLnN0eWxlLm1hcmdpbkxlZnQgPSBgJHt0aGlzLl9sYWJlbE1hcmdpbkxlZnR9cHhgKTtcbiAgfVxuICBfc2V0Q2hpcHNDbGFzcygpIHtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSh1ZywgXCJcIik7XG4gIH1cbiAgX2hhbmRsZURlbGV0ZUV2ZW50cyhlKSB7XG4gICAgY29uc3QgW2ldID0gdGhpcy5hbGxDaGlwcy5zbGljZSgtMSk7XG4gICAgaWYgKHRoaXMuYWN0aXZlQ2hpcCA9PT0gbnVsbClcbiAgICAgIGkucmVtb3ZlKCksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBmYSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5hbGxDaGlwcy5maW5kSW5kZXgoKGEpID0+IGEgPT09IHRoaXMuYWN0aXZlQ2hpcCksIG8gPSB0aGlzLl9oYW5kbGVBY3RpdmVDaGlwQWZ0ZXJSZW1vdmUobiksIHIgPSBbXTtcbiAgICAgIGlmICh0aGlzLmFjdGl2ZUNoaXAgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuYWN0aXZlQ2hpcC5yZW1vdmUoKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIGZhKSwgdGhpcy5udW1iZXJDbGlja3MgPSBuLCBvLnNldEF0dHJpYnV0ZShmdCwgXCJcIiksIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBhLmhhc0F0dHJpYnV0ZShmdCkgJiYgKHIucHVzaChhKSwgci5sZW5ndGggPiAxICYmIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgobCkgPT4gbC5yZW1vdmUoKSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVVcEV2ZW50cyhlKSB7XG4gICAgdGhpcy5udW1iZXJDbGlja3MgKz0gMSwgdGhpcy5udW1iZXJDbGlja3MgPT09IHRoaXMuYWxsQ2hpcHMubGVuZ3RoICsgMSAmJiAodGhpcy5udW1iZXJDbGlja3MgPSAwKSwgdGhpcy5faGFuZGxlUmlnaHRLZXlib2FyZEFycm93KHRoaXMubnVtYmVyQ2xpY2tzKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIGtnKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIE9nKTtcbiAgfVxuICBfaGFuZGxlRG93bkV2ZW50cyhlKSB7XG4gICAgdGhpcy5udW1iZXJDbGlja3MgLT0gMSwgdGhpcy5udW1iZXJDbGlja3MgPD0gMCAmJiAodGhpcy5udW1iZXJDbGlja3MgPSB0aGlzLmFsbENoaXBzLmxlbmd0aCksIHRoaXMuX2hhbmRsZUxlZnRLZXlib2FyZEFycm93KHRoaXMubnVtYmVyQ2xpY2tzKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIHdnKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIHlnKTtcbiAgfVxuICBfa2V5Ym9hcmRFdmVudHMoZSkge1xuICAgIGNvbnN0IHsgdGFyZ2V0OiBpLCBrZXlDb2RlOiBuLCBjdHJsS2V5OiBvIH0gPSBlO1xuICAgIGkudmFsdWUubGVuZ3RoID4gMCB8fCB0aGlzLmFsbENoaXBzLmxlbmd0aCA9PT0gMCB8fCAobiA9PT0gWHAgfHwgbiA9PT0gR3AgPyB0aGlzLl9oYW5kbGVEZWxldGVFdmVudHMoZSkgOiBuID09PSAkZSB8fCBuID09PSBydCA/IHRoaXMuX2hhbmRsZVVwRXZlbnRzKGUpIDogbiA9PT0gSWUgfHwgbiA9PT0gVSA/IHRoaXMuX2hhbmRsZURvd25FdmVudHMoZSkgOiBuID09PSA2NSAmJiBvICYmIHRoaXMuX2hhbmRsZUFkZEFjdGl2ZUNsYXNzKCkpO1xuICB9XG4gIF9oYW5kbGVLZXlib2FyZCgpIHtcbiAgICB1Lm9uKFxuICAgICAgdGhpcy5pbnB1dCxcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgKGUpID0+IHRoaXMuX2tleWJvYXJkRXZlbnRzKGUpXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlRWRpdGFibGUoKSB7XG4gICAgY29uc3QgeyBlZGl0YWJsZTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBlICYmIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgdS5vbihpLCBcImRibGNsaWNrXCIsIChuKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBoLmZpbmRPbmUoeG4sIGkpO1xuICAgICAgICBpLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5jb250ZW50RWRpdGFibGUuc3BsaXQoXCIgXCIpKSwgaS5jb250ZW50RWRpdGFibGUgPSAhMCwgaS5mb2N1cygpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBwLmFkZFN0eWxlKG8sIHsgZGlzcGxheTogXCJub25lXCIgfSk7XG4gICAgICAgIH0sIDIwMCksIG8uY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKSwgbi50YXJnZXQudGV4dENvbnRlbnQsIHUudHJpZ2dlcihpLCBfYSwge1xuICAgICAgICAgIGV2ZW50OiBuLFxuICAgICAgICAgIGFsbENoaXBzOiB0aGlzLmFsbENoaXBzXG4gICAgICAgIH0pO1xuICAgICAgfSksIHUub24oZG9jdW1lbnQsIFwiY2xpY2tcIiwgKHsgdGFyZ2V0OiBuIH0pID0+IHtcbiAgICAgICAgY29uc3QgbyA9IGguZmluZE9uZSh4biwgaSksIHIgPSBoLmZpbmRPbmUoZ2csIGkpLCBhID0gbiA9PT0gaSwgbCA9IGkgJiYgaS5jb250YWlucyhuKTtcbiAgICAgICAgIWEgJiYgIWwgJiYgKGkuY29udGVudEVkaXRhYmxlID0gITEsIGkuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLmNvbnRlbnRFZGl0YWJsZS5zcGxpdChcIiBcIikpLCByLnRleHRDb250ZW50ICE9PSBcIlwiICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHAuYWRkU3R5bGUobywgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIG8uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgfSwgMTYwKSksIHIudGV4dENvbnRlbnQgPT09IFwiXCIgJiYgKHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgfSwgMjAwKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaS5yZW1vdmUoKTtcbiAgICAgICAgfSwgMzAwKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSB7XG4gICAgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChlKSA9PiBlLnJlbW92ZUF0dHJpYnV0ZShmdCkpO1xuICB9XG4gIF9oYW5kbGVBZGRBY3RpdmVDbGFzcygpIHtcbiAgICB0aGlzLmFsbENoaXBzLmZvckVhY2goKGUpID0+IGUuc2V0QXR0cmlidXRlKGZ0LCBcIlwiKSk7XG4gIH1cbiAgX2hhbmRsZVJpZ2h0S2V5Ym9hcmRBcnJvdyhlKSB7XG4gICAgdGhpcy5faGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSwgZSA9PT0gMCAmJiAoZSA9IDEpLCB0aGlzLl9oYW5kbGVBZGRBY3RpdmVDbGFzc1dpdGhLZWJ5Ym9hcmQoZSk7XG4gIH1cbiAgX2hhbmRsZUxlZnRLZXlib2FyZEFycm93KGUpIHtcbiAgICB0aGlzLl9oYW5kbGVSZW1vdmVBY3RpdmVDbGFzcygpLCB0aGlzLl9oYW5kbGVBZGRBY3RpdmVDbGFzc1dpdGhLZWJ5Ym9hcmQoZSk7XG4gIH1cbiAgX2hhbmRsZUFjdGl2ZUNoaXBBZnRlclJlbW92ZShlKSB7XG4gICAgY29uc3QgaSA9IGUgPT09IDAgPyAxIDogZSAtIDE7XG4gICAgcmV0dXJuIHRoaXMuYWxsQ2hpcHNbaV07XG4gIH1cbiAgX2hhbmRsZUNsaWNrc09uQ2hpcHMoKSB7XG4gICAgdS5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuYWxsQ2hpcHMubGVuZ3RoID09PSAwICYmICh0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICAgICksIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKGZ0KSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVRleHRDb250ZW50KCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChpKSA9PiBlLnB1c2goeyB0YWc6IGkudGV4dENvbnRlbnQudHJpbSgpIH0pKSwgZTtcbiAgfVxuICBfaGFuZGxlRXZlbnRzKGUsIGkpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faGFuZGxlVGV4dENvbnRlbnQoKSwgbyA9IHRoaXMuYWxsQ2hpcHMuZmlsdGVyKFxuICAgICAgKHIpID0+IHIuaGFzQXR0cmlidXRlKGZ0KSAmJiByXG4gICAgKTtcbiAgICB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgaSwge1xuICAgICAgZXZlbnQ6IGUsXG4gICAgICBhbGxDaGlwczogdGhpcy5hbGxDaGlwcyxcbiAgICAgIGFyck9mT2JqZWN0czogbixcbiAgICAgIGFjdGl2ZTogbyxcbiAgICAgIGFjdGl2ZU9iajoge1xuICAgICAgICB0YWc6IG8ubGVuZ3RoIDw9IDAgPyBcIlwiIDogb1swXS50ZXh0Q29udGVudC50cmltKClcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2hpcHNGb2N1cygpIHtcbiAgICB1Lm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKHsgdGFyZ2V0OiB7IGF0dHJpYnV0ZXM6IGUgfSB9KSA9PiB7XG4gICAgICBjb25zdCBpID0gWy4uLmVdO1xuICAgICAgaS5pbmNsdWRlcyhLbikgfHwgaS5pbmNsdWRlcyhIbCkgfHwgaS5pbmNsdWRlcyhCbCkgfHwgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVJbml0aWFsVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuX2FwcGVuZElucHV0VG9FbGVtZW50KHBhKSwgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUocGEpKSB7XG4gICAgICBjb25zdCB7IGluaXRpYWxWYWx1ZXM6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBlLmZvckVhY2goXG4gICAgICAgICh7IHRhZzogaSB9KSA9PiB0aGlzLl9oYW5kbGVDcmVhdGVDaGlwKHRoaXMuaW5wdXQsIGkpXG4gICAgICApLCBoLmZpbmRPbmUoXG4gICAgICAgIFNuLFxuICAgICAgICB0aGlzLmlucHV0LnBhcmVudE5vZGVcbiAgICAgICkuc2V0QXR0cmlidXRlKEFlLCBcIlwiKSwgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoZnQsIFwiXCIpLCB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShBZSwgXCJcIik7XG4gICAgfVxuICAgIHRoaXMuYWxsQ2hpcHMubGVuZ3RoID4gMCAmJiAodGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMudHJhbnNpdGlvbi5zcGxpdChcIiBcIilcbiAgICApKTtcbiAgfVxuICBfaGFuZGxlS2V5c0lucHV0VG9FbGVtZW50KGUpIHtcbiAgICBjb25zdCB7IGtleUNvZGU6IGksIHRhcmdldDogbiB9ID0gZTtcbiAgICBpZiAobi5oYXNBdHRyaWJ1dGUoS24pKSB7XG4gICAgICBjb25zdCBvID0gaC5maW5kT25lKHhuLCBuKTtcbiAgICAgIGkgPT09IGx0ICYmIChuLmNvbnRlbnRFZGl0YWJsZSA9ICExLCBuLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5jb250ZW50RWRpdGFibGUuc3BsaXQoXCIgXCIpKSwgbi50ZXh0Q29udGVudCAhPT0gXCJcIiA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBwLmFkZFN0eWxlKG8sIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCBvLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICB9LCAxNjApIDogbi50ZXh0Q29udGVudCA9PT0gXCJcIiAmJiAoc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4uY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgIH0sIDIwMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBuLnJlbW92ZSgpO1xuICAgICAgfSwgMzAwKSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gbHQpIHtcbiAgICAgIGlmIChuLnZhbHVlID09PSBcIlwiKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9oYW5kbGVDcmVhdGVDaGlwKG4sIG4udmFsdWUpLCB0aGlzLl9oYW5kbGVSZW1vdmVBY3RpdmVDbGFzcygpLCB0aGlzLm51bWJlckNsaWNrcyA9IHRoaXMuYWxsQ2hpcHMubGVuZ3RoICsgMSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIEFnKTtcbiAgICB9XG4gICAgdGhpcy5hbGxDaGlwcy5sZW5ndGggPiAwID8gKHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICApLCB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLnRyYW5zaXRpb24uc3BsaXQoXCIgXCIpXG4gICAgKSkgOiB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlSW5wdXRUZXh0KCkge1xuICAgIGNvbnN0IGUgPSBoLmZpbmRPbmUoXG4gICAgICBiZyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXl1cFwiLFxuICAgICAgZSxcbiAgICAgIChpKSA9PiB0aGlzLl9oYW5kbGVLZXlzSW5wdXRUb0VsZW1lbnQoaSlcbiAgICApLCB1Lm9uKHRoaXMuaW5wdXQsIFwiYmx1clwiLCAoaSkgPT4gdGhpcy5faGFuZGxlQmx1cklucHV0KGkpKTtcbiAgfVxuICBfYXBwZW5kSW5wdXRUb0VsZW1lbnQoZSkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IGlnKHRoaXMuX29wdGlvbnMsIHRoaXMuX2NsYXNzZXMpO1xuICAgIHRoaXMuX2VsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGkpO1xuICB9XG4gIF9oYW5kbGVDcmVhdGVDaGlwKGUsIGkpIHtcbiAgICBjb25zdCBuID0gTShcImRpdlwiKSwgbyA9IGlpLmdldEluc3RhbmNlKG4pLCByID0gbmV3IGlpKG8sIHsgdGV4dDogaSB9LCB0aGlzLl9jbGFzc2VzKTtcbiAgICB0aGlzLl9vcHRpb25zLnBhcmVudFNlbGVjdG9yICE9PSBcIlwiID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9vcHRpb25zLnBhcmVudFNlbGVjdG9yKS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgci5hcHBlbmRDaGlwKCkpIDogZS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLCByLmFwcGVuZENoaXAoKSksIGUudmFsdWUgPSBcIlwiLCBoLmZpbmQoVW4pLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGxldCBsID0gaWkuZ2V0SW5zdGFuY2UoYSk7XG4gICAgICByZXR1cm4gbCB8fCAobCA9IG5ldyBpaShhLCB7fSwgdGhpcy5fY2xhc3NlcykpLCBsLmluaXQoKTtcbiAgICB9KSwgdGhpcy5faGFuZGxlRWRpdGFibGUoKTtcbiAgfVxuICBfaGFuZGxlQ2hpcHNPblNlbGVjdCgpIHtcbiAgICB0aGlzLmFsbENoaXBzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHUub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCAoaSkgPT4ge1xuICAgICAgICB1LnRyaWdnZXIoZSwgX2EsIHtcbiAgICAgICAgICBldmVudDogaSxcbiAgICAgICAgICBhbGxDaGlwczogdGhpcy5hbGxDaGlwc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVBZGRBY3RpdmVDbGFzc1dpdGhLZWJ5Ym9hcmQoZSkge1xuICAgIGxldCBpO1xuICAgIHRoaXMuYWxsQ2hpcHNbZSAtIDFdID09PSB2b2lkIDAgPyBpID0gdGhpcy5hbGxDaGlwc1tlIC0gMl0gOiBpID0gdGhpcy5hbGxDaGlwc1tlIC0gMV0sIGkuc2V0QXR0cmlidXRlKGZ0KTtcbiAgfVxuICBfZ2V0Q29uZmlnKGUpIHtcbiAgICBjb25zdCBpID0ge1xuICAgICAgLi4uU2csXG4gICAgICAuLi5wLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4uZVxuICAgIH07XG4gICAgcmV0dXJuIE4odWksIGksIHhnKSwgaTtcbiAgfVxuICBfZ2V0Q2xhc3NlcyhlKSB7XG4gICAgY29uc3QgaSA9IHAuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gZSA9IHtcbiAgICAgIC4uLkRnLFxuICAgICAgLi4uaSxcbiAgICAgIC4uLmVcbiAgICB9LCBOKHVpLCBlLCBJZyksIGU7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKGUpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKGUsIHVhKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZShlLCBpID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZShlKSB8fCBuZXcgdGhpcyhlLCB0eXBlb2YgaSA9PSBcIm9iamVjdFwiID8gaSA6IG51bGwpO1xuICB9XG59XG52YXIgJGcgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiBMZyh0KSAmJiAhTWcodCk7XG59O1xuZnVuY3Rpb24gTGcocykge1xuICByZXR1cm4gISFzICYmIHR5cGVvZiBzID09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBNZyhzKSB7XG4gIHZhciB0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHMpO1xuICByZXR1cm4gdCA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIiB8fCB0ID09PSBcIltvYmplY3QgRGF0ZV1cIiB8fCBQZyhzKTtcbn1cbnZhciBOZyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5mb3IsIFJnID0gTmcgPyBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSA6IDYwMTAzO1xuZnVuY3Rpb24gUGcocykge1xuICByZXR1cm4gcy4kJHR5cGVvZiA9PT0gUmc7XG59XG5mdW5jdGlvbiBIZyhzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHMpID8gW10gOiB7fTtcbn1cbmZ1bmN0aW9uIF9pKHMsIHQpIHtcbiAgcmV0dXJuIHQuY2xvbmUgIT09ICExICYmIHQuaXNNZXJnZWFibGVPYmplY3QocykgPyBXZShIZyhzKSwgcywgdCkgOiBzO1xufVxuZnVuY3Rpb24gQmcocywgdCwgZSkge1xuICByZXR1cm4gcy5jb25jYXQodCkubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gX2koaSwgZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gVmcocywgdCkge1xuICBpZiAoIXQuY3VzdG9tTWVyZ2UpXG4gICAgcmV0dXJuIFdlO1xuICB2YXIgZSA9IHQuY3VzdG9tTWVyZ2Uocyk7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogV2U7XG59XG5mdW5jdGlvbiBXZyhzKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKS5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCB0KTtcbiAgfSkgOiBbXTtcbn1cbmZ1bmN0aW9uIG1hKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHMpLmNvbmNhdChXZyhzKSk7XG59XG5mdW5jdGlvbiBWbChzLCB0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHQgaW4gcztcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBGZyhzLCB0KSB7XG4gIHJldHVybiBWbChzLCB0KSAmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHQpICYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHQpKTtcbn1cbmZ1bmN0aW9uIFlnKHMsIHQsIGUpIHtcbiAgdmFyIGkgPSB7fTtcbiAgcmV0dXJuIGUuaXNNZXJnZWFibGVPYmplY3QocykgJiYgbWEocykuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgaVtuXSA9IF9pKHNbbl0sIGUpO1xuICB9KSwgbWEodCkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgRmcocywgbikgfHwgKFZsKHMsIG4pICYmIGUuaXNNZXJnZWFibGVPYmplY3QodFtuXSkgPyBpW25dID0gVmcobiwgZSkoc1tuXSwgdFtuXSwgZSkgOiBpW25dID0gX2kodFtuXSwgZSkpO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIFdlKHMsIHQsIGUpIHtcbiAgZSA9IGUgfHwge30sIGUuYXJyYXlNZXJnZSA9IGUuYXJyYXlNZXJnZSB8fCBCZywgZS5pc01lcmdlYWJsZU9iamVjdCA9IGUuaXNNZXJnZWFibGVPYmplY3QgfHwgJGcsIGUuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBfaTtcbiAgdmFyIGkgPSBBcnJheS5pc0FycmF5KHQpLCBuID0gQXJyYXkuaXNBcnJheShzKSwgbyA9IGkgPT09IG47XG4gIHJldHVybiBvID8gaSA/IGUuYXJyYXlNZXJnZShzLCB0LCBlKSA6IFlnKHMsIHQsIGUpIDogX2kodCwgZSk7XG59XG5XZS5hbGwgPSBmdW5jdGlvbih0LCBlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXlcIik7XG4gIHJldHVybiB0LnJlZHVjZShmdW5jdGlvbihpLCBuKSB7XG4gICAgcmV0dXJuIFdlKGksIG4sIGUpO1xuICB9LCB7fSk7XG59O1xudmFyIGpnID0gV2UsIHpuID0gamc7XG5jb25zdCBnYSA9IFwiY2hhcnRcIiwgaXMgPSBcInRlLmNoYXJ0XCIsIEtnID0gXCJjaGFydFwiLCBiYSA9IChzLCB0LCBlKSA9PiB7XG4gIGNvbnN0IGkgPSAobiwgbywgcikgPT4ge1xuICAgIGNvbnN0IGEgPSBuLnNsaWNlKCk7XG4gICAgcmV0dXJuIG8uZm9yRWFjaCgobCwgYykgPT4ge1xuICAgICAgdHlwZW9mIGFbY10gPiBcInVcIiA/IGFbY10gPSByLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKFxuICAgICAgICBsLFxuICAgICAgICByXG4gICAgICApIDogci5pc01lcmdlYWJsZU9iamVjdChsKSA/IGFbY10gPSB6bihuW2NdLCBsLCByKSA6IG4uaW5kZXhPZihsKSA9PT0gLTEgJiYgYS5wdXNoKGwpO1xuICAgIH0pLCBhO1xuICB9O1xuICByZXR1cm4gem4oZVt0XSwgcywge1xuICAgIGFycmF5TWVyZ2U6IGlcbiAgfSk7XG59LCBVZyA9IHtcbiAgZGFya1RpY2tzQ29sb3I6IFwiI2ZmZlwiLFxuICBkYXJrTGFiZWxDb2xvcjogXCIjZmZmXCIsXG4gIGRhcmtHcmlkTGluZXNDb2xvcjogXCIjNTU1XCIsXG4gIGRhcmttb2RlT2ZmOiBcInVuZGVmaW5lZFwiLFxuICBkYXJrQmdDb2xvcjogXCIjMjYyNjI2XCIsXG4gIG9wdGlvbnM6IG51bGxcbn0sIHpnID0ge1xuICBkYXJrVGlja3NDb2xvcjogXCJzdHJpbmdcIixcbiAgZGFya0xhYmVsQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmtHcmlkTGluZXNDb2xvcjogXCJzdHJpbmdcIixcbiAgZGFya21vZGVPZmY6IFwiKHN0cmluZ3xudWxsKVwiLFxuICBkYXJrQmdDb2xvcjogXCJzdHJpbmdcIixcbiAgb3B0aW9uczogXCIob2JqZWN0fG51bGwpXCJcbn07XG5jbGFzcyBXbCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkgPSB7fSwgbiA9IHt9KSB7XG4gICAgdGhpcy5fd2FpdEZvckNoYXJ0cyh0LCBlLCBpLCBuKTtcbiAgfVxuICBhc3luYyBfZ2V0Q2hhcnRqcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBDaGFydDogdCxcbiAgICAgIEFyY0VsZW1lbnQ6IGUsXG4gICAgICBMaW5lRWxlbWVudDogaSxcbiAgICAgIEJhckVsZW1lbnQ6IG4sXG4gICAgICBQb2ludEVsZW1lbnQ6IG8sXG4gICAgICBCYXJDb250cm9sbGVyOiByLFxuICAgICAgQnViYmxlQ29udHJvbGxlcjogYSxcbiAgICAgIERvdWdobnV0Q29udHJvbGxlcjogbCxcbiAgICAgIExpbmVDb250cm9sbGVyOiBjLFxuICAgICAgUGllQ29udHJvbGxlcjogZCxcbiAgICAgIFBvbGFyQXJlYUNvbnRyb2xsZXI6IF8sXG4gICAgICBSYWRhckNvbnRyb2xsZXI6IGYsXG4gICAgICBTY2F0dGVyQ29udHJvbGxlcjogbSxcbiAgICAgIENhdGVnb3J5U2NhbGU6IGcsXG4gICAgICBMaW5lYXJTY2FsZTogYixcbiAgICAgIExvZ2FyaXRobWljU2NhbGU6IFQsXG4gICAgICBSYWRpYWxMaW5lYXJTY2FsZTogQyxcbiAgICAgIFRpbWVTY2FsZTogdyxcbiAgICAgIFRpbWVTZXJpZXNTY2FsZTogdixcbiAgICAgIERlY2ltYXRpb246IEUsXG4gICAgICBGaWxsZXI6IEEsXG4gICAgICBMZWdlbmQ6IHksXG4gICAgICBUaXRsZTogUyxcbiAgICAgIFRvb2x0aXA6IE8sXG4gICAgICBTdWJUaXRsZToga1xuICAgIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NoYXJ0LmVzLmpzXCIpLnRoZW4oKEQpID0+IEQuZik7XG4gICAgcmV0dXJuIHQucmVnaXN0ZXIoXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBvLFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsLFxuICAgICAgYyxcbiAgICAgIGQsXG4gICAgICBfLFxuICAgICAgZixcbiAgICAgIG0sXG4gICAgICBnLFxuICAgICAgYixcbiAgICAgIFQsXG4gICAgICBDLFxuICAgICAgdyxcbiAgICAgIHYsXG4gICAgICBFLFxuICAgICAgQSxcbiAgICAgIHksXG4gICAgICBTLFxuICAgICAgTyxcbiAgICAgIGtcbiAgICApLCB0O1xuICB9XG4gIGFzeW5jIF9nZXRDaGFydERhdGFMYWJlbHMoKSB7XG4gICAgY29uc3QgeyBDaGFydERhdGFMYWJlbHM6IHQgfSA9IGF3YWl0IGltcG9ydChcIi4vY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5lcy5qc1wiKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBhc3luYyBfd2FpdEZvckNoYXJ0cyh0LCBlLCBpID0ge30sIG4gPSB7fSkge1xuICAgIHRoaXMuX0NoYXJ0anMgPSBhd2FpdCB0aGlzLl9nZXRDaGFydGpzKCksIHRoaXMuX0NoYXJ0RGF0YUxhYmVscyA9IGF3YWl0IHRoaXMuX2dldENoYXJ0RGF0YUxhYmVscygpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZGF0YSA9IGUsIHRoaXMuX29wdGlvbnMgPSBpLCB0aGlzLl90eXBlID0gZS50eXBlLCB0aGlzLl9jYW52YXMgPSBudWxsLCB0aGlzLl9jaGFydCA9IG51bGwsIHRoaXMuX2RhcmtPcHRpb25zID0gdGhpcy5fZ2V0RGFya0NvbmZpZyhuKSwgdGhpcy5fZGFya01vZGVDbGFzc0NvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJodG1sXCIpLCB0aGlzLl9wcmV2Q29uZmlnID0gbnVsbCwgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsLCB0aGlzLl9lbGVtZW50ICYmIChJLnNldERhdGEodCwgaXMsIHRoaXMpLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIEtnKSwgdGhpcy5fY2hhcnRDb25zdHJ1Y3RvcigpKSwgdGhpcy5fZGFya09wdGlvbnMuZGFya21vZGVPZmYgIT09IG51bGwgJiYgKHRoaXMuX2hhbmRsZU1vZGUodGhpcy5zeXN0ZW1Db2xvck1vZGUpLCB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29ic2VydmVyQ2FsbGJhY2suYmluZCh0aGlzKSksIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZGFya01vZGVDbGFzc0NvbnRhaW5lciwge1xuICAgICAgYXR0cmlidXRlczogITBcbiAgICB9KSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGdhO1xuICB9XG4gIGdldCBzeXN0ZW1Db2xvck1vZGUoKSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS50aGVtZSB8fCAodGhpcy5fZGFya01vZGVDbGFzc0NvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoXCJkYXJrXCIpID8gXCJkYXJrXCIgOiBcImxpZ2h0XCIpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGlzKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgdXBkYXRlKHQsIGUpIHtcbiAgICB0ICYmICh0aGlzLl9kYXRhID0geyAuLi50aGlzLl9kYXRhLCAuLi50IH0sIHRoaXMuX2NoYXJ0LmRhdGEgPSB0aGlzLl9kYXRhKSwgdGhpcy5fcHJldkNvbmZpZyA9IHRoaXMuX2NoYXJ0Lm9wdGlvbnMsIHRoaXMuX29wdGlvbnMgPSB7IC4uLnRoaXMuX29wdGlvbnMsIC4uLmUgfSwgdGhpcy5fY2hhcnQub3B0aW9ucyA9IHpuKHRoaXMuX2NoYXJ0Lm9wdGlvbnMsIHRoaXMuX29wdGlvbnMpLCB0aGlzLl9jaGFydC51cGRhdGUoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXREYXJrQ29uZmlnKHQpIHtcbiAgICBsZXQgZSA9IHt9O1xuICAgIGNvbnN0IGkgPSBwLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIE9iamVjdC5rZXlzKGkpLmZvckVhY2goXG4gICAgICAoYykgPT4gYy5zdGFydHNXaXRoKFwiZGFya1wiKSAmJiAoZVtjXSA9IGlbY10pXG4gICAgKSwgZSA9IHtcbiAgICAgIC4uLlVnLFxuICAgICAgLi4uZVxuICAgIH07XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIHk6IHtcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvclxuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya0dyaWRMaW5lc0NvbG9yXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB4OiB7XG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya1RpY2tzQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtHcmlkTGluZXNDb2xvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgbyA9IHtcbiAgICAgIHI6IHtcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvcixcbiAgICAgICAgICBiYWNrZHJvcENvbG9yOiBlLmRhcmtCZ0NvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrR3JpZExpbmVzQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgbCA9IHtcbiAgICAgIHNjYWxlczogW1wicGllXCIsIFwiZG91Z2hudXRcIiwgXCJwb2xhckFyZWFcIiwgXCJyYWRhclwiXS5pbmNsdWRlcyh0aGlzLl90eXBlKSA/IFtcInBvbGFyQXJlYVwiLCBcInJhZGFyXCJdLmluY2x1ZGVzKHRoaXMuX3R5cGUpID8gbyA6IHt9IDogbixcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBjb2xvcjogZS5kYXJrTGFiZWxDb2xvclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5lLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICAuLi5sXG4gICAgICB9LFxuICAgICAgLi4udFxuICAgIH0sIE4oZ2EsIHQsIHpnKSwgdDtcbiAgfVxuICBfY2hhcnRDb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlQ2FudmFzKCk7XG4gICAgICBjb25zdCB0ID0gYmEodGhpcy5fb3B0aW9ucywgdGhpcy5fdHlwZSwgZ3MpLCBlID0gW107XG4gICAgICB0LmRhdGFMYWJlbHNQbHVnaW4gJiYgZS5wdXNoKHRoaXMuX0NoYXJ0RGF0YUxhYmVscyksIHRoaXMuX2NoYXJ0ID0gbmV3IHRoaXMuX0NoYXJ0anModGhpcy5fY2FudmFzLCB7XG4gICAgICAgIC4uLnRoaXMuX2RhdGEsXG4gICAgICAgIC4uLnQsXG4gICAgICAgIHBsdWdpbnM6IGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlQ2FudmFzKCkge1xuICAgIHRoaXMuX2NhbnZhcyB8fCAodGhpcy5fZWxlbWVudC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIiA/IHRoaXMuX2NhbnZhcyA9IHRoaXMuX2VsZW1lbnQgOiAodGhpcy5fY2FudmFzID0gTShcImNhbnZhc1wiKSwgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpKSk7XG4gIH1cbiAgX2hhbmRsZU1vZGUodCkge1xuICAgIHQgPT09IFwiZGFya1wiID8gKHRoaXMuX2NoYW5nZURhdGFzZXRCb3JkZXJDb2xvcigpLCB0aGlzLnVwZGF0ZShudWxsLCB0aGlzLl9kYXJrT3B0aW9ucy5vcHRpb25zKSkgOiAodGhpcy5fY2hhbmdlRGF0YXNldEJvcmRlckNvbG9yKCExKSwgdGhpcy5fcHJldkNvbmZpZyAmJiB0aGlzLnVwZGF0ZShudWxsLCB0aGlzLl9wcmV2Q29uZmlnKSk7XG4gIH1cbiAgX29ic2VydmVyQ2FsbGJhY2sodCkge1xuICAgIGZvciAoY29uc3QgZSBvZiB0KVxuICAgICAgZS50eXBlID09PSBcImF0dHJpYnV0ZXNcIiAmJiB0aGlzLl9oYW5kbGVNb2RlKHRoaXMuc3lzdGVtQ29sb3JNb2RlKTtcbiAgfVxuICBfY2hhbmdlRGF0YXNldEJvcmRlckNvbG9yKHQgPSAhMCkge1xuICAgIFsuLi50aGlzLl9kYXRhLmRhdGEuZGF0YXNldHNdLmZvckVhY2goXG4gICAgICAoZSkgPT4gW1wicGllXCIsIFwiZG91Z2hudXRcIiwgXCJwb2xhckFyZWFcIl0uaW5jbHVkZXModGhpcy5fdHlwZSkgJiYgKGUuYm9yZGVyQ29sb3IgPSB0ID8gdGhpcy5fZGFya09wdGlvbnMuZGFya0JnQ29sb3IgOiBcIiNmZmZcIilcbiAgICApO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSwgaSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgbiA9IEkuZ2V0RGF0YSh0aGlzLCBpcyk7XG4gICAgICBpZiAoISghbiAmJiAvZGlzcG9zZS8udGVzdCh0KSkpIHtcbiAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgY29uc3QgbyA9IGUgPyBiYShlLCBpLCBncykgOiBnc1tpXTtcbiAgICAgICAgICBuID0gbmV3IFdsKHRoaXMsIHtcbiAgICAgICAgICAgIC4uLnQsXG4gICAgICAgICAgICAuLi5vXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5bdF0gPiBcInVcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICAgIG5bdF0oZSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgaXMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFJuIGFzIEFsZXJ0LFxuICBtbCBhcyBBbmltYXRlLFxuICAkYSBhcyBCdXR0b24sXG4gIFl0IGFzIENhcm91c2VsLFxuICBXbCBhcyBDaGFydCxcbiAgaWkgYXMgQ2hpcCxcbiAgWmcgYXMgQ2hpcHNJbnB1dCxcbiAgVXQgYXMgQ29sbGFwc2UsXG4gIEdnIGFzIERhdGVwaWNrZXIsXG4gIHd0IGFzIERyb3Bkb3duLFxuICBWIGFzIElucHV0LFxuICBQbiBhcyBNb2RhbCxcbiAgcnMgYXMgT2ZmY2FudmFzLFxuICBsbCBhcyBQb3BvdmVyLFxuICBDcyBhcyBSaXBwbGUsXG4gIEJuIGFzIFNjcm9sbFNweSxcbiAgTmwgYXMgU2VsZWN0LFxuICBuaSBhcyBTaWRlbmF2LFxuICBRZyBhcyBTdGVwcGVyLFxuICBobCBhcyBUYWIsXG4gIHFnIGFzIFRpbWVwaWNrZXIsXG4gIFZuIGFzIFRvYXN0LFxuICB2aSBhcyBUb29sdGlwLFxuICBlZyBhcyBpbml0VEVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dy1lbGVtZW50cy5lcy5taW4uanMubWFwXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZiA9IHt9O1xuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIG9ubHkgdGhlIGVudHJ5IGNodW5rLlxuLy8gVGhlIGNodW5rIGxvYWRpbmcgZnVuY3Rpb24gZm9yIGFkZGl0aW9uYWwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmUgPSAoY2h1bmtJZCkgPT4ge1xuXHRyZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5mKS5yZWR1Y2UoKHByb21pc2VzLCBrZXkpID0+IHtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZba2V5XShjaHVua0lkLCBwcm9taXNlcyk7XG5cdFx0cmV0dXJuIHByb21pc2VzO1xuXHR9LCBbXSkpO1xufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhc3luYyBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18udSA9IChjaHVua0lkKSA9PiB7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gXCJqcy9cIiArIGNodW5rSWQgKyBcIi5pbmJvdW5kX29yZGVyLmpzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsInZhciBpblByb2dyZXNzID0ge307XG52YXIgZGF0YVdlYnBhY2tQcmVmaXggPSBcInN0YXRpYzpcIjtcbi8vIGxvYWRTY3JpcHQgZnVuY3Rpb24gdG8gbG9hZCBhIHNjcmlwdCB2aWEgc2NyaXB0IHRhZ1xuX193ZWJwYWNrX3JlcXVpcmVfXy5sID0gKHVybCwgZG9uZSwga2V5LCBjaHVua0lkKSA9PiB7XG5cdGlmKGluUHJvZ3Jlc3NbdXJsXSkgeyBpblByb2dyZXNzW3VybF0ucHVzaChkb25lKTsgcmV0dXJuOyB9XG5cdHZhciBzY3JpcHQsIG5lZWRBdHRhY2g7XG5cdGlmKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHMgPSBzY3JpcHRzW2ldO1xuXHRcdFx0aWYocy5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgPT0gdXJsIHx8IHMuZ2V0QXR0cmlidXRlKFwiZGF0YS13ZWJwYWNrXCIpID09IGRhdGFXZWJwYWNrUHJlZml4ICsga2V5KSB7IHNjcmlwdCA9IHM7IGJyZWFrOyB9XG5cdFx0fVxuXHR9XG5cdGlmKCFzY3JpcHQpIHtcblx0XHRuZWVkQXR0YWNoID0gdHJ1ZTtcblx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuXHRcdHNjcmlwdC5jaGFyc2V0ID0gJ3V0Zi04Jztcblx0XHRzY3JpcHQudGltZW91dCA9IDEyMDtcblx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5uYykge1xuXHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIF9fd2VicGFja19yZXF1aXJlX18ubmMpO1xuXHRcdH1cblx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwiZGF0YS13ZWJwYWNrXCIsIGRhdGFXZWJwYWNrUHJlZml4ICsga2V5KTtcblx0XHRzY3JpcHQuc3JjID0gdXJsO1xuXHR9XG5cdGluUHJvZ3Jlc3NbdXJsXSA9IFtkb25lXTtcblx0dmFyIG9uU2NyaXB0Q29tcGxldGUgPSAocHJldiwgZXZlbnQpID0+IHtcblx0XHQvLyBhdm9pZCBtZW0gbGVha3MgaW4gSUUuXG5cdFx0c2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gbnVsbDtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0dmFyIGRvbmVGbnMgPSBpblByb2dyZXNzW3VybF07XG5cdFx0ZGVsZXRlIGluUHJvZ3Jlc3NbdXJsXTtcblx0XHRzY3JpcHQucGFyZW50Tm9kZSAmJiBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdGRvbmVGbnMgJiYgZG9uZUZucy5mb3JFYWNoKChmbikgPT4gKGZuKGV2ZW50KSkpO1xuXHRcdGlmKHByZXYpIHJldHVybiBwcmV2KGV2ZW50KTtcblx0fVxuXHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQob25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHVuZGVmaW5lZCwgeyB0eXBlOiAndGltZW91dCcsIHRhcmdldDogc2NyaXB0IH0pLCAxMjAwMDApO1xuXHRzY3JpcHQub25lcnJvciA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25lcnJvcik7XG5cdHNjcmlwdC5vbmxvYWQgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9ubG9hZCk7XG5cdG5lZWRBdHRhY2ggJiYgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xufTsiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJ2YXIgc2NyaXB0VXJsO1xuaWYgKF9fd2VicGFja19yZXF1aXJlX18uZy5pbXBvcnRTY3JpcHRzKSBzY3JpcHRVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcubG9jYXRpb24gKyBcIlwiO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmRvY3VtZW50O1xuaWYgKCFzY3JpcHRVcmwgJiYgZG9jdW1lbnQpIHtcblx0aWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkgc2NyaXB0VXJsID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLnNyY1xuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybCArIFwiLi4vXCI7IiwiLy8gbm8gYmFzZVVSSVxuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLy8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4vLyBbcmVzb2x2ZSwgcmVqZWN0LCBQcm9taXNlXSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwibWFpblwiOiAwXG59O1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmYuaiA9IChjaHVua0lkLCBwcm9taXNlcykgPT4ge1xuXHRcdC8vIEpTT05QIGNodW5rIGxvYWRpbmcgZm9yIGphdmFzY3JpcHRcblx0XHR2YXIgaW5zdGFsbGVkQ2h1bmtEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgPyBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gOiB1bmRlZmluZWQ7XG5cdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSB7IC8vIDAgbWVhbnMgXCJhbHJlYWR5IGluc3RhbGxlZFwiLlxuXG5cdFx0XHQvLyBhIFByb21pc2UgbWVhbnMgXCJjdXJyZW50bHkgbG9hZGluZ1wiLlxuXHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG5cdFx0XHRcdHByb21pc2VzLnB1c2goaW5zdGFsbGVkQ2h1bmtEYXRhWzJdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRydWUpIHsgLy8gYWxsIGNodW5rcyBoYXZlIEpTXG5cdFx0XHRcdFx0Ly8gc2V0dXAgUHJvbWlzZSBpbiBjaHVuayBjYWNoZVxuXHRcdFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gKGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IFtyZXNvbHZlLCByZWplY3RdKSk7XG5cdFx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0gPSBwcm9taXNlKTtcblxuXHRcdFx0XHRcdC8vIHN0YXJ0IGNodW5rIGxvYWRpbmdcblx0XHRcdFx0XHR2YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy51KGNodW5rSWQpO1xuXHRcdFx0XHRcdC8vIGNyZWF0ZSBlcnJvciBiZWZvcmUgc3RhY2sgdW53b3VuZCB0byBnZXQgdXNlZnVsIHN0YWNrdHJhY2UgbGF0ZXJcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblx0XHRcdFx0XHR2YXIgbG9hZGluZ0VuZGVkID0gKGV2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSkge1xuXHRcdFx0XHRcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG5cdFx0XHRcdFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSAhPT0gMCkgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZXJyb3JUeXBlID0gZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdsb2FkJyA/ICdtaXNzaW5nJyA6IGV2ZW50LnR5cGUpO1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IubWVzc2FnZSA9ICdMb2FkaW5nIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5uYW1lID0gJ0NodW5rTG9hZEVycm9yJztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci50eXBlID0gZXJyb3JUeXBlO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZWFsU3JjO1xuXHRcdFx0XHRcdFx0XHRcdGluc3RhbGxlZENodW5rRGF0YVsxXShlcnJvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubCh1cmwsIGxvYWRpbmdFbmRlZCwgXCJjaHVuay1cIiArIGNodW5rSWQsIGNodW5rSWQpO1xuXHRcdFx0XHR9IGVsc2UgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0XHRcdH1cblx0XHR9XG59O1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdFxuXG4vLyBubyBvbiBjaHVua3MgbG9hZGVkXG5cbi8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xudmFyIHdlYnBhY2tKc29ucENhbGxiYWNrID0gKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uLCBkYXRhKSA9PiB7XG5cdHZhciBbY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBydW50aW1lXSA9IGRhdGE7XG5cdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuXHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcblx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMDtcblx0aWYoY2h1bmtJZHMuc29tZSgoaWQpID0+IChpbnN0YWxsZWRDaHVua3NbaWRdICE9PSAwKSkpIHtcblx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHJ1bnRpbWUpIHZhciByZXN1bHQgPSBydW50aW1lKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHR9XG5cdGlmKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKSBwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbihkYXRhKTtcblx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcblx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiYgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0oKTtcblx0XHR9XG5cdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0fVxuXG59XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSBzZWxmW1wid2VicGFja0NodW5rc3RhdGljXCJdID0gc2VsZltcIndlYnBhY2tDaHVua3N0YXRpY1wiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5ib3VuZF9vcmRlci9pbmJvdW5kX29yZGVyLnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9