/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@popperjs/core/lib/createPopper.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/createPopper.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "popperGenerator": () => (/* binding */ popperGenerator)
/* harmony export */ });
/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/debounce.js */ "./node_modules/@popperjs/core/lib/utils/debounce.js");
/* harmony import */ var _utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/validateModifiers.js */ "./node_modules/@popperjs/core/lib/utils/validateModifiers.js");
/* harmony import */ var _utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/uniqueBy.js */ "./node_modules/@popperjs/core/lib/utils/uniqueBy.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/mergeByName.js */ "./node_modules/@popperjs/core/lib/utils/mergeByName.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");














var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference.contextElement) : [],
          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (true) {
          var modifiers = (0,_utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_4__["default"])([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          (0,_utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_5__["default"])(modifiers);

          if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.options.placement) === _enums_js__WEBPACK_IMPORTED_MODULE_7__.auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = (0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__["default"])(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update â€“ it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_9__["default"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__["default"])(popper), state.options.strategy === 'fixed'),
          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_11__["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update â€“ it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ contains)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBoundingClientRect)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    scaleX = element.offsetWidth > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !(0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__["default"])() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getClippingRect)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getViewportRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");
/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");
/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");















function getInnerBoundingClientRect(element, strategy) {
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_1__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element, strategy)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__["default"])((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__["default"])(element) : element;

  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_11__["default"])(clippingParent, clipperElement) && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_12__["default"])(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.top, accRect.top);
    accRect.right = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.right, accRect.right);
    accRect.bottom = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.bottom, accRect.bottom);
    accRect.left = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getCompositeRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getNodeScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");









function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.width) / element.offsetWidth || 1;
  var scaleY = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);
  var offsetParentIsScaled = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent);
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(documentElement)) {
      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__["default"])(offsetParent);
    }

    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {
      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__["default"])(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getComputedStyle)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getComputedStyle(element) {
  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentElement)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return (((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentRect)
/* harmony export */ });
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");




 // Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  var y = -winScroll.scrollTop;

  if ((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(body || html).direction === 'rtl') {
    x += (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getHTMLElementScroll)
/* harmony export */ });
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLayoutRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
 // Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeName)
/* harmony export */ });
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeScroll)
/* harmony export */ });
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");




function getNodeScroll(node) {
  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node)) {
    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node);
  } else {
    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);
  }
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOffsetParent)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isTableElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");








function getTrueOffsetParent(element) {
  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__["default"])());
  var isIE = /Trident/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__["default"])());

  if (isIE && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = (0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(currentNode)) {
    currentNode = currentNode.host;
  }

  while ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(currentNode)) < 0) {
    var css = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(offsetParent) && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'html' || (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getParentNode)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");



function getParentNode(element) {
  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) // fallback

  );
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getScrollParent)
/* harmony export */ });
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) {
    return node;
  }

  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getViewportRect)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isLayoutViewport.js */ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js");




function getViewportRect(element, strategy) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = (0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element),
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindow)
/* harmony export */ });
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScroll)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getWindowScroll(node) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScrollBarX)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isElement": () => (/* binding */ isElement),
/* harmony export */   "isHTMLElement": () => (/* binding */ isHTMLElement),
/* harmony export */   "isShadowRoot": () => (/* binding */ isShadowRoot)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");


function isElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isLayoutViewport)
/* harmony export */ });
/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/userAgent.js */ "./node_modules/@popperjs/core/lib/utils/userAgent.js");

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__["default"])());
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isScrollParent)
/* harmony export */ });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isTableElement)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) >= 0;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ listScrollParents)
/* harmony export */ });
/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");




/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(target)));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "afterMain": () => (/* binding */ afterMain),
/* harmony export */   "afterRead": () => (/* binding */ afterRead),
/* harmony export */   "afterWrite": () => (/* binding */ afterWrite),
/* harmony export */   "auto": () => (/* binding */ auto),
/* harmony export */   "basePlacements": () => (/* binding */ basePlacements),
/* harmony export */   "beforeMain": () => (/* binding */ beforeMain),
/* harmony export */   "beforeRead": () => (/* binding */ beforeRead),
/* harmony export */   "beforeWrite": () => (/* binding */ beforeWrite),
/* harmony export */   "bottom": () => (/* binding */ bottom),
/* harmony export */   "clippingParents": () => (/* binding */ clippingParents),
/* harmony export */   "end": () => (/* binding */ end),
/* harmony export */   "left": () => (/* binding */ left),
/* harmony export */   "main": () => (/* binding */ main),
/* harmony export */   "modifierPhases": () => (/* binding */ modifierPhases),
/* harmony export */   "placements": () => (/* binding */ placements),
/* harmony export */   "popper": () => (/* binding */ popper),
/* harmony export */   "read": () => (/* binding */ read),
/* harmony export */   "reference": () => (/* binding */ reference),
/* harmony export */   "right": () => (/* binding */ right),
/* harmony export */   "start": () => (/* binding */ start),
/* harmony export */   "top": () => (/* binding */ top),
/* harmony export */   "variationPlacements": () => (/* binding */ variationPlacements),
/* harmony export */   "viewport": () => (/* binding */ viewport),
/* harmony export */   "write": () => (/* binding */ write)
/* harmony export */ });
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");









 // eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_2__.basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(state.placement);
  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(basePlacement);
  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_2__.left, _enums_js__WEBPACK_IMPORTED_MODULE_2__.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.top : _enums_js__WEBPACK_IMPORTED_MODULE_2__.left;
  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_2__.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_7__.within)(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (true) {
    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_8__.isHTMLElement)(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "mapToStyles": () => (/* binding */ mapToStyles)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");







 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
      y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(x * dpr) / dpr || 0,
    y: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.left;
  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;
  var win = window;

  if (adaptive) {
    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper)) {
      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(popper);

      if ((0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.right) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper)) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if (true) {
    var transitionProperty = (0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.placement),
    variation: (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto) {
    return [];
  }

  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement);
  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);

    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.start;
    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.top, _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.right : _enums_js__WEBPACK_IMPORTED_MODULE_1__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    }

    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases â€“ research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyStyles": () => (/* reexport safe */ _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "arrow": () => (/* reexport safe */ _arrow_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "computeStyles": () => (/* reexport safe */ _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "eventListeners": () => (/* reexport safe */ _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "flip": () => (/* reexport safe */ _flip_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "hide": () => (/* reexport safe */ _hide_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "offset": () => (/* reexport safe */ _offset_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "popperOffsets": () => (/* reexport safe */ _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "preventOverflow": () => (/* reexport safe */ _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"])
/* harmony export */ });
/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");










/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "distanceAndSkiddingToXY": () => (/* binding */ distanceAndSkiddingToXY)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");

 // eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");












function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);
  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement);
  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;
    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.min)(min, tetherMin) : min, offset, tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.max)(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;

    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper-lite.js":
/*!********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper-lite.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "defaultModifiers": () => (/* binding */ defaultModifiers),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "popperGenerator": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");





var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyStyles": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.applyStyles),
/* harmony export */   "arrow": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.arrow),
/* harmony export */   "computeStyles": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.computeStyles),
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "createPopperLite": () => (/* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__.createPopper),
/* harmony export */   "defaultModifiers": () => (/* binding */ defaultModifiers),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "eventListeners": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.eventListeners),
/* harmony export */   "flip": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.flip),
/* harmony export */   "hide": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.hide),
/* harmony export */   "offset": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.offset),
/* harmony export */   "popperGenerator": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator),
/* harmony export */   "popperOffsets": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.popperOffsets),
/* harmony export */   "preventOverflow": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.preventOverflow)
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");
/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");
/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");










var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeAutoPlacement)
/* harmony export */ });
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");




function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements : _options$allowedAutoP;
  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);
  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements.filter(function (placement) {
    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === variation;
  }) : _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;

    if (true) {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeOffsets)
/* harmony export */ });
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;
  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ detectOverflow)
/* harmony export */ });
/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");
/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements));
  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.elements.reference);
  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ expandToHashMap)
/* harmony export */ });
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/format.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/format.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ format)
/* harmony export */ });
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAltAxis)
/* harmony export */ });
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBasePlacement)
/* harmony export */ });

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getFreshSideObject)
/* harmony export */ });
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMainAxisFromPlacement)
/* harmony export */ });
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositePlacement)
/* harmony export */ });
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositeVariationPlacement)
/* harmony export */ });
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVariation)
/* harmony export */ });
function getVariation(placement) {
  return placement.split('-')[1];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/math.js":
/*!*******************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/math.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "round": () => (/* binding */ round)
/* harmony export */ });
var max = Math.max;
var min = Math.min;
var round = Math.round;

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeByName)
/* harmony export */ });
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergePaddingObject)
/* harmony export */ });
/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");

function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(), paddingObject);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ orderModifiers)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rectToClientRect)
/* harmony export */ });
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/uniqueBy.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/uniqueBy.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ uniqueBy)
/* harmony export */ });
function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/userAgent.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/userAgent.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUAString)
/* harmony export */ });
function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/validateModifiers.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/validateModifiers.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ validateModifiers)
/* harmony export */ });
/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format.js */ "./node_modules/@popperjs/core/lib/utils/format.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");


var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
    .filter(function (value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

          break;

        case 'phase':
          if (_enums_js__WEBPACK_IMPORTED_MODULE_1__.modifierPhases.indexOf(modifier.phase) < 0) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + _enums_js__WEBPACK_IMPORTED_MODULE_1__.modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (modifier.effect != null && typeof modifier.effect !== 'function') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "within": () => (/* binding */ within),
/* harmony export */   "withinMaxClamp": () => (/* binding */ withinMaxClamp)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");

function within(min, value, max) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(min, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/accordion/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/accordion/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initAccordions": () => (/* binding */ initAccordions)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    alwaysOpen: false,
    activeClasses: 'bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white',
    inactiveClasses: 'text-gray-500 dark:text-gray-400',
    onOpen: function () { },
    onClose: function () { },
    onToggle: function () { },
};
var Accordion = /** @class */ (function () {
    function Accordion(items, options) {
        if (items === void 0) { items = []; }
        if (options === void 0) { options = Default; }
        this._items = items;
        this._options = __assign(__assign({}, Default), options);
        this._init();
    }
    Accordion.prototype._init = function () {
        var _this = this;
        if (this._items.length) {
            // show accordion item based on click
            this._items.map(function (item) {
                if (item.active) {
                    _this.open(item.id);
                }
                item.triggerEl.addEventListener('click', function () {
                    _this.toggle(item.id);
                });
            });
        }
    };
    Accordion.prototype.getItem = function (id) {
        return this._items.filter(function (item) { return item.id === id; })[0];
    };
    Accordion.prototype.open = function (id) {
        var _a, _b;
        var _this = this;
        var item = this.getItem(id);
        // don't hide other accordions if always open
        if (!this._options.alwaysOpen) {
            this._items.map(function (i) {
                var _a, _b;
                if (i !== item) {
                    (_a = i.triggerEl.classList).remove.apply(_a, _this._options.activeClasses.split(' '));
                    (_b = i.triggerEl.classList).add.apply(_b, _this._options.inactiveClasses.split(' '));
                    i.targetEl.classList.add('hidden');
                    i.triggerEl.setAttribute('aria-expanded', 'false');
                    i.active = false;
                    // rotate icon if set
                    if (i.iconEl) {
                        i.iconEl.classList.remove('rotate-180');
                    }
                }
            });
        }
        // show active item
        (_a = item.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(' '));
        (_b = item.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(' '));
        item.triggerEl.setAttribute('aria-expanded', 'true');
        item.targetEl.classList.remove('hidden');
        item.active = true;
        // rotate icon if set
        if (item.iconEl) {
            item.iconEl.classList.add('rotate-180');
        }
        // callback function
        this._options.onOpen(this, item);
    };
    Accordion.prototype.toggle = function (id) {
        var item = this.getItem(id);
        if (item.active) {
            this.close(id);
        }
        else {
            this.open(id);
        }
        // callback function
        this._options.onToggle(this, item);
    };
    Accordion.prototype.close = function (id) {
        var _a, _b;
        var item = this.getItem(id);
        (_a = item.triggerEl.classList).remove.apply(_a, this._options.activeClasses.split(' '));
        (_b = item.triggerEl.classList).add.apply(_b, this._options.inactiveClasses.split(' '));
        item.targetEl.classList.add('hidden');
        item.triggerEl.setAttribute('aria-expanded', 'false');
        item.active = false;
        // rotate icon if set
        if (item.iconEl) {
            item.iconEl.classList.remove('rotate-180');
        }
        // callback function
        this._options.onClose(this, item);
    };
    return Accordion;
}());
if (typeof window !== 'undefined') {
    window.Accordion = Accordion;
}
function initAccordions() {
    document.querySelectorAll('[data-accordion]').forEach(function ($accordionEl) {
        var alwaysOpen = $accordionEl.getAttribute('data-accordion');
        var activeClasses = $accordionEl.getAttribute('data-active-classes');
        var inactiveClasses = $accordionEl.getAttribute('data-inactive-classes');
        var items = [];
        $accordionEl
            .querySelectorAll('[data-accordion-target]')
            .forEach(function ($triggerEl) {
            var item = {
                id: $triggerEl.getAttribute('data-accordion-target'),
                triggerEl: $triggerEl,
                targetEl: document.querySelector($triggerEl.getAttribute('data-accordion-target')),
                iconEl: $triggerEl.querySelector('[data-accordion-icon]'),
                active: $triggerEl.getAttribute('aria-expanded') === 'true'
                    ? true
                    : false,
            };
            items.push(item);
        });
        new Accordion(items, {
            alwaysOpen: alwaysOpen === 'open' ? true : false,
            activeClasses: activeClasses
                ? activeClasses
                : Default.activeClasses,
            inactiveClasses: inactiveClasses
                ? inactiveClasses
                : Default.inactiveClasses,
        });
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Accordion);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/accordion/interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/accordion/interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/accordion/types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/accordion/types.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/carousel/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/carousel/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initCarousels": () => (/* binding */ initCarousels)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    defaultPosition: 0,
    indicators: {
        items: [],
        activeClasses: 'bg-white dark:bg-gray-800',
        inactiveClasses: 'bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800',
    },
    interval: 3000,
    onNext: function () { },
    onPrev: function () { },
    onChange: function () { },
};
var Carousel = /** @class */ (function () {
    function Carousel(items, options) {
        if (items === void 0) { items = []; }
        if (options === void 0) { options = Default; }
        this._items = items;
        this._options = __assign(__assign(__assign({}, Default), options), { indicators: __assign(__assign({}, Default.indicators), options.indicators) });
        this._activeItem = this.getItem(this._options.defaultPosition);
        this._indicators = this._options.indicators.items;
        this._intervalDuration = this._options.interval;
        this._intervalInstance = null;
        this._init();
    }
    /**
     * initialize carousel and items based on active one
     */
    Carousel.prototype._init = function () {
        var _this = this;
        this._items.map(function (item) {
            item.el.classList.add('absolute', 'inset-0', 'transition-transform', 'transform');
        });
        // if no active item is set then first position is default
        if (this._getActiveItem()) {
            this.slideTo(this._getActiveItem().position);
        }
        else {
            this.slideTo(0);
        }
        this._indicators.map(function (indicator, position) {
            indicator.el.addEventListener('click', function () {
                _this.slideTo(position);
            });
        });
    };
    Carousel.prototype.getItem = function (position) {
        return this._items[position];
    };
    /**
     * Slide to the element based on id
     * @param {*} position
     */
    Carousel.prototype.slideTo = function (position) {
        var nextItem = this._items[position];
        var rotationItems = {
            left: nextItem.position === 0
                ? this._items[this._items.length - 1]
                : this._items[nextItem.position - 1],
            middle: nextItem,
            right: nextItem.position === this._items.length - 1
                ? this._items[0]
                : this._items[nextItem.position + 1],
        };
        this._rotate(rotationItems);
        this._setActiveItem(nextItem);
        if (this._intervalInstance) {
            this.pause();
            this.cycle();
        }
        this._options.onChange(this);
    };
    /**
     * Based on the currently active item it will go to the next position
     */
    Carousel.prototype.next = function () {
        var activeItem = this._getActiveItem();
        var nextItem = null;
        // check if last item
        if (activeItem.position === this._items.length - 1) {
            nextItem = this._items[0];
        }
        else {
            nextItem = this._items[activeItem.position + 1];
        }
        this.slideTo(nextItem.position);
        // callback function
        this._options.onNext(this);
    };
    /**
     * Based on the currently active item it will go to the previous position
     */
    Carousel.prototype.prev = function () {
        var activeItem = this._getActiveItem();
        var prevItem = null;
        // check if first item
        if (activeItem.position === 0) {
            prevItem = this._items[this._items.length - 1];
        }
        else {
            prevItem = this._items[activeItem.position - 1];
        }
        this.slideTo(prevItem.position);
        // callback function
        this._options.onPrev(this);
    };
    /**
     * This method applies the transform classes based on the left, middle, and right rotation carousel items
     * @param {*} rotationItems
     */
    Carousel.prototype._rotate = function (rotationItems) {
        // reset
        this._items.map(function (item) {
            item.el.classList.add('hidden');
        });
        // left item (previously active)
        rotationItems.left.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-20');
        rotationItems.left.el.classList.add('-translate-x-full', 'z-10');
        // currently active item
        rotationItems.middle.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-10');
        rotationItems.middle.el.classList.add('translate-x-0', 'z-20');
        // right item (upcoming active)
        rotationItems.right.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-20');
        rotationItems.right.el.classList.add('translate-x-full', 'z-10');
    };
    /**
     * Set an interval to cycle through the carousel items
     */
    Carousel.prototype.cycle = function () {
        var _this = this;
        if (typeof window !== 'undefined') {
            this._intervalInstance = window.setInterval(function () {
                _this.next();
            }, this._intervalDuration);
        }
    };
    /**
     * Clears the cycling interval
     */
    Carousel.prototype.pause = function () {
        clearInterval(this._intervalInstance);
    };
    /**
     * Get the currently active item
     */
    Carousel.prototype._getActiveItem = function () {
        return this._activeItem;
    };
    /**
     * Set the currently active item and data attribute
     * @param {*} position
     */
    Carousel.prototype._setActiveItem = function (item) {
        var _a, _b;
        var _this = this;
        this._activeItem = item;
        var position = item.position;
        // update the indicators if available
        if (this._indicators.length) {
            this._indicators.map(function (indicator) {
                var _a, _b;
                indicator.el.setAttribute('aria-current', 'false');
                (_a = indicator.el.classList).remove.apply(_a, _this._options.indicators.activeClasses.split(' '));
                (_b = indicator.el.classList).add.apply(_b, _this._options.indicators.inactiveClasses.split(' '));
            });
            (_a = this._indicators[position].el.classList).add.apply(_a, this._options.indicators.activeClasses.split(' '));
            (_b = this._indicators[position].el.classList).remove.apply(_b, this._options.indicators.inactiveClasses.split(' '));
            this._indicators[position].el.setAttribute('aria-current', 'true');
        }
    };
    return Carousel;
}());
if (typeof window !== 'undefined') {
    window.Carousel = Carousel;
}
function initCarousels() {
    document.querySelectorAll('[data-carousel]').forEach(function ($carouselEl) {
        var interval = $carouselEl.getAttribute('data-carousel-interval');
        var slide = $carouselEl.getAttribute('data-carousel') === 'slide'
            ? true
            : false;
        var items = [];
        var defaultPosition = 0;
        if ($carouselEl.querySelectorAll('[data-carousel-item]').length) {
            Array.from($carouselEl.querySelectorAll('[data-carousel-item]')).map(function ($carouselItemEl, position) {
                items.push({
                    position: position,
                    el: $carouselItemEl,
                });
                if ($carouselItemEl.getAttribute('data-carousel-item') ===
                    'active') {
                    defaultPosition = position;
                }
            });
        }
        var indicators = [];
        if ($carouselEl.querySelectorAll('[data-carousel-slide-to]').length) {
            Array.from($carouselEl.querySelectorAll('[data-carousel-slide-to]')).map(function ($indicatorEl) {
                indicators.push({
                    position: parseInt($indicatorEl.getAttribute('data-carousel-slide-to')),
                    el: $indicatorEl,
                });
            });
        }
        var carousel = new Carousel(items, {
            defaultPosition: defaultPosition,
            indicators: {
                items: indicators,
            },
            interval: interval ? interval : Default.interval,
        });
        if (slide) {
            carousel.cycle();
        }
        // check for controls
        var carouselNextEl = $carouselEl.querySelector('[data-carousel-next]');
        var carouselPrevEl = $carouselEl.querySelector('[data-carousel-prev]');
        if (carouselNextEl) {
            carouselNextEl.addEventListener('click', function () {
                carousel.next();
            });
        }
        if (carouselPrevEl) {
            carouselPrevEl.addEventListener('click', function () {
                carousel.prev();
            });
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Carousel);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/carousel/interface.js":
/*!************************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/carousel/interface.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/carousel/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/carousel/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/collapse/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/collapse/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initCollapses": () => (/* binding */ initCollapses)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    onCollapse: function () { },
    onExpand: function () { },
    onToggle: function () { },
};
var Collapse = /** @class */ (function () {
    function Collapse(targetEl, triggerEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (triggerEl === void 0) { triggerEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign(__assign({}, Default), options);
        this._visible = false;
        this._init();
    }
    Collapse.prototype._init = function () {
        var _this = this;
        if (this._triggerEl) {
            if (this._triggerEl.hasAttribute('aria-expanded')) {
                this._visible =
                    this._triggerEl.getAttribute('aria-expanded') === 'true';
            }
            else {
                // fix until v2 not to break previous single collapses which became dismiss
                this._visible = !this._targetEl.classList.contains('hidden');
            }
            this._triggerEl.addEventListener('click', function () {
                _this.toggle();
            });
        }
    };
    Collapse.prototype.collapse = function () {
        this._targetEl.classList.add('hidden');
        if (this._triggerEl) {
            this._triggerEl.setAttribute('aria-expanded', 'false');
        }
        this._visible = false;
        // callback function
        this._options.onCollapse(this);
    };
    Collapse.prototype.expand = function () {
        this._targetEl.classList.remove('hidden');
        if (this._triggerEl) {
            this._triggerEl.setAttribute('aria-expanded', 'true');
        }
        this._visible = true;
        // callback function
        this._options.onExpand(this);
    };
    Collapse.prototype.toggle = function () {
        if (this._visible) {
            this.collapse();
        }
        else {
            this.expand();
        }
        // callback function
        this._options.onToggle(this);
    };
    return Collapse;
}());
if (typeof window !== 'undefined') {
    window.Collapse = Collapse;
}
function initCollapses() {
    document
        .querySelectorAll('[data-collapse-toggle]')
        .forEach(function ($triggerEl) {
        var targetId = $triggerEl.getAttribute('data-collapse-toggle');
        var $targetEl = document.getElementById(targetId);
        // check if the target element exists
        if ($targetEl) {
            new Collapse($targetEl, $triggerEl);
        }
        else {
            console.error("The target element with id \"".concat(targetId, "\" does not exist. Please check the data-collapse-toggle attribute."));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Collapse);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/collapse/interface.js":
/*!************************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/collapse/interface.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/collapse/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/collapse/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dial/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dial/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initDials": () => (/* binding */ initDials)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    triggerType: 'hover',
    onShow: function () { },
    onHide: function () { },
    onToggle: function () { },
};
var Dial = /** @class */ (function () {
    function Dial(parentEl, triggerEl, targetEl, options) {
        if (parentEl === void 0) { parentEl = null; }
        if (triggerEl === void 0) { triggerEl = null; }
        if (targetEl === void 0) { targetEl = null; }
        if (options === void 0) { options = Default; }
        this._parentEl = parentEl;
        this._triggerEl = triggerEl;
        this._targetEl = targetEl;
        this._options = __assign(__assign({}, Default), options);
        this._visible = false;
        this._init();
    }
    Dial.prototype._init = function () {
        var _this = this;
        if (this._triggerEl) {
            var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
            triggerEventTypes.showEvents.forEach(function (ev) {
                _this._triggerEl.addEventListener(ev, function () {
                    _this.show();
                });
                _this._targetEl.addEventListener(ev, function () {
                    _this.show();
                });
            });
            triggerEventTypes.hideEvents.forEach(function (ev) {
                _this._parentEl.addEventListener(ev, function () {
                    if (!_this._parentEl.matches(':hover')) {
                        _this.hide();
                    }
                });
            });
        }
    };
    Dial.prototype.hide = function () {
        this._targetEl.classList.add('hidden');
        if (this._triggerEl) {
            this._triggerEl.setAttribute('aria-expanded', 'false');
        }
        this._visible = false;
        // callback function
        this._options.onHide(this);
    };
    Dial.prototype.show = function () {
        this._targetEl.classList.remove('hidden');
        if (this._triggerEl) {
            this._triggerEl.setAttribute('aria-expanded', 'true');
        }
        this._visible = true;
        // callback function
        this._options.onShow(this);
    };
    Dial.prototype.toggle = function () {
        if (this._visible) {
            this.hide();
        }
        else {
            this.show();
        }
    };
    Dial.prototype.isHidden = function () {
        return !this._visible;
    };
    Dial.prototype.isVisible = function () {
        return this._visible;
    };
    Dial.prototype._getTriggerEventTypes = function (triggerType) {
        switch (triggerType) {
            case 'hover':
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
            case 'click':
                return {
                    showEvents: ['click', 'focus'],
                    hideEvents: ['focusout', 'blur'],
                };
            case 'none':
                return {
                    showEvents: [],
                    hideEvents: [],
                };
            default:
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
        }
    };
    return Dial;
}());
if (typeof window !== 'undefined') {
    window.Dial = Dial;
}
function initDials() {
    document.querySelectorAll('[data-dial-init]').forEach(function ($parentEl) {
        var $triggerEl = $parentEl.querySelector('[data-dial-toggle]');
        if ($triggerEl) {
            var dialId = $triggerEl.getAttribute('data-dial-toggle');
            var $dialEl = document.getElementById(dialId);
            if ($dialEl) {
                var triggerType = $triggerEl.getAttribute('data-dial-trigger');
                new Dial($parentEl, $triggerEl, $dialEl, {
                    triggerType: triggerType
                        ? triggerType
                        : Default.triggerType,
                });
            }
            else {
                console.error("Dial with id ".concat(dialId, " does not exist. Are you sure that the data-dial-toggle attribute points to the correct modal id?"));
            }
        }
        else {
            console.error("Dial with id ".concat($parentEl.id, " does not have a trigger element. Are you sure that the data-dial-toggle attribute exists?"));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dial);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dial/interface.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dial/interface.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dial/types.js":
/*!****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dial/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dismiss/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dismiss/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initDismisses": () => (/* binding */ initDismisses)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    transition: 'transition-opacity',
    duration: 300,
    timing: 'ease-out',
    onHide: function () { },
};
var Dismiss = /** @class */ (function () {
    function Dismiss(targetEl, triggerEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (triggerEl === void 0) { triggerEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign(__assign({}, Default), options);
        this._init();
    }
    Dismiss.prototype._init = function () {
        var _this = this;
        if (this._triggerEl) {
            this._triggerEl.addEventListener('click', function () {
                _this.hide();
            });
        }
    };
    Dismiss.prototype.hide = function () {
        var _this = this;
        this._targetEl.classList.add(this._options.transition, "duration-".concat(this._options.duration), this._options.timing, 'opacity-0');
        setTimeout(function () {
            _this._targetEl.classList.add('hidden');
        }, this._options.duration);
        // callback function
        this._options.onHide(this, this._targetEl);
    };
    return Dismiss;
}());
if (typeof window !== 'undefined') {
    window.Dismiss = Dismiss;
}
function initDismisses() {
    document.querySelectorAll('[data-dismiss-target]').forEach(function ($triggerEl) {
        var targetId = $triggerEl.getAttribute('data-dismiss-target');
        var $dismissEl = document.querySelector(targetId);
        if ($dismissEl) {
            new Dismiss($dismissEl, $triggerEl);
        }
        else {
            console.error("The dismiss element with id \"".concat(targetId, "\" does not exist. Please check the data-dismiss-target attribute."));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dismiss);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dismiss/interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dismiss/interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dismiss/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dismiss/types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/drawer/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/drawer/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initDrawers": () => (/* binding */ initDrawers)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    placement: 'left',
    bodyScrolling: false,
    backdrop: true,
    edge: false,
    edgeOffset: 'bottom-[60px]',
    backdropClasses: 'bg-gray-900 bg-opacity-50 dark:bg-opacity-80 fixed inset-0 z-30',
    onShow: function () { },
    onHide: function () { },
    onToggle: function () { },
};
var Drawer = /** @class */ (function () {
    function Drawer(targetEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._options = __assign(__assign({}, Default), options);
        this._visible = false;
        this._init();
    }
    Drawer.prototype._init = function () {
        var _this = this;
        // set initial accessibility attributes
        if (this._targetEl) {
            this._targetEl.setAttribute('aria-hidden', 'true');
            this._targetEl.classList.add('transition-transform');
        }
        // set base placement classes
        this._getPlacementClasses(this._options.placement).base.map(function (c) {
            _this._targetEl.classList.add(c);
        });
        // add keyboard event listener to document
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                // if 'Escape' key is pressed
                if (_this.isVisible()) {
                    // if the Drawer is visible
                    _this.hide(); // hide the Drawer
                }
            }
        });
    };
    Drawer.prototype.hide = function () {
        var _this = this;
        // based on the edge option show placement classes
        if (this._options.edge) {
            this._getPlacementClasses(this._options.placement + '-edge').active.map(function (c) {
                _this._targetEl.classList.remove(c);
            });
            this._getPlacementClasses(this._options.placement + '-edge').inactive.map(function (c) {
                _this._targetEl.classList.add(c);
            });
        }
        else {
            this._getPlacementClasses(this._options.placement).active.map(function (c) {
                _this._targetEl.classList.remove(c);
            });
            this._getPlacementClasses(this._options.placement).inactive.map(function (c) {
                _this._targetEl.classList.add(c);
            });
        }
        // set accessibility attributes
        this._targetEl.setAttribute('aria-hidden', 'true');
        this._targetEl.removeAttribute('aria-modal');
        this._targetEl.removeAttribute('role');
        // enable body scroll
        if (!this._options.bodyScrolling) {
            document.body.classList.remove('overflow-hidden');
        }
        // destroy backdrop
        if (this._options.backdrop) {
            this._destroyBackdropEl();
        }
        this._visible = false;
        // callback function
        this._options.onHide(this);
    };
    Drawer.prototype.show = function () {
        var _this = this;
        if (this._options.edge) {
            this._getPlacementClasses(this._options.placement + '-edge').active.map(function (c) {
                _this._targetEl.classList.add(c);
            });
            this._getPlacementClasses(this._options.placement + '-edge').inactive.map(function (c) {
                _this._targetEl.classList.remove(c);
            });
        }
        else {
            this._getPlacementClasses(this._options.placement).active.map(function (c) {
                _this._targetEl.classList.add(c);
            });
            this._getPlacementClasses(this._options.placement).inactive.map(function (c) {
                _this._targetEl.classList.remove(c);
            });
        }
        // set accessibility attributes
        this._targetEl.setAttribute('aria-modal', 'true');
        this._targetEl.setAttribute('role', 'dialog');
        this._targetEl.removeAttribute('aria-hidden');
        // disable body scroll
        if (!this._options.bodyScrolling) {
            document.body.classList.add('overflow-hidden');
        }
        // show backdrop
        if (this._options.backdrop) {
            this._createBackdrop();
        }
        this._visible = true;
        // callback function
        this._options.onShow(this);
    };
    Drawer.prototype.toggle = function () {
        if (this.isVisible()) {
            this.hide();
        }
        else {
            this.show();
        }
    };
    Drawer.prototype._createBackdrop = function () {
        var _a;
        var _this = this;
        if (!this._visible) {
            var backdropEl = document.createElement('div');
            backdropEl.setAttribute('drawer-backdrop', '');
            (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(' '));
            document.querySelector('body').append(backdropEl);
            backdropEl.addEventListener('click', function () {
                _this.hide();
            });
        }
    };
    Drawer.prototype._destroyBackdropEl = function () {
        if (this._visible) {
            document.querySelector('[drawer-backdrop]').remove();
        }
    };
    Drawer.prototype._getPlacementClasses = function (placement) {
        switch (placement) {
            case 'top':
                return {
                    base: ['top-0', 'left-0', 'right-0'],
                    active: ['transform-none'],
                    inactive: ['-translate-y-full'],
                };
            case 'right':
                return {
                    base: ['right-0', 'top-0'],
                    active: ['transform-none'],
                    inactive: ['translate-x-full'],
                };
            case 'bottom':
                return {
                    base: ['bottom-0', 'left-0', 'right-0'],
                    active: ['transform-none'],
                    inactive: ['translate-y-full'],
                };
            case 'left':
                return {
                    base: ['left-0', 'top-0'],
                    active: ['transform-none'],
                    inactive: ['-translate-x-full'],
                };
            case 'bottom-edge':
                return {
                    base: ['left-0', 'top-0'],
                    active: ['transform-none'],
                    inactive: ['translate-y-full', this._options.edgeOffset],
                };
            default:
                return {
                    base: ['left-0', 'top-0'],
                    active: ['transform-none'],
                    inactive: ['-translate-x-full'],
                };
        }
    };
    Drawer.prototype.isHidden = function () {
        return !this._visible;
    };
    Drawer.prototype.isVisible = function () {
        return this._visible;
    };
    return Drawer;
}());
if (typeof window !== 'undefined') {
    window.Drawer = Drawer;
}
var getDrawerInstance = function (id, instances) {
    if (instances.some(function (drawerInstance) { return drawerInstance.id === id; })) {
        return instances.find(function (drawerInstance) { return drawerInstance.id === id; });
    }
};
function initDrawers() {
    var drawerInstances = [];
    document.querySelectorAll('[data-drawer-target]').forEach(function ($triggerEl) {
        // mandatory
        var drawerId = $triggerEl.getAttribute('data-drawer-target');
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
            // optional
            var placement = $triggerEl.getAttribute('data-drawer-placement');
            var bodyScrolling = $triggerEl.getAttribute('data-drawer-body-scrolling');
            var backdrop = $triggerEl.getAttribute('data-drawer-backdrop');
            var edge = $triggerEl.getAttribute('data-drawer-edge');
            var edgeOffset = $triggerEl.getAttribute('data-drawer-edge-offset');
            if (!getDrawerInstance(drawerId, drawerInstances)) {
                drawerInstances.push({
                    id: drawerId,
                    object: new Drawer($drawerEl, {
                        placement: placement ? placement : Default.placement,
                        bodyScrolling: bodyScrolling
                            ? bodyScrolling === 'true'
                                ? true
                                : false
                            : Default.bodyScrolling,
                        backdrop: backdrop
                            ? backdrop === 'true'
                                ? true
                                : false
                            : Default.backdrop,
                        edge: edge
                            ? edge === 'true'
                                ? true
                                : false
                            : Default.edge,
                        edgeOffset: edgeOffset
                            ? edgeOffset
                            : Default.edgeOffset,
                    }),
                });
            }
        }
        else {
            console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
        }
    });
    document.querySelectorAll('[data-drawer-toggle]').forEach(function ($triggerEl) {
        var drawerId = $triggerEl.getAttribute('data-drawer-toggle');
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
            var drawer_1 = getDrawerInstance(drawerId, drawerInstances);
            if (drawer_1) {
                $triggerEl.addEventListener('click', function () {
                    drawer_1.object.toggle();
                });
            }
            else {
                console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
            }
        }
        else {
            console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
        }
    });
    document
        .querySelectorAll('[data-drawer-dismiss], [data-drawer-hide]')
        .forEach(function ($triggerEl) {
        var drawerId = $triggerEl.getAttribute('data-drawer-dismiss')
            ? $triggerEl.getAttribute('data-drawer-dismiss')
            : $triggerEl.getAttribute('data-drawer-hide');
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
            var drawer_2 = getDrawerInstance(drawerId, drawerInstances);
            if (drawer_2) {
                $triggerEl.addEventListener('click', function () {
                    drawer_2.object.hide();
                });
            }
            else {
                console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
            }
        }
        else {
            console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id"));
        }
    });
    document.querySelectorAll('[data-drawer-show]').forEach(function ($triggerEl) {
        var drawerId = $triggerEl.getAttribute('data-drawer-show');
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
            var drawer_3 = getDrawerInstance(drawerId, drawerInstances);
            if (drawer_3) {
                $triggerEl.addEventListener('click', function () {
                    drawer_3.object.show();
                });
            }
            else {
                console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
            }
        }
        else {
            console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Drawer);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/drawer/interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/drawer/interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/drawer/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/drawer/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dropdown/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dropdown/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initDropdowns": () => (/* binding */ initDropdowns)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/* eslint-disable @typescript-eslint/no-empty-function */

var Default = {
    placement: 'bottom',
    triggerType: 'click',
    offsetSkidding: 0,
    offsetDistance: 10,
    delay: 300,
    onShow: function () { },
    onHide: function () { },
    onToggle: function () { },
};
var Dropdown = /** @class */ (function () {
    function Dropdown(targetElement, triggerElement, options) {
        if (targetElement === void 0) { targetElement = null; }
        if (triggerElement === void 0) { triggerElement = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetElement;
        this._triggerEl = triggerElement;
        this._options = __assign(__assign({}, Default), options);
        this._popperInstance = this._createPopperInstance();
        this._visible = false;
        this._init();
    }
    Dropdown.prototype._init = function () {
        if (this._triggerEl) {
            this._setupEventListeners();
        }
    };
    Dropdown.prototype._setupEventListeners = function () {
        var _this = this;
        var triggerEvents = this._getTriggerEvents();
        // click event handling for trigger element
        if (this._options.triggerType === 'click') {
            triggerEvents.showEvents.forEach(function (ev) {
                _this._triggerEl.addEventListener(ev, function () {
                    _this.toggle();
                });
            });
        }
        // hover event handling for trigger element
        if (this._options.triggerType === 'hover') {
            triggerEvents.showEvents.forEach(function (ev) {
                _this._triggerEl.addEventListener(ev, function () {
                    if (ev === 'click') {
                        _this.toggle();
                    }
                    else {
                        setTimeout(function () {
                            _this.show();
                        }, _this._options.delay);
                    }
                });
                _this._targetEl.addEventListener(ev, function () {
                    _this.show();
                });
            });
            triggerEvents.hideEvents.forEach(function (ev) {
                _this._triggerEl.addEventListener(ev, function () {
                    setTimeout(function () {
                        if (!_this._targetEl.matches(':hover')) {
                            _this.hide();
                        }
                    }, _this._options.delay);
                });
                _this._targetEl.addEventListener(ev, function () {
                    setTimeout(function () {
                        if (!_this._triggerEl.matches(':hover')) {
                            _this.hide();
                        }
                    }, _this._options.delay);
                });
            });
        }
    };
    Dropdown.prototype._createPopperInstance = function () {
        return (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(this._triggerEl, this._targetEl, {
            placement: this._options.placement,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [
                            this._options.offsetSkidding,
                            this._options.offsetDistance,
                        ],
                    },
                },
            ],
        });
    };
    Dropdown.prototype._setupClickOutsideListener = function () {
        var _this = this;
        this._clickOutsideEventListener = function (ev) {
            _this._handleClickOutside(ev, _this._targetEl);
        };
        document.body.addEventListener('click', this._clickOutsideEventListener, true);
    };
    Dropdown.prototype._removeClickOutsideListener = function () {
        document.body.removeEventListener('click', this._clickOutsideEventListener, true);
    };
    Dropdown.prototype._handleClickOutside = function (ev, targetEl) {
        var clickedEl = ev.target;
        if (clickedEl !== targetEl &&
            !targetEl.contains(clickedEl) &&
            !this._triggerEl.contains(clickedEl) &&
            this.isVisible()) {
            this.hide();
        }
    };
    Dropdown.prototype._getTriggerEvents = function () {
        switch (this._options.triggerType) {
            case 'hover':
                return {
                    showEvents: ['mouseenter', 'click'],
                    hideEvents: ['mouseleave'],
                };
            case 'click':
                return {
                    showEvents: ['click'],
                    hideEvents: [],
                };
            case 'none':
                return {
                    showEvents: [],
                    hideEvents: [],
                };
            default:
                return {
                    showEvents: ['click'],
                    hideEvents: [],
                };
        }
    };
    Dropdown.prototype.toggle = function () {
        if (this.isVisible()) {
            this.hide();
        }
        else {
            this.show();
        }
        this._options.onToggle(this);
    };
    Dropdown.prototype.isVisible = function () {
        return this._visible;
    };
    Dropdown.prototype.show = function () {
        this._targetEl.classList.remove('hidden');
        this._targetEl.classList.add('block');
        // Enable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: true },
            ], false) })); });
        this._setupClickOutsideListener();
        // Update its position
        this._popperInstance.update();
        this._visible = true;
        // callback function
        this._options.onShow(this);
    };
    Dropdown.prototype.hide = function () {
        this._targetEl.classList.remove('block');
        this._targetEl.classList.add('hidden');
        // Disable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: false },
            ], false) })); });
        this._visible = false;
        this._removeClickOutsideListener();
        // callback function
        this._options.onHide(this);
    };
    return Dropdown;
}());
if (typeof window !== 'undefined') {
    window.Dropdown = Dropdown;
}
function initDropdowns() {
    document
        .querySelectorAll('[data-dropdown-toggle]')
        .forEach(function ($triggerEl) {
        var dropdownId = $triggerEl.getAttribute('data-dropdown-toggle');
        var $dropdownEl = document.getElementById(dropdownId);
        if ($dropdownEl) {
            var placement = $triggerEl.getAttribute('data-dropdown-placement');
            var offsetSkidding = $triggerEl.getAttribute('data-dropdown-offset-skidding');
            var offsetDistance = $triggerEl.getAttribute('data-dropdown-offset-distance');
            var triggerType = $triggerEl.getAttribute('data-dropdown-trigger');
            var delay = $triggerEl.getAttribute('data-dropdown-delay');
            new Dropdown($dropdownEl, $triggerEl, {
                placement: placement ? placement : Default.placement,
                triggerType: triggerType
                    ? triggerType
                    : Default.triggerType,
                offsetSkidding: offsetSkidding
                    ? parseInt(offsetSkidding)
                    : Default.offsetSkidding,
                offsetDistance: offsetDistance
                    ? parseInt(offsetDistance)
                    : Default.offsetDistance,
                delay: delay ? parseInt(delay) : Default.delay,
            });
        }
        else {
            console.error("The dropdown element with id \"".concat(dropdownId, "\" does not exist. Please check the data-dropdown-toggle attribute."));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dropdown);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dropdown/interface.js":
/*!************************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dropdown/interface.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/dropdown/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/dropdown/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initFlowbite": () => (/* binding */ initFlowbite)
/* harmony export */ });
/* harmony import */ var _accordion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accordion */ "./node_modules/flowbite/lib/esm/components/accordion/index.js");
/* harmony import */ var _carousel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./carousel */ "./node_modules/flowbite/lib/esm/components/carousel/index.js");
/* harmony import */ var _collapse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collapse */ "./node_modules/flowbite/lib/esm/components/collapse/index.js");
/* harmony import */ var _dial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dial */ "./node_modules/flowbite/lib/esm/components/dial/index.js");
/* harmony import */ var _dismiss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dismiss */ "./node_modules/flowbite/lib/esm/components/dismiss/index.js");
/* harmony import */ var _drawer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./drawer */ "./node_modules/flowbite/lib/esm/components/drawer/index.js");
/* harmony import */ var _dropdown__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dropdown */ "./node_modules/flowbite/lib/esm/components/dropdown/index.js");
/* harmony import */ var _modal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modal */ "./node_modules/flowbite/lib/esm/components/modal/index.js");
/* harmony import */ var _popover__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./popover */ "./node_modules/flowbite/lib/esm/components/popover/index.js");
/* harmony import */ var _tabs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tabs */ "./node_modules/flowbite/lib/esm/components/tabs/index.js");
/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tooltip */ "./node_modules/flowbite/lib/esm/components/tooltip/index.js");











function initFlowbite() {
    (0,_accordion__WEBPACK_IMPORTED_MODULE_0__.initAccordions)();
    (0,_collapse__WEBPACK_IMPORTED_MODULE_2__.initCollapses)();
    (0,_carousel__WEBPACK_IMPORTED_MODULE_1__.initCarousels)();
    (0,_dismiss__WEBPACK_IMPORTED_MODULE_4__.initDismisses)();
    (0,_dropdown__WEBPACK_IMPORTED_MODULE_6__.initDropdowns)();
    (0,_modal__WEBPACK_IMPORTED_MODULE_7__.initModals)();
    (0,_drawer__WEBPACK_IMPORTED_MODULE_5__.initDrawers)();
    (0,_tabs__WEBPACK_IMPORTED_MODULE_9__.initTabs)();
    (0,_tooltip__WEBPACK_IMPORTED_MODULE_10__.initTooltips)();
    (0,_popover__WEBPACK_IMPORTED_MODULE_8__.initPopovers)();
    (0,_dial__WEBPACK_IMPORTED_MODULE_3__.initDials)();
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/modal/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/modal/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initModals": () => (/* binding */ initModals)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    placement: 'center',
    backdropClasses: 'bg-gray-900 bg-opacity-50 dark:bg-opacity-80 fixed inset-0 z-40',
    backdrop: 'dynamic',
    closable: true,
    onHide: function () { },
    onShow: function () { },
    onToggle: function () { },
};
var Modal = /** @class */ (function () {
    function Modal(targetEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._options = __assign(__assign({}, Default), options);
        this._isHidden = true;
        this._backdropEl = null;
        this._init();
    }
    Modal.prototype._init = function () {
        var _this = this;
        if (this._targetEl) {
            this._getPlacementClasses().map(function (c) {
                _this._targetEl.classList.add(c);
            });
        }
    };
    Modal.prototype._createBackdrop = function () {
        var _a;
        if (this._isHidden) {
            var backdropEl = document.createElement('div');
            backdropEl.setAttribute('modal-backdrop', '');
            (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(' '));
            document.querySelector('body').append(backdropEl);
            this._backdropEl = backdropEl;
        }
    };
    Modal.prototype._destroyBackdropEl = function () {
        if (!this._isHidden) {
            document.querySelector('[modal-backdrop]').remove();
        }
    };
    Modal.prototype._setupModalCloseEventListeners = function () {
        var _this = this;
        if (this._options.backdrop === 'dynamic') {
            this._clickOutsideEventListener = function (ev) {
                _this._handleOutsideClick(ev.target);
            };
            this._targetEl.addEventListener('click', this._clickOutsideEventListener, true);
        }
        this._keydownEventListener = function (ev) {
            if (ev.key === 'Escape') {
                _this.hide();
            }
        };
        document.body.addEventListener('keydown', this._keydownEventListener, true);
    };
    Modal.prototype._removeModalCloseEventListeners = function () {
        if (this._options.backdrop === 'dynamic') {
            this._targetEl.removeEventListener('click', this._clickOutsideEventListener, true);
        }
        document.body.removeEventListener('keydown', this._keydownEventListener, true);
    };
    Modal.prototype._handleOutsideClick = function (target) {
        if (target === this._targetEl ||
            (target === this._backdropEl && this.isVisible())) {
            this.hide();
        }
    };
    Modal.prototype._getPlacementClasses = function () {
        switch (this._options.placement) {
            // top
            case 'top-left':
                return ['justify-start', 'items-start'];
            case 'top-center':
                return ['justify-center', 'items-start'];
            case 'top-right':
                return ['justify-end', 'items-start'];
            // center
            case 'center-left':
                return ['justify-start', 'items-center'];
            case 'center':
                return ['justify-center', 'items-center'];
            case 'center-right':
                return ['justify-end', 'items-center'];
            // bottom
            case 'bottom-left':
                return ['justify-start', 'items-end'];
            case 'bottom-center':
                return ['justify-center', 'items-end'];
            case 'bottom-right':
                return ['justify-end', 'items-end'];
            default:
                return ['justify-center', 'items-center'];
        }
    };
    Modal.prototype.toggle = function () {
        if (this._isHidden) {
            this.show();
        }
        else {
            this.hide();
        }
        // callback function
        this._options.onToggle(this);
    };
    Modal.prototype.show = function () {
        if (this.isHidden) {
            this._targetEl.classList.add('flex');
            this._targetEl.classList.remove('hidden');
            this._targetEl.setAttribute('aria-modal', 'true');
            this._targetEl.setAttribute('role', 'dialog');
            this._targetEl.removeAttribute('aria-hidden');
            this._createBackdrop();
            this._isHidden = false;
            // prevent body scroll
            document.body.classList.add('overflow-hidden');
            // Add keyboard event listener to the document
            if (this._options.closable) {
                this._setupModalCloseEventListeners();
            }
            // callback function
            this._options.onShow(this);
        }
    };
    Modal.prototype.hide = function () {
        if (this.isVisible) {
            this._targetEl.classList.add('hidden');
            this._targetEl.classList.remove('flex');
            this._targetEl.setAttribute('aria-hidden', 'true');
            this._targetEl.removeAttribute('aria-modal');
            this._targetEl.removeAttribute('role');
            this._destroyBackdropEl();
            this._isHidden = true;
            // re-apply body scroll
            document.body.classList.remove('overflow-hidden');
            if (this._options.closable) {
                this._removeModalCloseEventListeners();
            }
            // callback function
            this._options.onHide(this);
        }
    };
    Modal.prototype.isVisible = function () {
        return !this._isHidden;
    };
    Modal.prototype.isHidden = function () {
        return this._isHidden;
    };
    return Modal;
}());
if (typeof window !== 'undefined') {
    window.Modal = Modal;
}
var getModalInstance = function (id, instances) {
    if (instances.some(function (modalInstance) { return modalInstance.id === id; })) {
        return instances.find(function (modalInstance) { return modalInstance.id === id; });
    }
    return null;
};
function initModals() {
    var modalInstances = [];
    // initiate modal based on data-modal-target
    document.querySelectorAll('[data-modal-target]').forEach(function ($triggerEl) {
        var modalId = $triggerEl.getAttribute('data-modal-target');
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
            var placement = $modalEl.getAttribute('data-modal-placement');
            var backdrop = $modalEl.getAttribute('data-modal-backdrop');
            if (!getModalInstance(modalId, modalInstances)) {
                modalInstances.push({
                    id: modalId,
                    object: new Modal($modalEl, {
                        placement: placement
                            ? placement
                            : Default.placement,
                        backdrop: backdrop ? backdrop : Default.backdrop,
                    }),
                });
            }
        }
        else {
            console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-target attribute points to the correct modal id?."));
        }
    });
    // support pre v1.6.0 data-modal-toggle initialization
    document.querySelectorAll('[data-modal-toggle]').forEach(function ($triggerEl) {
        var modalId = $triggerEl.getAttribute('data-modal-toggle');
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
            var placement = $modalEl.getAttribute('data-modal-placement');
            var backdrop = $modalEl.getAttribute('data-modal-backdrop');
            var modal_1 = getModalInstance(modalId, modalInstances);
            if (!modal_1) {
                modal_1 = {
                    id: modalId,
                    object: new Modal($modalEl, {
                        placement: placement
                            ? placement
                            : Default.placement,
                        backdrop: backdrop ? backdrop : Default.backdrop,
                    }),
                };
                modalInstances.push(modal_1);
            }
            $triggerEl.addEventListener('click', function () {
                modal_1.object.toggle();
            });
        }
        else {
            console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-toggle attribute points to the correct modal id?"));
        }
    });
    // show modal on click if exists based on id
    document.querySelectorAll('[data-modal-show]').forEach(function ($triggerEl) {
        var modalId = $triggerEl.getAttribute('data-modal-show');
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
            var modal_2 = getModalInstance(modalId, modalInstances);
            if (modal_2) {
                $triggerEl.addEventListener('click', function () {
                    if (modal_2.object.isHidden) {
                        modal_2.object.show();
                    }
                });
            }
            else {
                console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
            }
        }
        else {
            console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-show attribute points to the correct modal id?"));
        }
    });
    // hide modal on click if exists based on id
    document.querySelectorAll('[data-modal-hide]').forEach(function ($triggerEl) {
        var modalId = $triggerEl.getAttribute('data-modal-hide');
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
            var modal_3 = getModalInstance(modalId, modalInstances);
            if (modal_3) {
                $triggerEl.addEventListener('click', function () {
                    if (modal_3.object.isVisible) {
                        modal_3.object.hide();
                    }
                });
            }
            else {
                console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
            }
        }
        else {
            console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-hide attribute points to the correct modal id?"));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Modal);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/modal/interface.js":
/*!*********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/modal/interface.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/modal/types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/modal/types.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/popover/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/popover/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initPopovers": () => (/* binding */ initPopovers)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/* eslint-disable @typescript-eslint/no-empty-function */

var Default = {
    placement: 'top',
    offset: 10,
    triggerType: 'hover',
    onShow: function () { },
    onHide: function () { },
    onToggle: function () { },
};
var Popover = /** @class */ (function () {
    function Popover(targetEl, triggerEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (triggerEl === void 0) { triggerEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign(__assign({}, Default), options);
        this._popperInstance = this._createPopperInstance();
        this._visible = false;
        this._init();
    }
    Popover.prototype._init = function () {
        if (this._triggerEl) {
            this._setupEventListeners();
        }
    };
    Popover.prototype._setupEventListeners = function () {
        var _this = this;
        var triggerEvents = this._getTriggerEvents();
        triggerEvents.showEvents.forEach(function (ev) {
            _this._triggerEl.addEventListener(ev, function () {
                _this.show();
            });
            _this._targetEl.addEventListener(ev, function () {
                _this.show();
            });
        });
        triggerEvents.hideEvents.forEach(function (ev) {
            _this._triggerEl.addEventListener(ev, function () {
                setTimeout(function () {
                    if (!_this._targetEl.matches(':hover')) {
                        _this.hide();
                    }
                }, 100);
            });
            _this._targetEl.addEventListener(ev, function () {
                setTimeout(function () {
                    if (!_this._triggerEl.matches(':hover')) {
                        _this.hide();
                    }
                }, 100);
            });
        });
    };
    Popover.prototype._createPopperInstance = function () {
        return (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(this._triggerEl, this._targetEl, {
            placement: this._options.placement,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, this._options.offset],
                    },
                },
            ],
        });
    };
    Popover.prototype._getTriggerEvents = function () {
        switch (this._options.triggerType) {
            case 'hover':
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
            case 'click':
                return {
                    showEvents: ['click', 'focus'],
                    hideEvents: ['focusout', 'blur'],
                };
            case 'none':
                return {
                    showEvents: [],
                    hideEvents: [],
                };
            default:
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
        }
    };
    Popover.prototype._setupKeydownListener = function () {
        var _this = this;
        this._keydownEventListener = function (ev) {
            if (ev.key === 'Escape') {
                _this.hide();
            }
        };
        document.body.addEventListener('keydown', this._keydownEventListener, true);
    };
    Popover.prototype._removeKeydownListener = function () {
        document.body.removeEventListener('keydown', this._keydownEventListener, true);
    };
    Popover.prototype._setupClickOutsideListener = function () {
        var _this = this;
        this._clickOutsideEventListener = function (ev) {
            _this._handleClickOutside(ev, _this._targetEl);
        };
        document.body.addEventListener('click', this._clickOutsideEventListener, true);
    };
    Popover.prototype._removeClickOutsideListener = function () {
        document.body.removeEventListener('click', this._clickOutsideEventListener, true);
    };
    Popover.prototype._handleClickOutside = function (ev, targetEl) {
        var clickedEl = ev.target;
        if (clickedEl !== targetEl &&
            !targetEl.contains(clickedEl) &&
            !this._triggerEl.contains(clickedEl) &&
            this.isVisible()) {
            this.hide();
        }
    };
    Popover.prototype.isVisible = function () {
        return this._visible;
    };
    Popover.prototype.toggle = function () {
        if (this.isVisible()) {
            this.hide();
        }
        else {
            this.show();
        }
        this._options.onToggle(this);
    };
    Popover.prototype.show = function () {
        this._targetEl.classList.remove('opacity-0', 'invisible');
        this._targetEl.classList.add('opacity-100', 'visible');
        // Enable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: true },
            ], false) })); });
        // handle click outside
        this._setupClickOutsideListener();
        // handle esc keydown
        this._setupKeydownListener();
        // Update its position
        this._popperInstance.update();
        // set visibility to true
        this._visible = true;
        // callback function
        this._options.onShow(this);
    };
    Popover.prototype.hide = function () {
        this._targetEl.classList.remove('opacity-100', 'visible');
        this._targetEl.classList.add('opacity-0', 'invisible');
        // Disable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: false },
            ], false) })); });
        // handle click outside
        this._removeClickOutsideListener();
        // handle esc keydown
        this._removeKeydownListener();
        // set visibility to false
        this._visible = false;
        // callback function
        this._options.onHide(this);
    };
    return Popover;
}());
if (typeof window !== 'undefined') {
    window.Popover = Popover;
}
function initPopovers() {
    document.querySelectorAll('[data-popover-target]').forEach(function ($triggerEl) {
        var popoverID = $triggerEl.getAttribute('data-popover-target');
        var $popoverEl = document.getElementById(popoverID);
        if ($popoverEl) {
            var triggerType = $triggerEl.getAttribute('data-popover-trigger');
            var placement = $triggerEl.getAttribute('data-popover-placement');
            var offset = $triggerEl.getAttribute('data-popover-offset');
            new Popover($popoverEl, $triggerEl, {
                placement: placement ? placement : Default.placement,
                offset: offset ? parseInt(offset) : Default.offset,
                triggerType: triggerType
                    ? triggerType
                    : Default.triggerType,
            });
        }
        else {
            console.error("The popover element with id \"".concat(popoverID, "\" does not exist. Please check the data-popover-target attribute."));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Popover);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/popover/interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/popover/interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/popover/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/popover/types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tabs/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tabs/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initTabs": () => (/* binding */ initTabs)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Default = {
    defaultTabId: null,
    activeClasses: 'text-blue-600 hover:text-blue-600 dark:text-blue-500 dark:hover:text-blue-500 border-blue-600 dark:border-blue-500',
    inactiveClasses: 'dark:border-transparent text-gray-500 hover:text-gray-600 dark:text-gray-400 border-gray-100 hover:border-gray-300 dark:border-gray-700 dark:hover:text-gray-300',
    onShow: function () { },
};
var Tabs = /** @class */ (function () {
    function Tabs(items, options) {
        if (items === void 0) { items = []; }
        if (options === void 0) { options = Default; }
        this._items = items;
        this._activeTab = options ? this.getTab(options.defaultTabId) : null;
        this._options = __assign(__assign({}, Default), options);
        this._init();
    }
    Tabs.prototype._init = function () {
        var _this = this;
        if (this._items.length) {
            // set the first tab as active if not set by explicitly
            if (!this._activeTab) {
                this._setActiveTab(this._items[0]);
            }
            // force show the first default tab
            this.show(this._activeTab.id, true);
            // show tab content based on click
            this._items.map(function (tab) {
                tab.triggerEl.addEventListener('click', function () {
                    _this.show(tab.id);
                });
            });
        }
    };
    Tabs.prototype.getActiveTab = function () {
        return this._activeTab;
    };
    Tabs.prototype._setActiveTab = function (tab) {
        this._activeTab = tab;
    };
    Tabs.prototype.getTab = function (id) {
        return this._items.filter(function (t) { return t.id === id; })[0];
    };
    Tabs.prototype.show = function (id, forceShow) {
        var _a, _b;
        var _this = this;
        if (forceShow === void 0) { forceShow = false; }
        var tab = this.getTab(id);
        // don't do anything if already active
        if (tab === this._activeTab && !forceShow) {
            return;
        }
        // hide other tabs
        this._items.map(function (t) {
            var _a, _b;
            if (t !== tab) {
                (_a = t.triggerEl.classList).remove.apply(_a, _this._options.activeClasses.split(' '));
                (_b = t.triggerEl.classList).add.apply(_b, _this._options.inactiveClasses.split(' '));
                t.targetEl.classList.add('hidden');
                t.triggerEl.setAttribute('aria-selected', 'false');
            }
        });
        // show active tab
        (_a = tab.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(' '));
        (_b = tab.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(' '));
        tab.triggerEl.setAttribute('aria-selected', 'true');
        tab.targetEl.classList.remove('hidden');
        this._setActiveTab(tab);
        // callback function
        this._options.onShow(this, tab);
    };
    return Tabs;
}());
if (typeof window !== 'undefined') {
    window.Tabs = Tabs;
}
function initTabs() {
    document.querySelectorAll('[data-tabs-toggle]').forEach(function ($triggerEl) {
        var tabItems = [];
        var defaultTabId = null;
        $triggerEl
            .querySelectorAll('[role="tab"]')
            .forEach(function ($triggerEl) {
            var isActive = $triggerEl.getAttribute('aria-selected') === 'true';
            var tab = {
                id: $triggerEl.getAttribute('data-tabs-target'),
                triggerEl: $triggerEl,
                targetEl: document.querySelector($triggerEl.getAttribute('data-tabs-target')),
            };
            tabItems.push(tab);
            if (isActive) {
                defaultTabId = tab.id;
            }
        });
        new Tabs(tabItems, {
            defaultTabId: defaultTabId,
        });
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tabs);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tabs/interface.js":
/*!********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tabs/interface.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tabs/types.js":
/*!****************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tabs/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tooltip/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tooltip/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initTooltips": () => (/* binding */ initTooltips)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/* eslint-disable @typescript-eslint/no-empty-function */

var Default = {
    placement: 'top',
    triggerType: 'hover',
    onShow: function () { },
    onHide: function () { },
    onToggle: function () { },
};
var Tooltip = /** @class */ (function () {
    function Tooltip(targetEl, triggerEl, options) {
        if (targetEl === void 0) { targetEl = null; }
        if (triggerEl === void 0) { triggerEl = null; }
        if (options === void 0) { options = Default; }
        this._targetEl = targetEl;
        this._triggerEl = triggerEl;
        this._options = __assign(__assign({}, Default), options);
        this._popperInstance = this._createPopperInstance();
        this._visible = false;
        this._init();
    }
    Tooltip.prototype._init = function () {
        if (this._triggerEl) {
            this._setupEventListeners();
        }
    };
    Tooltip.prototype._setupEventListeners = function () {
        var _this = this;
        var triggerEvents = this._getTriggerEvents();
        triggerEvents.showEvents.forEach(function (ev) {
            _this._triggerEl.addEventListener(ev, function () {
                _this.show();
            });
        });
        triggerEvents.hideEvents.forEach(function (ev) {
            _this._triggerEl.addEventListener(ev, function () {
                _this.hide();
            });
        });
    };
    Tooltip.prototype._createPopperInstance = function () {
        return (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(this._triggerEl, this._targetEl, {
            placement: this._options.placement,
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, 8],
                    },
                },
            ],
        });
    };
    Tooltip.prototype._getTriggerEvents = function () {
        switch (this._options.triggerType) {
            case 'hover':
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
            case 'click':
                return {
                    showEvents: ['click', 'focus'],
                    hideEvents: ['focusout', 'blur'],
                };
            case 'none':
                return {
                    showEvents: [],
                    hideEvents: [],
                };
            default:
                return {
                    showEvents: ['mouseenter', 'focus'],
                    hideEvents: ['mouseleave', 'blur'],
                };
        }
    };
    Tooltip.prototype._setupKeydownListener = function () {
        var _this = this;
        this._keydownEventListener = function (ev) {
            if (ev.key === 'Escape') {
                _this.hide();
            }
        };
        document.body.addEventListener('keydown', this._keydownEventListener, true);
    };
    Tooltip.prototype._removeKeydownListener = function () {
        document.body.removeEventListener('keydown', this._keydownEventListener, true);
    };
    Tooltip.prototype._setupClickOutsideListener = function () {
        var _this = this;
        this._clickOutsideEventListener = function (ev) {
            _this._handleClickOutside(ev, _this._targetEl);
        };
        document.body.addEventListener('click', this._clickOutsideEventListener, true);
    };
    Tooltip.prototype._removeClickOutsideListener = function () {
        document.body.removeEventListener('click', this._clickOutsideEventListener, true);
    };
    Tooltip.prototype._handleClickOutside = function (ev, targetEl) {
        var clickedEl = ev.target;
        if (clickedEl !== targetEl &&
            !targetEl.contains(clickedEl) &&
            !this._triggerEl.contains(clickedEl) &&
            this.isVisible()) {
            this.hide();
        }
    };
    Tooltip.prototype.isVisible = function () {
        return this._visible;
    };
    Tooltip.prototype.toggle = function () {
        if (this.isVisible()) {
            this.hide();
        }
        else {
            this.show();
        }
    };
    Tooltip.prototype.show = function () {
        this._targetEl.classList.remove('opacity-0', 'invisible');
        this._targetEl.classList.add('opacity-100', 'visible');
        // Enable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: true },
            ], false) })); });
        // handle click outside
        this._setupClickOutsideListener();
        // handle esc keydown
        this._setupKeydownListener();
        // Update its position
        this._popperInstance.update();
        // set visibility
        this._visible = true;
        // callback function
        this._options.onShow(this);
    };
    Tooltip.prototype.hide = function () {
        this._targetEl.classList.remove('opacity-100', 'visible');
        this._targetEl.classList.add('opacity-0', 'invisible');
        // Disable the event listeners
        this._popperInstance.setOptions(function (options) { return (__assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                { name: 'eventListeners', enabled: false },
            ], false) })); });
        // handle click outside
        this._removeClickOutsideListener();
        // handle esc keydown
        this._removeKeydownListener();
        // set visibility
        this._visible = false;
        // callback function
        this._options.onHide(this);
    };
    return Tooltip;
}());
if (typeof window !== 'undefined') {
    window.Tooltip = Tooltip;
}
function initTooltips() {
    document.querySelectorAll('[data-tooltip-target]').forEach(function ($triggerEl) {
        var tooltipId = $triggerEl.getAttribute('data-tooltip-target');
        var $tooltipEl = document.getElementById(tooltipId);
        if ($tooltipEl) {
            var triggerType = $triggerEl.getAttribute('data-tooltip-trigger');
            var placement = $triggerEl.getAttribute('data-tooltip-placement');
            new Tooltip($tooltipEl, $triggerEl, {
                placement: placement ? placement : Default.placement,
                triggerType: triggerType
                    ? triggerType
                    : Default.triggerType,
            });
        }
        else {
            console.error("The tooltip element with id \"".concat(tooltipId, "\" does not exist. Please check the data-tooltip-target attribute."));
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tooltip);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tooltip/interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tooltip/interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/components/tooltip/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/components/tooltip/types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/dom/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/dom/events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Events = /** @class */ (function () {
    function Events(eventType, eventFunctions) {
        if (eventFunctions === void 0) { eventFunctions = []; }
        this._eventType = eventType;
        this._eventFunctions = eventFunctions;
    }
    Events.prototype.init = function () {
        var _this = this;
        this._eventFunctions.forEach(function (eventFunction) {
            if (typeof window !== 'undefined') {
                window.addEventListener(_this._eventType, eventFunction);
            }
        });
    };
    return Events;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Events);
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/flowbite/lib/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/flowbite/lib/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Accordion": () => (/* reexport safe */ _components_accordion__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "Carousel": () => (/* reexport safe */ _components_carousel__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "Collapse": () => (/* reexport safe */ _components_collapse__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "Dial": () => (/* reexport safe */ _components_dial__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "Dismiss": () => (/* reexport safe */ _components_dismiss__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "Drawer": () => (/* reexport safe */ _components_drawer__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "Dropdown": () => (/* reexport safe */ _components_dropdown__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "Modal": () => (/* reexport safe */ _components_modal__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "Popover": () => (/* reexport safe */ _components_popover__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "Tabs": () => (/* reexport safe */ _components_tabs__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "Tooltip": () => (/* reexport safe */ _components_tooltip__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "initAccordions": () => (/* reexport safe */ _components_accordion__WEBPACK_IMPORTED_MODULE_1__.initAccordions),
/* harmony export */   "initCarousels": () => (/* reexport safe */ _components_carousel__WEBPACK_IMPORTED_MODULE_3__.initCarousels),
/* harmony export */   "initCollapses": () => (/* reexport safe */ _components_collapse__WEBPACK_IMPORTED_MODULE_2__.initCollapses),
/* harmony export */   "initDials": () => (/* reexport safe */ _components_dial__WEBPACK_IMPORTED_MODULE_11__.initDials),
/* harmony export */   "initDismisses": () => (/* reexport safe */ _components_dismiss__WEBPACK_IMPORTED_MODULE_4__.initDismisses),
/* harmony export */   "initDrawers": () => (/* reexport safe */ _components_drawer__WEBPACK_IMPORTED_MODULE_7__.initDrawers),
/* harmony export */   "initDropdowns": () => (/* reexport safe */ _components_dropdown__WEBPACK_IMPORTED_MODULE_5__.initDropdowns),
/* harmony export */   "initFlowbite": () => (/* reexport safe */ _components_index__WEBPACK_IMPORTED_MODULE_34__.initFlowbite),
/* harmony export */   "initModals": () => (/* reexport safe */ _components_modal__WEBPACK_IMPORTED_MODULE_6__.initModals),
/* harmony export */   "initPopovers": () => (/* reexport safe */ _components_popover__WEBPACK_IMPORTED_MODULE_10__.initPopovers),
/* harmony export */   "initTabs": () => (/* reexport safe */ _components_tabs__WEBPACK_IMPORTED_MODULE_8__.initTabs),
/* harmony export */   "initTooltips": () => (/* reexport safe */ _components_tooltip__WEBPACK_IMPORTED_MODULE_9__.initTooltips)
/* harmony export */ });
/* harmony import */ var _dom_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom/events */ "./node_modules/flowbite/lib/esm/dom/events.js");
/* harmony import */ var _components_accordion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/accordion */ "./node_modules/flowbite/lib/esm/components/accordion/index.js");
/* harmony import */ var _components_collapse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/collapse */ "./node_modules/flowbite/lib/esm/components/collapse/index.js");
/* harmony import */ var _components_carousel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/carousel */ "./node_modules/flowbite/lib/esm/components/carousel/index.js");
/* harmony import */ var _components_dismiss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/dismiss */ "./node_modules/flowbite/lib/esm/components/dismiss/index.js");
/* harmony import */ var _components_dropdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/dropdown */ "./node_modules/flowbite/lib/esm/components/dropdown/index.js");
/* harmony import */ var _components_modal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/modal */ "./node_modules/flowbite/lib/esm/components/modal/index.js");
/* harmony import */ var _components_drawer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/drawer */ "./node_modules/flowbite/lib/esm/components/drawer/index.js");
/* harmony import */ var _components_tabs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/tabs */ "./node_modules/flowbite/lib/esm/components/tabs/index.js");
/* harmony import */ var _components_tooltip__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/tooltip */ "./node_modules/flowbite/lib/esm/components/tooltip/index.js");
/* harmony import */ var _components_popover__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/popover */ "./node_modules/flowbite/lib/esm/components/popover/index.js");
/* harmony import */ var _components_dial__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/dial */ "./node_modules/flowbite/lib/esm/components/dial/index.js");
/* harmony import */ var _components_accordion_types__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/accordion/types */ "./node_modules/flowbite/lib/esm/components/accordion/types.js");
/* harmony import */ var _components_carousel_types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/carousel/types */ "./node_modules/flowbite/lib/esm/components/carousel/types.js");
/* harmony import */ var _components_collapse_types__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/collapse/types */ "./node_modules/flowbite/lib/esm/components/collapse/types.js");
/* harmony import */ var _components_dial_types__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/dial/types */ "./node_modules/flowbite/lib/esm/components/dial/types.js");
/* harmony import */ var _components_dismiss_types__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/dismiss/types */ "./node_modules/flowbite/lib/esm/components/dismiss/types.js");
/* harmony import */ var _components_drawer_types__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/drawer/types */ "./node_modules/flowbite/lib/esm/components/drawer/types.js");
/* harmony import */ var _components_dropdown_types__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/dropdown/types */ "./node_modules/flowbite/lib/esm/components/dropdown/types.js");
/* harmony import */ var _components_modal_types__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/modal/types */ "./node_modules/flowbite/lib/esm/components/modal/types.js");
/* harmony import */ var _components_popover_types__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./components/popover/types */ "./node_modules/flowbite/lib/esm/components/popover/types.js");
/* harmony import */ var _components_tabs_types__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/tabs/types */ "./node_modules/flowbite/lib/esm/components/tabs/types.js");
/* harmony import */ var _components_tooltip_types__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/tooltip/types */ "./node_modules/flowbite/lib/esm/components/tooltip/types.js");
/* harmony import */ var _components_accordion_interface__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/accordion/interface */ "./node_modules/flowbite/lib/esm/components/accordion/interface.js");
/* harmony import */ var _components_carousel_interface__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/carousel/interface */ "./node_modules/flowbite/lib/esm/components/carousel/interface.js");
/* harmony import */ var _components_collapse_interface__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/collapse/interface */ "./node_modules/flowbite/lib/esm/components/collapse/interface.js");
/* harmony import */ var _components_dial_interface__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./components/dial/interface */ "./node_modules/flowbite/lib/esm/components/dial/interface.js");
/* harmony import */ var _components_dismiss_interface__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./components/dismiss/interface */ "./node_modules/flowbite/lib/esm/components/dismiss/interface.js");
/* harmony import */ var _components_drawer_interface__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./components/drawer/interface */ "./node_modules/flowbite/lib/esm/components/drawer/interface.js");
/* harmony import */ var _components_dropdown_interface__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./components/dropdown/interface */ "./node_modules/flowbite/lib/esm/components/dropdown/interface.js");
/* harmony import */ var _components_modal_interface__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./components/modal/interface */ "./node_modules/flowbite/lib/esm/components/modal/interface.js");
/* harmony import */ var _components_popover_interface__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./components/popover/interface */ "./node_modules/flowbite/lib/esm/components/popover/interface.js");
/* harmony import */ var _components_tabs_interface__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./components/tabs/interface */ "./node_modules/flowbite/lib/esm/components/tabs/interface.js");
/* harmony import */ var _components_tooltip_interface__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./components/tooltip/interface */ "./node_modules/flowbite/lib/esm/components/tooltip/interface.js");
/* harmony import */ var _components_index__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./components/index */ "./node_modules/flowbite/lib/esm/components/index.js");












// setup events for data attributes
var events = new _dom_events__WEBPACK_IMPORTED_MODULE_0__["default"]('load', [
    _components_accordion__WEBPACK_IMPORTED_MODULE_1__.initAccordions,
    _components_collapse__WEBPACK_IMPORTED_MODULE_2__.initCollapses,
    _components_carousel__WEBPACK_IMPORTED_MODULE_3__.initCarousels,
    _components_dismiss__WEBPACK_IMPORTED_MODULE_4__.initDismisses,
    _components_dropdown__WEBPACK_IMPORTED_MODULE_5__.initDropdowns,
    _components_modal__WEBPACK_IMPORTED_MODULE_6__.initModals,
    _components_drawer__WEBPACK_IMPORTED_MODULE_7__.initDrawers,
    _components_tabs__WEBPACK_IMPORTED_MODULE_8__.initTabs,
    _components_tooltip__WEBPACK_IMPORTED_MODULE_9__.initTooltips,
    _components_popover__WEBPACK_IMPORTED_MODULE_10__.initPopovers,
    _components_dial__WEBPACK_IMPORTED_MODULE_11__.initDials,
]);
events.init();
// export all components











// export all types











// export all interfaces











// export init functions











// export all init functions

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./src/inbound_order/add.ts":
/*!**********************************!*\
  !*** ./src/inbound_order/add.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initAddInboundOrderModal = void 0;
var flowbite_1 = __webpack_require__(/*! flowbite */ "./node_modules/flowbite/lib/esm/index.js");
var createInboundOrderHandler = function () {
    var createInboundOrderBtn = document.getElementById('inbound-order-create-btn');
    var createInboundOrderBtnSubmit = document.getElementById('inbound-order-add-submit-btn');
    if (!createInboundOrderBtn) {
        console.log("Error: no create inbound order button");
        return;
    }
    createInboundOrderBtn.addEventListener('click', function () {
        var allocatedProductsData = [];
        // Set products as JSON to field
        var productsAllocatedContainers = document.querySelectorAll('.product-allocated');
        productsAllocatedContainers.forEach(function (productContainer) {
            // Get HTML nodes with product values
            var productAllocatedSelectHTML = productContainer.querySelector('.product-allocated-add');
            var productAllocatedQuantityInput = productContainer.querySelector('.product-allocated-quantity');
            var productAllocatedShelfLifeStartInput = productContainer.querySelector('.product-allocated-shelf-life-start');
            var productAllocatedShelfLifeEndInput = productContainer.querySelector('.product-allocated-shelf-life-end');
            // Retrieve values from Nodes
            var productAllocatedId = parseInt(productAllocatedSelectHTML.value);
            var productAllocatedQuantity = parseInt(productAllocatedQuantityInput.value);
            var productAllocatedShelfLifeStart = productAllocatedShelfLifeStartInput.value;
            var productAllocatedShelfLifeEnd = productAllocatedShelfLifeEndInput.value;
            allocatedProductsData.push({
                id: productAllocatedId,
                quantity: productAllocatedQuantity,
                shelfLifeStart: productAllocatedShelfLifeStart,
                shelfLifeEnd: productAllocatedShelfLifeEnd,
            });
        });
        var inputProducts = document.querySelector("#inbound-order-add-products");
        inputProducts.value = JSON.stringify(allocatedProductsData);
        createInboundOrderBtnSubmit.click();
    });
};
var initAddInboundOrderModal = function () {
    var addModalButton = document.querySelector('#inbound-order-add-modal-button');
    var addInboundOrderModalElement = document.querySelector('#add-inbound-order-modal');
    var addModalOptions = {
        placement: 'bottom-right',
        backdrop: 'dynamic',
        backdropClasses: 'bg-gray-900 bg-opacity-50 dark:bg-opacity-80 fixed inset-0 z-40',
        closable: true,
        onHide: function () {
            console.log('inbound-order id: ');
        },
        onShow: function () {
            console.log('inbound-order id: ');
        },
        onToggle: function () {
            console.log('modal has been toggled');
        },
    };
    var addModal = new flowbite_1.Modal(addInboundOrderModalElement, addModalOptions);
    addModalButton.addEventListener('click', function () {
        addModal.show();
    });
    var addModalCloseButton = document.querySelector('#add-modal-btn-hide');
    addModalCloseButton.addEventListener('click', function () {
        addModal.hide();
    });
    createInboundOrderHandler();
};
exports.initAddInboundOrderModal = initAddInboundOrderModal;


/***/ }),

/***/ "./src/inbound_order/edit.ts":
/*!***********************************!*\
  !*** ./src/inbound_order/edit.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initEditOrderModal = void 0;
var flowbite_1 = __webpack_require__(/*! flowbite */ "./node_modules/flowbite/lib/esm/index.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./src/inbound_order/utils.ts");
var setNewQuantityView = function (quantityGroupContainer) {
    var quantitiesPerGroup = quantityGroupContainer.querySelectorAll('.inbound-order-edit-add-quantity');
    var quantityView = quantityGroupContainer.querySelector('.inbound-order-edit-check-quantity');
    var quantityAvailable = parseInt(quantityView.getAttribute('data-quantity'));
    var quantityTotal = 0;
    quantitiesPerGroup.forEach(function (quantityPerGroup) {
        if (quantityPerGroup.value) {
            quantityTotal += parseInt(quantityPerGroup.value);
        }
    });
    quantityView.innerHTML = (quantityAvailable - quantityTotal).toString();
};
var createProductGroup = function (allocatedProductContainer) {
    var groupItemTemplate = document.querySelector('.group-quantity-item');
    var groupQuantityItemNew = groupItemTemplate.cloneNode(true);
    groupQuantityItemNew.classList.remove('invisible');
    var buttonDeleteQuantityGroup = groupQuantityItemNew.querySelector('.quantity-group-delete-button');
    buttonDeleteQuantityGroup.addEventListener('click', function (e) {
        groupQuantityItemNew.remove();
        setNewQuantityView(allocatedProductContainer);
    });
    var quantityInput = groupQuantityItemNew.querySelector('.inbound-order-edit-add-quantity');
    var quantityView = allocatedProductContainer.querySelector('.inbound-order-edit-check-quantity');
    var quantitiesGroupInputs = allocatedProductContainer.querySelectorAll('.inbound-order-edit-add-quantity');
    var quantityLeft = parseInt(quantityView.getAttribute('data-quantity'));
    quantitiesGroupInputs.forEach(function (quantityGroupInput) {
        if (quantityGroupInput.value) {
            quantityLeft -= parseInt(quantityGroupInput.value);
        }
    });
    quantityInput.value = quantityLeft.toString();
    allocatedProductContainer.querySelector('.inbound-order-add-product-group-btn').before(groupQuantityItemNew);
    quantityInput.addEventListener('input', function (e) {
        setNewQuantityView(allocatedProductContainer);
    });
    setNewQuantityView(allocatedProductContainer);
    return groupQuantityItemNew;
};
var initEditOrderModal = function () {
    // Nodes
    var orderEditProductsAllocatedContainer = document.querySelector('#inbound-order-edit-check-container');
    var orderEditModalHTML = document.querySelector('#edit-inbound-order-modal');
    var orderEditButtons = document.querySelectorAll('.inbound-order-edit-button');
    var orderUuidInput = document.querySelector('#inbound-order-uuid');
    var orderStatusSelect = document.querySelector('#inbound-order-edit-status');
    var orderTitleInput = document.querySelector('#inbound-order-edit-order-title');
    var orderActiveDateInput = document.querySelector('#inbound-order-edit-active-date');
    var orderActiveTimeInput = document.querySelector('#inbound-order-edit-active-time');
    var orderDeliveryDateInput = document.querySelector('#inbound-order-edit-delivery-date');
    var orderSupplierIdSelect = document.querySelector('#inbound-order-edit-supplier-id');
    var orderWarehouseIdSelect = document.querySelector('#inbound-order-edit-warehouse-id');
    var orderEditAddGroupButtonTemplate = document.querySelector('.inbound-order-add-product-group-btn');
    var modalEditOptions = {
        placement: 'bottom-right',
        backdrop: 'dynamic',
        backdropClasses: 'bg-gray-900 bg-opacity-50 dark:bg-opacity-80 fixed inset-0 z-40',
        closable: true,
        onHide: function () {
            console.log(orderEditProductsAllocatedContainer);
            while (orderEditProductsAllocatedContainer.children.length > 1) {
                orderEditProductsAllocatedContainer.removeChild(orderEditProductsAllocatedContainer.lastElementChild);
            }
            var groupsQuantity = orderEditProductsAllocatedContainer.querySelectorAll('.group-quantity-item');
            groupsQuantity.forEach(function (group) { return group.remove(); });
            var buttonsAddGroupQuantity = orderEditProductsAllocatedContainer.querySelectorAll('.inbound-order-add-product-group-btn');
            buttonsAddGroupQuantity.forEach(function (button) { return button.remove(); });
        },
    };
    var orderEditModal = new flowbite_1.Modal(orderEditModalHTML, modalEditOptions);
    var editModalCloseButton = document.querySelector('#edit-modal-btn-hide');
    editModalCloseButton.addEventListener('click', function () {
        orderEditModal.hide();
    });
    orderEditButtons.forEach(function (orderEditButton) {
        var inboundOrderData = JSON.parse(orderEditButton.getAttribute('data-target'));
        orderEditButton.addEventListener('click', function () {
            // Set order edit modal values
            orderUuidInput.value = inboundOrderData.uuid;
            orderStatusSelect.value = inboundOrderData.status;
            orderTitleInput.value = inboundOrderData.title;
            orderActiveDateInput.value = (0, utils_1.getDatepickerDateFormat)(inboundOrderData.activeDate);
            orderActiveTimeInput.value = inboundOrderData.activeTime;
            orderDeliveryDateInput.value = (0, utils_1.getDatepickerDateFormat)(inboundOrderData.deliveryDate);
            orderSupplierIdSelect.value = inboundOrderData.supplier.id.toString();
            orderWarehouseIdSelect.value = inboundOrderData.warehouse.id.toString();
            for (var i = 0; i < inboundOrderData.productsAllocated.length - 1; i++) {
                var productAllocatedEditView = orderEditProductsAllocatedContainer.children[0].cloneNode(true);
                orderEditProductsAllocatedContainer.appendChild(productAllocatedEditView);
            }
            inboundOrderData.productsAllocated.forEach(function (productAllocated, i) {
                var currentProductAllocatedContainer = orderEditProductsAllocatedContainer.children[i];
                var productAllocatedIdInput = currentProductAllocatedContainer.querySelector('.product-allocated-id');
                var productAllocatedNameDiv = currentProductAllocatedContainer.querySelector('.inbound-order-edit-check-product');
                var productAllocatedQuantityDiv = currentProductAllocatedContainer.querySelector('.inbound-order-edit-check-quantity');
                var productAllocatedShelfLifeFromDiv = currentProductAllocatedContainer.querySelector('.inbound-order-edit-shelf-life-from');
                var productAllocatedShelfLifeToDiv = currentProductAllocatedContainer.querySelector('.inbound-order-edit-shelf-life-to');
                productAllocatedIdInput.value = productAllocated.id.toString();
                productAllocatedNameDiv.innerHTML = productAllocated.product.name;
                productAllocatedQuantityDiv.innerHTML = productAllocated.quantity.toString();
                productAllocatedQuantityDiv.setAttribute('data-quantity', productAllocated.quantity.toString());
                productAllocatedShelfLifeFromDiv.innerHTML = (0, utils_1.getDatepickerDateFormat)(productAllocated.shelfLifeStart);
                productAllocatedShelfLifeToDiv.innerHTML = (0, utils_1.getDatepickerDateFormat)(productAllocated.shelfLifeEnd);
                var buttonAddNewGroup = orderEditAddGroupButtonTemplate.cloneNode(true);
                // current point
                buttonAddNewGroup.addEventListener('click', function () { return createProductGroup(currentProductAllocatedContainer); });
                productAllocatedShelfLifeToDiv.parentNode.parentNode.after(buttonAddNewGroup);
                buttonAddNewGroup.classList.remove('invisible');
                productAllocated.productQuantityGroups.forEach(function (quantityGroup) {
                    var quantityGroupContainer = createProductGroup(currentProductAllocatedContainer);
                    var groupSelect = quantityGroupContainer.querySelector('.inbound-order-edit-add-group');
                    var groupQuantityInput = quantityGroupContainer.querySelector('.inbound-order-edit-add-quantity');
                    groupSelect.value = quantityGroup.group.id.toString();
                    groupQuantityInput.value = quantityGroup.quantity.toString();
                });
                setNewQuantityView(currentProductAllocatedContainer);
            });
            orderEditModal.show();
        });
    });
    // submit update order
    var buttonSave = document.querySelector('#inbound-order-save-products-btn');
    buttonSave.addEventListener('click', function () {
        var productAllocatedGroupsContainers = document.querySelectorAll('.product-allocated-groups-container');
        var productGroups = [];
        productAllocatedGroupsContainers.forEach(function (productGroupContainer) {
            var productAllocatedIdInput = productGroupContainer.querySelector('.product-allocated-id');
            var productGroupCreate = {
                productAllocatedId: parseInt(productAllocatedIdInput.value),
                productAllocatedGroups: [],
            };
            var groupQuantityItems = productGroupContainer.querySelectorAll('.group-quantity-item');
            groupQuantityItems.forEach(function (quantityItem) {
                var groupIdSelect = quantityItem.querySelector('.inbound-order-edit-add-group');
                var groupQuantityInput = quantityItem.querySelector('.inbound-order-edit-add-quantity');
                if (groupIdSelect.value && groupQuantityInput.value) {
                    var groupId = parseInt(groupIdSelect.value);
                    var groupQuantity = parseInt(groupQuantityInput.value);
                    productGroupCreate.productAllocatedGroups.push({
                        groupId: groupId,
                        quantity: groupQuantity,
                    });
                }
            });
            productGroups.push(productGroupCreate);
        });
        var productGroupsQuantitiesInput = document.querySelector('#inbound-order-edit-product-quantities');
        productGroupsQuantitiesInput.value = JSON.stringify(productGroups);
        var buttonSubmit = document.querySelector('#inbound-order-submit-btn');
        buttonSubmit.click();
    });
};
exports.initEditOrderModal = initEditOrderModal;


/***/ }),

/***/ "./src/inbound_order/inbound_order.ts":
/*!********************************************!*\
  !*** ./src/inbound_order/inbound_order.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tw_elements_1 = __webpack_require__(/*! tw-elements */ "./node_modules/tw-elements/dist/js/tw-elements.es.min.js");
var add_1 = __webpack_require__(/*! ./add */ "./src/inbound_order/add.ts");
var view_1 = __webpack_require__(/*! ./view */ "./src/inbound_order/view.ts");
var edit_1 = __webpack_require__(/*! ./edit */ "./src/inbound_order/edit.ts");
(0, tw_elements_1.initTE)({ Input: tw_elements_1.Input, Timepicker: tw_elements_1.Timepicker });
var $buttonElements = document.querySelectorAll('.inbound-order-edit-button');
$buttonElements.forEach(function (e) {
    return e.addEventListener('click', function () {
        var inboundOrder = JSON.parse(e.getAttribute('data-target'));
    });
});
// search flow
var searchInput = document.querySelector('#table-search-inbound-orders');
var searchInputButton = document.querySelector('#table-search-inbound-order-button');
if (searchInputButton && searchInput) {
    searchInputButton.addEventListener('click', function () {
        var url = new URL(window.location.href);
        url.searchParams.set('q', searchInput.value);
        window.location.href = "".concat(url.href);
    });
}
var deleteButtons = document.querySelectorAll('.delete-inbound-order-btn');
deleteButtons.forEach(function (e) {
    e.addEventListener('click', function () { return __awaiter(void 0, void 0, void 0, function () {
        var id, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!confirm('Are sure?')) return [3 /*break*/, 2];
                    id = e.getAttribute('data-inbound-order-id');
                    return [4 /*yield*/, fetch("/inbound_order/delete/".concat(id), {
                            method: 'DELETE',
                        })];
                case 1:
                    response = _a.sent();
                    if (response.status == 200) {
                        location.reload();
                    }
                    _a.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    }); });
});
var openCurrentOrder = function () {
    var urlParams = new URLSearchParams(window.location.search);
    var orderUuid = urlParams.get('current_order_uuid');
    console.log(orderUuid);
    if (!orderUuid) {
        return;
    }
    var orderColumn = document.querySelector("#inbound-order-".concat(orderUuid));
    if (!orderColumn) {
        return;
    }
    var orderEditButton = orderColumn.querySelector('.inbound-order-edit-button');
    orderEditButton.click();
};
var deleteAllocatedProduct = function (e) {
    var productAllocatedContainer = e.currentTarget.parentNode;
    var productsAllocatedContainer = productAllocatedContainer.parentNode;
    productAllocatedContainer.remove();
    console.log(productsAllocatedContainer.children.length);
    if (productsAllocatedContainer.children.length == 2) {
        var productAllocatedDeleteButton = productsAllocatedContainer.querySelector('.product-allocated-delete-button');
        console.log(productAllocatedDeleteButton);
        productAllocatedDeleteButton.classList.add('invisible');
    }
};
var createAllocationProductContainer = function (e) {
    var btn = e.currentTarget;
    var productAllocatedContainer = document.querySelector('.product-allocated').parentNode;
    if (productAllocatedContainer.parentNode.children.length == 2) {
        var buttonRemoveProductAllocated = productAllocatedContainer.querySelector('.product-allocated-delete-button');
        buttonRemoveProductAllocated.classList.remove('invisible');
    }
    var productAllocatedNew = productAllocatedContainer.cloneNode(true);
    // Clear inputs
    productAllocatedNew.querySelectorAll('input').forEach(function (input) {
        input.value = '';
    });
    var buttonDeleteAllocatedProduct = productAllocatedNew.querySelector('.product-allocated-delete-button');
    buttonDeleteAllocatedProduct.addEventListener('click', deleteAllocatedProduct);
    var productsAllocatedContainer = btn.parentNode.parentNode;
    productsAllocatedContainer.insertBefore(productAllocatedNew, btn.parentNode);
};
// # NOTE: depends on flash from create route on inbound_order_blueprint
document.addEventListener('DOMContentLoaded', function () {
    // view order
    (0, view_1.initViewInboundOrderModal)();
    // Add new inbound order handler
    (0, add_1.initAddInboundOrderModal)();
    // Add edit inbound order handler
    (0, edit_1.initEditOrderModal)();
    var buttonAllocateProduct = document.getElementById('inbound-order-allocate-product-btn');
    buttonAllocateProduct.addEventListener('click', createAllocationProductContainer);
    var buttonDeleteAllocatedProduct = document.querySelector('.product-allocated-delete-button');
    buttonDeleteAllocatedProduct.addEventListener('click', deleteAllocatedProduct);
    // Open current order
    openCurrentOrder();
});


/***/ }),

/***/ "./src/inbound_order/utils.ts":
/*!************************************!*\
  !*** ./src/inbound_order/utils.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDatepickerDateFormat = void 0;
var getDatepickerDateFormat = function (dateString) {
    var date = new Date(dateString);
    var dateParts = date.toLocaleDateString().split('/');
    var tmp = dateParts[0];
    dateParts[0] = dateParts[1];
    dateParts[1] = tmp;
    return dateParts.join('/');
};
exports.getDatepickerDateFormat = getDatepickerDateFormat;


/***/ }),

/***/ "./src/inbound_order/view.ts":
/*!***********************************!*\
  !*** ./src/inbound_order/view.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initViewInboundOrderModal = void 0;
var flowbite_1 = __webpack_require__(/*! flowbite */ "./node_modules/flowbite/lib/esm/index.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./src/inbound_order/utils.ts");
var initViewInboundOrderModal = function () {
    // modal Nodes
    var viewInboundOrderModalElement = document.querySelector('#view-inbound-order-modal');
    var orderIdView = viewInboundOrderModalElement.querySelector('#inbound-order-view-order_id');
    var orderStatus = viewInboundOrderModalElement.querySelector('#inbound-order-view-status');
    var orderActiveDate = viewInboundOrderModalElement.querySelector('#inbound-order-view-active_date');
    var orderActiveTime = viewInboundOrderModalElement.querySelector('#inbound-order-view-active_time');
    var orderTitle = viewInboundOrderModalElement.querySelector('#inbound-order-view-order_title');
    var orderDeliveryDate = viewInboundOrderModalElement.querySelector('#inbound-order-view-delivery_date');
    var orderWarehouseName = viewInboundOrderModalElement.querySelector('#inbound-order-view-warehouse-name');
    var orderSupplierName = viewInboundOrderModalElement.querySelector('#inbound-order-view-supplier-name');
    var orderSupplierAddress = viewInboundOrderModalElement.querySelector('#inbound-order-view-supplier-address');
    var modalViewDivs = [orderIdView, orderStatus, orderActiveDate, orderActiveTime, orderTitle, orderDeliveryDate, orderWarehouseName, orderSupplierName, orderSupplierAddress];
    // create modal
    var viewModalOptions = {
        placement: 'bottom-right',
        backdrop: 'dynamic',
        backdropClasses: 'bg-gray-900 bg-opacity-50 dark:bg-opacity-80 fixed inset-0 z-40',
        closable: true,
        onHide: function () {
            modalViewDivs.forEach(function (modalDiv) {
                modalDiv.innerHTML = '';
            });
        },
    };
    var viewModal = new flowbite_1.Modal(viewInboundOrderModalElement, viewModalOptions);
    var orderViewButtons = document.querySelectorAll('.inbound-order-view-button');
    orderViewButtons.forEach(function (viewButton) {
        var inboundOrderData = JSON.parse(viewButton.getAttribute('data-target'));
        // Nodes
        viewButton.addEventListener('click', function () {
            // Fill order view modal data
            orderIdView.innerHTML = inboundOrderData.orderId;
            orderStatus.innerHTML = inboundOrderData.status;
            orderActiveDate.innerHTML = (0, utils_1.getDatepickerDateFormat)(inboundOrderData.activeDate);
            orderActiveTime.innerHTML = inboundOrderData.activeTime;
            orderTitle.innerHTML = inboundOrderData.title;
            orderDeliveryDate.innerHTML = (0, utils_1.getDatepickerDateFormat)(inboundOrderData.deliveryDate);
            orderWarehouseName.innerHTML = inboundOrderData.warehouse.name;
            orderSupplierName.innerHTML = inboundOrderData.supplier.name;
            orderSupplierAddress.innerHTML = inboundOrderData.supplier.address;
            viewModal.show();
        });
    });
    var viewModalCloseButton = document.querySelector('#view-modal-btn-hide');
    viewModalCloseButton.addEventListener('click', function () {
        viewModal.hide();
    });
};
exports.initViewInboundOrderModal = initViewInboundOrderModal;


/***/ }),

/***/ "./node_modules/tw-elements/dist/js/tw-elements.es.min.js":
/*!****************************************************************!*\
  !*** ./node_modules/tw-elements/dist/js/tw-elements.es.min.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Alert": () => (/* binding */ Rn),
/* harmony export */   "Animate": () => (/* binding */ ml),
/* harmony export */   "Button": () => (/* binding */ $a),
/* harmony export */   "Carousel": () => (/* binding */ Yt),
/* harmony export */   "Chart": () => (/* binding */ Wl),
/* harmony export */   "Chip": () => (/* binding */ ii),
/* harmony export */   "ChipsInput": () => (/* binding */ Zg),
/* harmony export */   "Collapse": () => (/* binding */ Ut),
/* harmony export */   "Datepicker": () => (/* binding */ Gg),
/* harmony export */   "Dropdown": () => (/* binding */ wt),
/* harmony export */   "Input": () => (/* binding */ V),
/* harmony export */   "Modal": () => (/* binding */ Pn),
/* harmony export */   "Offcanvas": () => (/* binding */ rs),
/* harmony export */   "Popover": () => (/* binding */ ll),
/* harmony export */   "Ripple": () => (/* binding */ Cs),
/* harmony export */   "ScrollSpy": () => (/* binding */ Bn),
/* harmony export */   "Select": () => (/* binding */ Nl),
/* harmony export */   "Sidenav": () => (/* binding */ ni),
/* harmony export */   "Stepper": () => (/* binding */ Qg),
/* harmony export */   "Tab": () => (/* binding */ hl),
/* harmony export */   "Timepicker": () => (/* binding */ qg),
/* harmony export */   "Toast": () => (/* binding */ Vn),
/* harmony export */   "Tooltip": () => (/* binding */ vi),
/* harmony export */   "initTE": () => (/* binding */ eg)
/* harmony export */ });
/*!
* Taliwind Elements 1.0.0-beta2
* 
* Tailwind Elements is an open-source UI kit of advanced components for TailwindCSS.
* Copyright Â© 2023 MDBootstrap.com
* 
* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
* 
*/
var Xl = Object.defineProperty;
var Gl = (s, t, e) => t in s ? Xl(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var Tt = (s, t, e) => (Gl(s, typeof t != "symbol" ? t + "" : t, e), e);
const Bs = (() => {
  const s = {};
  let t = 1;
  return {
    set(e, i, n) {
      typeof e[i] > "u" && (e[i] = {
        key: i,
        id: t
      }, t++), s[e[i].id] = n;
    },
    get(e, i) {
      if (!e || typeof e[i] > "u")
        return null;
      const n = e[i];
      return n.key === i ? s[n.id] : null;
    },
    delete(e, i) {
      if (typeof e[i] > "u")
        return;
      const n = e[i];
      n.key === i && (delete s[n.id], delete e[i]);
    }
  };
})(), I = {
  setData(s, t, e) {
    Bs.set(s, t, e);
  },
  getData(s, t) {
    return Bs.get(s, t);
  },
  removeData(s, t) {
    Bs.delete(s, t);
  }
}, ql = 1e6, Ql = 1e3, Dn = "transitionend", Zl = (s) => s == null ? `${s}` : {}.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase(), Ot = (s) => {
  do
    s += Math.floor(Math.random() * ql);
  while (document.getElementById(s));
  return s;
}, va = (s) => {
  let t = s.getAttribute("data-te-target");
  if (!t || t === "#") {
    let e = s.getAttribute("href");
    if (!e || !e.includes("#") && !e.startsWith("."))
      return null;
    e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t = e && e !== "#" ? e.trim() : null;
  }
  return t;
}, Xn = (s) => {
  const t = va(s);
  return t && document.querySelector(t) ? t : null;
}, Xt = (s) => {
  const t = va(s);
  return t ? document.querySelector(t) : null;
}, Jl = (s) => {
  if (!s)
    return 0;
  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(s);
  const i = Number.parseFloat(t), n = Number.parseFloat(e);
  return !i && !n ? 0 : (t = t.split(",")[0], e = e.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * Ql);
}, Ea = (s) => {
  s.dispatchEvent(new Event(Dn));
}, Ne = (s) => !s || typeof s != "object" ? !1 : (typeof s.jquery < "u" && (s = s[0]), typeof s.nodeType < "u"), Gt = (s) => Ne(s) ? s.jquery ? s[0] : s : typeof s == "string" && s.length > 0 ? document.querySelector(s) : null, N = (s, t, e) => {
  Object.keys(e).forEach((i) => {
    const n = e[i], o = t[i], r = o && Ne(o) ? "element" : Zl(o);
    if (!new RegExp(n).test(r))
      throw new Error(
        `${s.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${n}".`
      );
  });
}, St = (s) => {
  if (!s || s.getClientRects().length === 0)
    return !1;
  if (s.style && s.parentNode && s.parentNode.style) {
    const t = getComputedStyle(s), e = getComputedStyle(s.parentNode);
    return getComputedStyle(s).getPropertyValue("visibility") === "visible" || t.display !== "none" && e.display !== "none" && t.visibility !== "hidden";
  }
  return !1;
}, ue = (s) => !s || s.nodeType !== Node.ELEMENT_NODE || s.classList.contains("disabled") ? !0 : typeof s.disabled < "u" ? s.disabled : s.hasAttribute("disabled") && s.getAttribute("disabled") !== "false", Ta = (s) => {
  if (!document.documentElement.attachShadow)
    return null;
  if (typeof s.getRootNode == "function") {
    const t = s.getRootNode();
    return t instanceof ShadowRoot ? t : null;
  }
  return s instanceof ShadowRoot ? s : s.parentNode ? Ta(s.parentNode) : null;
}, vs = () => function() {
}, Fe = (s) => {
  s.offsetHeight;
}, Ca = () => {
  const { jQuery: s } = window;
  return s && !document.body.hasAttribute("data-te-no-jquery") ? s : null;
}, Vs = [], Aa = (s) => {
  document.readyState === "loading" ? (Vs.length || document.addEventListener("DOMContentLoaded", () => {
    Vs.forEach((t) => t());
  }), Vs.push(s)) : s();
}, F = () => document.documentElement.dir === "rtl", tc = (s) => Array.from(s), M = (s) => document.createElement(s), he = (s) => {
  typeof s == "function" && s();
}, ya = (s, t, e = !0) => {
  if (!e) {
    he(s);
    return;
  }
  const i = 5, n = Jl(t) + i;
  let o = !1;
  const r = ({ target: a }) => {
    a === t && (o = !0, t.removeEventListener(Dn, r), he(s));
  };
  t.addEventListener(Dn, r), setTimeout(() => {
    o || Ea(t);
  }, n);
}, wa = (s, t, e, i) => {
  let n = s.indexOf(t);
  if (n === -1)
    return s[!e && i ? s.length - 1 : 0];
  const o = s.length;
  return n += e ? 1 : -1, i && (n = (n + o) % o), s[Math.max(0, Math.min(n, o - 1))];
}, ec = /[^.]*(?=\..*)\.|.*/, ic = /\..*/, sc = /::\d+$/, Ws = {};
let Eo = 1;
const nc = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, oc = /^(mouseenter|mouseleave)/i, ka = /* @__PURE__ */ new Set([
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
]);
function Oa(s, t) {
  return t && `${t}::${Eo++}` || s.uidEvent || Eo++;
}
function xa(s) {
  const t = Oa(s);
  return s.uidEvent = t, Ws[t] = Ws[t] || {}, Ws[t];
}
function rc(s, t) {
  return function e(i) {
    return i.delegateTarget = s, e.oneOff && u.off(s, i.type, t), t.apply(s, [i]);
  };
}
function ac(s, t, e) {
  return function i(n) {
    const o = s.querySelectorAll(t);
    for (let { target: r } = n; r && r !== this; r = r.parentNode)
      for (let a = o.length; a--; "")
        if (o[a] === r)
          return n.delegateTarget = r, i.oneOff && u.off(s, n.type, e), e.apply(r, [n]);
    return null;
  };
}
function Sa(s, t, e = null) {
  const i = Object.keys(s);
  for (let n = 0, o = i.length; n < o; n++) {
    const r = s[i[n]];
    if (r.originalHandler === t && r.delegationSelector === e)
      return r;
  }
  return null;
}
function Da(s, t, e) {
  const i = typeof t == "string", n = i ? e : t;
  let o = Ia(s);
  return ka.has(o) || (o = s), [i, n, o];
}
function To(s, t, e, i, n) {
  if (typeof t != "string" || !s)
    return;
  if (e || (e = i, i = null), oc.test(t)) {
    const m = (g) => function(b) {
      if (!b.relatedTarget || b.relatedTarget !== b.delegateTarget && !b.delegateTarget.contains(b.relatedTarget))
        return g.call(this, b);
    };
    i ? i = m(i) : e = m(e);
  }
  const [o, r, a] = Da(
    t,
    e,
    i
  ), l = xa(s), c = l[a] || (l[a] = {}), d = Sa(
    c,
    r,
    o ? e : null
  );
  if (d) {
    d.oneOff = d.oneOff && n;
    return;
  }
  const _ = Oa(
    r,
    t.replace(ec, "")
  ), f = o ? ac(s, e, i) : rc(s, e);
  f.delegationSelector = o ? e : null, f.originalHandler = r, f.oneOff = n, f.uidEvent = _, c[_] = f, s.addEventListener(a, f, o);
}
function In(s, t, e, i, n) {
  const o = Sa(t[e], i, n);
  o && (s.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);
}
function lc(s, t, e, i) {
  const n = t[e] || {};
  Object.keys(n).forEach((o) => {
    if (o.includes(i)) {
      const r = n[o];
      In(
        s,
        t,
        e,
        r.originalHandler,
        r.delegationSelector
      );
    }
  });
}
function Ia(s) {
  return s = s.replace(ic, ""), nc[s] || s;
}
const u = {
  on(s, t, e, i) {
    To(s, t, e, i, !1);
  },
  one(s, t, e, i) {
    To(s, t, e, i, !0);
  },
  off(s, t, e, i) {
    if (typeof t != "string" || !s)
      return;
    const [n, o, r] = Da(
      t,
      e,
      i
    ), a = r !== t, l = xa(s), c = t.startsWith(".");
    if (typeof o < "u") {
      if (!l || !l[r])
        return;
      In(
        s,
        l,
        r,
        o,
        n ? e : null
      );
      return;
    }
    c && Object.keys(l).forEach((_) => {
      lc(
        s,
        l,
        _,
        t.slice(1)
      );
    });
    const d = l[r] || {};
    Object.keys(d).forEach((_) => {
      const f = _.replace(sc, "");
      if (!a || t.includes(f)) {
        const m = d[_];
        In(
          s,
          l,
          r,
          m.originalHandler,
          m.delegationSelector
        );
      }
    });
  },
  trigger(s, t, e) {
    if (typeof t != "string" || !s)
      return null;
    const i = Ca(), n = Ia(t), o = t !== n, r = ka.has(n);
    let a, l = !0, c = !0, d = !1, _ = null;
    return o && i && (a = i.Event(t, e), i(s).trigger(a), l = !a.isPropagationStopped(), c = !a.isImmediatePropagationStopped(), d = a.isDefaultPrevented()), r ? (_ = document.createEvent("HTMLEvents"), _.initEvent(n, l, !0)) : _ = new CustomEvent(t, {
      bubbles: l,
      cancelable: !0
    }), typeof e < "u" && Object.keys(e).forEach((f) => {
      Object.defineProperty(_, f, {
        get() {
          return e[f];
        }
      });
    }), d && _.preventDefault(), c && s.dispatchEvent(_), _.defaultPrevented && typeof a < "u" && a.preventDefault(), _;
  }
}, ee = {
  on(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      u.on(s, n[o], e, i);
  },
  off(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      u.off(s, n[o], e, i);
  }
}, cc = "5.1.3";
class vt {
  constructor(t) {
    t = Gt(t), t && (this._element = t, I.setData(this._element, this.constructor.DATA_KEY, this));
  }
  dispose() {
    I.removeData(this._element, this.constructor.DATA_KEY), u.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {
      this[t] = null;
    });
  }
  _queueCallback(t, e, i = !0) {
    ya(t, e, i);
  }
  /** Static */
  static getInstance(t) {
    return I.getData(Gt(t), this.DATA_KEY);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static get VERSION() {
    return cc;
  }
  static get NAME() {
    throw new Error(
      'You have to implement the static method "NAME", for each component!'
    );
  }
  static get DATA_KEY() {
    return `te.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
}
const dc = "button", hc = "active";
class $a extends vt {
  // Getters
  static get NAME() {
    return dc;
  }
  // Public
  toggle() {
    this._element.setAttribute(
      "aria-pressed",
      this._element.classList.toggle(hc)
    );
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = $a.getOrCreateInstance(this);
      t === "toggle" && e[t]();
    });
  }
}
var Z = "top", dt = "bottom", ht = "right", J = "left", mi = "auto", Ye = [Z, dt, ht, J], _e = "start", Re = "end", La = "clippingParents", Gn = "viewport", ye = "popper", Ma = "reference", $n = /* @__PURE__ */ Ye.reduce(function(s, t) {
  return s.concat([t + "-" + _e, t + "-" + Re]);
}, []), qn = /* @__PURE__ */ [].concat(Ye, [mi]).reduce(function(s, t) {
  return s.concat([t, t + "-" + _e, t + "-" + Re]);
}, []), Na = "beforeRead", Ra = "read", Pa = "afterRead", Ha = "beforeMain", Ba = "main", Va = "afterMain", Wa = "beforeWrite", Fa = "write", Ya = "afterWrite", Es = [Na, Ra, Pa, Ha, Ba, Va, Wa, Fa, Ya];
function It(s) {
  return s ? (s.nodeName || "").toLowerCase() : null;
}
function ut(s) {
  if (s == null)
    return window;
  if (s.toString() !== "[object Window]") {
    var t = s.ownerDocument;
    return t && t.defaultView || window;
  }
  return s;
}
function me(s) {
  var t = ut(s).Element;
  return s instanceof t || s instanceof Element;
}
function ct(s) {
  var t = ut(s).HTMLElement;
  return s instanceof t || s instanceof HTMLElement;
}
function Qn(s) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = ut(s).ShadowRoot;
  return s instanceof t || s instanceof ShadowRoot;
}
function uc(s) {
  var t = s.state;
  Object.keys(t.elements).forEach(function(e) {
    var i = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];
    !ct(o) || !It(o) || (Object.assign(o.style, i), Object.keys(n).forEach(function(r) {
      var a = n[r];
      a === !1 ? o.removeAttribute(r) : o.setAttribute(r, a === !0 ? "" : a);
    }));
  });
}
function pc(s) {
  var t = s.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(i) {
      var n = t.elements[i], o = t.attributes[i] || {}, r = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), a = r.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !ct(n) || !It(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {
        n.removeAttribute(l);
      }));
    });
  };
}
const Zn = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: uc,
  effect: pc,
  requires: ["computeStyles"]
};
function gt(s) {
  return s.split("-")[0];
}
var pe = Math.max, Ts = Math.min, Pe = Math.round;
function Ln() {
  var s = navigator.userAgentData;
  return s != null && s.brands && Array.isArray(s.brands) ? s.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function ja() {
  return !/^((?!chrome|android).)*safari/i.test(Ln());
}
function He(s, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var i = s.getBoundingClientRect(), n = 1, o = 1;
  t && ct(s) && (n = s.offsetWidth > 0 && Pe(i.width) / s.offsetWidth || 1, o = s.offsetHeight > 0 && Pe(i.height) / s.offsetHeight || 1);
  var r = me(s) ? ut(s) : window, a = r.visualViewport, l = !ja() && e, c = (i.left + (l && a ? a.offsetLeft : 0)) / n, d = (i.top + (l && a ? a.offsetTop : 0)) / o, _ = i.width / n, f = i.height / o;
  return {
    width: _,
    height: f,
    top: d,
    right: c + _,
    bottom: d + f,
    left: c,
    x: c,
    y: d
  };
}
function Jn(s) {
  var t = He(s), e = s.offsetWidth, i = s.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
    x: s.offsetLeft,
    y: s.offsetTop,
    width: e,
    height: i
  };
}
function Ka(s, t) {
  var e = t.getRootNode && t.getRootNode();
  if (s.contains(t))
    return !0;
  if (e && Qn(e)) {
    var i = t;
    do {
      if (i && s.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function bt(s) {
  return ut(s).getComputedStyle(s);
}
function fc(s) {
  return ["table", "td", "th"].indexOf(It(s)) >= 0;
}
function qt(s) {
  return ((me(s) ? s.ownerDocument : (
    // $FlowFixMe[prop-missing]
    s.document
  )) || window.document).documentElement;
}
function ws(s) {
  return It(s) === "html" ? s : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    s.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    s.parentNode || // DOM Element detected
    (Qn(s) ? s.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    qt(s)
  );
}
function Co(s) {
  return !ct(s) || // https://github.com/popperjs/popper-core/issues/837
  bt(s).position === "fixed" ? null : s.offsetParent;
}
function _c(s) {
  var t = /firefox/i.test(Ln()), e = /Trident/i.test(Ln());
  if (e && ct(s)) {
    var i = bt(s);
    if (i.position === "fixed")
      return null;
  }
  var n = ws(s);
  for (Qn(n) && (n = n.host); ct(n) && ["html", "body"].indexOf(It(n)) < 0; ) {
    var o = bt(n);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function gi(s) {
  for (var t = ut(s), e = Co(s); e && fc(e) && bt(e).position === "static"; )
    e = Co(e);
  return e && (It(e) === "html" || It(e) === "body" && bt(e).position === "static") ? t : e || _c(s) || t;
}
function to(s) {
  return ["top", "bottom"].indexOf(s) >= 0 ? "x" : "y";
}
function li(s, t, e) {
  return pe(s, Ts(t, e));
}
function mc(s, t, e) {
  var i = li(s, t, e);
  return i > e ? e : i;
}
function Ua() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function za(s) {
  return Object.assign({}, Ua(), s);
}
function Xa(s, t) {
  return t.reduce(function(e, i) {
    return e[i] = s, e;
  }, {});
}
var gc = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, za(typeof t != "number" ? t : Xa(t, Ye));
};
function bc(s) {
  var t, e = s.state, i = s.name, n = s.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = gt(e.placement), l = to(a), c = [J, ht].indexOf(a) >= 0, d = c ? "height" : "width";
  if (!(!o || !r)) {
    var _ = gc(n.padding, e), f = Jn(o), m = l === "y" ? Z : J, g = l === "y" ? dt : ht, b = e.rects.reference[d] + e.rects.reference[l] - r[l] - e.rects.popper[d], T = r[l] - e.rects.reference[l], C = gi(o), w = C ? l === "y" ? C.clientHeight || 0 : C.clientWidth || 0 : 0, v = b / 2 - T / 2, E = _[m], A = w - f[d] - _[g], y = w / 2 - f[d] / 2 + v, S = li(E, y, A), O = l;
    e.modifiersData[i] = (t = {}, t[O] = S, t.centerOffset = S - y, t);
  }
}
function vc(s) {
  var t = s.state, e = s.options, i = e.element, n = i === void 0 ? "[data-popper-arrow]" : i;
  if (n != null && !(typeof n == "string" && (n = t.elements.popper.querySelector(n), !n))) {
    if ({}.NODE_ENV !== "production" && (ct(n) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !Ka(t.elements.popper, n)) {
      ({}).NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = n;
  }
}
const Ga = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: bc,
  effect: vc,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Be(s) {
  return s.split("-")[1];
}
var Ec = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Tc(s, t) {
  var e = s.x, i = s.y, n = t.devicePixelRatio || 1;
  return {
    x: Pe(e * n) / n || 0,
    y: Pe(i * n) / n || 0
  };
}
function Ao(s) {
  var t, e = s.popper, i = s.popperRect, n = s.placement, o = s.variation, r = s.offsets, a = s.position, l = s.gpuAcceleration, c = s.adaptive, d = s.roundOffsets, _ = s.isFixed, f = r.x, m = f === void 0 ? 0 : f, g = r.y, b = g === void 0 ? 0 : g, T = typeof d == "function" ? d({
    x: m,
    y: b
  }) : {
    x: m,
    y: b
  };
  m = T.x, b = T.y;
  var C = r.hasOwnProperty("x"), w = r.hasOwnProperty("y"), v = J, E = Z, A = window;
  if (c) {
    var y = gi(e), S = "clientHeight", O = "clientWidth";
    if (y === ut(e) && (y = qt(e), bt(y).position !== "static" && a === "absolute" && (S = "scrollHeight", O = "scrollWidth")), y = y, n === Z || (n === J || n === ht) && o === Re) {
      E = dt;
      var k = _ && y === A && A.visualViewport ? A.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        y[S]
      );
      b -= k - i.height, b *= l ? 1 : -1;
    }
    if (n === J || (n === Z || n === dt) && o === Re) {
      v = ht;
      var D = _ && y === A && A.visualViewport ? A.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        y[O]
      );
      m -= D - i.width, m *= l ? 1 : -1;
    }
  }
  var x = Object.assign({
    position: a
  }, c && Ec), $ = d === !0 ? Tc({
    x: m,
    y: b
  }, ut(e)) : {
    x: m,
    y: b
  };
  if (m = $.x, b = $.y, l) {
    var P;
    return Object.assign({}, x, (P = {}, P[E] = w ? "0" : "", P[v] = C ? "0" : "", P.transform = (A.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + b + "px)" : "translate3d(" + m + "px, " + b + "px, 0)", P));
  }
  return Object.assign({}, x, (t = {}, t[E] = w ? b + "px" : "", t[v] = C ? m + "px" : "", t.transform = "", t));
}
function Cc(s) {
  var t = s.state, e = s.options, i = e.gpuAcceleration, n = i === void 0 ? !0 : i, o = e.adaptive, r = o === void 0 ? !0 : o, a = e.roundOffsets, l = a === void 0 ? !0 : a;
  if ({}.NODE_ENV !== "production") {
    var c = bt(t.elements.popper).transitionProperty || "";
    r && ["transform", "top", "right", "bottom", "left"].some(function(_) {
      return c.indexOf(_) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var d = {
    placement: gt(t.placement),
    variation: Be(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Ao(Object.assign({}, d, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: r,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Ao(Object.assign({}, d, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const eo = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Cc,
  data: {}
};
var Di = {
  passive: !0
};
function Ac(s) {
  var t = s.state, e = s.instance, i = s.options, n = i.scroll, o = n === void 0 ? !0 : n, r = i.resize, a = r === void 0 ? !0 : r, l = ut(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && c.forEach(function(d) {
    d.addEventListener("scroll", e.update, Di);
  }), a && l.addEventListener("resize", e.update, Di), function() {
    o && c.forEach(function(d) {
      d.removeEventListener("scroll", e.update, Di);
    }), a && l.removeEventListener("resize", e.update, Di);
  };
}
const io = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: Ac,
  data: {}
};
var yc = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function ss(s) {
  return s.replace(/left|right|bottom|top/g, function(t) {
    return yc[t];
  });
}
var wc = {
  start: "end",
  end: "start"
};
function yo(s) {
  return s.replace(/start|end/g, function(t) {
    return wc[t];
  });
}
function so(s) {
  var t = ut(s), e = t.pageXOffset, i = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: i
  };
}
function no(s) {
  return He(qt(s)).left + so(s).scrollLeft;
}
function kc(s, t) {
  var e = ut(s), i = qt(s), n = e.visualViewport, o = i.clientWidth, r = i.clientHeight, a = 0, l = 0;
  if (n) {
    o = n.width, r = n.height;
    var c = ja();
    (c || !c && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: o,
    height: r,
    x: a + no(s),
    y: l
  };
}
function Oc(s) {
  var t, e = qt(s), i = so(s), n = (t = s.ownerDocument) == null ? void 0 : t.body, o = pe(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = pe(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + no(s), l = -i.scrollTop;
  return bt(n || e).direction === "rtl" && (a += pe(e.clientWidth, n ? n.clientWidth : 0) - o), {
    width: o,
    height: r,
    x: a,
    y: l
  };
}
function oo(s) {
  var t = bt(s), e = t.overflow, i = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + n + i);
}
function qa(s) {
  return ["html", "body", "#document"].indexOf(It(s)) >= 0 ? s.ownerDocument.body : ct(s) && oo(s) ? s : qa(ws(s));
}
function ci(s, t) {
  var e;
  t === void 0 && (t = []);
  var i = qa(s), n = i === ((e = s.ownerDocument) == null ? void 0 : e.body), o = ut(i), r = n ? [o].concat(o.visualViewport || [], oo(i) ? i : []) : i, a = t.concat(r);
  return n ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(ci(ws(r)))
  );
}
function Mn(s) {
  return Object.assign({}, s, {
    left: s.x,
    top: s.y,
    right: s.x + s.width,
    bottom: s.y + s.height
  });
}
function xc(s, t) {
  var e = He(s, !1, t === "fixed");
  return e.top = e.top + s.clientTop, e.left = e.left + s.clientLeft, e.bottom = e.top + s.clientHeight, e.right = e.left + s.clientWidth, e.width = s.clientWidth, e.height = s.clientHeight, e.x = e.left, e.y = e.top, e;
}
function wo(s, t, e) {
  return t === Gn ? Mn(kc(s, e)) : me(t) ? xc(t, e) : Mn(Oc(qt(s)));
}
function Sc(s) {
  var t = ci(ws(s)), e = ["absolute", "fixed"].indexOf(bt(s).position) >= 0, i = e && ct(s) ? gi(s) : s;
  return me(i) ? t.filter(function(n) {
    return me(n) && Ka(n, i) && It(n) !== "body";
  }) : [];
}
function Dc(s, t, e, i) {
  var n = t === "clippingParents" ? Sc(s) : [].concat(t), o = [].concat(n, [e]), r = o[0], a = o.reduce(function(l, c) {
    var d = wo(s, c, i);
    return l.top = pe(d.top, l.top), l.right = Ts(d.right, l.right), l.bottom = Ts(d.bottom, l.bottom), l.left = pe(d.left, l.left), l;
  }, wo(s, r, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function Qa(s) {
  var t = s.reference, e = s.element, i = s.placement, n = i ? gt(i) : null, o = i ? Be(i) : null, r = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;
  switch (n) {
    case Z:
      l = {
        x: r,
        y: t.y - e.height
      };
      break;
    case dt:
      l = {
        x: r,
        y: t.y + t.height
      };
      break;
    case ht:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case J:
      l = {
        x: t.x - e.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var c = n ? to(n) : null;
  if (c != null) {
    var d = c === "y" ? "height" : "width";
    switch (o) {
      case _e:
        l[c] = l[c] - (t[d] / 2 - e[d] / 2);
        break;
      case Re:
        l[c] = l[c] + (t[d] / 2 - e[d] / 2);
        break;
    }
  }
  return l;
}
function Ve(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = i === void 0 ? s.placement : i, o = e.strategy, r = o === void 0 ? s.strategy : o, a = e.boundary, l = a === void 0 ? La : a, c = e.rootBoundary, d = c === void 0 ? Gn : c, _ = e.elementContext, f = _ === void 0 ? ye : _, m = e.altBoundary, g = m === void 0 ? !1 : m, b = e.padding, T = b === void 0 ? 0 : b, C = za(typeof T != "number" ? T : Xa(T, Ye)), w = f === ye ? Ma : ye, v = s.rects.popper, E = s.elements[g ? w : f], A = Dc(me(E) ? E : E.contextElement || qt(s.elements.popper), l, d, r), y = He(s.elements.reference), S = Qa({
    reference: y,
    element: v,
    strategy: "absolute",
    placement: n
  }), O = Mn(Object.assign({}, v, S)), k = f === ye ? O : y, D = {
    top: A.top - k.top + C.top,
    bottom: k.bottom - A.bottom + C.bottom,
    left: A.left - k.left + C.left,
    right: k.right - A.right + C.right
  }, x = s.modifiersData.offset;
  if (f === ye && x) {
    var $ = x[n];
    Object.keys(D).forEach(function(P) {
      var tt = [ht, dt].indexOf(P) >= 0 ? 1 : -1, et = [Z, dt].indexOf(P) >= 0 ? "y" : "x";
      D[P] += $[et] * tt;
    });
  }
  return D;
}
function Ic(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, c = l === void 0 ? qn : l, d = Be(i), _ = d ? a ? $n : $n.filter(function(g) {
    return Be(g) === d;
  }) : Ye, f = _.filter(function(g) {
    return c.indexOf(g) >= 0;
  });
  f.length === 0 && (f = _, {}.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var m = f.reduce(function(g, b) {
    return g[b] = Ve(s, {
      placement: b,
      boundary: n,
      rootBoundary: o,
      padding: r
    })[gt(b)], g;
  }, {});
  return Object.keys(m).sort(function(g, b) {
    return m[g] - m[b];
  });
}
function $c(s) {
  if (gt(s) === mi)
    return [];
  var t = ss(s);
  return [yo(s), t, yo(t)];
}
function Lc(s) {
  var t = s.state, e = s.options, i = s.name;
  if (!t.modifiersData[i]._skip) {
    for (var n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !0 : r, l = e.fallbackPlacements, c = e.padding, d = e.boundary, _ = e.rootBoundary, f = e.altBoundary, m = e.flipVariations, g = m === void 0 ? !0 : m, b = e.allowedAutoPlacements, T = t.options.placement, C = gt(T), w = C === T, v = l || (w || !g ? [ss(T)] : $c(T)), E = [T].concat(v).reduce(function(be, Nt) {
      return be.concat(gt(Nt) === mi ? Ic(t, {
        placement: Nt,
        boundary: d,
        rootBoundary: _,
        padding: c,
        flipVariations: g,
        allowedAutoPlacements: b
      }) : Nt);
    }, []), A = t.rects.reference, y = t.rects.popper, S = /* @__PURE__ */ new Map(), O = !0, k = E[0], D = 0; D < E.length; D++) {
      var x = E[D], $ = gt(x), P = Be(x) === _e, tt = [Z, dt].indexOf($) >= 0, et = tt ? "width" : "height", z = Ve(t, {
        placement: x,
        boundary: d,
        rootBoundary: _,
        altBoundary: f,
        padding: c
      }), _t = tt ? P ? ht : J : P ? dt : Z;
      A[et] > y[et] && (_t = ss(_t));
      var wi = ss(_t), Zt = [];
      if (o && Zt.push(z[$] <= 0), a && Zt.push(z[_t] <= 0, z[wi] <= 0), Zt.every(function(be) {
        return be;
      })) {
        k = x, O = !1;
        break;
      }
      S.set(x, Zt);
    }
    if (O)
      for (var ki = g ? 3 : 1, Ns = function(Nt) {
        var Xe = E.find(function(xi) {
          var Jt = S.get(xi);
          if (Jt)
            return Jt.slice(0, Nt).every(function(Rs) {
              return Rs;
            });
        });
        if (Xe)
          return k = Xe, "break";
      }, ze = ki; ze > 0; ze--) {
        var Oi = Ns(ze);
        if (Oi === "break")
          break;
      }
    t.placement !== k && (t.modifiersData[i]._skip = !0, t.placement = k, t.reset = !0);
  }
}
const Za = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Lc,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function ko(s, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: s.top - t.height - e.y,
    right: s.right - t.width + e.x,
    bottom: s.bottom - t.height + e.y,
    left: s.left - t.width - e.x
  };
}
function Oo(s) {
  return [Z, ht, dt, J].some(function(t) {
    return s[t] >= 0;
  });
}
function Mc(s) {
  var t = s.state, e = s.name, i = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = Ve(t, {
    elementContext: "reference"
  }), a = Ve(t, {
    altBoundary: !0
  }), l = ko(r, i), c = ko(a, n, o), d = Oo(l), _ = Oo(c);
  t.modifiersData[e] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: d,
    hasPopperEscaped: _
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": d,
    "data-popper-escaped": _
  });
}
const Ja = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Mc
};
function Nc(s, t, e) {
  var i = gt(s), n = [J, Z].indexOf(i) >= 0 ? -1 : 1, o = typeof e == "function" ? e(Object.assign({}, t, {
    placement: s
  })) : e, r = o[0], a = o[1];
  return r = r || 0, a = (a || 0) * n, [J, ht].indexOf(i) >= 0 ? {
    x: a,
    y: r
  } : {
    x: r,
    y: a
  };
}
function Rc(s) {
  var t = s.state, e = s.options, i = s.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = qn.reduce(function(d, _) {
    return d[_] = Nc(_, t.rects, o), d;
  }, {}), a = r[t.placement], l = a.x, c = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[i] = r;
}
const tl = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Rc
};
function Pc(s) {
  var t = s.state, e = s.name;
  t.modifiersData[e] = Qa({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const ro = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Pc,
  data: {}
};
function Hc(s) {
  return s === "x" ? "y" : "x";
}
function Bc(s) {
  var t = s.state, e = s.options, i = s.name, n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !1 : r, l = e.boundary, c = e.rootBoundary, d = e.altBoundary, _ = e.padding, f = e.tether, m = f === void 0 ? !0 : f, g = e.tetherOffset, b = g === void 0 ? 0 : g, T = Ve(t, {
    boundary: l,
    rootBoundary: c,
    padding: _,
    altBoundary: d
  }), C = gt(t.placement), w = Be(t.placement), v = !w, E = to(C), A = Hc(E), y = t.modifiersData.popperOffsets, S = t.rects.reference, O = t.rects.popper, k = typeof b == "function" ? b(Object.assign({}, t.rects, {
    placement: t.placement
  })) : b, D = typeof k == "number" ? {
    mainAxis: k,
    altAxis: k
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, k), x = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, $ = {
    x: 0,
    y: 0
  };
  if (y) {
    if (o) {
      var P, tt = E === "y" ? Z : J, et = E === "y" ? dt : ht, z = E === "y" ? "height" : "width", _t = y[E], wi = _t + T[tt], Zt = _t - T[et], ki = m ? -O[z] / 2 : 0, Ns = w === _e ? S[z] : O[z], ze = w === _e ? -O[z] : -S[z], Oi = t.elements.arrow, be = m && Oi ? Jn(Oi) : {
        width: 0,
        height: 0
      }, Nt = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Ua(), Xe = Nt[tt], xi = Nt[et], Jt = li(0, S[z], be[z]), Rs = v ? S[z] / 2 - ki - Jt - Xe - D.mainAxis : Ns - Jt - Xe - D.mainAxis, Fl = v ? -S[z] / 2 + ki + Jt + xi + D.mainAxis : ze + Jt + xi + D.mainAxis, Ps = t.elements.arrow && gi(t.elements.arrow), Yl = Ps ? E === "y" ? Ps.clientTop || 0 : Ps.clientLeft || 0 : 0, ho = (P = x == null ? void 0 : x[E]) != null ? P : 0, jl = _t + Rs - ho - Yl, Kl = _t + Fl - ho, uo = li(m ? Ts(wi, jl) : wi, _t, m ? pe(Zt, Kl) : Zt);
      y[E] = uo, $[E] = uo - _t;
    }
    if (a) {
      var po, Ul = E === "x" ? Z : J, zl = E === "x" ? dt : ht, te = y[A], Si = A === "y" ? "height" : "width", fo = te + T[Ul], _o = te - T[zl], Hs = [Z, J].indexOf(C) !== -1, mo = (po = x == null ? void 0 : x[A]) != null ? po : 0, go = Hs ? fo : te - S[Si] - O[Si] - mo + D.altAxis, bo = Hs ? te + S[Si] + O[Si] - mo - D.altAxis : _o, vo = m && Hs ? mc(go, te, bo) : li(m ? go : fo, te, m ? bo : _o);
      y[A] = vo, $[A] = vo - te;
    }
    t.modifiersData[i] = $;
  }
}
const el = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: Bc,
  requiresIfExists: ["offset"]
};
function Vc(s) {
  return {
    scrollLeft: s.scrollLeft,
    scrollTop: s.scrollTop
  };
}
function Wc(s) {
  return s === ut(s) || !ct(s) ? so(s) : Vc(s);
}
function Fc(s) {
  var t = s.getBoundingClientRect(), e = Pe(t.width) / s.offsetWidth || 1, i = Pe(t.height) / s.offsetHeight || 1;
  return e !== 1 || i !== 1;
}
function Yc(s, t, e) {
  e === void 0 && (e = !1);
  var i = ct(t), n = ct(t) && Fc(t), o = qt(t), r = He(s, n, e), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !e) && ((It(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  oo(o)) && (a = Wc(t)), ct(t) ? (l = He(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = no(o))), {
    x: r.left + a.scrollLeft - l.x,
    y: r.top + a.scrollTop - l.y,
    width: r.width,
    height: r.height
  };
}
function jc(s) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];
  s.forEach(function(o) {
    t.set(o.name, o);
  });
  function n(o) {
    e.add(o.name);
    var r = [].concat(o.requires || [], o.requiresIfExists || []);
    r.forEach(function(a) {
      if (!e.has(a)) {
        var l = t.get(a);
        l && n(l);
      }
    }), i.push(o);
  }
  return s.forEach(function(o) {
    e.has(o.name) || n(o);
  }), i;
}
function Kc(s) {
  var t = jc(s);
  return Es.reduce(function(e, i) {
    return e.concat(t.filter(function(n) {
      return n.phase === i;
    }));
  }, []);
}
function Uc(s) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(s());
      });
    })), t;
  };
}
function Rt(s) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  return [].concat(e).reduce(function(n, o) {
    return n.replace(/%s/, o);
  }, s);
}
var ie = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', zc = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', xo = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function Xc(s) {
  s.forEach(function(t) {
    [].concat(Object.keys(t), xo).filter(function(e, i, n) {
      return n.indexOf(e) === i;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(Rt(ie, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(Rt(ie, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          Es.indexOf(t.phase) < 0 && console.error(Rt(ie, t.name, '"phase"', "either " + Es.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(Rt(ie, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(Rt(ie, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(Rt(ie, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(Rt(ie, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + xo.map(function(i) {
            return '"' + i + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(i) {
        s.find(function(n) {
          return n.name === i;
        }) == null && console.error(Rt(zc, String(t.name), i, i));
      });
    });
  });
}
function Gc(s, t) {
  var e = /* @__PURE__ */ new Set();
  return s.filter(function(i) {
    var n = t(i);
    if (!e.has(n))
      return e.add(n), !0;
  });
}
function qc(s) {
  var t = s.reduce(function(e, i) {
    var n = e[i.name];
    return e[i.name] = n ? Object.assign({}, n, i, {
      options: Object.assign({}, n.options, i.options),
      data: Object.assign({}, n.data, i.data)
    }) : i, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var So = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", Qc = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", Do = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Io() {
  for (var s = arguments.length, t = new Array(s), e = 0; e < s; e++)
    t[e] = arguments[e];
  return !t.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function ks(s) {
  s === void 0 && (s = {});
  var t = s, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? Do : n;
  return function(a, l, c) {
    c === void 0 && (c = o);
    var d = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Do, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, _ = [], f = !1, m = {
      state: d,
      setOptions: function(C) {
        var w = typeof C == "function" ? C(d.options) : C;
        b(), d.options = Object.assign({}, o, d.options, w), d.scrollParents = {
          reference: me(a) ? ci(a) : a.contextElement ? ci(a.contextElement) : [],
          popper: ci(l)
        };
        var v = Kc(qc([].concat(i, d.options.modifiers)));
        if (d.orderedModifiers = v.filter(function(x) {
          return x.enabled;
        }), {}.NODE_ENV !== "production") {
          var E = Gc([].concat(v, d.options.modifiers), function(x) {
            var $ = x.name;
            return $;
          });
          if (Xc(E), gt(d.options.placement) === mi) {
            var A = d.orderedModifiers.find(function(x) {
              var $ = x.name;
              return $ === "flip";
            });
            A || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var y = bt(l), S = y.marginTop, O = y.marginRight, k = y.marginBottom, D = y.marginLeft;
          [S, O, k, D].some(function(x) {
            return parseFloat(x);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return g(), m.update();
      },
      // Sync update â€“ it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var C = d.elements, w = C.reference, v = C.popper;
          if (!Io(w, v)) {
            ({}).NODE_ENV !== "production" && console.error(So);
            return;
          }
          d.rects = {
            reference: Yc(w, gi(v), d.options.strategy === "fixed"),
            popper: Jn(v)
          }, d.reset = !1, d.placement = d.options.placement, d.orderedModifiers.forEach(function(x) {
            return d.modifiersData[x.name] = Object.assign({}, x.data);
          });
          for (var E = 0, A = 0; A < d.orderedModifiers.length; A++) {
            if ({}.NODE_ENV !== "production" && (E += 1, E > 100)) {
              console.error(Qc);
              break;
            }
            if (d.reset === !0) {
              d.reset = !1, A = -1;
              continue;
            }
            var y = d.orderedModifiers[A], S = y.fn, O = y.options, k = O === void 0 ? {} : O, D = y.name;
            typeof S == "function" && (d = S({
              state: d,
              options: k,
              name: D,
              instance: m
            }) || d);
          }
        }
      },
      // Async and optimistically optimized update â€“ it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Uc(function() {
        return new Promise(function(T) {
          m.forceUpdate(), T(d);
        });
      }),
      destroy: function() {
        b(), f = !0;
      }
    };
    if (!Io(a, l))
      return {}.NODE_ENV !== "production" && console.error(So), m;
    m.setOptions(c).then(function(T) {
      !f && c.onFirstUpdate && c.onFirstUpdate(T);
    });
    function g() {
      d.orderedModifiers.forEach(function(T) {
        var C = T.name, w = T.options, v = w === void 0 ? {} : w, E = T.effect;
        if (typeof E == "function") {
          var A = E({
            state: d,
            name: C,
            instance: m,
            options: v
          }), y = function() {
          };
          _.push(A || y);
        }
      });
    }
    function b() {
      _.forEach(function(T) {
        return T();
      }), _ = [];
    }
    return m;
  };
}
var Zc = /* @__PURE__ */ ks(), Jc = [io, ro, eo, Zn], td = /* @__PURE__ */ ks({
  defaultModifiers: Jc
}), ed = [io, ro, eo, Zn, tl, Za, el, Ga, Ja], je = /* @__PURE__ */ ks({
  defaultModifiers: ed
});
const il = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  afterMain: Va,
  afterRead: Pa,
  afterWrite: Ya,
  applyStyles: Zn,
  arrow: Ga,
  auto: mi,
  basePlacements: Ye,
  beforeMain: Ha,
  beforeRead: Na,
  beforeWrite: Wa,
  bottom: dt,
  clippingParents: La,
  computeStyles: eo,
  createPopper: je,
  createPopperBase: Zc,
  createPopperLite: td,
  detectOverflow: Ve,
  end: Re,
  eventListeners: io,
  flip: Za,
  hide: Ja,
  left: J,
  main: Ba,
  modifierPhases: Es,
  offset: tl,
  placements: qn,
  popper: ye,
  popperGenerator: ks,
  popperOffsets: ro,
  preventOverflow: el,
  read: Ra,
  reference: Ma,
  right: ht,
  start: _e,
  top: Z,
  variationPlacements: $n,
  viewport: Gn,
  write: Fa
}, Symbol.toStringTag, { value: "Module" }));
function Fs(s) {
  return s === "true" ? !0 : s === "false" ? !1 : s === Number(s).toString() ? Number(s) : s === "" || s === "null" ? null : s;
}
function Ys(s) {
  return s.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
const p = {
  setDataAttribute(s, t, e) {
    s.setAttribute(`data-te-${Ys(t)}`, e);
  },
  removeDataAttribute(s, t) {
    s.removeAttribute(`data-te-${Ys(t)}`);
  },
  getDataAttributes(s) {
    if (!s)
      return {};
    const t = {};
    return Object.keys(s.dataset).filter((e) => e.startsWith("te")).forEach((e) => {
      if (e.startsWith("teClass"))
        return;
      let i = e.replace(/^te/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = Fs(s.dataset[e]);
    }), t;
  },
  getDataClassAttributes(s) {
    if (!s)
      return {};
    const t = {
      ...s.dataset
    };
    return Object.keys(t).filter((e) => e.startsWith("teClass")).forEach((e) => {
      let i = e.replace(/^teClass/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = Fs(t[e]);
    }), t;
  },
  getDataAttribute(s, t) {
    return Fs(
      s.getAttribute(`data-te-${Ys(t)}`)
    );
  },
  offset(s) {
    const t = s.getBoundingClientRect();
    return {
      top: t.top + document.body.scrollTop,
      left: t.left + document.body.scrollLeft
    };
  },
  position(s) {
    return {
      top: s.offsetTop,
      left: s.offsetLeft
    };
  },
  style(s, t) {
    Object.assign(s.style, t);
  },
  toggleClass(s, t) {
    s && js(t).forEach((e) => {
      s.classList.contains(e) ? s.classList.remove(e) : s.classList.add(e);
    });
  },
  addClass(s, t) {
    js(t).forEach(
      (e) => !s.classList.contains(e) && s.classList.add(e)
    );
  },
  addStyle(s, t) {
    Object.keys(t).forEach((e) => {
      s.style[e] = t[e];
    });
  },
  removeClass(s, t) {
    js(t).forEach(
      (e) => s.classList.contains(e) && s.classList.remove(e)
    );
  },
  hasClass(s, t) {
    return s.classList.contains(t);
  }
};
function js(s) {
  return typeof s == "string" ? s.split(" ") : Array.isArray(s) ? s : !1;
}
const id = 3, h = {
  closest(s, t) {
    return s.closest(t);
  },
  matches(s, t) {
    return s.matches(t);
  },
  find(s, t = document.documentElement) {
    return [].concat(
      ...Element.prototype.querySelectorAll.call(t, s)
    );
  },
  findOne(s, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, s);
  },
  children(s, t) {
    return [].concat(...s.children).filter((i) => i.matches(t));
  },
  parents(s, t) {
    const e = [];
    let i = s.parentNode;
    for (; i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== id; )
      this.matches(i, t) && e.push(i), i = i.parentNode;
    return e;
  },
  prev(s, t) {
    let e = s.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  next(s, t) {
    let e = s.nextElementSibling;
    for (; e; ) {
      if (this.matches(e, t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  },
  focusableChildren(s) {
    const t = [
      "a",
      "button",
      "input",
      "textarea",
      "select",
      "details",
      "[tabindex]",
      '[contenteditable="true"]'
    ].map((e) => `${e}:not([tabindex^="-"])`).join(", ");
    return this.find(t, s).filter(
      (e) => !ue(e) && St(e)
    );
  }
}, Ks = "dropdown", sd = "te.dropdown", ge = `.${sd}`, ao = ".data-api", ns = "Escape", $o = "Space", Lo = "Tab", Nn = "ArrowUp", os = "ArrowDown", nd = 2, od = new RegExp(
  `${Nn}|${os}|${ns}`
), rd = `hide${ge}`, ad = `hidden${ge}`, ld = `show${ge}`, cd = `shown${ge}`, dd = `click${ge}${ao}`, Mo = `keydown${ge}${ao}`, hd = `keyup${ge}${ao}`, Pt = "show", ud = "dropup", pd = "dropend", fd = "dropstart", _d = "[data-te-navbar-ref]", Ii = "[data-te-dropdown-toggle-ref]", Us = "[data-te-dropdown-menu-ref]", md = "[data-te-navbar-nav-ref]", gd = "[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)", bd = F() ? "top-end" : "top-start", vd = F() ? "top-start" : "top-end", Ed = F() ? "bottom-end" : "bottom-start", Td = F() ? "bottom-start" : "bottom-end", Cd = F() ? "left-start" : "right-start", Ad = F() ? "right-start" : "left-start", yd = [{ opacity: "0" }, { opacity: "1" }], wd = [{ opacity: "1" }, { opacity: "0" }], $i = {
  duration: 550,
  iterations: 1,
  easing: "ease",
  fill: "both"
}, kd = {
  offset: [0, 2],
  boundary: "clippingParents",
  reference: "toggle",
  display: "dynamic",
  popperConfig: null,
  autoClose: !0,
  dropdownAnimation: "on"
}, Od = {
  offset: "(array|string|function)",
  boundary: "(string|element)",
  reference: "(string|element|object)",
  display: "string",
  popperConfig: "(null|object|function)",
  autoClose: "(boolean|string)",
  dropdownAnimation: "string"
};
class wt extends vt {
  constructor(t, e) {
    super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._fadeOutAnimate = null;
    const i = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    this._animationCanPlay = this._config.dropdownAnimation === "on" && !i, this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return kd;
  }
  static get DefaultType() {
    return Od;
  }
  static get NAME() {
    return Ks;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (ue(this._element) || this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    if (u.trigger(
      this._element,
      ld,
      t
    ).defaultPrevented)
      return;
    const i = wt.getParentFromElement(this._element);
    this._inNavbar ? p.setDataAttribute(this._menu, "popper", "none") : this._createPopper(i), "ontouchstart" in document.documentElement && !i.closest(md) && [].concat(...document.body.children).forEach((n) => u.on(n, "mouseover", vs)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.setAttribute(`data-te-dropdown-${Pt}`, ""), this._animationCanPlay && this._menu.animate(yd, $i), this._element.setAttribute(`data-te-dropdown-${Pt}`, ""), setTimeout(
      () => {
        u.trigger(this._element, cd, t);
      },
      this._animationCanPlay ? $i.duration : 0
    );
  }
  hide() {
    if (ue(this._element) || !this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    this._completeHide(t);
  }
  dispose() {
    this._popper && this._popper.destroy(), super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
  }
  // Private
  _init() {
    this._didInit || (u.on(
      document,
      Mo,
      Ii,
      wt.dataApiKeydownHandler
    ), u.on(
      document,
      Mo,
      Us,
      wt.dataApiKeydownHandler
    ), u.on(document, dd, wt.clearMenus), u.on(document, hd, wt.clearMenus), this._didInit = !0);
  }
  _completeHide(t) {
    this._fadeOutAnimate && this._fadeOutAnimate.playState === "running" || u.trigger(
      this._element,
      rd,
      t
    ).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((i) => u.off(i, "mouseover", vs)), this._animationCanPlay && (this._fadeOutAnimate = this._menu.animate(
      wd,
      $i
    )), setTimeout(
      () => {
        this._popper && this._popper.destroy(), this._menu.removeAttribute(`data-te-dropdown-${Pt}`), this._element.removeAttribute(`data-te-dropdown-${Pt}`), this._element.setAttribute("aria-expanded", "false"), p.removeDataAttribute(this._menu, "popper"), u.trigger(this._element, ad, t);
      },
      this._animationCanPlay ? $i.duration : 0
    ));
  }
  _getConfig(t) {
    if (t = {
      ...this.constructor.Default,
      ...p.getDataAttributes(this._element),
      ...t
    }, N(Ks, t, this.constructor.DefaultType), typeof t.reference == "object" && !Ne(t.reference) && typeof t.reference.getBoundingClientRect != "function")
      throw new TypeError(
        `${Ks.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
      );
    return t;
  }
  _createPopper(t) {
    if (typeof il > "u")
      throw new TypeError(
        "Bootstrap's dropdowns require Popper (https://popper.js.org)"
      );
    let e = this._element;
    this._config.reference === "parent" ? e = t : Ne(this._config.reference) ? e = Gt(this._config.reference) : typeof this._config.reference == "object" && (e = this._config.reference);
    const i = this._getPopperConfig(), n = i.modifiers.find(
      (o) => o.name === "applyStyles" && o.enabled === !1
    );
    this._popper = je(
      e,
      this._menu,
      i
    ), n && p.setDataAttribute(this._menu, "popper", "static");
  }
  _isShown(t = this._element) {
    return t.dataset[`teDropdown${Pt.charAt(0).toUpperCase() + Pt.slice(1)}`] === "";
  }
  _getMenuElement() {
    return h.next(this._element, Us)[0];
  }
  _getPlacement() {
    const t = this._element.parentNode;
    if (t.dataset.teDropdownPosition === pd)
      return Cd;
    if (t.dataset.teDropdownPosition === fd)
      return Ad;
    const e = getComputedStyle(this._menu).getPropertyValue("--te-position").trim() === "end";
    return t.dataset.teDropdownPosition === ud ? e ? vd : bd : e ? Td : Ed;
  }
  _detectNavbar() {
    return this._element.closest(_d) !== null;
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _getPopperConfig() {
    const t = {
      placement: this._getPlacement(),
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }
      ]
    };
    return this._config.display === "static" && (t.modifiers = [
      {
        name: "applyStyles",
        enabled: !1
      }
    ]), {
      ...t,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig
    };
  }
  _selectMenuItem({ key: t, target: e }) {
    const i = h.find(
      gd,
      this._menu
    ).filter(St);
    i.length && wa(
      i,
      e,
      t === os,
      !i.includes(e)
    ).focus();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = wt.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static clearMenus(t) {
    if (t && (t.button === nd || t.type === "keyup" && t.key !== Lo))
      return;
    const e = h.find(Ii);
    for (let i = 0, n = e.length; i < n; i++) {
      const o = wt.getInstance(e[i]);
      if (!o || o._config.autoClose === !1 || !o._isShown())
        continue;
      const r = {
        relatedTarget: o._element
      };
      if (t) {
        const a = t.composedPath(), l = a.includes(o._menu);
        if (a.includes(o._element) || o._config.autoClose === "inside" && !l || o._config.autoClose === "outside" && l || o._menu.contains(t.target) && (t.type === "keyup" && t.key === Lo || /input|select|option|textarea|form/i.test(t.target.tagName)))
          continue;
        t.type === "click" && (r.clickEvent = t);
      }
      o._completeHide(r);
    }
  }
  static getParentFromElement(t) {
    return Xt(t) || t.parentNode;
  }
  static dataApiKeydownHandler(t) {
    if (/input|textarea/i.test(t.target.tagName) ? t.key === $o || t.key !== ns && (t.key !== os && t.key !== Nn || t.target.closest(Us)) : !od.test(t.key))
      return;
    const e = this.dataset[`teDropdown${Pt.charAt(0).toUpperCase() + Pt.slice(1)}`] === "";
    if (!e && t.key === ns || (t.preventDefault(), t.stopPropagation(), ue(this)))
      return;
    const i = this.matches(Ii) ? this : h.prev(this, Ii)[0], n = wt.getOrCreateInstance(i);
    if (t.key === ns) {
      n.hide();
      return;
    }
    if (t.key === Nn || t.key === os) {
      e || n.show(), n._selectMenuItem(t);
      return;
    }
    (!e || t.key === $o) && wt.clearMenus();
  }
}
const zs = "collapse", sl = "te.collapse", Os = `.${sl}`, No = {
  toggle: !0,
  parent: null
}, xd = {
  toggle: "boolean",
  parent: "(null|element)"
}, Sd = `show${Os}`, Dd = `shown${Os}`, Id = `hide${Os}`, $d = `hidden${Os}`, Xs = "data-te-collapse-show", Ro = "data-te-collapse-collapsed", Li = "data-te-collapse-collapsing", Ld = "data-te-collapse-horizontal", Oe = "data-te-collapse-item", Po = `:scope [${Oe}] [${Oe}]`, Md = "width", Nd = "height", Rd = "[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]", Ho = "[data-te-collapse-init]", Pd = {
  visible: "!visible",
  hidden: "hidden",
  baseTransition: "overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsing: "h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsingHorizontal: "w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none"
}, Hd = {
  visible: "string",
  hidden: "string",
  baseTransition: "string",
  collapsing: "string",
  collapsingHorizontal: "string"
};
class Ut extends vt {
  constructor(t, e, i) {
    super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._triggerArray = [];
    const n = h.find(Ho);
    for (let o = 0, r = n.length; o < r; o++) {
      const a = n[o], l = Xn(a), c = h.find(l).filter(
        (d) => d === this._element
      );
      l !== null && c.length && (this._selector = l, this._triggerArray.push(a));
    }
    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
  }
  // Getters
  static get Default() {
    return No;
  }
  static get NAME() {
    return zs;
  }
  // Public
  toggle() {
    this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (this._isTransitioning || this._isShown())
      return;
    let t = [], e;
    if (this._config.parent) {
      const d = h.find(
        Po,
        this._config.parent
      );
      t = h.find(
        Rd,
        this._config.parent
      ).filter((_) => !d.includes(_));
    }
    const i = h.findOne(this._selector);
    if (t.length) {
      const d = t.find((_) => i !== _);
      if (e = d ? Ut.getInstance(d) : null, e && e._isTransitioning)
        return;
    }
    if (u.trigger(this._element, Sd).defaultPrevented)
      return;
    t.forEach((d) => {
      i !== d && Ut.getOrCreateInstance(d, { toggle: !1 }).hide(), e || I.setData(d, sl, null);
    });
    const o = this._getDimension(), r = o === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    p.removeClass(this._element, this._classes.visible), p.removeClass(this._element, this._classes.hidden), p.addClass(this._element, r), this._element.removeAttribute(Oe), this._element.setAttribute(Li, ""), this._element.style[o] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
    const a = () => {
      this._isTransitioning = !1, p.removeClass(this._element, this._classes.hidden), p.removeClass(this._element, r), p.addClass(this._element, this._classes.visible), this._element.removeAttribute(Li), this._element.setAttribute(Oe, ""), this._element.setAttribute(Xs, ""), this._element.style[o] = "", u.trigger(this._element, Dd);
    }, c = `scroll${o[0].toUpperCase() + o.slice(1)}`;
    this._queueCallback(a, this._element, !0), this._element.style[o] = `${this._element[c]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown() || u.trigger(this._element, Id).defaultPrevented)
      return;
    const e = this._getDimension(), i = e === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Fe(this._element), p.addClass(this._element, i), p.removeClass(this._element, this._classes.visible), p.removeClass(this._element, this._classes.hidden), this._element.setAttribute(Li, ""), this._element.removeAttribute(Oe), this._element.removeAttribute(Xs);
    const n = this._triggerArray.length;
    for (let r = 0; r < n; r++) {
      const a = this._triggerArray[r], l = Xt(a);
      l && !this._isShown(l) && this._addAriaAndCollapsedClass([a], !1);
    }
    this._isTransitioning = !0;
    const o = () => {
      this._isTransitioning = !1, p.removeClass(this._element, i), p.addClass(this._element, this._classes.visible), p.addClass(this._element, this._classes.hidden), this._element.removeAttribute(Li), this._element.setAttribute(Oe, ""), u.trigger(this._element, $d);
    };
    this._element.style[e] = "", this._queueCallback(o, this._element, !0);
  }
  _isShown(t = this._element) {
    return t.hasAttribute(Xs);
  }
  // Private
  _getConfig(t) {
    return t = {
      ...No,
      ...p.getDataAttributes(this._element),
      ...t
    }, t.toggle = !!t.toggle, t.parent = Gt(t.parent), N(zs, t, xd), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...Pd,
      ...e,
      ...t
    }, N(zs, t, Hd), t;
  }
  _getDimension() {
    return this._element.hasAttribute(Ld) ? Md : Nd;
  }
  _initializeChildren() {
    if (!this._config.parent)
      return;
    const t = h.find(
      Po,
      this._config.parent
    );
    h.find(Ho, this._config.parent).filter((e) => !t.includes(e)).forEach((e) => {
      const i = Xt(e);
      i && this._addAriaAndCollapsedClass([e], this._isShown(i));
    });
  }
  _addAriaAndCollapsedClass(t, e) {
    t.length && t.forEach((i) => {
      e ? i.removeAttribute(Ro) : i.setAttribute(`${Ro}`, ""), i.setAttribute("aria-expanded", e);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = {};
      typeof t == "string" && /show|hide/.test(t) && (e.toggle = !1);
      const i = Ut.getOrCreateInstance(this, e);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t]();
      }
    });
  }
}
const Bo = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", Vo = ".sticky-top";
class pi {
  constructor() {
    this._element = document.body;
  }
  getWidth() {
    const t = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - t);
  }
  hide() {
    const t = this.getWidth();
    this._disableOverFlow(), this._setElementAttributes(
      this._element,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      Bo,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      Vo,
      "marginRight",
      (e) => e - t
    );
  }
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
  }
  _setElementAttributes(t, e, i) {
    const n = this.getWidth(), o = (r) => {
      if (r !== this._element && window.innerWidth > r.clientWidth + n)
        return;
      this._saveInitialAttribute(r, e);
      const a = window.getComputedStyle(r)[e];
      r.style[e] = `${i(
        Number.parseFloat(a)
      )}px`;
    };
    this._applyManipulationCallback(t, o);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(Bo, "paddingRight"), this._resetElementAttributes(Vo, "marginRight");
  }
  _saveInitialAttribute(t, e) {
    const i = t.style[e];
    i && p.setDataAttribute(t, e, i);
  }
  _resetElementAttributes(t, e) {
    const i = (n) => {
      const o = p.getDataAttribute(n, e);
      typeof o > "u" ? n.style.removeProperty(e) : (p.removeDataAttribute(n, e), n.style[e] = o);
    };
    this._applyManipulationCallback(t, i);
  }
  _applyManipulationCallback(t, e) {
    Ne(t) ? e(t) : h.find(t, this._element).forEach(e);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
}
const Bd = {
  isVisible: !0,
  // if false, we use the backdrop helper without adding any element to the dom
  isAnimated: !1,
  rootElement: "body",
  // give the choice to place backdrop under different elements
  clickCallback: null,
  backdropClasses: null
}, Vd = {
  isVisible: "boolean",
  isAnimated: "boolean",
  rootElement: "(element|string)",
  clickCallback: "(function|null)",
  backdropClasses: "(array|null)"
}, nl = "backdrop", Wo = `mousedown.te.${nl}`;
class lo {
  constructor(t) {
    this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
  }
  show(t) {
    if (!this._config.isVisible) {
      he(t);
      return;
    }
    this._append(), this._config.isAnimated && Fe(this._getElement());
    const e = this._config.backdropClasses || [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      "fixed",
      "top-0",
      "left-0",
      "z-[1040]",
      "bg-black",
      "w-screen",
      "h-screen"
    ];
    p.removeClass(this._getElement(), "opacity-0"), p.addClass(this._getElement(), e), this._element.setAttribute("data-te-backdrop-show", ""), this._emulateAnimation(() => {
      he(t);
    });
  }
  hide(t) {
    if (!this._config.isVisible) {
      he(t);
      return;
    }
    this._element.removeAttribute("data-te-backdrop-show"), this._getElement().classList.add("opacity-0"), this._getElement().classList.remove("opacity-50"), this._emulateAnimation(() => {
      this.dispose(), he(t);
    });
  }
  // Private
  _getElement() {
    if (!this._element) {
      const t = document.createElement("div");
      t.className = this._config.className, this._config.isAnimated && t.classList.add("opacity-50"), this._element = t;
    }
    return this._element;
  }
  _getConfig(t) {
    return t = {
      ...Bd,
      ...typeof t == "object" ? t : {}
    }, t.rootElement = Gt(t.rootElement), N(nl, t, Vd), t;
  }
  _append() {
    this._isAppended || (this._config.rootElement.append(this._getElement()), u.on(this._getElement(), Wo, () => {
      he(this._config.clickCallback);
    }), this._isAppended = !0);
  }
  dispose() {
    this._isAppended && (u.off(this._element, Wo), this._element.remove(), this._isAppended = !1);
  }
  _emulateAnimation(t) {
    ya(
      t,
      this._getElement(),
      this._config.isAnimated
    );
  }
}
class bi {
  constructor(t, e = {}, i) {
    this._element = t, this._toggler = i, this._event = e.event || "blur", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {
      this._condition(n) && !n.shiftKey && n.target === this._lastElement ? (n.preventDefault(), this._firstElement.focus()) : this._condition(n) && n.shiftKey && n.target === this._firstElement && (n.preventDefault(), this._lastElement.focus());
    };
  }
  trap() {
    this._setElements(), this._init(), this._setFocusTrap();
  }
  disable() {
    this._focusableElements.forEach((t) => {
      t.removeEventListener(this._event, this.handler);
    }), this._toggler && this._toggler.focus();
  }
  update() {
    this._setElements(), this._setFocusTrap();
  }
  _init() {
    const t = (e) => {
      !this._firstElement || e.key !== "Tab" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener("keydown", t));
    };
    window.addEventListener("keydown", t);
  }
  _filterVisible(t) {
    return t.filter((e) => {
      if (!St(e))
        return !1;
      const i = h.parents(e, "*");
      for (let n = 0; n < i.length; n++) {
        const o = window.getComputedStyle(i[n]);
        if (o && (o.display === "none" || o.visibility === "hidden"))
          return !1;
      }
      return !0;
    });
  }
  _setElements() {
    this._focusableElements = h.focusableChildren(this._element), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];
  }
  _setFocusTrap() {
    this._focusableElements.forEach((t, e) => {
      e === this._focusableElements.length - 1 || e === 0 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);
    });
  }
}
const xs = (s, t = "hide") => {
  const e = `click.dismiss${s.EVENT_KEY}`, i = s.NAME;
  u.on(
    document,
    e,
    `[data-te-${i}-dismiss]`,
    function(n) {
      if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), ue(this))
        return;
      const o = Xt(this) || this.closest(`.${i}`) || this.closest(`[data-te-${i}-init]`);
      if (!o)
        return;
      s.getOrCreateInstance(o)[t]();
    }
  );
}, Fo = "offcanvas", Wd = "te.offcanvas", Ke = `.${Wd}`, Fd = ".data-api", Yd = `load${Ke}${Fd}`, jd = "Escape", Yo = {
  backdrop: !0,
  keyboard: !0,
  scroll: !1
}, Kd = {
  backdrop: "boolean",
  keyboard: "boolean",
  scroll: "boolean"
}, jo = "show", Ud = "[data-te-offcanvas-init][data-te-offcanvas-show]", zd = `show${Ke}`, Xd = `shown${Ke}`, Gd = `hide${Ke}`, qd = `hidden${Ke}`, Qd = `keydown.dismiss${Ke}`;
class rs extends vt {
  constructor(t, e) {
    super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return Fo;
  }
  static get Default() {
    return Yo;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    if (this._isShown || u.trigger(this._element, zd, {
      relatedTarget: t
    }).defaultPrevented)
      return;
    this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || new pi().hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`data-te-offcanvas-${jo}`, "");
    const i = () => {
      this._config.scroll || this._focustrap.trap(), u.trigger(this._element, Xd, { relatedTarget: t });
    };
    this._queueCallback(i, this._element, !0);
  }
  hide() {
    if (!this._isShown || u.trigger(this._element, Gd).defaultPrevented)
      return;
    this._focustrap.disable(), this._element.blur(), this._isShown = !1, this._element.removeAttribute(`data-te-offcanvas-${jo}`), this._backdrop.hide();
    const e = () => {
      this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new pi().reset(), u.trigger(this._element, qd);
    };
    this._queueCallback(e, this._element, !0);
  }
  dispose() {
    this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (u.on(
      window,
      Yd,
      () => h.find(Ud).forEach(
        (t) => rs.getOrCreateInstance(t).show()
      )
    ), xs(rs), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...Yo,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, N(Fo, t, Kd), t;
  }
  _initializeBackDrop() {
    return new lo({
      isVisible: this._config.backdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      clickCallback: () => this.hide()
    });
  }
  _initializeFocusTrap() {
    return new bi(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _addEventListeners() {
    u.on(this._element, Qd, (t) => {
      this._config.keyboard && t.key === jd && this.hide();
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = rs.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const Gs = "alert", Zd = "te.alert", ol = `.${Zd}`, Jd = `close${ol}`, th = `closed${ol}`, Ge = "data-te-alert-show", eh = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, Ko = {
  animation: !0,
  autohide: !0,
  delay: 1e3
}, ih = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, sh = {
  fadeIn: "string",
  fadeOut: "string"
};
class Rn extends vt {
  constructor(t, e, i) {
    super(t), this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._didInit = !1, this._init();
  }
  // Getters
  static get DefaultType() {
    return eh;
  }
  static get Default() {
    return Ko;
  }
  static get NAME() {
    return Gs;
  }
  // Public
  close() {
    if (u.trigger(this._element, Jd).defaultPrevented)
      return;
    let e = 0;
    this._config.animation && (e = 300, p.addClass(this._element, this._classes.fadeOut)), this._element.removeAttribute(Ge), setTimeout(() => {
      this._queueCallback(
        () => this._destroyElement(),
        this._element,
        this._config.animation
      );
    }, e);
  }
  show() {
    if (this._element) {
      if (this._config.autohide && this._setupAutohide(), !this._element.hasAttribute(Ge) && (p.removeClass(this._element, "hidden"), p.addClass(this._element, "block"), St(this._element))) {
        const t = (e) => {
          p.removeClass(this._element, "hidden"), p.addClass(this._element, "block"), u.off(e.target, "animationend", t);
        };
        this._element.setAttribute(Ge, ""), u.on(this._element, "animationend", t);
      }
      this._config.animation && (p.removeClass(this._element, this._classes.fadeOut), p.addClass(this._element, this._classes.fadeIn));
    }
  }
  hide() {
    if (this._element && this._element.hasAttribute(Ge)) {
      this._element.removeAttribute(Ge);
      const t = (e) => {
        p.addClass(this._element, "hidden"), p.removeClass(this._element, "block"), this._timeout !== null && (clearTimeout(this._timeout), this._timeout = null), u.off(e.target, "animationend", t);
      };
      u.on(this._element, "animationend", t), p.removeClass(this._element, this._classes.fadeIn), p.addClass(this._element, this._classes.fadeOut);
    }
  }
  // Private
  _init() {
    this._didInit || (xs(Rn, "close"), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...Ko,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, N(Gs, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...ih,
      ...e,
      ...t
    }, N(Gs, t, sh), t;
  }
  _setupAutohide() {
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _destroyElement() {
    this._element.remove(), u.trigger(this._element, th), this.dispose();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Rn.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const qs = "carousel", nh = "te.carousel", pt = `.${nh}`, rl = ".data-api", oh = "ArrowLeft", rh = "ArrowRight", ah = 500, lh = 40, Uo = {
  interval: 5e3,
  keyboard: !0,
  slide: !1,
  pause: "hover",
  wrap: !0,
  touch: !0
}, ch = {
  interval: "(number|boolean)",
  keyboard: "boolean",
  slide: "(boolean|string)",
  pause: "(string|boolean)",
  wrap: "boolean",
  touch: "boolean"
}, dh = {
  pointer: "touch-pan-y",
  block: "!block",
  visible: "data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]",
  invisible: "data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-0 data-[te-carousel-fade]:delay-600",
  slideRight: "translate-x-full",
  slideLeft: "-translate-x-full"
}, hh = {
  pointer: "string",
  block: "string",
  visible: "string",
  invisible: "string",
  slideRight: "string",
  slideLeft: "string"
}, se = "next", ne = "prev", ce = "left", si = "right", uh = {
  [oh]: si,
  [rh]: ce
}, ph = `slide${pt}`, zo = `slid${pt}`, fh = `keydown${pt}`, _h = `mouseenter${pt}`, mh = `mouseleave${pt}`, gh = `touchstart${pt}`, bh = `touchmove${pt}`, vh = `touchend${pt}`, Eh = `pointerdown${pt}`, Th = `pointerup${pt}`, Ch = `dragstart${pt}`, Ah = `load${pt}${rl}`, yh = `click${pt}${rl}`, wh = "data-te-carousel-init", oe = "data-te-carousel-active", kh = "data-te-carousel-slide", Oh = "data-te-carousel-item-end", Qs = "data-te-carousel-item-start", xh = "data-te-carousel-item-next", Sh = "data-te-carousel-item-prev", Dh = "data-te-carousel-pointer-event", Ih = "[data-te-carousel-init]", al = "[data-te-carousel-active]", co = "[data-te-carousel-item]", ve = `${al}${co}`, $h = `${co} img`, Lh = "[data-te-carousel-item-next], [data-te-carousel-item-prev]", Mh = "[data-te-carousel-indicators]", Nh = "[data-te-target]", Rh = "[data-te-slide], [data-te-slide-to]", Ph = "touch", Hh = "pen";
class Yt extends vt {
  constructor(t, e, i) {
    super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._indicatorsElement = h.findOne(
      Mh,
      this._element
    ), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = !!window.PointerEvent, this._setActiveElementClass(), this._addEventListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return Uo;
  }
  static get NAME() {
    return qs;
  }
  // Public
  next() {
    this._slide(se);
  }
  nextWhenVisible() {
    !document.hidden && St(this._element) && this.next();
  }
  prev() {
    this._slide(ne);
  }
  pause(t) {
    t || (this._isPaused = !0), h.findOne(Lh, this._element) && (Ea(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;
  }
  cycle(t) {
    t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval(
      (document.visibilityState ? this.nextWhenVisible : this.next).bind(
        this
      ),
      this._config.interval
    ));
  }
  to(t) {
    this._activeElement = h.findOne(
      ve,
      this._element
    );
    const e = this._getItemIndex(this._activeElement);
    if (t > this._items.length - 1 || t < 0)
      return;
    if (this._isSliding) {
      u.one(this._element, zo, () => this.to(t));
      return;
    }
    if (e === t) {
      this.pause(), this.cycle();
      return;
    }
    const i = t > e ? se : ne;
    this._slide(i, this._items[t]);
  }
  // Private
  _init() {
    this._didInit || (u.on(
      document,
      yh,
      Rh,
      Yt.dataApiClickHandler
    ), u.on(window, Ah, () => {
      const t = h.find(Ih);
      for (let e = 0, i = t.length; e < i; e++)
        Yt.carouselInterface(
          t[e],
          Yt.getInstance(t[e])
        );
    }), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...Uo,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, N(qs, t, ch), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...dh,
      ...e,
      ...t
    }, N(qs, t, hh), t;
  }
  _applyInitialClasses() {
    const t = h.findOne(
      ve,
      this._element
    );
    t.classList.add(
      this._classes.block,
      ...this._classes.visible.split(" ")
    ), this._setActiveIndicatorElement(t);
  }
  _handleSwipe() {
    const t = Math.abs(this.touchDeltaX);
    if (t <= lh)
      return;
    const e = t / this.touchDeltaX;
    this.touchDeltaX = 0, e && this._slide(e > 0 ? si : ce);
  }
  _setActiveElementClass() {
    this._activeElement = h.findOne(
      ve,
      this._element
    ), p.addClass(this._activeElement, "hidden");
  }
  _addEventListeners() {
    this._config.keyboard && u.on(
      this._element,
      fh,
      (t) => this._keydown(t)
    ), this._config.pause === "hover" && (u.on(
      this._element,
      _h,
      (t) => this.pause(t)
    ), u.on(
      this._element,
      mh,
      (t) => this.cycle(t)
    )), this._config.touch && this._touchSupported && this._addTouchEventListeners(), this._applyInitialClasses();
  }
  _addTouchEventListeners() {
    const t = (o) => this._pointerEvent && (o.pointerType === Hh || o.pointerType === Ph), e = (o) => {
      t(o) ? this.touchStartX = o.clientX : this._pointerEvent || (this.touchStartX = o.touches[0].clientX);
    }, i = (o) => {
      this.touchDeltaX = o.touches && o.touches.length > 1 ? 0 : o.touches[0].clientX - this.touchStartX;
    }, n = (o) => {
      t(o) && (this.touchDeltaX = o.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(
        (r) => this.cycle(r),
        ah + this._config.interval
      ));
    };
    h.find($h, this._element).forEach(
      (o) => {
        u.on(
          o,
          Ch,
          (r) => r.preventDefault()
        );
      }
    ), this._pointerEvent ? (u.on(
      this._element,
      Eh,
      (o) => e(o)
    ), u.on(this._element, Th, (o) => n(o)), this._element.classList.add(this._classes.pointer), this._element.setAttribute(`${Dh}`, "")) : (u.on(this._element, gh, (o) => e(o)), u.on(this._element, bh, (o) => i(o)), u.on(this._element, vh, (o) => n(o)));
  }
  _keydown(t) {
    if (/input|textarea/i.test(t.target.tagName))
      return;
    const e = uh[t.key];
    e && (t.preventDefault(), this._slide(e));
  }
  _getItemIndex(t) {
    return this._items = t && t.parentNode ? h.find(co, t.parentNode) : [], this._items.indexOf(t);
  }
  _getItemByOrder(t, e) {
    const i = t === se;
    return wa(
      this._items,
      e,
      i,
      this._config.wrap
    );
  }
  _triggerSlideEvent(t, e) {
    const i = this._getItemIndex(t), n = this._getItemIndex(
      h.findOne(ve, this._element)
    );
    return u.trigger(this._element, ph, {
      relatedTarget: t,
      direction: e,
      from: n,
      to: i
    });
  }
  _setActiveIndicatorElement(t) {
    if (this._indicatorsElement) {
      const e = h.findOne(
        al,
        this._indicatorsElement
      );
      e.removeAttribute(oe), e.removeAttribute("aria-current"), e.classList.remove("!opacity-100");
      const i = h.find(
        Nh,
        this._indicatorsElement
      );
      for (let n = 0; n < i.length; n++)
        if (Number.parseInt(
          i[n].getAttribute("data-te-slide-to"),
          10
        ) === this._getItemIndex(t)) {
          i[n].setAttribute(`${oe}`, ""), i[n].setAttribute("aria-current", "true"), i[n].classList.add("!opacity-100");
          break;
        }
    }
  }
  _updateInterval() {
    const t = this._activeElement || h.findOne(ve, this._element);
    if (!t)
      return;
    const e = Number.parseInt(
      t.getAttribute("data-te-interval"),
      10
    );
    e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;
  }
  _slide(t, e) {
    const i = this._directionToOrder(t), n = h.findOne(
      ve,
      this._element
    ), o = this._getItemIndex(n), r = e || this._getItemByOrder(i, n), a = this._getItemIndex(r), l = !!this._interval, c = i === se, d = c ? Qs : Oh, _ = c ? xh : Sh, f = this._orderToDirection(i), m = d === Qs ? this._classes.slideLeft : this._classes.slideRight, g = d !== Qs ? this._classes.slideLeft : this._classes.slideRight;
    if (r && r.hasAttribute(oe)) {
      this._isSliding = !1;
      return;
    }
    if (this._isSliding || this._triggerSlideEvent(r, f).defaultPrevented || !n || !r)
      return;
    this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(r), this._activeElement = r;
    const T = () => {
      u.trigger(this._element, zo, {
        relatedTarget: r,
        direction: f,
        from: o,
        to: a
      });
    };
    if (this._element.hasAttribute(kh)) {
      r.setAttribute(`${_}`, ""), r.classList.add(this._classes.block, g), Fe(r), n.setAttribute(`${d}`, ""), n.classList.add(
        m,
        ...this._classes.invisible.split(" ")
      ), n.classList.remove(...this._classes.visible.split(" ")), r.setAttribute(`${d}`, ""), r.classList.add(...this._classes.visible.split(" ")), r.classList.remove(
        this._classes.slideRight,
        this._classes.slideLeft
      );
      const C = () => {
        r.removeAttribute(d), r.removeAttribute(_), r.setAttribute(`${oe}`, ""), n.removeAttribute(oe), n.classList.remove(
          m,
          ...this._classes.invisible.split(" "),
          this._classes.block
        ), n.removeAttribute(_), n.removeAttribute(d), this._isSliding = !1, setTimeout(T, 0);
      };
      this._queueCallback(C, n, !0);
    } else
      n.removeAttribute(oe), n.classList.remove(this._classes.block), r.setAttribute(`${oe}`, ""), r.classList.add(this._classes.block), this._isSliding = !1, T();
    l && this.cycle();
  }
  _directionToOrder(t) {
    return [si, ce].includes(t) ? F() ? t === ce ? ne : se : t === ce ? se : ne : t;
  }
  _orderToDirection(t) {
    return [se, ne].includes(t) ? F() ? t === ne ? ce : si : t === ne ? si : ce : t;
  }
  // Static
  static carouselInterface(t, e) {
    const i = Yt.getOrCreateInstance(t, e);
    let { _config: n } = i;
    typeof e == "object" && (n = {
      ...n,
      ...e
    });
    const o = typeof e == "string" ? e : n.slide;
    if (typeof e == "number")
      i.to(e);
    else if (typeof o == "string") {
      if (typeof i[o] > "u")
        throw new TypeError(`No method named "${o}"`);
      i[o]();
    } else
      n.interval && n.carouselInit === null && (i.pause(), i.cycle());
  }
  static jQueryInterface(t) {
    return this.each(function() {
      Yt.carouselInterface(this, t);
    });
  }
  static dataApiClickHandler(t) {
    const e = Xt(this);
    if (!e || !e.hasAttribute(wh))
      return;
    const i = {
      ...p.getDataAttributes(e),
      ...p.getDataAttributes(this)
    }, n = this.getAttribute("data-te-slide-to");
    n && (i.interval = !1), Yt.carouselInterface(e, i), n && Yt.getInstance(e).to(n), t.preventDefault();
  }
}
const Zs = "modal", Bh = "te.modal", Et = `.${Bh}`, Xo = "Escape", Go = {
  backdrop: !0,
  keyboard: !0,
  focus: !0
}, Vh = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  focus: "boolean"
}, Wh = {
  show: "transform-none",
  static: "scale-[1.02]",
  staticProperties: "transition-scale duration-300 ease-in-out"
}, Fh = {
  show: "string",
  static: "string",
  staticProperties: "string"
}, Yh = `hide${Et}`, jh = `hidePrevented${Et}`, Kh = `hidden${Et}`, Uh = `show${Et}`, zh = `shown${Et}`, qo = `resize${Et}`, Qo = `click.dismiss${Et}`, Zo = `keydown.dismiss${Et}`, Xh = `mouseup.dismiss${Et}`, Jo = `mousedown.dismiss${Et}`, tr = "data-te-modal-open", er = "data-te-open", qe = "[data-te-modal-dialog-ref]", Gh = "[data-te-modal-body-ref]";
class Pn extends vt {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._dialog = h.findOne(qe, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new pi(), this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return Go;
  }
  static get NAME() {
    return Zs;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    this._isShown || this._isTransitioning || u.trigger(this._element, Uh, {
      relatedTarget: t
    }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.setAttribute(tr, "true"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), u.on(this._dialog, Jo, () => {
      u.one(this._element, Xh, (i) => {
        i.target === this._element && (this._ignoreBackdropClick = !0);
      });
    }), this._showElement(t), this._showBackdrop());
  }
  hide() {
    if (!this._isShown || this._isTransitioning || u.trigger(this._element, Yh).defaultPrevented)
      return;
    this._isShown = !1;
    const e = this._isAnimated();
    e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.disable(), h.findOne(qe, this._element).classList.remove(this._classes.show), u.off(this._element, Qo), u.off(this._dialog, Jo), this._queueCallback(() => this._hideModal(), this._element, e), this._element.removeAttribute(er);
  }
  dispose() {
    [window, this._dialog].forEach(
      (t) => u.off(t, Et)
    ), this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _init() {
    this._didInit || (xs(Pn), this._didInit = !0);
  }
  _initializeBackDrop() {
    return new lo({
      isVisible: !!this._config.backdrop,
      // 'static' option will be translated to true, and booleans will keep their value
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new bi(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _getConfig(t) {
    return t = {
      ...Go,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, N(Zs, t, Vh), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...Wh,
      ...e,
      ...t
    }, N(Zs, t, Fh), t;
  }
  _showElement(t) {
    const e = this._isAnimated(), i = h.findOne(Gh, this._dialog);
    (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = "block", this._element.classList.remove("hidden"), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`${er}`, "true"), this._element.scrollTop = 0;
    const n = h.findOne(qe, this._element);
    n.classList.add(this._classes.show), n.classList.remove("opacity-0"), n.classList.add("opacity-100"), i && (i.scrollTop = 0), e && Fe(this._element);
    const o = () => {
      this._config.focus && this._focustrap.trap(), this._isTransitioning = !1, u.trigger(this._element, zh, {
        relatedTarget: t
      });
    };
    this._queueCallback(o, this._dialog, e);
  }
  _setEscapeEvent() {
    this._isShown ? u.on(document, Zo, (t) => {
      this._config.keyboard && t.key === Xo ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === Xo && this._triggerBackdropTransition();
    }) : u.off(this._element, Zo);
  }
  _setResizeEvent() {
    this._isShown ? u.on(window, qo, () => this._adjustDialog()) : u.off(window, qo);
  }
  _hideModal() {
    const t = h.findOne(qe, this._element);
    t.classList.remove(this._classes.show), t.classList.remove("opacity-100"), t.classList.add("opacity-0"), setTimeout(() => {
      this._element.style.display = "none";
    }, 300), this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
      document.body.removeAttribute(tr), this._resetAdjustments(), this._scrollBar.reset(), u.trigger(this._element, Kh);
    });
  }
  _showBackdrop(t) {
    u.on(this._element, Qo, (e) => {
      if (this._ignoreBackdropClick) {
        this._ignoreBackdropClick = !1;
        return;
      }
      e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === "static" && this._triggerBackdropTransition());
    }), this._backdrop.show(t);
  }
  _isAnimated() {
    return !!h.findOne(qe, this._element);
  }
  _triggerBackdropTransition() {
    if (u.trigger(this._element, jh).defaultPrevented)
      return;
    const { classList: e, scrollHeight: i, style: n } = this._element, o = i > document.documentElement.clientHeight;
    !o && n.overflowY === "hidden" || e.contains(this._classes.static) || (o || (n.overflowY = "hidden"), e.add(...this._classes.static.split(" ")), e.add(...this._classes.staticProperties.split(" ")), this._queueCallback(() => {
      e.remove(this._classes.static), setTimeout(() => {
        e.remove(...this._classes.staticProperties.split(" "));
      }, 300), o || this._queueCallback(() => {
        n.overflowY = "";
      }, this._dialog);
    }, this._dialog), this._element.focus());
  }
  // ----------------------------------------------------------------------
  // the following methods are used to handle overflowing modals
  // ----------------------------------------------------------------------
  _adjustDialog() {
    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), i = e > 0;
    (!i && t && !F() || i && !t && F()) && (this._element.style.paddingLeft = `${e}px`), (i && !t && !F() || !i && t && F()) && (this._element.style.paddingRight = `${e}px`);
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const i = Pn.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
}
const qh = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Qh = /^aria-[\w-]*$/i, Zh = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Jh = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, tu = (s, t) => {
  const e = s.nodeName.toLowerCase();
  if (t.includes(e))
    return qh.has(e) ? !!(Zh.test(s.nodeValue) || Jh.test(s.nodeValue)) : !0;
  const i = t.filter(
    (n) => n instanceof RegExp
  );
  for (let n = 0, o = i.length; n < o; n++)
    if (i[n].test(e))
      return !0;
  return !1;
}, eu = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Qh],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
function ir(s, t, e) {
  if (!s.length)
    return s;
  if (e && typeof e == "function")
    return e(s);
  const n = new window.DOMParser().parseFromString(s, "text/html"), o = [].concat(...n.body.querySelectorAll("*"));
  for (let r = 0, a = o.length; r < a; r++) {
    const l = o[r], c = l.nodeName.toLowerCase();
    if (!Object.keys(t).includes(c)) {
      l.remove();
      continue;
    }
    const d = [].concat(...l.attributes), _ = [].concat(
      t["*"] || [],
      t[c] || []
    );
    d.forEach((f) => {
      tu(f, _) || l.removeAttribute(f.nodeName);
    });
  }
  return n.body.innerHTML;
}
const sr = "tooltip", iu = "te.tooltip", Ct = `.${iu}`, su = "te-tooltip", nu = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), ou = {
  animation: "boolean",
  template: "string",
  title: "(string|element|function)",
  trigger: "string",
  delay: "(number|object)",
  html: "boolean",
  selector: "(string|boolean)",
  placement: "(string|function)",
  offset: "(array|string|function)",
  container: "(string|element|boolean)",
  fallbackPlacements: "array",
  boundary: "(string|element)",
  customClass: "(string|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  allowList: "object",
  popperConfig: "(null|object|function)"
}, ru = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: F() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: F() ? "right" : "left"
}, au = {
  animation: !0,
  template: '<div class="opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal" role="tooltip"><div data-te-tooltip-inner-ref class="tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded"></div></div>',
  trigger: "hover focus",
  title: "",
  delay: 0,
  html: !1,
  selector: !1,
  placement: "top",
  offset: [0, 0],
  container: !1,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  boundary: "clippingParents",
  customClass: "",
  sanitize: !0,
  sanitizeFn: null,
  allowList: eu,
  popperConfig: { hide: !0 }
}, lu = {
  HIDE: `hide${Ct}`,
  HIDDEN: `hidden${Ct}`,
  SHOW: `show${Ct}`,
  SHOWN: `shown${Ct}`,
  INSERTED: `inserted${Ct}`,
  CLICK: `click${Ct}`,
  FOCUSIN: `focusin${Ct}`,
  FOCUSOUT: `focusout${Ct}`,
  MOUSEENTER: `mouseenter${Ct}`,
  MOUSELEAVE: `mouseleave${Ct}`
}, cu = "fade", du = "modal", Js = "show", Qe = "show", tn = "out", nr = ".tooltip-inner", or = `.${du}`, rr = "hide.te.modal", Ze = "hover", en = "focus", hu = "click", uu = "manual";
class vi extends vt {
  constructor(t, e) {
    if (typeof il > "u")
      throw new TypeError(
        "Bootstrap's tooltips require Popper (https://popper.js.org)"
      );
    super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();
  }
  // Getters
  static get Default() {
    return au;
  }
  static get NAME() {
    return sr;
  }
  static get Event() {
    return lu;
  }
  static get DefaultType() {
    return ou;
  }
  // Public
  enable() {
    this._isEnabled = !0;
  }
  disable() {
    this._isEnabled = !1;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle(t) {
    if (this._isEnabled)
      if (t) {
        const e = this._initializeOnDelegatedTarget(t);
        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);
      } else {
        if (this.getTipElement().classList.contains(Js)) {
          this._leave(null, this);
          return;
        }
        this._enter(null, this);
      }
  }
  dispose() {
    clearTimeout(this._timeout), u.off(
      this._element.closest(or),
      rr,
      this._hideModalHandler
    ), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();
  }
  show() {
    if (this._element.style.display === "none")
      throw new Error("Please use show on visible elements");
    if (!(this.isWithContent() && this._isEnabled))
      return;
    const t = u.trigger(
      this._element,
      this.constructor.Event.SHOW
    ), e = Ta(this._element), i = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);
    if (t.defaultPrevented || !i)
      return;
    this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(nr).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);
    const n = this.getTipElement(), o = Ot(this.constructor.NAME);
    n.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this._config.animation && setTimeout(() => {
      this.tip.classList.add("opacity-100"), this.tip.classList.remove("opacity-0");
    }, 100);
    const r = typeof this._config.placement == "function" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(r);
    this._addAttachmentClass(a);
    const { container: l } = this._config;
    if (I.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), u.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = je(
      this._element,
      n,
      this._getPopperConfig(a)
    ), n.getAttribute("id").includes("tooltip"))
      switch (r) {
        case "bottom":
          n.classList.add("py-[0.4rem]");
          break;
        case "left":
          n.classList.add("px-[0.4rem]");
          break;
        case "right":
          n.classList.add("px-[0.4rem]");
          break;
        default:
          n.classList.add("py-[0.4rem]");
          break;
      }
    const d = this._resolvePossibleFunction(this._config.customClass);
    d && n.classList.add(...d.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((m) => {
      u.on(m, "mouseover", vs);
    });
    const _ = () => {
      const m = this._hoverState;
      this._hoverState = null, u.trigger(this._element, this.constructor.Event.SHOWN), m === tn && this._leave(null, this);
    }, f = this.tip.classList.contains("transition-opacity");
    this._queueCallback(_, this.tip, f);
  }
  hide() {
    if (!this._popper)
      return;
    const t = this.getTipElement(), e = () => {
      this._isWithActiveTrigger() || (this._hoverState !== Qe && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), u.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());
    };
    if (u.trigger(
      this._element,
      this.constructor.Event.HIDE
    ).defaultPrevented)
      return;
    t.classList.add("opacity-0"), t.classList.remove("opacity-100"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((o) => u.off(o, "mouseover", vs)), this._activeTrigger[hu] = !1, this._activeTrigger[en] = !1, this._activeTrigger[Ze] = !1;
    const n = this.tip.classList.contains("opacity-0");
    this._queueCallback(e, this.tip, n), this._hoverState = "";
  }
  update() {
    this._popper !== null && this._popper.update();
  }
  // Protected
  isWithContent() {
    return !!this.getTitle();
  }
  getTipElement() {
    if (this.tip)
      return this.tip;
    const t = document.createElement("div");
    t.innerHTML = this._config.template;
    const e = t.children[0];
    return this.setContent(e), e.classList.remove(cu, Js), this.tip = e, this.tip;
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), nr);
  }
  _sanitizeAndSetContent(t, e, i) {
    const n = h.findOne(i, t);
    if (!e && n) {
      n.remove();
      return;
    }
    this.setElementContent(n, e);
  }
  setElementContent(t, e) {
    if (t !== null) {
      if (Ne(e)) {
        e = Gt(e), this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent;
        return;
      }
      this._config.html ? (this._config.sanitize && (e = ir(
        e,
        this._config.allowList,
        this._config.sanitizeFn
      )), t.innerHTML = e) : t.textContent = e;
    }
  }
  getTitle() {
    const t = this._element.getAttribute("data-te-original-title") || this._config.title;
    return this._resolvePossibleFunction(t);
  }
  updateAttachment(t) {
    return t === "right" ? "end" : t === "left" ? "start" : t;
  }
  // Private
  _initializeOnDelegatedTarget(t, e) {
    return e || this.constructor.getOrCreateInstance(
      t.delegateTarget,
      this._getDelegateConfig()
    );
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _resolvePossibleFunction(t) {
    return typeof t == "function" ? t.call(this._element) : t;
  }
  _getPopperConfig(t) {
    const e = {
      placement: t,
      modifiers: [
        {
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        },
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        },
        {
          name: "onChange",
          enabled: !0,
          phase: "afterWrite",
          fn: (i) => this._handlePopperPlacementChange(i)
        }
      ],
      onFirstUpdate: (i) => {
        i.options.placement !== i.placement && this._handlePopperPlacementChange(i);
      }
    };
    return {
      ...e,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig
    };
  }
  _addAttachmentClass(t) {
    this.getTipElement().classList.add(
      `${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`
    );
  }
  _getAttachment(t) {
    return ru[t.toUpperCase()];
  }
  _setListeners() {
    this._config.trigger.split(" ").forEach((e) => {
      if (e === "click")
        u.on(
          this._element,
          this.constructor.Event.CLICK,
          this._config.selector,
          (i) => this.toggle(i)
        );
      else if (e !== uu) {
        const i = e === Ze ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === Ze ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
        u.on(
          this._element,
          i,
          this._config.selector,
          (o) => this._enter(o)
        ), u.on(
          this._element,
          n,
          this._config.selector,
          (o) => this._leave(o)
        );
      }
    }), this._hideModalHandler = () => {
      this._element && this.hide();
    }, u.on(
      this._element.closest(or),
      rr,
      this._hideModalHandler
    ), this._config.selector ? this._config = {
      ...this._config,
      trigger: "manual",
      selector: ""
    } : this._fixTitle();
  }
  _fixTitle() {
    const t = this._element.getAttribute("title"), e = typeof this._element.getAttribute(
      "data-te-original-title"
    );
    (t || e !== "string") && (this._element.setAttribute("data-te-original-title", t || ""), t && !this._element.getAttribute("aria-label") && !this._element.textContent && this._element.setAttribute("aria-label", t), this._element.setAttribute("title", ""));
  }
  _enter(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusin" ? en : Ze] = !0), e.getTipElement().classList.contains(Js) || e._hoverState === Qe) {
      e._hoverState = Qe;
      return;
    }
    if (clearTimeout(e._timeout), e._hoverState = Qe, !e._config.delay || !e._config.delay.show) {
      e.show();
      return;
    }
    e._timeout = setTimeout(() => {
      e._hoverState === Qe && e.show();
    }, e._config.delay.show);
  }
  _leave(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusout" ? en : Ze] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {
      if (clearTimeout(e._timeout), e._hoverState = tn, !e._config.delay || !e._config.delay.hide) {
        e.hide();
        return;
      }
      e._timeout = setTimeout(() => {
        e._hoverState === tn && e.hide();
      }, e._config.delay.hide);
    }
  }
  _isWithActiveTrigger() {
    for (const t in this._activeTrigger)
      if (this._activeTrigger[t])
        return !0;
    return !1;
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._element);
    return Object.keys(e).forEach((i) => {
      nu.has(i) && delete e[i];
    }), t = {
      ...this.constructor.Default,
      ...e,
      ...typeof t == "object" && t ? t : {}
    }, t.container = t.container === !1 ? document.body : Gt(t.container), typeof t.delay == "number" && (t.delay = {
      show: t.delay,
      hide: t.delay
    }), typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), N(sr, t, this.constructor.DefaultType), t.sanitize && (t.template = ir(
      t.template,
      t.allowList,
      t.sanitizeFn
    )), t;
  }
  _getDelegateConfig() {
    const t = {};
    for (const e in this._config)
      this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);
    return t;
  }
  _cleanTipClass() {
    const t = this.getTipElement(), e = new RegExp(
      `(^|\\s)${this._getBasicClassPrefix()}\\S+`,
      "g"
    ), i = t.getAttribute("class").match(e);
    i !== null && i.length > 0 && i.map((n) => n.trim()).forEach((n) => t.classList.remove(n));
  }
  _getBasicClassPrefix() {
    return su;
  }
  _handlePopperPlacementChange(t) {
    const { state: e } = t;
    e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));
  }
  _disposePopper() {
    this._popper && (this._popper.destroy(), this._popper = null);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = vi.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const pu = "popover", fu = "te.popover", At = `.${fu}`, _u = "te-popover", mu = {
  ...vi.Default,
  placement: "right",
  offset: [0, 8],
  trigger: "click",
  content: "",
  template: '<div class="opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden" role="tooltip"><h3 class="popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500"></h3><div class="popover-body p-4 text-[#212529] dark:text-white"></div></div>'
}, gu = {
  ...vi.DefaultType,
  content: "(string|element|function)"
}, bu = {
  HIDE: `hide${At}`,
  HIDDEN: `hidden${At}`,
  SHOW: `show${At}`,
  SHOWN: `shown${At}`,
  INSERTED: `inserted${At}`,
  CLICK: `click${At}`,
  FOCUSIN: `focusin${At}`,
  FOCUSOUT: `focusout${At}`,
  MOUSEENTER: `mouseenter${At}`,
  MOUSELEAVE: `mouseleave${At}`
}, vu = ".popover-header", Eu = ".popover-body";
class ll extends vi {
  // Getters
  static get Default() {
    return mu;
  }
  static get NAME() {
    return pu;
  }
  static get Event() {
    return bu;
  }
  static get DefaultType() {
    return gu;
  }
  // Overrides
  isWithContent() {
    return this.getTitle() || this._getContent();
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), vu), this._sanitizeAndSetContent(t, this._getContent(), Eu);
  }
  // Private
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  _getBasicClassPrefix() {
    return _u;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = ll.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const sn = "scrollspy", Tu = "te.scrollspy", Ss = `.${Tu}`, Cu = ".data-api", ar = {
  offset: 10,
  method: "auto",
  target: ""
}, Au = {
  offset: "number",
  method: "string",
  target: "(string|element)"
}, yu = {
  active: "!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400"
}, wu = {
  active: "string"
}, ku = `activate${Ss}`, Ou = `scroll${Ss}`, xu = `load${Ss}${Cu}`, nn = "data-te-nav-link-active", cl = "[data-te-dropdown-item-ref]", Su = '[data-te-spy="scroll"]', Du = "[data-te-nav-list-ref]", Hn = "[data-te-nav-link-ref]", Iu = "[data-te-nav-item-ref]", dl = "[data-te-list-group-item-ref]", on = `${Hn}, ${dl}, ${cl}`, $u = "[data-te-dropdown-ref]", Lu = "[data-te-dropdown-toggle-ref]", Mu = "offset", lr = "position";
class Bn extends vt {
  constructor(t, e, i) {
    super(t), this._scrollElement = this._element.tagName === "BODY" ? window : this._element, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, u.on(this._scrollElement, Ou, () => this._process()), this.refresh(), this._process(), this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return ar;
  }
  static get NAME() {
    return sn;
  }
  // Public
  refresh() {
    const t = this._scrollElement === this._scrollElement.window ? Mu : lr, e = this._config.method === "auto" ? t : this._config.method, i = e === lr ? this._getScrollTop() : 0;
    this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), h.find(
      on,
      this._config.target
    ).map((o) => {
      const r = Xn(o), a = r ? h.findOne(r) : null;
      if (a) {
        const l = a.getBoundingClientRect();
        if (l.width || l.height)
          return [
            p[e](a).top + i,
            r
          ];
      }
      return null;
    }).filter((o) => o).sort((o, r) => o[0] - r[0]).forEach((o) => {
      this._offsets.push(o[0]), this._targets.push(o[1]);
    });
  }
  dispose() {
    u.off(this._scrollElement, Ss), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (u.on(window, xu, () => {
      h.find(Su).forEach(
        (t) => new Bn(t)
      );
    }), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...ar,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, t.target = Gt(t.target) || document.documentElement, N(sn, t, Au), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...yu,
      ...e,
      ...t
    }, N(sn, t, wu), t;
  }
  _getScrollTop() {
    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
  }
  _getScrollHeight() {
    return this._scrollElement.scrollHeight || Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight
    );
  }
  _getOffsetHeight() {
    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
  }
  _process() {
    const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), i = this._config.offset + e - this._getOffsetHeight();
    if (this._scrollHeight !== e && this.refresh(), t >= i) {
      const n = this._targets[this._targets.length - 1];
      this._activeTarget !== n && this._activate(n);
      return;
    }
    if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {
      this._activeTarget = null, this._clear();
      return;
    }
    for (let n = this._offsets.length; n--; )
      this._activeTarget !== this._targets[n] && t >= this._offsets[n] && (typeof this._offsets[n + 1] > "u" || t < this._offsets[n + 1]) && this._activate(this._targets[n]);
  }
  _activate(t) {
    this._activeTarget = t, this._clear();
    const e = on.split(",").map(
      (n) => `${n}[data-te-target="${t}"],${n}[href="${t}"]`
    ), i = h.findOne(e.join(","), this._config.target);
    i.classList.add(...this._classes.active.split(" ")), i.setAttribute(nn, ""), i.getAttribute(cl) ? h.findOne(
      Lu,
      i.closest($u)
    ).classList.add(...this._classes.active.split(" ")) : h.parents(i, Du).forEach(
      (n) => {
        h.prev(
          n,
          `${Hn}, ${dl}`
        ).forEach((o) => {
          o.classList.add(...this._classes.active.split(" ")), o.setAttribute(nn, "");
        }), h.prev(n, Iu).forEach(
          (o) => {
            h.children(o, Hn).forEach(
              (r) => r.classList.add(...this._classes.active.split(" "))
            );
          }
        );
      }
    ), u.trigger(this._scrollElement, ku, {
      relatedTarget: t
    });
  }
  _clear() {
    h.find(on, this._config.target).filter(
      (t) => t.classList.contains(...this._classes.active.split(" "))
    ).forEach((t) => {
      t.classList.remove(...this._classes.active.split(" ")), t.removeAttribute(nn);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Bn.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const cr = "tab", Nu = "te.tab", Ds = `.${Nu}`, Ru = `hide${Ds}`, Pu = `hidden${Ds}`, Hu = `show${Ds}`, Bu = `shown${Ds}`, Vu = "data-te-dropdown-menu-ref", we = "data-te-tab-active", as = "data-te-nav-active", Wu = "[data-te-dropdown-ref]", Fu = "[data-te-nav-ref]", dr = `[${we}]`, Yu = `[${as}]`, hr = ":scope > li > .active", ju = "[data-te-dropdown-toggle-ref]", Ku = ":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]", Uu = {
  show: "opacity-100",
  hide: "opacity-0"
}, zu = {
  show: "string",
  hide: "string"
};
class hl extends vt {
  constructor(t, e) {
    super(t), this._classes = this._getClasses(e);
  }
  // Getters
  static get NAME() {
    return cr;
  }
  // Public
  show() {
    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(as) === "")
      return;
    let t;
    const e = Xt(this._element), i = this._element.closest(Fu), n = h.findOne(
      Yu,
      i
    );
    if (i) {
      const l = i.nodeName === "UL" || i.nodeName === "OL" ? hr : dr;
      t = h.find(l, i), t = t[t.length - 1];
    }
    const o = t ? u.trigger(t, Ru, {
      relatedTarget: this._element
    }) : null;
    if (u.trigger(this._element, Hu, {
      relatedTarget: t
    }).defaultPrevented || o !== null && o.defaultPrevented)
      return;
    this._activate(
      this._element,
      i,
      null,
      n,
      this._element
    );
    const a = () => {
      u.trigger(t, Pu, {
        relatedTarget: this._element
      }), u.trigger(this._element, Bu, {
        relatedTarget: t
      });
    };
    e ? this._activate(
      e,
      e.parentNode,
      a,
      n,
      this._element
    ) : a();
  }
  // Private
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...Uu,
      ...e,
      ...t
    }, N(cr, t, zu), t;
  }
  _activate(t, e, i, n, o) {
    const a = (e && (e.nodeName === "UL" || e.nodeName === "OL") ? h.find(hr, e) : h.children(e, dr))[0], l = i && a && a.hasAttribute(we), c = () => this._transitionComplete(
      t,
      a,
      i,
      n,
      o
    );
    a && l ? (p.removeClass(a, this._classes.show), p.addClass(a, this._classes.hide), this._queueCallback(c, t, !0)) : c();
  }
  _transitionComplete(t, e, i, n, o) {
    if (e && n) {
      e.removeAttribute(we), n.removeAttribute(as);
      const a = h.findOne(
        Ku,
        e.parentNode
      );
      a && a.removeAttribute(we), e.getAttribute("role") === "tab" && e.setAttribute("aria-selected", !1);
    }
    t.setAttribute(we, ""), o.setAttribute(as, ""), t.getAttribute("role") === "tab" && t.setAttribute("aria-selected", !0), Fe(t), t.classList.contains(this._classes.hide) && (p.removeClass(t, this._classes.hide), p.addClass(t, this._classes.show));
    let r = t.parentNode;
    if (r && r.nodeName === "LI" && (r = r.parentNode), r && r.hasAttribute(Vu)) {
      const a = t.closest(Wu);
      a && h.find(ju, a).forEach(
        (l) => l.setAttribute(we, "")
      ), t.setAttribute("aria-expanded", !0);
    }
    i && i();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = hl.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const rn = "toast", Xu = "te.toast", Qt = `.${Xu}`, Gu = `mouseover${Qt}`, qu = `mouseout${Qt}`, Qu = `focusin${Qt}`, Zu = `focusout${Qt}`, Ju = `hide${Qt}`, tp = `hidden${Qt}`, ep = `show${Qt}`, ip = `shown${Qt}`, ur = "data-te-toast-hide", an = "data-te-toast-show", Mi = "data-te-toast-showing", sp = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, pr = {
  animation: !0,
  autohide: !0,
  delay: 5e3
}, np = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, op = {
  fadeIn: "string",
  fadeOut: "string"
};
class Vn extends vt {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get DefaultType() {
    return sp;
  }
  static get Default() {
    return pr;
  }
  static get NAME() {
    return rn;
  }
  // Public
  show() {
    if (u.trigger(this._element, ep).defaultPrevented)
      return;
    this._clearTimeout(), this._config.animation && (p.removeClass(this._element, this._classes.fadeOut), p.addClass(this._element, this._classes.fadeIn));
    const e = () => {
      this._element.removeAttribute(Mi), u.trigger(this._element, ip), this._maybeScheduleHide();
    };
    this._element.removeAttribute(ur), Fe(this._element), this._element.setAttribute(an, ""), this._element.setAttribute(Mi, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  hide() {
    if (!this._element || this._element.dataset.teToastShow === void 0 || u.trigger(this._element, Ju).defaultPrevented)
      return;
    const e = () => {
      let i = 0;
      this._config.animation && (i = 300, p.removeClass(this._element, this._classes.fadeIn), p.addClass(this._element, this._classes.fadeOut)), setTimeout(() => {
        this._element.setAttribute(ur, ""), this._element.removeAttribute(Mi), this._element.removeAttribute(an), u.trigger(this._element, tp);
      }, i);
    };
    this._element.setAttribute(Mi, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout(), this._element.dataset.teToastShow !== void 0 && this._element.removeAttribute(an), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (xs(Vn), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...pr,
      ...p.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, N(rn, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...np,
      ...e,
      ...t
    }, N(rn, t, op), t;
  }
  _maybeScheduleHide() {
    this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay)));
  }
  _onInteraction(t, e) {
    switch (t.type) {
      case "mouseover":
      case "mouseout":
        this._hasMouseInteraction = e;
        break;
      case "focusin":
      case "focusout":
        this._hasKeyboardInteraction = e;
        break;
    }
    if (e) {
      this._clearTimeout();
      return;
    }
    const i = t.relatedTarget;
    this._element === i || this._element.contains(i) || this._maybeScheduleHide();
  }
  _setListeners() {
    u.on(
      this._element,
      Gu,
      (t) => this._onInteraction(t, !0)
    ), u.on(
      this._element,
      qu,
      (t) => this._onInteraction(t, !1)
    ), u.on(
      this._element,
      Qu,
      (t) => this._onInteraction(t, !0)
    ), u.on(
      this._element,
      Zu,
      (t) => this._onInteraction(t, !1)
    );
  }
  _clearTimeout() {
    clearTimeout(this._timeout), this._timeout = null;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Vn.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
(() => {
  var s = { 454: (i, n, o) => {
    o.d(n, { Z: () => l });
    var r = o(645), a = o.n(r)()(function(c) {
      return c[1];
    });
    a.push([i.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
    const l = a;
  }, 645: (i) => {
    i.exports = function(n) {
      var o = [];
      return o.toString = function() {
        return this.map(function(r) {
          var a = n(r);
          return r[2] ? "@media ".concat(r[2], " {").concat(a, "}") : a;
        }).join("");
      }, o.i = function(r, a, l) {
        typeof r == "string" && (r = [[null, r, ""]]);
        var c = {};
        if (l)
          for (var d = 0; d < this.length; d++) {
            var _ = this[d][0];
            _ != null && (c[_] = !0);
          }
        for (var f = 0; f < r.length; f++) {
          var m = [].concat(r[f]);
          l && c[m[0]] || (a && (m[2] ? m[2] = "".concat(a, " and ").concat(m[2]) : m[2] = a), o.push(m));
        }
      }, o;
    };
  }, 810: () => {
    (function() {
      if (typeof window < "u")
        try {
          var i = new window.CustomEvent("test", { cancelable: !0 });
          if (i.preventDefault(), i.defaultPrevented !== !0)
            throw new Error("Could not prevent default");
        } catch {
          var n = function(r, a) {
            var l, c;
            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent("CustomEvent")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), c = l.preventDefault, l.preventDefault = function() {
              c.call(this);
              try {
                Object.defineProperty(this, "defaultPrevented", { get: function() {
                  return !0;
                } });
              } catch {
                this.defaultPrevented = !0;
              }
            }, l;
          };
          n.prototype = window.Event.prototype, window.CustomEvent = n;
        }
    })();
  }, 379: (i, n, o) => {
    var r, a = function() {
      var v = {};
      return function(E) {
        if (v[E] === void 0) {
          var A = document.querySelector(E);
          if (window.HTMLIFrameElement && A instanceof window.HTMLIFrameElement)
            try {
              A = A.contentDocument.head;
            } catch {
              A = null;
            }
          v[E] = A;
        }
        return v[E];
      };
    }(), l = [];
    function c(v) {
      for (var E = -1, A = 0; A < l.length; A++)
        if (l[A].identifier === v) {
          E = A;
          break;
        }
      return E;
    }
    function d(v, E) {
      for (var A = {}, y = [], S = 0; S < v.length; S++) {
        var O = v[S], k = E.base ? O[0] + E.base : O[0], D = A[k] || 0, x = "".concat(k, " ").concat(D);
        A[k] = D + 1;
        var $ = c(x), P = { css: O[1], media: O[2], sourceMap: O[3] };
        $ !== -1 ? (l[$].references++, l[$].updater(P)) : l.push({ identifier: x, updater: w(P, E), references: 1 }), y.push(x);
      }
      return y;
    }
    function _(v) {
      var E = document.createElement("style"), A = v.attributes || {};
      if (A.nonce === void 0) {
        var y = o.nc;
        y && (A.nonce = y);
      }
      if (Object.keys(A).forEach(function(O) {
        E.setAttribute(O, A[O]);
      }), typeof v.insert == "function")
        v.insert(E);
      else {
        var S = a(v.insert || "head");
        if (!S)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        S.appendChild(E);
      }
      return E;
    }
    var f, m = (f = [], function(v, E) {
      return f[v] = E, f.filter(Boolean).join(`
`);
    });
    function g(v, E, A, y) {
      var S = A ? "" : y.media ? "@media ".concat(y.media, " {").concat(y.css, "}") : y.css;
      if (v.styleSheet)
        v.styleSheet.cssText = m(E, S);
      else {
        var O = document.createTextNode(S), k = v.childNodes;
        k[E] && v.removeChild(k[E]), k.length ? v.insertBefore(O, k[E]) : v.appendChild(O);
      }
    }
    function b(v, E, A) {
      var y = A.css, S = A.media, O = A.sourceMap;
      if (S ? v.setAttribute("media", S) : v.removeAttribute("media"), O && typeof btoa < "u" && (y += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(O)))), " */")), v.styleSheet)
        v.styleSheet.cssText = y;
      else {
        for (; v.firstChild; )
          v.removeChild(v.firstChild);
        v.appendChild(document.createTextNode(y));
      }
    }
    var T = null, C = 0;
    function w(v, E) {
      var A, y, S;
      if (E.singleton) {
        var O = C++;
        A = T || (T = _(E)), y = g.bind(null, A, O, !1), S = g.bind(null, A, O, !0);
      } else
        A = _(E), y = b.bind(null, A, E), S = function() {
          (function(k) {
            if (k.parentNode === null)
              return !1;
            k.parentNode.removeChild(k);
          })(A);
        };
      return y(v), function(k) {
        if (k) {
          if (k.css === v.css && k.media === v.media && k.sourceMap === v.sourceMap)
            return;
          y(v = k);
        } else
          S();
      };
    }
    i.exports = function(v, E) {
      (E = E || {}).singleton || typeof E.singleton == "boolean" || (E.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));
      var A = d(v = v || [], E);
      return function(y) {
        if (y = y || [], Object.prototype.toString.call(y) === "[object Array]") {
          for (var S = 0; S < A.length; S++) {
            var O = c(A[S]);
            l[O].references--;
          }
          for (var k = d(y, E), D = 0; D < A.length; D++) {
            var x = c(A[D]);
            l[x].references === 0 && (l[x].updater(), l.splice(x, 1));
          }
          A = k;
        }
      };
    };
  } }, t = {};
  function e(i) {
    var n = t[i];
    if (n !== void 0)
      return n.exports;
    var o = t[i] = { id: i, exports: {} };
    return s[i](o, o.exports, e), o.exports;
  }
  e.n = (i) => {
    var n = i && i.__esModule ? () => i.default : () => i;
    return e.d(n, { a: n }), n;
  }, e.d = (i, n) => {
    for (var o in n)
      e.o(n, o) && !e.o(i, o) && Object.defineProperty(i, o, { enumerable: !0, get: n[o] });
  }, e.o = (i, n) => Object.prototype.hasOwnProperty.call(i, n), (() => {
    var i = e(379), n = e.n(i), o = e(454);
    function r(l) {
      if (!l.hasAttribute("autocompleted")) {
        l.setAttribute("autocompleted", "");
        var c = new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !0, detail: null });
        l.dispatchEvent(c) || (l.value = "");
      }
    }
    function a(l) {
      l.hasAttribute("autocompleted") && (l.removeAttribute("autocompleted"), l.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !1, detail: null })));
    }
    n()(o.Z, { insert: "head", singleton: !1 }), o.Z.locals, e(810), document.addEventListener("animationstart", function(l) {
      l.animationName === "onautofillstart" ? r(l.target) : a(l.target);
    }, !0), document.addEventListener("input", function(l) {
      l.inputType !== "insertReplacementText" && "data" in l ? a(l.target) : r(l.target);
    }, !0);
  })();
})();
const ln = "input", Ni = "te.input", ul = "data-te-input-wrapper-init", pl = "data-te-input-notch-ref", fl = "data-te-input-notch-leading-ref", _l = "data-te-input-notch-middle-ref", rp = "data-te-input-notch-trailing-ref", ap = "data-te-input-helper-ref", lp = "data-te-input-placeholder-active", Ht = "data-te-input-state-active", fr = "data-te-input-focused", _r = "data-te-input-form-counter", re = `[${ul}] input`, ae = `[${ul}] textarea`, Ee = `[${pl}]`, mr = `[${fl}]`, gr = `[${_l}]`, cp = `[${ap}]`, dp = {
  inputFormWhite: !1
}, hp = {
  inputFormWhite: "(boolean)"
}, up = {
  notch: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
  notchLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0",
  notchLeadingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchLeadingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent",
  notchMiddleNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchMiddleWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0",
  notchTrailingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchTrailingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  counter: "text-right leading-[1.6]"
}, pp = {
  notch: "string",
  notchLeading: "string",
  notchLeadingNormal: "string",
  notchLeadingWhite: "string",
  notchMiddle: "string",
  notchMiddleNormal: "string",
  notchMiddleWhite: "string",
  notchTrailing: "string",
  notchTrailingNormal: "string",
  notchTrailingWhite: "string",
  counter: "string"
};
class V {
  constructor(t, e, i) {
    this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(i), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (I.setData(t, Ni, this), this.init());
  }
  // Getters
  static get NAME() {
    return ln;
  }
  get input() {
    return h.findOne("input", this._element) || h.findOne("textarea", this._element);
  }
  // Public
  init() {
    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = !0);
  }
  update() {
    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();
  }
  forceActive() {
    this.input.setAttribute(Ht, ""), h.findOne(Ee, this.input.parentNode).setAttribute(
      Ht,
      ""
    );
  }
  forceInactive() {
    this.input.removeAttribute(Ht), h.findOne(
      Ee,
      this.input.parentNode
    ).removeAttribute(Ht);
  }
  dispose() {
    this._removeBorder(), I.removeData(this._element, Ni), this._element = null;
  }
  // Private
  _getConfig(t, e) {
    return t = {
      ...dp,
      ...p.getDataAttributes(e),
      ...typeof t == "object" ? t : {}
    }, N(ln, t, hp), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...up,
      ...e,
      ...t
    }, N(ln, t, pp), t;
  }
  _getLabelData() {
    this._label = h.findOne("label", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());
  }
  _getHelper() {
    this._helper = h.findOne(cp, this._element);
  }
  _getCounter() {
    this._counter = p.getDataAttribute(
      this.input,
      "inputShowcounter"
    ), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());
  }
  _getEvents() {
    u.on(
      document,
      "focus",
      re,
      V.activate(new V())
    ), u.on(
      document,
      "input",
      re,
      V.activate(new V())
    ), u.on(
      document,
      "blur",
      re,
      V.deactivate(new V())
    ), u.on(
      document,
      "focus",
      ae,
      V.activate(new V())
    ), u.on(
      document,
      "input",
      ae,
      V.activate(new V())
    ), u.on(
      document,
      "blur",
      ae,
      V.deactivate(new V())
    ), u.on(window, "shown.te.modal", (t) => {
      h.find(re, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        }
      ), h.find(ae, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        }
      );
    }), u.on(window, "shown.te.dropdown", (t) => {
      const e = t.target.parentNode.querySelector(
        "[data-te-dropdown-menu-ref]"
      );
      e && (h.find(re, e).forEach(
        (i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }
      ), h.find(ae, e).forEach(
        (i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }
      ));
    }), u.on(window, "shown.te.tab", (t) => {
      let e;
      t.target.href ? e = t.target.href.split("#")[1] : e = p.getDataAttribute(t.target, "target").split(
        "#"
      )[1];
      const i = h.findOne(`#${e}`);
      h.find(re, i).forEach((n) => {
        const o = V.getInstance(n.parentNode);
        o && o.update();
      }), h.find(ae, i).forEach(
        (n) => {
          const o = V.getInstance(n.parentNode);
          o && o.update();
        }
      );
    }), u.on(window, "reset", (t) => {
      h.find(re, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      ), h.find(ae, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      );
    }), u.on(window, "onautocomplete", (t) => {
      const e = V.getInstance(t.target.parentNode);
      !e || !t.cancelable || e.forceActive();
    });
  }
  _showCounter() {
    if (h.find(
      `[${_r}]`,
      this._element
    ).length > 0)
      return;
    this._counterElement = document.createElement("div"), p.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(_r, "");
    const e = this.input.value.length;
    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();
  }
  _bindCounter() {
    u.on(this.input, "input", () => {
      const t = this.input.value.length;
      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;
    });
  }
  _toggleDefaultDatePlaceholder(t = this.input) {
    if (!(t.getAttribute("type") === "date"))
      return;
    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;
  }
  _showPlaceholder() {
    this.input.setAttribute(lp, "");
  }
  _getNotchData() {
    this._notchMiddle = h.findOne(
      gr,
      this._element
    ), this._notchLeading = h.findOne(
      mr,
      this._element
    );
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _getLabelPositionInInputGroup() {
    if (this._labelMarginLeft = 0, !this._element.hasAttribute("data-te-input-group-ref"))
      return;
    const t = this.input, e = h.prev(
      t,
      "[data-te-input-group-text-ref]"
    )[0];
    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;
  }
  _applyDivs() {
    const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, i = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = h.find(Ee, this._element), o = M("div");
    p.addClass(o, this._classes.notch), o.setAttribute(pl, ""), this._notchLeading = M("div"), p.addClass(
      this._notchLeading,
      `${this._classes.notchLeading} ${t}`
    ), this._notchLeading.setAttribute(fl, ""), this._notchMiddle = M("div"), p.addClass(
      this._notchMiddle,
      `${this._classes.notchMiddle} ${e}`
    ), this._notchMiddle.setAttribute(_l, ""), this._notchTrailing = M("div"), p.addClass(
      this._notchTrailing,
      `${this._classes.notchTrailing} ${i}`
    ), this._notchTrailing.setAttribute(rp, ""), !(n.length >= 1) && (o.append(this._notchLeading), o.append(this._notchMiddle), o.append(this._notchTrailing), this._element.append(o));
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
  }
  _removeBorder() {
    const t = h.findOne(Ee, this._element);
    t && t.remove();
  }
  _activate(t) {
    Aa(() => {
      this._getElements(t);
      const e = t ? t.target : this.input, i = h.findOne(
        Ee,
        this._element
      );
      t && t.type === "focus" && i.setAttribute(fr, ""), e.value !== "" && (e.setAttribute(Ht, ""), i.setAttribute(Ht, "")), this._toggleDefaultDatePlaceholder(e);
    });
  }
  _getElements(t) {
    if (t && (this._element = t.target.parentNode, this._label = h.findOne("label", this._element)), t && this._label) {
      const e = this._labelWidth;
      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = h.findOne(
        gr,
        t.target.parentNode
      ), this._notchLeading = h.findOne(
        mr,
        t.target.parentNode
      ), this._applyNotch());
    }
  }
  _deactivate(t) {
    const e = t ? t.target : this.input, i = h.findOne(
      Ee,
      e.parentNode
    );
    i.removeAttribute(fr), e.value === "" && (e.removeAttribute(Ht), i.removeAttribute(Ht)), this._toggleDefaultDatePlaceholder(e);
  }
  static activate(t) {
    return function(e) {
      t._activate(e);
    };
  }
  static deactivate(t) {
    return function(e) {
      t._deactivate(e);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, Ni);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new V(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, Ni);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const br = "animation", cn = "te.animation", fp = {
  animation: "string",
  animationStart: "string",
  animationShowOnLoad: "boolean",
  onStart: "(null|function)",
  onEnd: "(null|function)",
  onHide: "(null|function)",
  onShow: "(null|function)",
  animationOnScroll: "(string)",
  animationWindowHeight: "number",
  animationOffset: "(number|string)",
  animationDelay: "(number|string)",
  animationReverse: "boolean",
  animationInterval: "(number|string)",
  animationRepeat: "(number|boolean)",
  animationReset: "boolean"
}, _p = {
  animation: "fade",
  animationStart: "onClick",
  animationShowOnLoad: !0,
  onStart: null,
  onEnd: null,
  onHide: null,
  onShow: null,
  animationOnScroll: "once",
  animationWindowHeight: 0,
  animationOffset: 0,
  animationDelay: 0,
  animationReverse: !1,
  animationInterval: 0,
  animationRepeat: !1,
  animationReset: !1
};
class ml {
  constructor(t, e) {
    this._element = t, this._animateElement = this._getAnimateElement(), this._isFirstScroll = !0, this._repeatAnimateOnScroll = !0, this._options = this._getConfig(e), this._element && (I.setData(t, cn, this), this._init());
  }
  // Getters
  static get NAME() {
    return br;
  }
  // Public
  init() {
    this._init();
  }
  startAnimation() {
    this._startAnimation();
  }
  stopAnimation() {
    this._clearAnimationClass();
  }
  changeAnimationType(t) {
    this._options.animation = t;
  }
  dispose() {
    u.off(this._element, "mousedown"), u.off(this._animateElement, "animationend"), u.off(window, "scroll"), u.off(this._element, "mouseover"), I.removeData(this._element, cn), this._element = null, this._animateElement = null, this._isFirstScroll = null, this._repeatAnimateOnScroll = null, this._options = null;
  }
  // Private
  _init() {
    switch (this._options.animationStart) {
      case "onHover":
        this._bindHoverEvents();
        break;
      case "onLoad":
        this._startAnimation();
        break;
      case "onScroll":
        this._bindScrollEvents();
        break;
      case "onClick":
        this._bindClickEvents();
        break;
    }
    this._bindTriggerOnEndCallback(), this._options.animationReset && this._bindResetAnimationAfterFinish();
  }
  _getAnimateElement() {
    const t = p.getDataAttribute(
      this._element,
      "animation-target"
    );
    return t ? h.find(t)[0] : this._element;
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._animateElement);
    return t = {
      ..._p,
      ...e,
      ...t
    }, N(br, t, fp), t;
  }
  _animateOnScroll() {
    const t = p.offset(this._animateElement).top, e = this._animateElement.offsetHeight, i = window.innerHeight, n = t + this._options.animationOffset <= i && t + this._options.animationOffset + e >= 0, o = this._animateElement.style.visibility === "visible";
    switch (!0) {
      case (n && this._isFirstScroll):
        this._isFirstScroll = !1, this._startAnimation();
        break;
      case (!n && this._isFirstScroll):
        this._isFirstScroll = !1, this._hideAnimateElement();
        break;
      case (n && !o && this._repeatAnimateOnScroll):
        this._options.animationOnScroll !== "repeat" && (this._repeatAnimateOnScroll = !1), this._callback(this._options.onShow), this._showAnimateElement(), this._startAnimation();
        break;
      case (!n && o && this._repeatAnimateOnScroll):
        this._hideAnimateElement(), this._clearAnimationClass(), this._callback(this._options.onHide);
        break;
    }
  }
  _addAnimatedClass() {
    p.addClass(
      this._animateElement,
      `animate-${this._options.animation}`
    );
  }
  _clearAnimationClass() {
    this._animateElement.classList.remove(`animate-${this._options.animation}`);
  }
  _startAnimation() {
    this._callback(this._options.onStart), this._addAnimatedClass(), this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(), this._options.animationReverse && this._setAnimationReverse(), this._options.animationDelay && this._setAnimationDelay(), this._options.animationDuration && this._setAnimationDuration(), this._options.animationInterval && this._setAnimationInterval();
  }
  _setAnimationReverse() {
    p.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : "2",
      animationDirection: "alternate"
    });
  }
  _setAnimationDuration() {
    p.style(this._animateElement, {
      animationDuration: `${this._options.animationDuration}ms`
    });
  }
  _setAnimationDelay() {
    p.style(this._animateElement, {
      animationDelay: `${this._options.animationDelay}ms`
    });
  }
  _setAnimationRepeat() {
    p.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : this._options.animationRepeat
    });
  }
  _setAnimationInterval() {
    u.on(this._animateElement, "click", () => {
      this._clearAnimationClass(), setTimeout(() => {
        this._addAnimatedClass();
      }, this._options.animationInterval);
    });
  }
  _hideAnimateElement() {
    p.style(this._animateElement, { visibility: "hidden" });
  }
  _showAnimateElement() {
    p.style(this._animateElement, { visibility: "visible" });
  }
  _bindResetAnimationAfterFinish() {
    u.on(this._animateElement, "animationend", () => {
      this._clearAnimationClass();
    });
  }
  _bindTriggerOnEndCallback() {
    u.on(this._animateElement, "animationend", () => {
      this._callback(this._options.onEnd);
    });
  }
  _bindScrollEvents() {
    this._options.animationShowOnLoad || this._animateOnScroll(), u.on(window, "scroll", () => {
      this._animateOnScroll();
    });
  }
  _bindClickEvents() {
    u.on(this._element, "mousedown", () => {
      this._startAnimation();
    });
  }
  _bindHoverEvents() {
    u.one(this._element, "mouseover", () => {
      this._startAnimation();
    }), u.one(this._animateElement, "animationend", () => {
      setTimeout(() => {
        this._bindHoverEvents();
      }, 100);
    });
  }
  _callback(t) {
    t instanceof Function && t();
  }
  // Static
  static autoInit(t) {
    t._init();
  }
  static jQueryInterface(t) {
    new ml(this[0], t).init();
  }
  static getInstance(t) {
    return I.getData(t, cn);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const dn = "ripple", Ri = "te.ripple", mp = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%", gp = ["[data-te-ripple-init]"], Pi = [0, 0, 0], bp = [
  { name: "primary", gradientColor: "#3B71CA" },
  { name: "secondary", gradientColor: "#9FA6B2" },
  { name: "success", gradientColor: "#14A44D" },
  { name: "danger", gradientColor: "#DC4C64" },
  { name: "warning", gradientColor: "#E4A11B" },
  { name: "info", gradientColor: "#54B4D3" },
  { name: "light", gradientColor: "#fbfbfb" },
  { name: "dark", gradientColor: "#262626" }
], vr = 0.5, vp = {
  rippleCentered: !1,
  rippleColor: "",
  rippleColorDark: "",
  rippleDuration: "500ms",
  rippleRadius: 0,
  rippleUnbound: !1
}, Ep = {
  rippleCentered: "boolean",
  rippleColor: "string",
  rippleColorDark: "string",
  rippleDuration: "string",
  rippleRadius: "number",
  rippleUnbound: "boolean"
}, Tp = {
  ripple: "relative overflow-hidden inline-block align-bottom",
  rippleWave: "rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]",
  unbound: "overflow-visible"
}, Cp = {
  ripple: "string",
  rippleWave: "string",
  unbound: "string"
};
class Cs {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && (I.setData(t, Ri, this), p.addClass(this._element, this._classes.ripple)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._initialClasses = null, this.init();
  }
  // Getters
  static get NAME() {
    return dn;
  }
  // Public
  init() {
    this._addClickEvent(this._element);
  }
  dispose() {
    I.removeData(this._element, Ri), u.off(this._element, "click", this._clickHandler), this._element = null, this._options = null;
  }
  // Private
  _autoInit(t) {
    gp.forEach((e) => {
      h.closest(t.target, e) && (this._element = h.closest(t.target, e));
    }), this._element.style.minWidth || (p.style(this._element, {
      "min-width": getComputedStyle(this._element).width
    }), this._isMinWidthSet = !0), this._initialClasses = [...this._element.classList], p.addClass(this._element, this._classes.ripple), this._options = this._getConfig(), this._createRipple(t);
  }
  _addClickEvent(t) {
    u.on(t, "mousedown", this._clickHandler);
  }
  _createRipple(t) {
    this._element.className.indexOf(this._classes.ripple) < 0 && p.addClass(this._element, this._classes.ripple);
    const { layerX: e, layerY: i } = t, n = e, o = i, r = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), c = {
      offsetX: this._options.rippleCentered ? r / 2 : n,
      offsetY: this._options.rippleCentered ? a / 2 : o,
      height: r,
      width: a
    }, d = this._getDiameter(c), _ = this._options.rippleRadius || d / 2, f = {
      delay: l * vr,
      duration: l - l * vr
    }, m = {
      left: this._options.rippleCentered ? `${a / 2 - _}px` : `${n - _}px`,
      top: this._options.rippleCentered ? `${r / 2 - _}px` : `${o - _}px`,
      height: `${this._options.rippleRadius * 2 || d}px`,
      width: `${this._options.rippleRadius * 2 || d}px`,
      transitionDelay: `0s, ${f.delay}ms`,
      transitionDuration: `${l}ms, ${f.duration}ms`
    }, g = M("div");
    this._createHTMLRipple({
      wrapper: this._element,
      ripple: g,
      styles: m
    }), this._removeHTMLRipple({ ripple: g, duration: l });
  }
  _createHTMLRipple({ wrapper: t, ripple: e, styles: i }) {
    Object.keys(i).forEach(
      (n) => e.style[n] = i[n]
    ), p.addClass(e, this._classes.rippleWave), e.setAttribute("data-te-ripple-ref", ""), this._addColor(e, t), this._toggleUnbound(t), this._appendRipple(e, t);
  }
  _removeHTMLRipple({ ripple: t, duration: e }) {
    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), t && setTimeout(() => {
      t.classList.add("!opacity-0");
    }, 10), this._rippleTimer = setTimeout(() => {
      if (t && (t.remove(), this._element)) {
        h.find("[data-te-ripple-ref]", this._element).forEach(
          (n) => {
            n.remove();
          }
        ), this._isMinWidthSet && (p.style(this._element, { "min-width": "" }), this._isMinWidthSet = !1);
        const i = this._initialClasses ? this._addedNewRippleClasses(
          this._classes.ripple,
          this._initialClasses
        ) : this._classes.ripple.split(" ");
        p.removeClass(this._element, i);
      }
    }, e);
  }
  _addedNewRippleClasses(t, e) {
    return t.split(" ").filter(
      (i) => e.findIndex((n) => i === n) === -1
    );
  }
  _durationToMsNumber(t) {
    return Number(t.replace("ms", "").replace("s", "000"));
  }
  _getConfig(t = {}) {
    const e = p.getDataAttributes(this._element);
    return t = {
      ...vp,
      ...e,
      ...t
    }, N(dn, t, Ep), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...Tp,
      ...e,
      ...t
    }, N(dn, t, Cp), t;
  }
  _getDiameter({ offsetX: t, offsetY: e, height: i, width: n }) {
    const o = e <= i / 2, r = t <= n / 2, a = (f, m) => Math.sqrt(f ** 2 + m ** 2), l = e === i / 2 && t === n / 2, c = {
      first: o === !0 && r === !1,
      second: o === !0 && r === !0,
      third: o === !1 && r === !0,
      fourth: o === !1 && r === !1
    }, d = {
      topLeft: a(t, e),
      topRight: a(n - t, e),
      bottomLeft: a(t, i - e),
      bottomRight: a(n - t, i - e)
    };
    let _ = 0;
    return l || c.fourth ? _ = d.topLeft : c.third ? _ = d.topRight : c.second ? _ = d.bottomRight : c.first && (_ = d.bottomLeft), _ * 2;
  }
  _appendRipple(t, e) {
    e.appendChild(t), setTimeout(() => {
      p.addClass(t, "opacity-0 scale-100");
    }, 50);
  }
  _toggleUnbound(t) {
    this._options.rippleUnbound === !0 ? p.addClass(t, this._classes.unbound) : p.removeClass(t, this._classes.unbound);
  }
  _addColor(t) {
    let e = this._options.rippleColor || "rgb(0,0,0)";
    (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (e = this._options.rippleColorDark || this._options.rippleColor);
    const i = bp.find(
      (r) => r.name === e.toLowerCase()
    ), n = i ? this._colorToRGB(i.gradientColor).join(",") : this._colorToRGB(e).join(","), o = mp.split("{{color}}").join(`${n}`);
    t.style.backgroundImage = `radial-gradient(circle, ${o})`;
  }
  _colorToRGB(t) {
    function e(o) {
      return o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [
        parseInt(o.substr(1, 2), 16),
        parseInt(o.substr(3, 2), 16),
        parseInt(o.substr(5, 2), 16)
      ];
    }
    function i(o) {
      const r = document.body.appendChild(
        document.createElement("fictum")
      ), a = "rgb(1, 2, 3)";
      return r.style.color = a, r.style.color !== a || (r.style.color = o, r.style.color === a || r.style.color === "") ? Pi : (o = getComputedStyle(r).color, document.body.removeChild(r), o);
    }
    function n(o) {
      return o = o.match(/[.\d]+/g).map((r) => +Number(r)), o.length = 3, o;
    }
    return t.toLowerCase() === "transparent" ? Pi : t[0] === "#" ? e(t) : (t.indexOf("rgb") === -1 && (t = i(t)), t.indexOf("rgb") === 0 ? n(t) : Pi);
  }
  // Static
  static autoInitial(t) {
    return function(e) {
      t._autoInit(e);
    };
  }
  static jQueryInterface(t) {
    return this.each(function() {
      return I.getData(this, Ri) ? null : new Cs(this, t);
    });
  }
  static getInstance(t) {
    return I.getData(t, Ri);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
function Q(s) {
  return s.getDate();
}
function ls(s) {
  return s.getDay();
}
function Y(s) {
  return s.getMonth();
}
function H(s) {
  return s.getFullYear();
}
function Ap(s, t, e) {
  const i = e.startDay, n = i > 0 ? 7 - i : 0, r = new Date(s, t).getDay() + n;
  return r >= 7 ? r - 7 : r;
}
function Wn(s) {
  return yp(s).getDate();
}
function yp(s) {
  return Dt(s.getFullYear(), s.getMonth() + 1, 0);
}
function De() {
  return /* @__PURE__ */ new Date();
}
function it(s, t) {
  return nt(s, t * 12);
}
function nt(s, t) {
  const e = Dt(
    s.getFullYear(),
    s.getMonth() + t,
    s.getDate()
  ), i = Q(s), n = Q(e);
  return i !== n && e.setDate(0), e;
}
function Te(s, t) {
  return Dt(s.getFullYear(), s.getMonth(), s.getDate() + t);
}
function Dt(s, t, e) {
  const i = new Date(s, t, e);
  return s >= 0 && s < 100 && i.setFullYear(i.getFullYear() - 1900), i;
}
function Er(s) {
  const t = s.split("-"), e = t[0], i = t[1], n = t[2];
  return Dt(e, i, n);
}
function wp(s) {
  return !Number.isNaN(s.getTime());
}
function xe(s, t) {
  return H(s) - H(t) || Y(s) - Y(t) || Q(s) - Q(t);
}
function de(s, t) {
  return s.setHours(0, 0, 0, 0), t.setHours(0, 0, 0, 0), s.getTime() === t.getTime();
}
function cs(s, t) {
  const i = H(s) - Op();
  return kp(i, t);
}
function kp(s, t) {
  return (s % t + t) % t;
}
function Op(s, t, e) {
  let i = 0;
  return e ? i = H(e) - s + 1 : t && (i = H(t)), i;
}
function As(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date();
  r.setHours(0, 0, 0, 0);
  const a = t && xe(s, t) <= -1, l = e && xe(s, e) >= 1, c = n && xe(s, r) <= -1, d = o && xe(s, r) >= 1, _ = i && i(s) === !1;
  return a || l || _ || c || d;
}
function gl(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date(), a = i && H(i), l = i && Y(i), c = e && H(e), d = e && Y(e), _ = H(r), f = Y(r), m = l && a && (t > a || t === a && s > l), g = d && c && (t < c || t === c && s < d), b = n && (t < _ || t === _ && s < f), T = o && (t > _ || t === _ && s > f);
  return m || g || b || T;
}
function Fn(s, t, e, i, n) {
  const o = t && H(t), r = e && H(e), a = H(/* @__PURE__ */ new Date()), l = r && s > r, c = o && s < o, d = i && s < a, _ = n && s > a;
  return l || c || d || _;
}
function xp(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && o && xe(o, l) < 0 || s) && (o = l), o && di(
    t,
    o,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function Sp(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && n && xe(n, l) < 0 || s) && (n = l), n && di(
    t,
    n,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function di(s, t, e, i, n, o, r, a) {
  return e === "days" ? H(s) === H(t) && Y(s) === Y(t) : e === "months" ? H(s) === H(t) : e === "years" ? H(t) >= a && H(t) <= r : !1;
}
const Dp = "data-te-datepicker-modal-container-ref", Ip = "data-te-datepicker-dropdown-container-ref", $p = "data-te-dropdown-backdrop-ref", Lp = "data-te-datepicker-date-text-ref", Tr = "data-te-datepicker-view-ref", Mp = "data-te-datepicker-previous-button-ref", Np = "data-te-datepicker-next-button-ref", Rp = "data-te-datepicker-ok-button-ref", Pp = "data-te-datepicker-cancel-button-ref", Hp = "data-te-datepicker-clear-button-ref", Bp = "data-te-datepicker-view-change-button-ref";
function Vp(s, t, e, i, n, o, r, a, l, c) {
  const d = Y(s), _ = H(s), f = Q(s), m = ls(s), g = M("div"), b = `
        ${Cr(
    s,
    d,
    _,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    c
  )}
    `, T = `
      ${Fp(f, m, d, n, c)}
      ${Cr(
    s,
    d,
    _,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    c
  )}
    `;
  return n.inline ? (p.addClass(g, c.datepickerDropdownContainer), g.setAttribute(Ip, l), g.innerHTML = b) : (p.addClass(g, c.modalContainer), g.setAttribute(Dp, l), g.innerHTML = T), g;
}
function Wp(s) {
  const t = M("div");
  return p.addClass(t, s), t.setAttribute($p, ""), t;
}
function Fp(s, t, e, i, n) {
  return `
      <div class="${n.datepickerHeader}">
        <div class="${n.datepickerTitle}">
          <span class="${n.datepickerTitleText}">${i.title}</span>
        </div>
        <div class="${n.datepickerDate}">
          <span class="${n.datepickerDateText}" ${Lp} >${i.weekdaysShort[t]}, ${i.monthsShort[e]} ${s}</span>
        </div>
      </div>
    `;
}
function Cr(s, t, e, i, n, o, r, a, l, c, d) {
  let _;
  return r.inline ? _ = `
    <div class="${d.datepickerMain}">
      ${yr(t, e, r, d)}
      <div class="${d.datepickerView}" ${Tr} tabindex="0">
        ${Ar(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    c,
    d
  )}
      </div>
    </div>
  ` : _ = `
    <div class="${d.datepickerMain}">
      ${yr(t, e, r, d)}
      <div class="${d.datepickerView}" ${Tr} tabindex="0">
        ${Ar(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    c,
    d
  )}
      </div>
      ${Yp(r, d)}
    </div>
  `, _;
}
function Ar(s, t, e, i, n, o, r, a, l, c) {
  let d;
  return o.view === "days" ? d = ds(s, e, o, c) : o.view === "months" ? d = hs(
    t,
    i,
    n,
    o,
    r,
    c
  ) : d = us(
    s,
    i,
    o,
    a,
    l,
    c
  ), d;
}
function yr(s, t, e, i) {
  return `
    <div class="${i.datepickerDateControls}">
      <button class="${i.datepickerViewChangeButton}" aria-label="${e.switchToMultiYearViewLabel}" ${Bp}>
        ${e.monthsFull[s]} ${t} ${kt(
    e,
    i
  )}
      </button>
      <div class="${i.datepickerArrowControls}">
        <button class="${i.datepickerPreviousButton}" aria-label="${e.prevMonthLabel}" ${Mp}>${e.changeMonthIconTemplate}</button>
        <button class="${i.datepickerNextButton}" aria-label="${e.nextMonthLabel}" ${Np}>${e.changeMonthIconTemplate}</button>
      </div>
    </div>
    `;
}
function kt(s, t) {
  return `
  <span class="${t.datepickerViewChangeIcon}">
  ${s.viewChangeIconTemplate}
  </span>
  `;
}
function Yp(s, t) {
  const e = `<button class="${t.datepickerFooterBtn}" aria-label="${s.okBtnLabel}" ${Rp}>${s.okBtnText}</button>`, i = `<button class="${t.datepickerFooterBtn}" aria-label="${s.cancelBtnLabel}" ${Pp}>${s.cancelBtnText}</button>`, n = `<button class="${t.datepickerFooterBtn} ${t.datepickerClearBtn}" aria-label="${s.clearBtnLabel}" ${Hp}>${s.clearBtnText}</button>`;
  return `
        <div class="${t.datepickerFooter}">
          
        ${s.removeClearBtn ? "" : n}
        ${s.removeCancelBtn ? "" : i}
        ${s.removeOkBtn ? "" : e}
        </div>
      `;
}
function ds(s, t, e, i) {
  const n = jp(s, t, e), r = `
      <tr>
        ${e.weekdaysNarrow.map((l, c) => `<th class="${i.datepickerDayHeading}" scope="col" aria-label="${e.weekdaysFull[c]}">${l}</th>`).join("")}
      </tr>
    `, a = n.map((l) => `
        <tr>
          ${l.map((c) => `
              <td
              class="${i.datepickerCell} ${i.datepickerCellSmall}"
              data-te-date="${H(c.date)}-${Y(
    c.date
  )}-${Q(c.date)}"
              aria-label="${c.date}"
              aria-selected="${c.isSelected}"
              ${c.isSelected ? "data-te-datepicker-cell-selected" : ""}
              ${!c.currentMonth || c.disabled ? "data-te-datepicker-cell-disabled" : ""}
              ${c.isToday ? "data-te-datepicker-cell-current" : ""}
              >
                <div
                  class="${i.datepickerCellContent} ${i.datepickerCellContentSmall}"
                  style="${c.currentMonth ? "display: block" : "display: none"}"
                  >
                  ${c.dayNumber}
                  </div>
              </td>
            `).join("")}
        </tr>
      `).join("");
  return `
      <table class="${i.datepickerTable}">
        <thead>
          ${r}
        </thead>
        <tbody>
         ${a}
        </tbody>
      </table>
    `;
}
function jp(s, t, e) {
  const i = [], n = Y(s), o = Y(nt(s, -1)), r = Y(nt(s, 1)), a = H(s), l = Ap(a, n, e), c = Wn(s), d = Wn(nt(s, -1)), _ = 7;
  let f = 1, m = !1;
  for (let g = 1; g < _; g++) {
    const b = [];
    if (g === 1) {
      const T = d - l + 1;
      for (let w = T; w <= d; w++) {
        const v = Dt(a, o, w);
        b.push({
          date: v,
          currentMonth: m,
          isSelected: t && de(v, t),
          isToday: de(v, De()),
          dayNumber: Q(v)
        });
      }
      m = !0;
      const C = _ - b.length;
      for (let w = 0; w < C; w++) {
        const v = Dt(a, n, f);
        b.push({
          date: v,
          currentMonth: m,
          isSelected: t && de(v, t),
          isToday: de(v, De()),
          dayNumber: Q(v),
          disabled: As(
            v,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), f++;
      }
    } else
      for (let T = 1; T < 8; T++) {
        f > c && (f = 1, m = !1);
        const C = Dt(
          a,
          m ? n : r,
          f
        );
        b.push({
          date: C,
          currentMonth: m,
          isSelected: t && de(C, t),
          isToday: de(C, De()),
          dayNumber: Q(C),
          disabled: As(
            C,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), f++;
      }
    i.push(b);
  }
  return i;
}
function hs(s, t, e, i, n, o) {
  const r = Kp(i, n), a = Y(De()), l = H(De()), c = `
      ${r.map((d) => `
          <tr>
            ${d.map((_) => {
    const f = i.monthsShort.indexOf(_);
    return `
                <td class="${o.datepickerCell} ${o.datepickerCellLarge}"
                ${gl(
      f,
      s,
      i.min,
      i.max,
      i.disablePast,
      i.disableFuture
    ) ? "data-te-datepicker-cell-disabled" : ""}
                
                data-te-month="${f}" data-te-year="${s}" aria-label="${_}, ${s}"
                ${f === e && s === t ? "data-te-datepicker-cell-selected" : ""}
                ${f === a && s === l ? "data-te-datepicker-cell-current" : ""}" data-te-month="${f}" data-te-year="${s}" aria-label="${_}, ${s}">
                  <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${_}</div>
                </td>
              `;
  }).join("")}
          </tr>
        `).join("")}
    `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
         ${c}
        </tbody>
      </table>
    `;
}
function Kp(s, t) {
  const e = [];
  let i = [];
  for (let n = 0; n < s.monthsShort.length; n++)
    if (i.push(s.monthsShort[n]), i.length === t) {
      const o = i;
      e.push(o), i = [];
    }
  return e;
}
function us(s, t, e, i, n, o) {
  const r = Up(s, i, n), a = H(De()), l = `
    ${r.map((c) => `
        <tr>
          ${c.map((d) => `
              <td class="${o.datepickerCell} ${o.datepickerCellLarge}"  aria-label="${d}" data-te-year="${d}"
              ${Fn(
    d,
    e.min,
    e.max,
    e.disablePast,
    e.disableFuture
  ) ? "data-te-datepicker-cell-disabled" : ""}
              ${d === t ? "data-te-datepicker-cell-selected" : ""}
              ${d === a ? "data-te-datepicker-cell-current" : ""}
              >
                <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${d}</div>
              </td>
            `).join("")}
        </tr>
      `).join("")}
  `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
        ${l}
        </tbody>
      </table>
    `;
}
function Up(s, t, e) {
  const i = [], n = H(s), o = cs(s, t), r = n - o;
  let a = [];
  for (let l = 0; l < t; l++)
    if (a.push(r + l), a.length === e) {
      const c = a;
      i.push(c), a = [];
    }
  return i;
}
function zp(s, t) {
  return `
    <button id="${s}" type="button" class="${t}" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
      <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z" clip-rule="evenodd" />
      </svg>  
    </button>
  `;
}
const Ie = 37, rt = 38, $e = 39, U = 40, Le = 36, Me = 35, hn = 33, un = 34, lt = 13, ps = 32, Is = 27, fi = 9, Xp = 8, Gp = 46, mt = 24, Hi = 4, Bi = 4, pn = "datepicker", fs = "te.datepicker", $s = `.${fs}`, qp = ".data-api", Qp = `close${$s}`, Zp = `open${$s}`, Jp = `dateChange${$s}`, Vi = `click${$s}${qp}`, bl = "data-te-datepicker-modal-container-ref", vl = "data-te-datepicker-dropdown-container-ref", Wi = "[data-te-datepicker-toggle-ref]", tf = `[${bl}]`, ef = `[${vl}]`, sf = "[data-te-datepicker-view-change-button-ref]", nf = "[data-te-datepicker-previous-button-ref]", of = "[data-te-datepicker-next-button-ref]", rf = "[data-te-datepicker-ok-button-ref]", af = "[data-te-datepicker-cancel-button-ref]", lf = "[data-te-datepicker-clear-button-ref]", cf = "[data-te-datepicker-view-ref]", df = "[data-te-datepicker-toggle-button-ref]", hf = "[data-te-datepicker-date-text-ref]", uf = "[data-te-dropdown-backdrop-ref]", pf = "animate-[fade-in_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", ff = "animate-[fade-out_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", _f = "animate-[fade-in_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", mf = "animate-[fade-out_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", gf = "flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700", bf = "w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]", vf = "relative h-full", Ef = "xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800", Tf = "h-8 flex flex-col justify-end", Cf = "text-[10px] font-normal uppercase tracking-[1.7px] text-white", Af = "xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end", yf = "text-[34px] font-normal text-white", wf = "outline-none px-3", kf = "px-3 pt-2.5 pb-0 flex justify-between text-black/[64]", Of = "flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", xf = "mt-2.5", Sf = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto", Df = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto", If = "h-14 flex absolute w-full bottom-0 justify-end items-center px-3", $f = "outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", Lf = "mr-auto", Mf = "w-10 h-10 text-center text-[12px] font-normal dark:text-white", Nf = "text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group", Rf = "w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8", Pf = "w-[76px] h-[42px]", Hf = "mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:text-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10 dark:group-[[data-te-datepicker-cell-disabled]]:text-neutral-500", Bf = "w-9 h-9 leading-9 rounded-[50%] text-[13px]", Vf = "w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]", Wf = "mx-auto w-[304px]", Ff = "flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200", Yf = "inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white", jf = "w-[328px] h-[380px] bg-white rounded-lg shadow-[0px_2px_15px_-3px_rgba(0,0,0,.07),_0px_10px_20px_-2px_rgba(0,0,0,.04)] z-[1066] dark:bg-zinc-700", Kf = {
  title: "Select date",
  container: "body",
  disablePast: !1,
  disableFuture: !1,
  monthsFull: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  monthsShort: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  weekdaysFull: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  weekdaysNarrow: ["S", "M", "T", "W", "T", "F", "S"],
  okBtnText: "Ok",
  clearBtnText: "Clear",
  cancelBtnText: "Cancel",
  okBtnLabel: "Confirm selection",
  clearBtnLabel: "Clear selection",
  cancelBtnLabel: "Cancel selection",
  nextMonthLabel: "Next month",
  prevMonthLabel: "Previous month",
  nextYearLabel: "Next year",
  prevYearLabel: "Previous year",
  changeMonthIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
  </svg>
  `,
  nextMultiYearLabel: "Next 24 years",
  prevMultiYearLabel: "Previous 24 years",
  switchToMultiYearViewLabel: "Choose year and month",
  switchToMonthViewLabel: "Choose date",
  switchToDayViewLabel: "Choose date",
  startDate: null,
  startDay: 0,
  format: "dd/mm/yyyy",
  view: "days",
  viewChangeIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="0" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
  </svg>
  `,
  min: null,
  max: null,
  filter: null,
  inline: !1,
  toggleButton: !0,
  disableToggleButton: !1,
  disableInput: !1,
  animations: !0,
  confirmDateOnSelect: !1,
  removeOkBtn: !1,
  removeCancelBtn: !1,
  removeClearBtn: !1
}, Uf = {
  title: "string",
  container: "string",
  disablePast: "boolean",
  disableFuture: "boolean",
  monthsFull: "array",
  monthsShort: "array",
  weekdaysFull: "array",
  weekdaysShort: "array",
  weekdaysNarrow: "array",
  okBtnText: "string",
  clearBtnText: "string",
  cancelBtnText: "string",
  okBtnLabel: "string",
  clearBtnLabel: "string",
  cancelBtnLabel: "string",
  nextMonthLabel: "string",
  prevMonthLabel: "string",
  nextYearLabel: "string",
  prevYearLabel: "string",
  nextMultiYearLabel: "string",
  prevMultiYearLabel: "string",
  changeMonthIconTemplate: "string",
  switchToMultiYearViewLabel: "string",
  switchToMonthViewLabel: "string",
  switchToDayViewLabel: "string",
  startDate: "(null|string|date)",
  startDay: "number",
  format: "string",
  view: "string",
  viewChangeIconTemplate: "string",
  min: "(null|string|date)",
  max: "(null|string|date)",
  filter: "(null|function)",
  inline: "boolean",
  toggleButton: "boolean",
  disableToggleButton: "boolean",
  disableInput: "boolean",
  animations: "boolean",
  confirmDateOnSelect: "boolean",
  removeOkBtn: "boolean",
  removeCancelBtn: "boolean",
  removeClearBtn: "boolean"
}, zf = {
  fadeIn: pf,
  fadeOut: ff,
  fadeInShort: _f,
  fadeOutShort: mf,
  modalContainer: gf,
  datepickerBackdrop: bf,
  datepickerMain: vf,
  datepickerHeader: Ef,
  datepickerTitle: Tf,
  datepickerTitleText: Cf,
  datepickerDate: Af,
  datepickerDateText: yf,
  datepickerView: wf,
  datepickerDateControls: kf,
  datepickerViewChangeButton: Of,
  datepickerViewChangeIcon: Yf,
  datepickerArrowControls: xf,
  datepickerPreviousButton: Sf,
  datepickerNextButton: Df,
  datepickerFooter: If,
  datepickerFooterBtn: $f,
  datepickerClearBtn: Lf,
  datepickerDayHeading: Mf,
  datepickerCell: Nf,
  datepickerCellSmall: Rf,
  datepickerCellLarge: Pf,
  datepickerCellContent: Hf,
  datepickerCellContentSmall: Bf,
  datepickerCellContentLarge: Vf,
  datepickerTable: Wf,
  datepickerToggleButton: Ff,
  datepickerDropdownContainer: jf
}, Xf = {
  fadeIn: "string",
  fadeOut: "string",
  fadeInShort: "string",
  fadeOutShort: "string",
  modalContainer: "string",
  datepickerBackdrop: "string",
  datepickerMain: "string",
  datepickerHeader: "string",
  datepickerTitle: "string",
  datepickerTitleText: "string",
  datepickerDate: "string",
  datepickerDateText: "string",
  datepickerView: "string",
  datepickerDateControls: "string",
  datepickerViewChangeButton: "string",
  datepickerArrowControls: "string",
  datepickerPreviousButton: "string",
  datepickerNextButton: "string",
  datepickerFooter: "string",
  datepickerFooterBtn: "string",
  datepickerClearBtn: "string",
  datepickerDayHeading: "string",
  datepickerCell: "string",
  datepickerCellSmall: "string",
  datepickerCellLarge: "string",
  datepickerCellContent: "string",
  datepickerCellContentSmall: "string",
  datepickerCellContentLarge: "string",
  datepickerTable: "string",
  datepickerToggleButton: "string",
  datepickerDropdownContainer: "string"
};
class Gg {
  constructor(t, e, i) {
    this._element = t, this._input = h.findOne("input", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = Ot("datepicker-toggle-"), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this._scrollBar = new pi(), this._element && I.setData(t, fs, this), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = "true"), this._options.disableInput && (this._input.disabled = "true");
  }
  // Getters
  static get NAME() {
    return pn;
  }
  get container() {
    return h.findOne(
      `[${bl}='${this._toggleButtonId}']`
    ) || h.findOne(
      `[${vl}='${this._toggleButtonId}']`
    );
  }
  get options() {
    return this._options;
  }
  get activeCell() {
    let t;
    return this._view === "days" && (t = this._getActiveDayCell()), this._view === "months" && (t = this._getActiveMonthCell()), this._view === "years" && (t = this._getActiveYearCell()), t;
  }
  get activeDay() {
    return Q(this._activeDate);
  }
  get activeMonth() {
    return Y(this._activeDate);
  }
  get activeYear() {
    return H(this._activeDate);
  }
  get firstYearInView() {
    return this.activeYear - cs(this._activeDate, mt);
  }
  get lastYearInView() {
    return this.firstYearInView + mt - 1;
  }
  get viewChangeButton() {
    return h.findOne(sf, this.container);
  }
  get previousButton() {
    return h.findOne(nf, this.container);
  }
  get nextButton() {
    return h.findOne(of, this.container);
  }
  get okButton() {
    return h.findOne(rf, this.container);
  }
  get cancelButton() {
    return h.findOne(af, this.container);
  }
  get clearButton() {
    return h.findOne(lf, this.container);
  }
  get datesContainer() {
    return h.findOne(cf, this.container);
  }
  get toggleButton() {
    return h.findOne(df, this._element);
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._element);
    if (t = {
      ...Kf,
      ...e,
      ...t
    }, N(pn, t, Uf), t.max && typeof t.max == "string" && (t.max = new Date(t.max)), t.min && typeof t.min == "string" && (t.min = new Date(t.min)), t.startDay && t.startDay !== 0) {
      const i = this._getNewDaysOrderArray(t);
      t.weekdaysNarrow = i;
    }
    return t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...zf,
      ...e,
      ...t
    }, N(pn, t, Xf), t;
  }
  _getContainer() {
    return h.findOne(this._options.container);
  }
  _getNewDaysOrderArray(t) {
    const e = t.startDay, i = t.weekdaysNarrow;
    return i.slice(e).concat(i.slice(0, e));
  }
  _init() {
    !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = "none")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown();
  }
  _appendToggleButton() {
    const t = zp(
      this._toggleButtonId,
      this._classes.datepickerToggleButton
    );
    this._element.insertAdjacentHTML("beforeend", t);
  }
  open() {
    if (this._input.readOnly || this._input.disabled)
      return;
    const t = u.trigger(this._element, Zp);
    if (this._isOpen || t.defaultPrevented)
      return;
    this._setInitialDate();
    const e = Wp(this._classes.datepickerBackdrop), i = Vp(
      this._activeDate,
      this._selectedDate,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Bi,
      mt,
      Hi,
      this._toggleButtonId,
      this._classes
    );
    this._options.inline ? this._openDropdown(i) : (this._openModal(e, i), this._scrollBar.hide()), this._animations && (p.addClass(this.container, this._classes.fadeIn), p.addClass(e, this._classes.fadeInShort)), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(() => {
      this._listenToOutsideClick();
    }, 0);
  }
  _openDropdown(t) {
    this._popper = je(this._input, t, {
      placement: "bottom-start"
    }), this._getContainer().appendChild(t);
  }
  _openModal(t, e) {
    const i = this._getContainer();
    i.appendChild(t), i.appendChild(e);
  }
  _setFocusTrap(t) {
    this._focusTrap = new bi(t, {
      event: "keydown",
      condition: (e) => e.key === "Tab"
    }), this._focusTrap.trap();
  }
  _listenToUserInput() {
    u.on(this._input, "input", (t) => {
      this._handleUserInput(t.target.value);
    });
  }
  _listenToToggleClick() {
    u.on(
      this._element,
      Vi,
      Wi,
      (t) => {
        t.preventDefault(), this.open();
      }
    );
  }
  _listenToToggleKeydown() {
    u.on(
      this._element,
      "keydown",
      Wi,
      (t) => {
        t.keyCode === lt && !this._isOpen && this.open();
      }
    );
  }
  _listenToDateSelection() {
    u.on(this.datesContainer, "click", (t) => {
      this._handleDateSelection(t);
    });
  }
  _handleDateSelection(t) {
    const e = t.target.nodeName === "DIV" ? t.target.parentNode.dataset : t.target.dataset, i = t.target.nodeName === "DIV" ? t.target.parentNode : t.target;
    if (e.teDate && this._pickDay(e.teDate, i), e.teMonth && e.teYear) {
      const n = parseInt(e.teMonth, 10), o = parseInt(e.teYear, 10);
      this._pickMonth(n, o);
    }
    if (e.teYear && !e.teMonth) {
      const n = parseInt(e.teYear, 10);
      this._pickYear(n);
    }
    this._options.inline || this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _updateHeaderDate(t, e, i) {
    const n = h.findOne(
      hf,
      this.container
    ), o = Y(t), r = Q(t), a = ls(t);
    n.innerHTML = `${i[a]}, ${e[o]} ${r}`;
  }
  _addControlsListeners() {
    u.on(this.nextButton, "click", () => {
      this._view === "days" ? this.nextMonth() : this._view === "years" ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState();
    }), u.on(this.previousButton, "click", () => {
      this._view === "days" ? this.previousMonth() : this._view === "years" ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState();
    }), u.on(this.viewChangeButton, "click", () => {
      this._view === "days" ? this._changeView("years") : (this._view === "years" || this._view === "months") && this._changeView("days");
    }), this._options.inline || this._listenToFooterButtonsClick();
  }
  _listenToFooterButtonsClick() {
    u.on(this.okButton, "click", () => this.handleOk()), u.on(this.cancelButton, "click", () => this.handleCancel()), u.on(this.clearButton, "click", () => this.handleClear());
  }
  _listenToOutsideClick() {
    u.on(document, Vi, (t) => {
      const e = t.target === this.container, i = this.container && this.container.contains(t.target);
      !e && !i && this.close();
    });
  }
  _listenToEscapeClick() {
    u.on(document, "keydown", (t) => {
      t.keyCode === Is && this._isOpen && this.close();
    });
  }
  _listenToKeyboardNavigation() {
    u.on(this.datesContainer, "keydown", (t) => {
      this._handleKeydown(t);
    });
  }
  _listenToDatesContainerFocus() {
    u.on(this.datesContainer, "focus", () => {
      this._focusActiveCell(this.activeCell);
    });
  }
  _listenToDatesContainerBlur() {
    u.on(this.datesContainer, "blur", () => {
      this._removeCurrentFocusStyles();
    });
  }
  _handleKeydown(t) {
    this._view === "days" && this._handleDaysViewKeydown(t), this._view === "months" && this._handleMonthsViewKeydown(t), this._view === "years" && this._handleYearsViewKeydown(t);
  }
  _handleDaysViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Ie:
        this._activeDate = Te(this._activeDate, F() ? 1 : -1);
        break;
      case $e:
        this._activeDate = Te(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = Te(this._activeDate, -7);
        break;
      case U:
        this._activeDate = Te(this._activeDate, 7);
        break;
      case Le:
        this._activeDate = Te(
          this._activeDate,
          1 - Q(this._activeDate)
        );
        break;
      case Me:
        this._activeDate = Te(
          this._activeDate,
          Wn(this._activeDate) - Q(this._activeDate)
        );
        break;
      case hn:
        this._activeDate = nt(this._activeDate, -1);
        break;
      case un:
        this._activeDate = nt(this._activeDate, 1);
        break;
      case lt:
      case ps:
        this._selectDate(this._activeDate), this._handleDateSelection(t), t.preventDefault();
        return;
      default:
        return;
    }
    di(
      e,
      this._activeDate,
      this._view,
      mt,
      this._options.min,
      this._options.max
    ) || this._changeView("days"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _asyncFocusDatesContainer() {
    setTimeout(() => {
      this.datesContainer.focus();
    }, 0);
  }
  _focusActiveCell(t) {
    t && t.setAttribute("data-te-datepicker-cell-focused", "");
  }
  _removeHighlightFromCell(t) {
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  _getActiveDayCell() {
    const t = h.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = Er(i.dataset.teDate);
      return de(n, this._activeDate);
    });
  }
  _handleMonthsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Ie:
        this._activeDate = nt(this._activeDate, F() ? 1 : -1);
        break;
      case $e:
        this._activeDate = nt(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = nt(this._activeDate, -4);
        break;
      case U:
        this._activeDate = nt(this._activeDate, 4);
        break;
      case Le:
        this._activeDate = nt(this._activeDate, -this.activeMonth);
        break;
      case Me:
        this._activeDate = nt(this._activeDate, 11 - this.activeMonth);
        break;
      case hn:
        this._activeDate = it(this._activeDate, -1);
        break;
      case un:
        this._activeDate = it(this._activeDate, 1);
        break;
      case lt:
      case ps:
        this._selectMonth(this.activeMonth);
        return;
      default:
        return;
    }
    di(
      e,
      this._activeDate,
      this._view,
      mt,
      this._options.min,
      this._options.max
    ) || this._changeView("months"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveMonthCell() {
    const t = h.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = parseInt(i.dataset.teYear, 10), o = parseInt(i.dataset.teMonth, 10);
      return n === this.activeYear && o === this.activeMonth;
    });
  }
  _handleYearsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell, n = 4, o = 24;
    switch (t.keyCode) {
      case Ie:
        this._activeDate = it(this._activeDate, F() ? 1 : -1);
        break;
      case $e:
        this._activeDate = it(this._activeDate, F() ? -1 : 1);
        break;
      case rt:
        this._activeDate = it(this._activeDate, -n);
        break;
      case U:
        this._activeDate = it(this._activeDate, n);
        break;
      case Le:
        this._activeDate = it(
          this._activeDate,
          -cs(this._activeDate, o)
        );
        break;
      case Me:
        this._activeDate = it(
          this._activeDate,
          o - cs(this._activeDate, o) - 1
        );
        break;
      case hn:
        this._activeDate = it(this._activeDate, -o);
        break;
      case un:
        this._activeDate = it(this._activeDate, o);
        break;
      case lt:
      case ps:
        this._selectYear(this.activeYear);
        return;
      default:
        return;
    }
    di(
      e,
      this._activeDate,
      this._view,
      mt,
      this._options.min,
      this._options.max
    ) || this._changeView("years"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveYearCell() {
    const t = h.find("td", this.datesContainer);
    return Array.from(t).find((i) => parseInt(i.dataset.teYear, 10) === this.activeYear);
  }
  _setInitialDate() {
    this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = /* @__PURE__ */ new Date();
  }
  close() {
    const t = u.trigger(this._element, Qp);
    !this._isOpen || t.defaultPrevented || (this._removeDatepickerListeners(), this._animations && p.addClass(this.container, this._classes.fadeOut), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, this.toggleButton ? this.toggleButton.focus() : this._input.focus());
  }
  _closeDropdown() {
    const t = h.findOne(ef);
    window.matchMedia("(prefers-reduced-motion: reduce)").matches && (t && document.body.removeChild(t), this._popper && this._popper.destroy()), t.addEventListener("animationend", () => {
      t && document.body.removeChild(t), this._popper && this._popper.destroy();
    }), this._removeFocusTrap();
  }
  _closeModal() {
    const t = h.findOne(uf), e = h.findOne(tf);
    !e || !t || (this._animations ? (p.addClass(t, this._classes.fadeOutShort), t.addEventListener("animationend", () => {
      this._removePicker(t, e), this._scrollBar.reset();
    })) : (this._removePicker(t, e), this._scrollBar.reset()));
  }
  _removePicker(t, e) {
    const i = this._getContainer();
    i.removeChild(t), i.removeChild(e);
  }
  _removeFocusTrap() {
    this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null);
  }
  _removeDatepickerListeners() {
    u.off(this.nextButton, "click"), u.off(this.previousButton, "click"), u.off(this.viewChangeButton, "click"), u.off(this.okButton, "click"), u.off(this.cancelButton, "click"), u.off(this.clearButton, "click"), u.off(this.datesContainer, "click"), u.off(this.datesContainer, "keydown"), u.off(this.datesContainer, "focus"), u.off(this.datesContainer, "blur"), u.off(document, Vi);
  }
  dispose() {
    this._isOpen && this.close(), this._removeInputAndToggleListeners();
    const t = h.findOne(
      `#${this._toggleButtonId}`
    );
    t && this._element.removeChild(t), I.removeData(this._element, fs), this._element = null, this._input = null, this._options = null, this._activeDate = null, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = null, this._popper = null, this._focusTrap = null;
  }
  _removeInputAndToggleListeners() {
    u.off(this._input, "input"), u.off(
      this._element,
      Vi,
      Wi
    ), u.off(this._element, "keydown", Wi);
  }
  handleOk() {
    this._confirmSelection(this._headerDate), this.close();
  }
  _selectDate(t, e = this.activeCell) {
    const { min: i, max: n, filter: o, disablePast: r, disableFuture: a } = this._options;
    As(t, i, n, o, r, a) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = H(t), this._selectedMonth = Y(t), this._headerDate = t, (this._options.inline || this.options.confirmDateOnSelect) && (this._confirmSelection(t), this.close()));
  }
  _selectYear(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView("months");
  }
  _selectMonth(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView("days");
  }
  _removeSelectedStyles(t) {
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _addSelectedStyles(t) {
    t && t.setAttribute("data-te-datepicker-cell-selected", "");
  }
  _confirmSelection(t) {
    if (t) {
      const e = this.formatDate(t);
      this._input.value = e, u.trigger(this._element, Jp, { date: t }), u.trigger(this._input, "input");
    }
  }
  handleCancel() {
    this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close();
  }
  handleClear() {
    this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = "", this._setInitialDate(), this._changeView("days"), this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _removeCurrentSelectionStyles() {
    const t = h.findOne(
      "[data-te-datepicker-cell-selected]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _removeCurrentFocusStyles() {
    const t = h.findOne(
      "[data-te-datepicker-cell-focused]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  formatDate(t) {
    const e = Q(t), i = this._addLeadingZero(Q(t)), n = this._options.weekdaysShort[ls(t)], o = this._options.weekdaysFull[ls(t)], r = Y(t) + 1, a = this._addLeadingZero(Y(t) + 1), l = this._options.monthsShort[Y(t)], c = this._options.monthsFull[Y(t)], d = H(t).toString().length === 2 ? H(t) : H(t).toString().slice(2, 4), _ = H(t), f = this._options.format.split(
      /(d{1,4}|m{1,4}|y{4}|yy|!.)/g
    );
    let m = "";
    return f.forEach((g) => {
      switch (g) {
        case "dddd":
          g = g.replace(g, o);
          break;
        case "ddd":
          g = g.replace(g, n);
          break;
        case "dd":
          g = g.replace(g, i);
          break;
        case "d":
          g = g.replace(g, e);
          break;
        case "mmmm":
          g = g.replace(g, c);
          break;
        case "mmm":
          g = g.replace(g, l);
          break;
        case "mm":
          g = g.replace(g, a);
          break;
        case "m":
          g = g.replace(g, r);
          break;
        case "yyyy":
          g = g.replace(g, _);
          break;
        case "yy":
          g = g.replace(g, d);
          break;
      }
      m += g;
    }), m;
  }
  _addLeadingZero(t) {
    return parseInt(t, 10) < 10 ? `0${t}` : t;
  }
  _pickDay(t, e) {
    const i = Er(t), { min: n, max: o, filter: r, disablePast: a, disableFuture: l } = this._options;
    As(i, n, o, r, a, l) || (this._activeDate = i, this._selectDate(i, e));
  }
  _pickYear(t) {
    const { min: e, max: i, disablePast: n, disableFuture: o } = this._options;
    if (Fn(t, e, i, n, o))
      return;
    const r = Dt(t, this.activeMonth, this.activeDay);
    this._activeDate = r, this._selectedDate = r, this._selectYear(t);
  }
  _pickMonth(t, e) {
    const { min: i, max: n, disablePast: o, disableFuture: r } = this._options;
    if (gl(t, e, i, n, o, r) || Fn(e, i, n, o, r))
      return;
    const a = Dt(e, t, this.activeDay);
    this._activeDate = a, this._selectMonth(t);
  }
  nextMonth() {
    const t = nt(this._activeDate, 1), e = ds(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this._activeDate = t, this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousMonth() {
    const t = nt(this._activeDate, -1);
    this._activeDate = t;
    const e = ds(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  nextYear() {
    const t = it(this._activeDate, 1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    );
    const e = hs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Bi,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  previousYear() {
    const t = it(this._activeDate, -1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    );
    const e = hs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Bi,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  nextYears() {
    const t = it(this._activeDate, 24);
    this._activeDate = t;
    const e = us(
      t,
      this._selectedYear,
      this._options,
      mt,
      Hi,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousYears() {
    const t = it(this._activeDate, -24);
    this._activeDate = t;
    const e = us(
      t,
      this._selectedYear,
      this._options,
      mt,
      Hi,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  _asyncChangeView(t) {
    setTimeout(() => {
      this._changeView(t);
    }, 0);
  }
  _changeView(t) {
    this._view = t, this.datesContainer.blur(), t === "days" && (this.datesContainer.innerHTML = ds(
      this._activeDate,
      this._headerDate,
      this._options,
      this._classes
    )), t === "months" && (this.datesContainer.innerHTML = hs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      Bi,
      this._classes
    )), t === "years" && (this.datesContainer.innerHTML = us(
      this._activeDate,
      this._selectedYear,
      this._options,
      mt,
      Hi,
      this._classes
    )), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState();
  }
  _updateViewControlsAndAttributes(t) {
    t === "days" && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMultiYearViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMonthLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextMonthLabel)), t === "months" && (this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToDayViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevYearLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextYearLabel)), t === "years" && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += kt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMonthViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMultiYearLabel
    ), this.nextButton.setAttribute(
      "aria-label",
      this._options.nextMultiYearLabel
    ));
  }
  _updateControlsDisabledState() {
    xp(
      this._options.disableFuture,
      this._activeDate,
      this._view,
      mt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.nextButton.disabled = !0 : this.nextButton.disabled = !1, Sp(
      this._options.disablePast,
      this._activeDate,
      this._view,
      mt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.previousButton.disabled = !0 : this.previousButton.disabled = !1;
  }
  _handleUserInput(t) {
    const e = this._getDelimeters(this._options.format), i = this._parseDate(t, this._options.format, e);
    wp(i) ? (this._activeDate = i, this._selectedDate = i, this._selectedYear = H(i), this._selectedMonth = Y(i), this._headerDate = i) : (this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null);
  }
  _getDelimeters(t) {
    return t.match(/[^(dmy)]{1,}/g);
  }
  _parseDate(t, e, i) {
    let n;
    i[0] !== i[1] ? n = i[0] + i[1] : n = i[0];
    const o = new RegExp(`[${n}]`), r = t.split(o), a = e.split(o), l = e.indexOf("mmm") !== -1, c = [];
    for (let b = 0; b < a.length; b++)
      a[b].indexOf("yy") !== -1 && (c[0] = { value: r[b], format: a[b] }), a[b].indexOf("m") !== -1 && (c[1] = { value: r[b], format: a[b] }), a[b].indexOf("d") !== -1 && a[b].length <= 2 && (c[2] = { value: r[b], format: a[b] });
    let d;
    e.indexOf("mmmm") !== -1 ? d = this._options.monthsFull : d = this._options.monthsShort;
    const _ = Number(c[0].value), f = l ? this.getMonthNumberByMonthName(c[1].value, d) : Number(c[1].value) - 1, m = Number(c[2].value);
    return Dt(_, f, m);
  }
  getMonthNumberByMonthName(t, e) {
    return e.findIndex((i) => i === t);
  }
  static getInstance(t) {
    return I.getData(t, fs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Gf = ({
  format24: s,
  okLabel: t,
  cancelLabel: e,
  headID: i,
  footerID: n,
  bodyID: o,
  pickerID: r,
  clearLabel: a,
  inline: l,
  showClearBtn: c,
  amLabel: d,
  pmLabel: _
}, f) => {
  const m = `<div id='${r}' class='${f.timepickerWrapper}' data-te-timepicker-wrapper>
      <div class="${f.timepickerContainer}">
        <div class="${f.timepickerElements}">
        <div id='${i}' class='${f.timepickerHead}' style='padding-right:${s ? 50 : 10}px'>
        <div class='${f.timepickerHeadContent}'>
            <div class="${f.timepickerCurrentWrapper}">
              <span class="${f.timepickerCurrentButtonWrapper}">
                <button type='button' class='${f.timepickerCurrentButton}' tabindex="0" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>
              </span>
              <button type='button' class='${f.timepickerDot}' disabled>:</button>
            <span class="${f.timepickerCurrentButtonWrapper}">
              <button type='button' class='${f.timepickerCurrentButton}' tabindex="0" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>
            </span>
            </div>
            ${s ? "" : `<div class="${f.timepickerModeWrapper}">
                  <button type='button' class="${f.timepickerModeAm}" tabindex="0" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${d}</button>
                  <button class="${f.timepickerModePm}" tabindex="0" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${_}</button>
                </div>`}
        </div>
      </div>
      ${l ? "" : `<div id='${o}' class='${f.timepickerClockWrapper}' data-te-timepicker-clock-wrapper>
            <div class='${f.timepickerClock}' data-te-timepicker-clock>
              <span class='${f.timepickerMiddleDot}' data-te-timepicker-middle-dot></span>
              <div class='${f.timepickerHandPointer}' data-te-timepicker-hand-pointer>
                <div class='${f.timepickerPointerCircle}' data-te-timepicker-circle></div>
              </div>
              ${s ? '<div class="' + f.timepickerClockInner + '" data-te-timepicker-clock-inner></div>' : ""}
            </div>
          </div>`}
    </div>
    <div id='${n}' class='${f.timepickerFooterWrapper}'>
      <div class="${f.timepickerFooter}">
        ${c ? `<button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-clear tabindex="0" data-te-ripple-init>${a}</button>` : ""}
        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-cancel tabindex="0" data-te-ripple-init>${e}</button>
        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
      </div>
    </div>
  </div>
</div>`, g = `<div id='${r}' class='${f.timepickerInlineWrapper}' data-te-timepicker-wrapper>
        <div class="${f.timepickerInlineContainer}">
          <div class="${f.timepickerInlineElements}">
          <div id='${i}' class='${f.timepickerInlineHead}'
          style='padding-right:10px'>
          <div class='${f.timepickerInlineHeadContent}'>
              <div class="${f.timepickerCurrentWrapper}">
                <span class="${f.timepickerInlineHourWrapper}" data-te-timepicker-inline-hour-icons>
                  <span class="${f.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>
                    <span class="${f.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                      </svg>   
                    </span>
                  </span>
                  <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                  <span class="${f.timepickerInlineIconDown}" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>
                    <span class="${f.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                      </svg>  
                    </span>
                  </span>
                </span>
                <button type='button' class='${f.timepickerInlineDot}' data-te-timepicker-current-inline disabled>:</button>
              <span class="${f.timepickerCurrentMinuteWrapper}">
                <span class="${f.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>
                  <span class="${f.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                    </svg>
                  </span>
                </span>
                <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                <span class="${f.timepickerInlineIconDown}" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>
                  <span class="${f.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                    </svg> 
                  </span>
                </span>
              </span>
              </div>
              ${s ? "" : `<div class="${f.timepickerInlineModeWrapper}">
                      <button type='button' class="${f.timepickerInlineModeAm}" data-te-timepicker-am data-te-timepicker-hour-mode tabindex="0" data-te-ripple-init>${d}</button>
                      <button class="${f.timepickerInlineModePm}" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex="0" data-te-ripple-init>${_}</button>
                      <button type='button' class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
                    </div>`}
              ${s ? `<button class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>` : ""}
          </div>
        </div>
      </div>
    </div>
</div>`;
  return l ? g : m;
}, qf = (s, t, e) => {
  const { iconSVG: i } = s;
  return `
  <button id="${t}" tabindex="0" type="button" class="${e.timepickerToggleButton}" data-te-toggle="timepicker" data-te-timepicker-toggle-button data-te-timepicker-icon>
    ${i}
  </button>
`;
}, Ls = "data-te-timepicker-disabled", Fi = "data-te-timepicker-active", fe = (s) => {
  if (s === "")
    return;
  let t, e, i, n;
  return El(s) ? (t = s.getHours(), n = t, e = s.getMinutes(), t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM"), e = e < 10 ? `0${e}` : e) : ([t, e, i] = R(s, !1), n = t, t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM")), {
    hours: t,
    minutes: e,
    amOrPm: i
  };
}, El = (s) => s && Object.prototype.toString.call(s) === "[object Date]" && !Number.isNaN(s), wr = (s) => {
  if (s === "")
    return;
  let t, e;
  return El(s) ? (t = s.getHours(), e = s.getMinutes()) : [t, e] = R(s, !1), e = Number(e) < 10 ? `0${Number(e)}` : e, {
    hours: t,
    minutes: e
  };
}, Qf = (s, t, e) => u.on(document, s, t, ({ target: i }) => {
  if (i.hasAttribute(Fi))
    return;
  document.querySelectorAll(t).forEach((o) => {
    o.hasAttribute(Fi) && (p.removeClass(o, e.opacity), o.removeAttribute(Fi));
  }), p.addClass(i, e.opacity), i.setAttribute(Fi, "");
}), kr = ({ clientX: s, clientY: t, touches: e }, i, n = !1) => {
  const { left: o, top: r } = i.getBoundingClientRect();
  let a = {};
  return !n || !e ? a = {
    x: s - o,
    y: t - r
  } : n && Object.keys(e).length > 0 && (a = {
    x: e[0].clientX - o,
    y: e[0].clientY - r
  }), a;
}, Yi = () => navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  navigator.userAgent
), R = (s, t = !0) => t ? s.value.replace(/:/gi, " ").split(" ") : s.replace(/:/gi, " ").split(" "), Tl = (s, t) => {
  const [e, i, n] = R(s, !1), [o, r, a] = R(t, !1);
  return n === "PM" && a === "AM" || n === a && e > o || i > r;
}, Cl = () => {
  const s = /* @__PURE__ */ new Date(), t = s.getHours(), e = s.getMinutes();
  return `${t}:${e < 10 ? `0${e}` : e}`;
}, jt = (s, t, e) => {
  if (!t)
    return s;
  let i = Cl();
  return e && (i = `${fe(i).hours}:${fe(i).minutes} ${fe(i).amOrPm}`), (s !== "" && Tl(i, s) || s === "") && (s = i), s;
}, Kt = (s, t, e) => {
  if (!t)
    return s;
  let i = Cl();
  return e && (i = `${fe(i).hours}:${fe(i).minutes} ${fe(i).amOrPm}`), (s !== "" && !Tl(i, s) || s === "") && (s = i), s;
}, Zf = ({ format12: s, maxTime: t, minTime: e, disablePast: i, disableFuture: n }, o, r) => {
  const a = R(o)[1];
  e = jt(e, i, s), t = Kt(t, n, s);
  const [l, c, d] = R(t, !1), [_, f, m] = R(e, !1);
  if (d !== void 0 || m !== void 0)
    return [r, a];
  if (!(l !== "" && _ === "" && Number(r) > Number(l)) && !(l === "" && _ !== "" && c === void 0 && f !== "" && Number(r) < Number(_)))
    return [r, a];
}, Or = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, (n.textContent === "00" || Number(n.textContent === "12" && i ? "0" : n.textContent) > t) && (p.addClass(n, e.tipsDisabled), n.setAttribute(Ls, ""));
  });
}, xr = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, n.textContent !== "00" && Number(n.textContent === "12" && i ? "0" : n.textContent) < Number(t) && (p.addClass(n, e.tipsDisabled), n.setAttribute(Ls, ""));
  });
}, Al = (s, t, e, i) => {
  if (t === "12" || t === "24")
    return;
  const n = e ? 12 : 24;
  return i === "max" ? (Number(s) === n ? 0 : Number(s)) > Number(t) : (Number(s) === n ? 0 : Number(s)) < Number(t);
}, Jf = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (Al(i, e, o, "max") || Number(r.textContent) > t && Number(i) === Number(e)) && (p.addClass(r, n.tipsDisabled), r.setAttribute(Ls, ""));
  });
}, t_ = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (Al(i, e, o, "min") || Number(r.textContent) < t && Number(i) === Number(e)) && (p.addClass(r, n.tipsDisabled), r.setAttribute(Ls, ""));
  });
}, e_ = (s) => s.startsWith("0") ? Number(s.slice(1)) : Number(s), hi = "timepicker", L = `data-te-${hi}`, Sr = "[data-te-toggle]", _s = `te.${hi}`, $t = `.${_s}`, Lt = ".data-api", Dr = `click${$t}${Lt}`, ji = `keydown${$t}${Lt}`, Ir = `mousedown${$t}${Lt}`, $r = `mouseup${$t}${Lt}`, Lr = `mousemove${$t}${Lt}`, Mr = `mouseleave${$t}${Lt}`, Nr = `mouseover${$t}${Lt}`, Rr = `touchmove${$t}${Lt}`, Pr = `touchend${$t}${Lt}`, Hr = `touchstart${$t}${Lt}`, i_ = `[${L}-am]`, s_ = `[${L}-pm]`, n_ = `[${L}-format24]`, Ki = `[${L}-current]`, Ui = `[${L}-hour-mode]`, o_ = `[${L}-toggle-button]`, fn = `${L}-cancel`, Br = `${L}-clear`, _n = `${L}-submit`, r_ = `${L}-icon`, mn = `${L}-icon-up`, gn = `${L}-icon-down`, a_ = `${L}-icon-inline-hour`, l_ = `${L}-icon-inline-minute`, Vr = `${L}-inline-hour-icons`, c_ = `${L}-current-inline`, d_ = "readonly", Wr = `${L}-invalid-feedback`, bn = `${L}-is-invalid`, Bt = `${L}-disabled`, B = `${L}-active`, h_ = `${L}-input`, le = `${L}-clock`, Je = `${L}-clock-inner`, vn = `${L}-wrapper`, Fr = `${L}-clock-wrapper`, zi = `${L}-hour`, En = `${L}-minute`, Xi = `${L}-tips-element`, K = `${L}-tips-hours`, X = `${L}-tips-minutes`, at = `${L}-tips-inner`, Gi = `${L}-tips-inner-element`, Yr = `${L}-middle-dot`, Tn = `${L}-hand-pointer`, Cn = `${L}-circle`, jr = `${L}-modal`, u_ = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>`, p_ = {
  appendValidationInfo: !0,
  bodyID: "",
  cancelLabel: "Cancel",
  clearLabel: "Clear",
  closeModalOnBackdropClick: !0,
  closeModalOnMinutesClick: !1,
  container: "body",
  defaultTime: "",
  disabled: !1,
  disablePast: !1,
  disableFuture: !1,
  enableValidation: !0,
  focusInputAfterApprove: !1,
  footerID: "",
  format12: !0,
  format24: !1,
  headID: "",
  increment: !1,
  inline: !1,
  invalidLabel: "Invalid Time Format",
  maxTime: "",
  minTime: "",
  modalID: "",
  okLabel: "Ok",
  overflowHidden: !0,
  pickerID: "",
  readOnly: !1,
  showClearBtn: !0,
  switchHoursToMinutesOnClick: !0,
  iconSVG: u_,
  withIcon: !0,
  pmLabel: "PM",
  amLabel: "AM",
  animations: !0
}, f_ = {
  appendValidationInfo: "boolean",
  bodyID: "string",
  cancelLabel: "string",
  clearLabel: "string",
  closeModalOnBackdropClick: "boolean",
  closeModalOnMinutesClick: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  enableValidation: "boolean",
  footerID: "string",
  format12: "boolean",
  format24: "boolean",
  headID: "string",
  increment: "boolean",
  inline: "boolean",
  invalidLabel: "string",
  modalID: "string",
  okLabel: "string",
  overflowHidden: "boolean",
  pickerID: "string",
  readOnly: "boolean",
  showClearBtn: "boolean",
  switchHoursToMinutesOnClick: "boolean",
  defaultTime: "(string|date|number)",
  iconSVG: "string",
  withIcon: "boolean",
  pmLabel: "string",
  amLabel: "string",
  animations: "boolean"
}, __ = {
  tips: "absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent",
  tipsActive: "text-white bg-[#3b71ca] font-normal",
  tipsDisabled: "text-[#b3afaf] pointer-events-none bg-transparent",
  transform: "transition-[transform,height] ease-in-out duration-[400ms]",
  modal: "z-[1065]",
  clockAnimation: "animate-[show-up-clock_350ms_linear]",
  opacity: "!opacity-100",
  timepickerWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed",
  timepickerContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg",
  timepickerElements: "flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center",
  timepickerHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly",
  timepickerCurrentWrapper: "[direction:ltr] rtl:[direction:rtl]",
  timepickerCurrentButtonWrapper: "relative h-full",
  timepickerCurrentButton: "text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none ",
  timepickerDot: "font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal",
  timepickerModeWrapper: "flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerModeAm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerModePm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerClockWrapper: "min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500",
  timepickerClock: "relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50",
  timepickerMiddleDot: "top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute",
  timepickerHandPointer: "bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute",
  timepickerPointerCircle: "-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute",
  timepickerClockInner: "absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]",
  timepickerFooterWrapper: "rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500",
  timepickerFooter: "w-full flex justify-between",
  timepickerFooterButton: "text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none",
  timepickerInlineWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg",
  timepickerInlineContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]",
  timepickerInlineElements: "flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerInlineHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg",
  timepickerInlineHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center",
  timepickerInlineHourWrapper: "relative h-full !opacity-100",
  timepickerCurrentMinuteWrapper: "relative h-full",
  timepickerInlineIconUp: "absolute fill-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineIconSvg: "h-4 w-4",
  timepickerInlineCurrentButton: "font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]",
  timepickerInlineIconDown: "absolute fill-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineDot: "font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]",
  timepickerInlineModeWrapper: "flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerInlineModeAm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6",
  timepickerInlineModePm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer",
  timepickerInlineSubmitButton: "hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0",
  timepickerToggleButton: "h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-1.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca] dark:text-white"
}, m_ = {
  tips: "string",
  tipsActive: "string",
  tipsDisabled: "string",
  transform: "string",
  modal: "string",
  clockAnimation: "string",
  opacity: "string",
  timepickerWrapper: "string",
  timepickerContainer: "string",
  timepickerElements: "string",
  timepickerHead: "string",
  timepickerHeadContent: "string",
  timepickerCurrentWrapper: "string",
  timepickerCurrentButtonWrapper: "string",
  timepickerCurrentButton: "string",
  timepickerDot: "string",
  timepickerModeWrapper: "string",
  timepickerModeAm: "string",
  timepickerModePm: "string",
  timepickerClockWrapper: "string",
  timepickerClock: "string",
  timepickerMiddleDot: "string",
  timepickerHandPointer: "string",
  timepickerPointerCircle: "string",
  timepickerClockInner: "string",
  timepickerFooterWrapper: "string",
  timepickerFooterButton: "string",
  timepickerInlineWrapper: "string",
  timepickerInlineContainer: "string",
  timepickerInlineElements: "string",
  timepickerInlineHead: "string",
  timepickerInlineHeadContent: "string",
  timepickerInlineHourWrapper: "string",
  timepickerCurrentMinuteWrapper: "string",
  timepickerInlineIconUp: "string",
  timepickerInlineIconSvg: "string",
  timepickerInlineCurrentButton: "string",
  timepickerInlineIconDown: "string",
  timepickerInlineDot: "string",
  timepickerInlineModeWrapper: "string",
  timepickerInlineModeAm: "string",
  timepickerInlineModePm: "string",
  timepickerInlineSubmitButton: "string",
  timepickerToggleButton: "string"
};
class qg {
  constructor(t, e = {}, i) {
    Tt(this, "_toggleAmPm", (t) => {
      t === "PM" ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : t === "AM" && (this._isPmEnabled = !1, this._isAmEnabled = !0);
    });
    Tt(this, "_toggleBackgroundColorCircle", (t) => {
      if (this._modal.querySelector(`${t}[${B}]`) !== null) {
        p.addStyle(this._circle, {
          backgroundColor: "#1976d2"
        });
        return;
      }
      p.addStyle(this._circle, {
        backgroundColor: "transparent"
      });
    });
    Tt(this, "_toggleClassActive", (t, { textContent: e }, i) => {
      const n = [...t].find(
        (o) => Number(o) === Number(e)
      );
      return i.forEach((o) => {
        if (!o.hasAttribute(Bt)) {
          if (o.textContent === n) {
            p.addClass(o, this._classes.tipsActive), o.setAttribute(B, "");
            return;
          }
          p.removeClass(o, this._classes.tipsActive), o.removeAttribute(B);
        }
      });
    });
    Tt(this, "_makeMinutesDegrees", (t, e) => {
      const { increment: i } = this._options;
      return t < 0 ? (e = Math.round(360 + t / 6) % 60, t = 360 + Math.round(t / 6) * 6) : (e = Math.round(t / 6) % 60, t = Math.round(t / 6) * 6), i && (t = Math.round(t / 30) * 30, e = Math.round(t / 6) * 6 / 6, e === 60 && (e = "00")), t >= 360 && (t = 0), {
        degrees: t,
        minute: e,
        addDegrees: i ? 30 : 6
      };
    });
    Tt(this, "_makeHourDegrees", (t, e, i) => {
      if (t)
        return this._hasTargetInnerClass(t) ? e < 0 ? (i = Math.round(360 + e / 30) % 24, e = 360 + e) : (i = Math.round(e / 30) + 12, i === 12 && (i = "00")) : e < 0 ? (i = Math.round(360 + e / 30) % 12, e = 360 + e) : (i = Math.round(e / 30) % 12, (i === 0 || i > 12) && (i = 12)), e >= 360 && (e = 0), {
          degrees: e,
          hour: i,
          addDegrees: 30
        };
    });
    Tt(this, "_makeInnerHoursDegrees", (t, e) => (t < 0 ? (e = Math.round(360 + t / 30) % 24, t = 360 + t) : (e = Math.round(t / 30) + 12, e === 12 && (e = "00")), {
      degrees: t,
      hour: e,
      addDegrees: 30
    }));
    Tt(this, "_getAppendClock", (t = [], e = `[${le}]`, i) => {
      let { minTime: n, maxTime: o } = this._options;
      const { inline: r, format12: a, disablePast: l, disableFuture: c } = this._options;
      n = jt(n, l, a), o = Kt(o, c, a);
      const [d, _, f] = R(
        o,
        !1
      ), [m, g, b] = R(
        n,
        !1
      );
      !r && a && this._isInvalidTimeFormat && !this._AM.hasAttribute(B) && (p.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(B, ""));
      const T = h.findOne(e), C = 360 / t.length;
      function w(y) {
        return y * (Math.PI / 180);
      }
      if (T === null)
        return;
      const v = (T.offsetWidth - 32) / 2, E = (T.offsetHeight - 32) / 2, A = v - 4;
      setTimeout(() => {
        let y;
        a && (y = h.findOne(
          `${Ui}[${B}]`
        ).textContent), this._handleDisablingTipsMinTime(
          y,
          b,
          g,
          m
        ), this._handleDisablingTipsMaxTime(
          y,
          f,
          _,
          d
        );
      }, 0), [...t].forEach((y, S) => {
        const O = w(S * C), k = M("span"), D = M("span");
        D.innerHTML = y, p.addClass(k, this._classes.tips), k.setAttribute(i, "");
        const x = k.offsetWidth, $ = k.offsetHeight;
        return p.addStyle(k, {
          left: `${v + Math.sin(O) * A - x}px`,
          bottom: `${E + Math.cos(O) * A - $}px`
        }), t.includes("05") && k.setAttribute(X, ""), t.includes("13") ? D.setAttribute(Gi, "") : D.setAttribute(Xi, ""), k.appendChild(D), T.appendChild(k);
      });
    });
    this._element = t, this._element && I.setData(t, _s, this), this._document = document, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._currentTime = null, this._toggleButtonId = Ot("timepicker-toggle-"), this.hoursArray = [
      "12",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "10",
      "11"
    ], this.innerHours = [
      "00",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "20",
      "21",
      "22",
      "23"
    ], this.minutesArray = [
      "00",
      "05",
      "10",
      "15",
      "20",
      "25",
      "30",
      "35",
      "40",
      "45",
      "50",
      "55"
    ], this.input = h.findOne("input", this._element), this.dataWithIcon = t.dataset.withIcon, this.dataToggle = t.dataset.toggle, this.customIcon = h.findOne(
      o_,
      this._element
    ), this._checkToggleButton(), this.inputFormatShow = h.findOne(
      n_,
      this._element
    ), this.inputFormat = this.inputFormatShow === null ? "" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = h.findOne(
      Sr,
      this._element
    ), this.toggleElement = Object.values(
      t.querySelector(Sr).dataset
    )[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._inputValue = this._options.defaultTime !== "" ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = wr(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = fe(this._inputValue)), this._options.readOnly && this.input.setAttribute(d_, !0), this.inputFormat === "true" && this.inputFormat !== "" && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = wr(this._inputValue)), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = { degrees: null }, this._scrollBar = new pi();
  }
  // Getters
  static get NAME() {
    return hi;
  }
  // Public
  init() {
    const { format12: t, format24: e, enableValidation: i } = this._options;
    let n, o, r;
    if (this.input.setAttribute(h_, ""), this._currentTime !== void 0) {
      const { hours: a, minutes: l, amOrPm: c } = this._currentTime;
      n = Number(a) < 10 ? 0 : "", o = `${n}${Number(a)}:${l}`, r = c, t ? this.input.value = `${o} ${r}` : e && (this.input.value = `${o}`);
    } else
      n = "", o = "", r = "", this.input.value = "";
    this.input.value.length > 0 && this.input.value !== "" && (this.input.setAttribute(B, ""), u.trigger(this.input, "input")), !(this._options === null && this._element === null) && (i && this._getValidate("keydown change blur focus"), this._handleOpen(), this._listenToToggleKeydown());
  }
  dispose() {
    this._removeModal(), this._element !== null && I.removeData(this._element, _s), setTimeout(() => {
      this._element = null, this._options = null, this.input = null, this._focusTrap = null;
    }, 350), u.off(
      this._document,
      "click",
      `[data-te-toggle='${this.toggleElement}']`
    ), u.off(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`
    );
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  // private
  _checkToggleButton() {
    this.customIcon === null && (this.dataWithIcon !== void 0 && (this._options.withIcon = null, this.dataWithIcon === "true" && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options));
  }
  _appendToggleButton() {
    const t = qf(
      this._options,
      this._toggleButtonId,
      this._classes
    );
    this.input.insertAdjacentHTML("afterend", t);
  }
  _getDomElements() {
    this._hour = h.findOne(`[${zi}]`), this._minutes = h.findOne(`[${En}]`), this._AM = h.findOne(i_), this._PM = h.findOne(s_), this._wrapper = h.findOne(`[${vn}]`), this._modal = h.findOne(`[${jr}]`), this._hand = h.findOne(`[${Tn}]`), this._circle = h.findOne(`[${Cn}]`), this._clock = h.findOne(`[${le}]`), this._clockInner = h.findOne(
      `[${Je}]`
    );
  }
  _handlerMaxMinHoursOptions(t, e, i, n, o, r) {
    if (!e && !i)
      return !0;
    const { format24: a, format12: l, disablePast: c, disableFuture: d } = this._options, { _isAmEnabled: _, _isPmEnabled: f } = this, m = r.keyCode, g = r.target.hasAttribute(Je) || r.target.hasAttribute(at) || r.target.hasAttribute(Gi);
    i = jt(i, c, l), e = Kt(e, d, l), typeof e != "number" && (e = R(e, !1)[0]);
    const b = e !== "" ? e * 30 : "", T = i !== "" ? i * 30 : "";
    t < 0 && (t = 360 + t), t = t === 360 ? 0 : t;
    const C = () => {
      const S = document.querySelectorAll(
        `[${Xi}]`
      ), O = document.querySelectorAll(
        `[${Gi}]`
      ), k = e_(this._hour.innerText);
      let D, x, $;
      return m === rt ? x = 1 : m === U && (x = -1), k === 12 && m === rt ? $ = 1 : k === 0 && m === rt ? $ = 13 : k === 0 && m === U ? $ = 23 : k === 13 && m === U ? $ = 0 : k === 1 && m === U ? $ = 12 : $ = k + x, S.forEach((P) => {
        Number(P.textContent) === $ && (D = P);
      }), O.forEach((P) => {
        Number(P.textContent) === $ && (D = P);
      }), !D.parentElement.hasAttribute(Bt);
    }, w = () => {
      const S = i !== "" && i > 12 ? (i - 12) * 30 : "", O = e !== "" && e > 12 ? (e - 12) * 30 : "";
      if (!(S && t < S || O && t > O || e && e < 12))
        return !0;
    };
    if (a && r.type !== "keydown" && g)
      return w();
    if (r.type === "keydown")
      return C();
    const v = !o || o === "PM" && f || i !== "" && o === "AM" && _, E = !n || n === "PM" && f || e !== "" && n === "AM" && _, A = () => {
      const S = T === 360 && l ? 0 : T;
      if (i) {
        if (o === "PM" && _ || v && t < S)
          return;
      } else
        return !0;
      return !0;
    }, y = () => {
      const S = b === 360 && l ? 0 : b;
      if (e) {
        if (n === "AM" && f || E && t > S)
          return;
      } else
        return !0;
      return !0;
    };
    return A() && y();
  }
  _handleKeyboard() {
    u.on(this._document, ji, "", (t) => {
      let e, i, n;
      const {
        increment: o,
        maxTime: r,
        minTime: a,
        format12: l,
        disablePast: c,
        disableFuture: d
      } = this._options;
      let _ = R(a, !1)[0], f = R(r, !1)[0];
      const m = R(a, !1)[2], g = R(r, !1)[2];
      _ = jt(_, c, l), f = Kt(f, d, l), typeof f != "number" && (f = R(f, !1)[0]);
      const b = h.findOne(`[${X}]`) === null, T = h.findOne(`[${at}]`) !== null, C = Number(this._hand.style.transform.replace(/[^\d-]/g, "")), w = h.find(
        `[${X}]`,
        this._modal
      ), v = h.find(
        `[${K}]`,
        this._modal
      ), E = h.find(
        `[${at}]`,
        this._modal
      );
      let A = this._makeHourDegrees(t.target, C, e).hour;
      const { degrees: y, addDegrees: S } = this._makeHourDegrees(
        t.target,
        C,
        e
      );
      let { minute: O, degrees: k } = this._makeMinutesDegrees(C, i);
      const D = this._makeMinutesDegrees(
        C,
        i
      ).addDegrees;
      let { hour: x } = this._makeInnerHoursDegrees(
        C,
        n
      );
      if (t.keyCode === Is) {
        const $ = h.findOne(
          `[${fn}]`,
          this._modal
        );
        u.trigger($, "click");
      } else if (b) {
        if (T && (t.keyCode === $e && (this._isInner = !1, p.addStyle(this._hand, {
          height: "calc(40% + 1px)"
        }), this._hour.textContent = this._setHourOrMinute(
          A > 12 ? 1 : A
        ), this._toggleClassActive(this.hoursArray, this._hour, v), this._toggleClassActive(this.innerHours, this._hour, E)), t.keyCode === Ie && (this._isInner = !0, p.addStyle(this._hand, {
          height: "21.5%"
        }), this._hour.textContent = this._setHourOrMinute(
          x >= 24 || x === "00" ? 0 : x
        ), this._toggleClassActive(this.innerHours, this._hour, E), this._toggleClassActive(
          this.hoursArray,
          this._hour - 1,
          v
        ))), t.keyCode === rt) {
          if (!this._handlerMaxMinHoursOptions(
            y + 30,
            f,
            _,
            g,
            m,
            t
          ))
            return;
          p.addStyle(this._hand, {
            transform: `rotateZ(${y + S}deg)`
          }), this._isInner ? (x += 1, x === 24 ? x = 0 : (x === 25 || x === "001") && (x = 13), this._hour.textContent = this._setHourOrMinute(x), this._toggleClassActive(this.innerHours, this._hour, E)) : (A += 1, this._hour.textContent = this._setHourOrMinute(
            A > 12 ? 1 : A
          ), this._toggleClassActive(this.hoursArray, this._hour, v));
        }
        if (t.keyCode === U) {
          if (!this._handlerMaxMinHoursOptions(
            y - 30,
            f,
            _,
            g,
            m,
            t
          ))
            return;
          p.addStyle(this._hand, {
            transform: `rotateZ(${y - S}deg)`
          }), this._isInner ? (x -= 1, x === 12 ? x = 0 : x === -1 && (x = 23), this._hour.textContent = this._setHourOrMinute(x), this._toggleClassActive(this.innerHours, this._hour, E)) : (A -= 1, this._hour.textContent = this._setHourOrMinute(
            A === 0 ? 12 : A
          ), this._toggleClassActive(this.hoursArray, this._hour, v));
        }
      } else
        t.keyCode === rt && (k += D, p.addStyle(this._hand, {
          transform: `rotateZ(${k}deg)`
        }), O += 1, o && (O += 4, O === "0014" && (O = 5)), this._minutes.textContent = this._setHourOrMinute(
          O > 59 ? 0 : O
        ), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          w
        ), this._toggleBackgroundColorCircle(
          `[${X}]`
        )), t.keyCode === U && (k -= D, p.addStyle(this._hand, {
          transform: `rotateZ(${k}deg)`
        }), o ? O -= 5 : O -= 1, O === -1 ? O = 59 : O === -5 && (O = 55), this._minutes.textContent = this._setHourOrMinute(O), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          w
        ), this._toggleBackgroundColorCircle(
          `[${X}]`
        ));
    });
  }
  _setActiveClassToTipsOnOpen(t, ...e) {
    if (!this._isInvalidTimeFormat)
      if (this._options.format24) {
        const i = h.find(
          `[${K}]`,
          this._modal
        ), n = h.find(
          `[${at}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t), this._addActiveClassToTip(n, t);
      } else {
        [...e].filter((n) => (n === "PM" ? (p.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(B, "")) : n === "AM" ? (p.addClass(this._AM, this._classes.opacity), this._AM.setAttribute(B, "")) : (p.removeClass(this._AM, this._classes.opacity), p.removeClass(this._PM, this._classes.opacity), this._AM.removeAttribute(B), this._PM.removeAttribute(B)), n));
        const i = h.find(
          `[${K}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t);
      }
  }
  _setTipsAndTimesDependOnInputValue(t, e) {
    const { inline: i, format12: n } = this._options;
    if (this._isInvalidTimeFormat)
      this._hour.textContent = "12", this._minutes.textContent = "00", i || p.addStyle(this._hand, {
        transform: "rotateZ(0deg)"
      }), n && (p.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(B, ""));
    else {
      const o = t > 12 ? t * 30 - 360 : t * 30;
      this._hour.textContent = t, this._minutes.textContent = e, i || (p.addStyle(this._hand, {
        transform: `rotateZ(${o}deg)`
      }), p.addStyle(this._circle, {
        backgroundColor: "#1976d2"
      }), (Number(t) > 12 || t === "00") && p.addStyle(this._hand, {
        height: "21.5%"
      }));
    }
  }
  _listenToToggleKeydown() {
    u.on(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`,
      (t) => {
        t.keyCode === lt && (t.preventDefault(), u.trigger(this.elementToggle, "click"));
      }
    );
  }
  _handleOpen() {
    const t = this._getContainer();
    ee.on(
      this._element,
      "click",
      `[data-te-toggle='${this.toggleElement}']`,
      (e) => {
        if (this._options === null)
          return;
        const i = p.getDataAttribute(this.input, "toggle") !== null ? 200 : 0;
        setTimeout(() => {
          p.addStyle(this.elementToggle, {
            pointerEvents: "none"
          }), this.elementToggle.blur();
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const { modalID: o, inline: r, format12: a } = this._options, [l, c, d] = n, _ = M("div");
          if ((Number(l) > 12 || l === "00") && (this._isInner = !0), this.input.blur(), e.target.blur(), _.innerHTML = Gf(this._options, this._classes), p.addClass(_, this._classes.modal), _.setAttribute(jr, ""), _.setAttribute("role", "dialog"), _.setAttribute("tabIndex", "-1"), _.setAttribute("id", o), r ? (this._popper = je(this.input, _, {
            placement: "bottom-start"
          }), t.appendChild(_)) : (t.appendChild(_), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : p.addClass(this._wrapper, this._classes.opacity), this._setActiveClassToTipsOnOpen(l, c, d), this._appendTimes(), this._setActiveClassToTipsOnOpen(l, c, d), this._setTipsAndTimesDependOnInputValue(l, c), this.input.value === "") {
            const f = h.find(
              `[${K}]`,
              this._modal
            );
            a && (p.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(B, "")), this._hour.textContent = "12", this._minutes.textContent = "00", this._addActiveClassToTip(
              f,
              Number(this._hour.textContent)
            );
          }
          if (this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), r)
            this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks();
          else {
            this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard();
            const f = document.querySelector(
              `${Ki}[${B}]`
            );
            p.addClass(f, this._classes.opacity), p.addStyle(this._hour, {
              pointerEvents: "none"
            }), p.addStyle(this._minutes, {
              pointerEvents: ""
            });
          }
          this._focusTrap = new bi(this._wrapper, {
            event: "keydown",
            condition: ({ key: f }) => f === "Tab"
          }), this._focusTrap.trap();
        }, i);
      }
    );
  }
  _handleInlineClicks() {
    let t, e;
    const i = (f) => {
      let m = f;
      return m > 59 ? m = 0 : m < 0 && (m = 59), m;
    }, n = (f) => {
      let m = f;
      return this._options.format24 ? (m > 24 ? m = 1 : m < 0 && (m = 23), m > 23 && (m = 0)) : (m > 12 ? m = 1 : m < 1 && (m = 12), m > 12 && (m = 1)), m;
    }, o = (f) => {
      const m = n(f);
      this._hour.textContent = this._setHourOrMinute(m);
    }, r = (f) => {
      const m = i(f);
      this._minutes.textContent = this._setHourOrMinute(m);
    }, a = () => {
      t += 1, o(t);
    }, l = () => {
      e += 1, r(e);
    }, c = () => {
      t -= 1, o(t);
    }, d = () => {
      e -= 1, r(e);
    }, _ = (f) => {
      clearInterval(this._interval), this._interval = setInterval(f, 100);
    };
    ee.on(
      this._modal,
      "click mousedown mouseup touchstart touchend contextmenu",
      `[${mn}], [${gn}]`,
      (f) => {
        t = Number(this._hour.textContent), e = Number(this._minutes.textContent);
        const { target: m, type: g } = f, b = g === "mousedown" || g === "touchstart";
        m.closest(`[${mn}]`) ? m.closest(`[${mn}]`).parentNode.hasAttribute(Vr) ? b ? _(a) : g === "mouseup" || g === "touchend" || g === "contextmenu" ? clearInterval(this._interval) : a() : b ? _(l) : g === "mouseup" || g === "touchend" || g === "contextmenu" ? clearInterval(this._interval) : l() : m.closest(`[${gn}]`) && (m.closest(`[${gn}]`).parentNode.hasAttribute(Vr) ? b ? _(c) : g === "mouseup" || g === "touchend" ? clearInterval(this._interval) : c() : b ? _(d) : g === "mouseup" || g === "touchend" ? clearInterval(this._interval) : d());
      }
    ), u.on(window, ji, (f) => {
      const m = f.code, g = document.activeElement.hasAttribute(zi), b = document.activeElement.hasAttribute(
        En
      ), T = document.activeElement === document.body;
      switch (t = Number(this._hour.textContent), e = Number(this._minutes.textContent), m) {
        case "ArrowUp":
          f.preventDefault(), T || g ? (this._hour.focus(), a()) : b && l();
          break;
        case "ArrowDown":
          f.preventDefault(), T || g ? (this._hour.focus(), c()) : b && d();
          break;
      }
    });
  }
  _handleClose() {
    u.on(
      this._modal,
      "click",
      `[${vn}], [${fn}], [${Br}]`,
      ({ target: t }) => {
        const { closeModalOnBackdropClick: e } = this._options, i = () => {
          var n;
          p.addStyle(this.elementToggle, {
            pointerEvents: "auto"
          }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), (n = this._focusTrap) == null || n.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus();
        };
        if (t.hasAttribute(Br)) {
          this._toggleAmPm("PM"), this.input.value = "", this.input.removeAttribute(B);
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const [o, r, a] = n;
          this._setTipsAndTimesDependOnInputValue("12", "00"), this._setActiveClassToTipsOnOpen(o, r, a), this._hour.click();
        } else
          (t.hasAttribute(fn) || t.hasAttribute(_n) || t.hasAttribute(vn) && e) && i();
      }
    );
  }
  showValueInput() {
    return this.input.value;
  }
  _handleOkButton() {
    ee.on(
      this._modal,
      "click",
      `[${_n}]`,
      () => {
        let { maxTime: t, minTime: e } = this._options;
        const {
          format12: i,
          format24: n,
          readOnly: o,
          focusInputAfterApprove: r,
          disablePast: a,
          disableFuture: l
        } = this._options, c = this._document.querySelector(
          `${Ui}[${B}]`
        ), d = `${this._hour.textContent}:${this._minutes.textContent}`, _ = Number(this._hour.textContent), f = _ === 12 && i ? 0 : _, m = Number(this._minutes.textContent);
        e = jt(e, a, i), t = Kt(t, l, i);
        let [g, b, T] = R(
          t,
          !1
        ), [C, w, v] = R(
          e,
          !1
        );
        C = C === "12" && i ? "00" : C, g = g === "12" && i ? "00" : g;
        const E = f < Number(C), A = f > Number(g);
        let y = !0;
        c && (y = T === c.textContent);
        let S = !0;
        c && (S = v === c.textContent);
        const O = m > b && f === Number(g), k = m < w && f === Number(C);
        if (this.input.setAttribute(B, ""), p.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), t !== "") {
          if (y && (A || O))
            return;
          if (T === "AM" && c.textContent === "PM")
            return;
        }
        e !== "" && (S && (E || k) || v === "PM" && c.textContent === "AM") || Zf(
          this._options,
          this.input,
          this._hour.textContent
        ) !== void 0 && (this._isInvalidTimeFormat && this.input.removeAttribute(bn), !o && r && this.input.focus(), p.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), n ? this.input.value = d : c === null ? this.input.value = `${d} PM` : this.input.value = `${d} ${c.textContent}`, this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), u.trigger(this.input, "input.te.timepicker"), u.trigger(this.input, "input"));
      }
    );
  }
  _handleHoverInlineBtn() {
    ee.on(
      this._modal,
      "mouseover mouseleave",
      `[${c_}]`,
      ({ type: t, target: e }) => {
        const i = h.find(
          `[${a_}]`,
          this._modal
        ), n = h.find(
          `[${l_}]`,
          this._modal
        ), o = (l, c) => l.forEach((d) => {
          if (c) {
            p.addClass(d, this._classes.opacity), d.setAttribute(B, "");
            return;
          }
          p.removeClass(d, this._classes.opacity), d.removeAttribute(B);
        }), a = e.hasAttribute(zi) ? i : n;
        o(a, t === "mouseover");
      }
    );
  }
  _handleDocumentClickInline() {
    u.on(document, Dr, ({ target: t }) => {
      if (this._modal && !this._modal.contains(t) && !t.hasAttribute(r_)) {
        if (clearInterval(this._interval), p.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), this._removeModal(), !this._animations)
          return;
        this._toggleBackdropAnimation(!0);
      }
    });
  }
  _handleSwitchHourMinute() {
    Qf(
      "click",
      Ki,
      this._classes
    ), u.on(
      this._modal,
      "click",
      Ki,
      () => {
        const { format24: t } = this._options, e = h.find(
          Ki,
          this._modal
        ), i = h.find(
          `[${X}]`,
          this._modal
        ), n = h.find(
          `[${K}]`,
          this._modal
        ), o = h.find(
          `[${at}]`,
          this._modal
        ), r = Number(this._hour.textContent), a = Number(this._minutes.textContent), l = (c, d) => {
          n.forEach((f) => f.remove()), i.forEach((f) => f.remove()), p.addClass(this._hand, this._classes.transform), setTimeout(() => {
            p.removeClass(this._hand, this._classes.transform);
          }, 401), this._getAppendClock(c, `[${le}]`, d);
          const _ = () => {
            const f = h.find(
              `[${K}]`,
              this._modal
            ), m = h.find(
              `[${X}]`,
              this._modal
            );
            this._addActiveClassToTip(f, r), this._addActiveClassToTip(m, a);
          };
          if (!t)
            setTimeout(() => {
              _();
            }, 401);
          else {
            const f = h.find(
              `[${at}]`,
              this._modal
            );
            setTimeout(() => {
              this._addActiveClassToTip(f, r), _();
            }, 401);
          }
        };
        e.forEach((c) => {
          c.hasAttribute(B) && (c.hasAttribute(En) ? (p.addClass(this._hand, this._classes.transform), p.addStyle(this._hand, {
            transform: `rotateZ(${this._minutes.textContent * 6}deg)`,
            height: "calc(40% + 1px)"
          }), t && o.length > 0 && o.forEach((d) => d.remove()), l(
            this.minutesArray,
            X
          ), this._hour.style.pointerEvents = "", this._minutes.style.pointerEvents = "none") : c.hasAttribute(zi) && (p.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30}deg)`
          }), Number(this._hour.textContent) > 12 ? (p.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,
            height: "21.5%"
          }), Number(this._hour.textContent) > 12 && p.addStyle(this._hand, {
            height: "21.5%"
          })) : p.addStyle(this._hand, {
            height: "calc(40% + 1px)"
          }), t && this._getAppendClock(
            this.innerHours,
            `[${Je}]`,
            at
          ), o.length > 0 && o.forEach((d) => d.remove()), l(
            this.hoursArray,
            K
          ), p.addStyle(this._hour, {
            pointerEvents: "none"
          }), p.addStyle(this._minutes, {
            pointerEvents: ""
          })));
        });
      }
    );
  }
  _handleDisablingTipsMaxTime(t, e, i, n) {
    if (!this._options.maxTime && !this._options.disableFuture)
      return;
    const o = h.find(
      `[${K}]`
    ), r = h.find(
      `[${at}]`
    ), a = h.find(
      `[${X}]`
    );
    if (!e || e === t) {
      Or(
        r,
        n,
        this._classes,
        this._options.format12
      ), Or(
        o,
        n,
        this._classes,
        this._options.format12
      ), Jf(
        a,
        i,
        n,
        this._hour.textContent,
        this._classes,
        this._options.format12
      );
      return;
    }
    e === "AM" && t === "PM" && (o.forEach((l) => {
      p.addClass(l, this._classes.tipsDisabled), l.setAttribute(Bt, "");
    }), a.forEach((l) => {
      p.addClass(l, this._classes.tipsDisabled), l.setAttribute(Bt, "");
    }));
  }
  _handleDisablingTipsMinTime(t, e, i, n) {
    if (!this._options.minTime && !this._options.disablePast)
      return;
    const o = h.find(
      `[${K}]`
    ), r = h.find(
      `[${at}]`
    ), a = h.find(
      `[${X}]`
    );
    !e || e === t ? (xr(
      o,
      n,
      this._classes,
      this._options.format12
    ), xr(
      r,
      n,
      this._classes,
      this._options.format12
    ), t_(
      a,
      i,
      n,
      this._hour.textContent,
      this._classes,
      this._options.format12
    )) : e === "PM" && t === "AM" && (o.forEach((l) => {
      p.addClass(l, this._classes.tipsDisabled), l.setAttribute(Bt, "");
    }), a.forEach((l) => {
      p.addClass(l, this._classes.tipsDisabled), l.setAttribute(Bt, "");
    }));
  }
  _handleSwitchTimeMode() {
    u.on(
      document,
      "click",
      Ui,
      ({ target: t }) => {
        let { maxTime: e, minTime: i } = this._options;
        const { disablePast: n, disableFuture: o, format12: r } = this._options;
        i = jt(i, n, r), e = Kt(e, o, r);
        const [a, l, c] = R(
          e,
          !1
        ), [d, _, f] = R(
          i,
          !1
        ), m = h.find(
          `[${K}]`
        ), g = h.find(
          `[${X}]`
        );
        (() => {
          m.forEach((T) => {
            p.removeClass(T, this._classes.tipsDisabled), T.removeAttribute(Bt);
          }), g.forEach((T) => {
            p.removeClass(T, this._classes.tipsDisabled), T.removeAttribute(Bt);
          });
        })(), this._handleDisablingTipsMinTime(
          t.textContent,
          f,
          _,
          d
        ), this._handleDisablingTipsMaxTime(
          t.textContent,
          c,
          l,
          a
        ), this._toggleAmPm(t.textContent), t.hasAttribute(B) || (h.find(
          Ui
        ).forEach((C) => {
          C.hasAttribute(B) && (p.removeClass(C, this._classes.opacity), C.removeAttribute(B));
        }), p.addClass(t, this._classes.opacity), t.setAttribute(B, ""));
      }
    );
  }
  _handleClockClick() {
    let { maxTime: t, minTime: e } = this._options;
    const { disablePast: i, disableFuture: n, format12: o } = this._options;
    e = jt(e, i, o), t = Kt(t, n, o);
    const r = R(t, !1)[2], a = R(e, !1)[2], l = R(t, !1)[0], c = R(e, !1)[0], d = h.findOne(
      `[${Fr}]`
    );
    ee.on(
      document,
      `${Ir} ${$r} ${Lr} ${Mr} ${Nr} ${Hr} ${Rr} ${Pr}`,
      "",
      (_) => {
        Yi() || _.preventDefault();
        const { type: f, target: m } = _, { closeModalOnMinutesClick: g, switchHoursToMinutesOnClick: b } = this._options, T = h.findOne(
          `[${X}]`,
          this._modal
        ) !== null, C = h.findOne(
          `[${K}]`,
          this._modal
        ) !== null, w = h.findOne(
          `[${at}]`,
          this._modal
        ) !== null, v = h.find(
          `[${X}]`,
          this._modal
        ), E = kr(_, d), A = d.offsetWidth / 2;
        let y = Math.atan2(E.y - A, E.x - A);
        if (Yi()) {
          const D = kr(_, d, !0);
          y = Math.atan2(D.y - A, D.x - A);
        }
        let S = null, O = null, k = null;
        if (f === "mousedown" || f === "mousemove" || f === "touchmove" || f === "touchstart")
          (f === "mousedown" || f === "touchstart" || f === "touchmove") && (this._hasTargetInnerClass(m) || m.hasAttribute(Fr) || m.hasAttribute(le) || m.hasAttribute(X) || m.hasAttribute(K) || m.hasAttribute(Cn) || m.hasAttribute(Tn) || m.hasAttribute(Yr) || m.hasAttribute(Xi)) && (this._isMouseMove = !0, Yi() && _.touches && (S = _.touches[0].clientX, O = _.touches[0].clientY, k = document.elementFromPoint(S, O)));
        else if (f === "mouseup" || f === "touchend") {
          if (this._isMouseMove = !1, this._hasTargetInnerClass(m) || m.hasAttribute(le) || m.hasAttribute(K) || m.hasAttribute(Cn) || m.hasAttribute(Tn) || m.hasAttribute(Yr) || m.hasAttribute(Xi)) {
            if ((C || w) && b) {
              const D = Number(this._hour.textContent) > l || Number(this._hour.textContent) < c;
              if (this._options.format24 && l !== "" && c !== "" && D)
                return;
              if (this._options.format24 && c !== "" && Number(this._hour.textContent) < c)
                return;
            }
            u.trigger(this._minutes, "click");
          }
          if (T && g) {
            const D = h.findOne(
              `[${_n}]`,
              this._modal
            );
            u.trigger(D, "click");
          }
        }
        if (T) {
          let D;
          const x = Math.trunc(y * 180 / Math.PI) + 90, { degrees: $, minute: P } = this._makeMinutesDegrees(x, D);
          if (this._handlerMaxMinMinutesOptions($, P) === void 0)
            return;
          const { degrees: tt, minute: et } = this._handlerMaxMinMinutesOptions($, P);
          if (this._isMouseMove) {
            if (p.addStyle(this._hand, {
              transform: `rotateZ(${tt}deg)`
            }), et === void 0)
              return;
            const z = () => et >= 10 || et === "00" ? et : `0${et}`;
            this._minutes.textContent = z(), this._toggleClassActive(
              this.minutesArray,
              this._minutes,
              v
            ), this._toggleBackgroundColorCircle(
              `[${X}]`
            ), this._objWithDataOnChange.degreesMinutes = tt, this._objWithDataOnChange.minutes = et;
          }
        }
        if (C || w) {
          let D, x = Math.trunc(y * 180 / Math.PI) + 90;
          if (x = Math.round(x / 30) * 30, p.addStyle(this._circle, {
            backgroundColor: "#1976d2"
          }), this._makeHourDegrees(m, x, D) === void 0)
            return;
          const $ = () => {
            if (Yi() && x && k) {
              const { degrees: P, hour: tt } = this._makeHourDegrees(k, x, D);
              return this._handleMoveHand(
                k,
                tt,
                P
              );
            } else {
              const { degrees: P, hour: tt } = this._makeHourDegrees(m, x, D);
              return this._handleMoveHand(m, tt, P);
            }
          };
          this._objWithDataOnChange.degreesHours = x, this._handlerMaxMinHoursOptions(
            x,
            l,
            c,
            r,
            a,
            _
          ) && $();
        }
        _.stopPropagation();
      }
    );
  }
  _hasTargetInnerClass(t) {
    return t.hasAttribute(Je) || t.hasAttribute(at) || t.hasAttribute(Gi);
  }
  _handleMoveHand(t, e, i) {
    const n = h.find(
      `[${K}]`,
      this._modal
    ), o = h.find(
      `[${at}]`,
      this._modal
    );
    this._isMouseMove && (this._hasTargetInnerClass(t) ? p.addStyle(this._hand, {
      height: "21.5%"
    }) : p.addStyle(this._hand, {
      height: "calc(40% + 1px)"
    }), p.addStyle(this._hand, {
      transform: `rotateZ(${i}deg)`
    }), this._hour.textContent = e >= 10 || e === "00" ? e : `0${e}`, this._toggleClassActive(this.hoursArray, this._hour, n), this._toggleClassActive(this.innerHours, this._hour, o), this._objWithDataOnChange.hour = e >= 10 || e === "00" ? e : `0${e}`);
  }
  _handlerMaxMinMinutesOptions(t, e) {
    let { maxTime: i, minTime: n } = this._options;
    const { format12: o, increment: r, disablePast: a, disableFuture: l } = this._options;
    n = jt(n, a, o), i = Kt(i, l, o);
    const c = R(i, !1)[1], d = R(n, !1)[1], _ = R(i, !1)[0], f = R(n, !1)[0], m = f === "12" && o ? "0" : f, g = _ === "12" && o ? "0" : _, b = R(i, !1)[2], T = R(n, !1)[2], C = c !== "" ? c * 6 : "", w = d !== "" ? d * 6 : "", v = Number(this._hour.textContent), E = v === 12 && o ? 0 : v;
    if (!b && !T) {
      if (i !== "" && n !== "") {
        if (Number(g) === E && t > C || Number(m) === E && t < w)
          return t;
      } else if (n !== "" && E <= Number(m)) {
        if (t <= w - 6)
          return t;
      } else if (i !== "" && E >= Number(g) && t >= C + 6)
        return t;
    } else {
      if (n !== "") {
        if (T === "PM" && this._isAmEnabled)
          return;
        if (T === "PM" && this._isPmEnabled) {
          if (E < Number(m))
            return;
          if (E <= Number(m) && t <= w - 6)
            return t;
        } else if (T === "AM" && this._isAmEnabled) {
          if (E < Number(m))
            return;
          if (E <= Number(m) && t <= w - 6)
            return t;
        }
      }
      if (i !== "") {
        if (b === "AM" && this._isPmEnabled)
          return;
        if (b === "PM" && this._isPmEnabled) {
          if (E >= Number(g) && t >= C + 6)
            return t;
        } else if (b === "AM" && this._isAmEnabled && E >= Number(g) && t >= C + 6)
          return t;
      }
    }
    return r && (t = Math.round(t / 30) * 30), t < 0 ? t = 360 + t : t >= 360 && (t = 0), {
      degrees: t,
      minute: e
    };
  }
  _removeModal() {
    this._animations ? setTimeout(() => {
      this._removeModalElements(), this._scrollBar.reset();
    }, 300) : (this._removeModalElements(), this._scrollBar.reset()), ee.off(
      this._document,
      `${Dr} ${ji} ${Ir} ${$r} ${Lr} ${Mr} ${Nr} ${Hr} ${Rr} ${Pr}`
    ), u.off(window, ji);
  }
  _removeModalElements() {
    this._modal && this._modal.remove();
  }
  _toggleBackdropAnimation(t = !1) {
    t ? this._wrapper.classList.add("animate-[fade-out_350ms_ease-in-out]") : (this._wrapper.classList.add("animate-[fade-in_350ms_ease-in-out]"), this._options.inline || p.addClass(this._clock, this._classes.clockAnimation)), setTimeout(() => {
      this._wrapper.classList.remove(
        "animate-[fade-out_350ms_ease-in-out]",
        "animate-[fade-in_350ms_ease-in-out]"
      );
    }, 351);
  }
  _addActiveClassToTip(t, e) {
    t.forEach((i) => {
      Number(i.textContent) === Number(e) && (p.addClass(i, this._classes.tipsActive), i.setAttribute(B, ""));
    });
  }
  _setHourOrMinute(t) {
    return t < 10 ? `0${t}` : t;
  }
  _appendTimes() {
    const { format24: t } = this._options;
    if (t) {
      this._getAppendClock(
        this.hoursArray,
        `[${le}]`,
        K
      ), this._getAppendClock(
        this.innerHours,
        `[${Je}]`,
        at
      );
      return;
    }
    this._getAppendClock(
      this.hoursArray,
      `[${le}]`,
      K
    );
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._element);
    return t = {
      ...p_,
      ...e,
      ...t
    }, N(hi, t, f_), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...__,
      ...e,
      ...t
    }, N(hi, t, m_), t;
  }
  _getContainer() {
    return h.findOne(this._options.container);
  }
  _getValidate(t) {
    const { invalidLabel: e, format24: i, format12: n, appendValidationInfo: o } = this._options;
    let r;
    o && (r = M("div"), r.setAttribute(Wr, ""), r.innerHTML = e), ee.on(this.input, t, ({ target: a }) => {
      if (this._options === null || this.input.value === "")
        return;
      const l = /^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/, c = /^([01]\d|2[0-3])(:[0-5]\d)$/, d = l.test(a.value);
      if (c.test(a.value) !== !0 && i || d !== !0 && n) {
        o && (this.input.setAttribute(bn, ""), this.input.parentNode.insertBefore(
          r,
          this.input.nextSibling
        )), p.addStyle(a, { marginBottom: 0 }), p.addStyle(r, { bottom: "-23px" }), this._isInvalidTimeFormat = !0;
        return;
      }
      this.input.removeAttribute(bn), this._isInvalidTimeFormat = !1;
      const f = h.findOne(
        `[${Wr}]`
      );
      f !== null && f.remove();
    });
  }
  // Static
  static getInstance(t) {
    return I.getData(t, _s);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function xt(s) {
  return getComputedStyle(s);
}
function ot(s, t) {
  for (var e in t) {
    var i = t[e];
    typeof i == "number" && (i = i + "px"), s.style[e] = i;
  }
  return s;
}
function qi(s) {
  var t = document.createElement("div");
  return t.className = s, t;
}
var Kr = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function zt(s, t) {
  if (!Kr)
    throw new Error("No element matching method supported");
  return Kr.call(s, t);
}
function Se(s) {
  s.remove ? s.remove() : s.parentNode && s.parentNode.removeChild(s);
}
function Ur(s, t) {
  return Array.prototype.filter.call(
    s.children,
    function(e) {
      return zt(e, t);
    }
  );
}
var j = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(s) {
      return "ps__thumb-" + s;
    },
    rail: function(s) {
      return "ps__rail-" + s;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(s) {
      return "ps--active-" + s;
    },
    scrolling: function(s) {
      return "ps--scrolling-" + s;
    }
  }
}, yl = { x: null, y: null };
function wl(s, t) {
  var e = s.element.classList, i = j.state.scrolling(t);
  e.contains(i) ? clearTimeout(yl[t]) : e.add(i);
}
function kl(s, t) {
  yl[t] = setTimeout(
    function() {
      return s.isAlive && s.element.classList.remove(j.state.scrolling(t));
    },
    s.settings.scrollingThreshold
  );
}
function g_(s, t) {
  wl(s, t), kl(s, t);
}
var Ei = function(t) {
  this.element = t, this.handlers = {};
}, Ol = { isEmpty: { configurable: !0 } };
Ei.prototype.bind = function(t, e) {
  typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);
};
Ei.prototype.unbind = function(t, e) {
  var i = this;
  this.handlers[t] = this.handlers[t].filter(function(n) {
    return e && n !== e ? !0 : (i.element.removeEventListener(t, n, !1), !1);
  });
};
Ei.prototype.unbindAll = function() {
  for (var t in this.handlers)
    this.unbind(t);
};
Ol.isEmpty.get = function() {
  var s = this;
  return Object.keys(this.handlers).every(
    function(t) {
      return s.handlers[t].length === 0;
    }
  );
};
Object.defineProperties(Ei.prototype, Ol);
var Ue = function() {
  this.eventElements = [];
};
Ue.prototype.eventElement = function(t) {
  var e = this.eventElements.filter(function(i) {
    return i.element === t;
  })[0];
  return e || (e = new Ei(t), this.eventElements.push(e)), e;
};
Ue.prototype.bind = function(t, e, i) {
  this.eventElement(t).bind(e, i);
};
Ue.prototype.unbind = function(t, e, i) {
  var n = this.eventElement(t);
  n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);
};
Ue.prototype.unbindAll = function() {
  this.eventElements.forEach(function(t) {
    return t.unbindAll();
  }), this.eventElements = [];
};
Ue.prototype.once = function(t, e, i) {
  var n = this.eventElement(t), o = function(r) {
    n.unbind(e, o), i(r);
  };
  n.bind(e, o);
};
function Qi(s) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(s);
  var t = document.createEvent("CustomEvent");
  return t.initCustomEvent(s, !1, !1, void 0), t;
}
function ys(s, t, e, i, n) {
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var o;
  if (t === "top")
    o = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  else if (t === "left")
    o = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  else
    throw new Error("A proper axis should be provided");
  b_(s, e, o, i, n);
}
function b_(s, t, e, i, n) {
  var o = e[0], r = e[1], a = e[2], l = e[3], c = e[4], d = e[5];
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var _ = s.element;
  s.reach[l] = null, _[a] < 1 && (s.reach[l] = "start"), _[a] > s[o] - s[r] - 1 && (s.reach[l] = "end"), t && (_.dispatchEvent(Qi("ps-scroll-" + l)), t < 0 ? _.dispatchEvent(Qi("ps-scroll-" + c)) : t > 0 && _.dispatchEvent(Qi("ps-scroll-" + d)), i && g_(s, l)), s.reach[l] && (t || n) && _.dispatchEvent(Qi("ps-" + l + "-reach-" + s.reach[l]));
}
function W(s) {
  return parseInt(s, 10) || 0;
}
function v_(s) {
  return zt(s, "input,[contenteditable]") || zt(s, "select,[contenteditable]") || zt(s, "textarea,[contenteditable]") || zt(s, "button,[contenteditable]");
}
function E_(s) {
  var t = xt(s);
  return W(t.width) + W(t.paddingLeft) + W(t.paddingRight) + W(t.borderLeftWidth) + W(t.borderRightWidth);
}
var ke = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function Mt(s) {
  var t = s.element, e = Math.floor(t.scrollTop), i = t.getBoundingClientRect();
  s.containerWidth = Math.round(i.width), s.containerHeight = Math.round(i.height), s.contentWidth = t.scrollWidth, s.contentHeight = t.scrollHeight, t.contains(s.scrollbarXRail) || (Ur(t, j.element.rail("x")).forEach(
    function(n) {
      return Se(n);
    }
  ), t.appendChild(s.scrollbarXRail)), t.contains(s.scrollbarYRail) || (Ur(t, j.element.rail("y")).forEach(
    function(n) {
      return Se(n);
    }
  ), t.appendChild(s.scrollbarYRail)), !s.settings.suppressScrollX && s.containerWidth + s.settings.scrollXMarginOffset < s.contentWidth ? (s.scrollbarXActive = !0, s.railXWidth = s.containerWidth - s.railXMarginWidth, s.railXRatio = s.containerWidth / s.railXWidth, s.scrollbarXWidth = zr(
    s,
    W(s.railXWidth * s.containerWidth / s.contentWidth)
  ), s.scrollbarXLeft = W(
    (s.negativeScrollAdjustment + t.scrollLeft) * (s.railXWidth - s.scrollbarXWidth) / (s.contentWidth - s.containerWidth)
  )) : s.scrollbarXActive = !1, !s.settings.suppressScrollY && s.containerHeight + s.settings.scrollYMarginOffset < s.contentHeight ? (s.scrollbarYActive = !0, s.railYHeight = s.containerHeight - s.railYMarginHeight, s.railYRatio = s.containerHeight / s.railYHeight, s.scrollbarYHeight = zr(
    s,
    W(s.railYHeight * s.containerHeight / s.contentHeight)
  ), s.scrollbarYTop = W(
    e * (s.railYHeight - s.scrollbarYHeight) / (s.contentHeight - s.containerHeight)
  )) : s.scrollbarYActive = !1, s.scrollbarXLeft >= s.railXWidth - s.scrollbarXWidth && (s.scrollbarXLeft = s.railXWidth - s.scrollbarXWidth), s.scrollbarYTop >= s.railYHeight - s.scrollbarYHeight && (s.scrollbarYTop = s.railYHeight - s.scrollbarYHeight), T_(t, s), s.scrollbarXActive ? t.classList.add(j.state.active("x")) : (t.classList.remove(j.state.active("x")), s.scrollbarXWidth = 0, s.scrollbarXLeft = 0, t.scrollLeft = s.isRtl === !0 ? s.contentWidth : 0), s.scrollbarYActive ? t.classList.add(j.state.active("y")) : (t.classList.remove(j.state.active("y")), s.scrollbarYHeight = 0, s.scrollbarYTop = 0, t.scrollTop = 0);
}
function zr(s, t) {
  return s.settings.minScrollbarLength && (t = Math.max(t, s.settings.minScrollbarLength)), s.settings.maxScrollbarLength && (t = Math.min(t, s.settings.maxScrollbarLength)), t;
}
function T_(s, t) {
  var e = { width: t.railXWidth }, i = Math.floor(s.scrollTop);
  t.isRtl ? e.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth - t.contentWidth : e.left = s.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - i : e.top = t.scrollbarXTop + i, ot(t.scrollbarXRail, e);
  var n = { top: i, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + s.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - s.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + s.scrollLeft, ot(t.scrollbarYRail, n), ot(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), ot(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function C_(s) {
  s.element, s.event.bind(s.scrollbarY, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarYRail, "mousedown", function(t) {
    var e = t.pageY - window.pageYOffset - s.scrollbarYRail.getBoundingClientRect().top, i = e > s.scrollbarYTop ? 1 : -1;
    s.element.scrollTop += i * s.containerHeight, Mt(s), t.stopPropagation();
  }), s.event.bind(s.scrollbarX, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarXRail, "mousedown", function(t) {
    var e = t.pageX - window.pageXOffset - s.scrollbarXRail.getBoundingClientRect().left, i = e > s.scrollbarXLeft ? 1 : -1;
    s.element.scrollLeft += i * s.containerWidth, Mt(s), t.stopPropagation();
  });
}
function A_(s) {
  Xr(s, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]), Xr(s, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function Xr(s, t) {
  var e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], a = t[5], l = t[6], c = t[7], d = t[8], _ = s.element, f = null, m = null, g = null;
  function b(w) {
    w.touches && w.touches[0] && (w[n] = w.touches[0].pageY), _[l] = f + g * (w[n] - m), wl(s, c), Mt(s), w.stopPropagation(), w.type.startsWith("touch") && w.changedTouches.length > 1 && w.preventDefault();
  }
  function T() {
    kl(s, c), s[d].classList.remove(j.state.clicking), s.event.unbind(s.ownerDocument, "mousemove", b);
  }
  function C(w, v) {
    f = _[l], v && w.touches && (w[n] = w.touches[0].pageY), m = w[n], g = (s[i] - s[e]) / (s[o] - s[a]), v ? s.event.bind(s.ownerDocument, "touchmove", b) : (s.event.bind(s.ownerDocument, "mousemove", b), s.event.once(s.ownerDocument, "mouseup", T), w.preventDefault()), s[d].classList.add(j.state.clicking), w.stopPropagation();
  }
  s.event.bind(s[r], "mousedown", function(w) {
    C(w);
  }), s.event.bind(s[r], "touchstart", function(w) {
    C(w, !0);
  });
}
function y_(s) {
  var t = s.element, e = function() {
    return zt(t, ":hover");
  }, i = function() {
    return zt(s.scrollbarX, ":focus") || zt(s.scrollbarY, ":focus");
  };
  function n(o, r) {
    var a = Math.floor(t.scrollTop);
    if (o === 0) {
      if (!s.scrollbarYActive)
        return !1;
      if (a === 0 && r > 0 || a >= s.contentHeight - s.containerHeight && r < 0)
        return !s.settings.wheelPropagation;
    }
    var l = t.scrollLeft;
    if (r === 0) {
      if (!s.scrollbarXActive)
        return !1;
      if (l === 0 && o < 0 || l >= s.contentWidth - s.containerWidth && o > 0)
        return !s.settings.wheelPropagation;
    }
    return !0;
  }
  s.event.bind(s.ownerDocument, "keydown", function(o) {
    if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !i())) {
      var r = document.activeElement ? document.activeElement : s.ownerDocument.activeElement;
      if (r) {
        if (r.tagName === "IFRAME")
          r = r.contentDocument.activeElement;
        else
          for (; r.shadowRoot; )
            r = r.shadowRoot.activeElement;
        if (v_(r))
          return;
      }
      var a = 0, l = 0;
      switch (o.which) {
        case 37:
          o.metaKey ? a = -s.contentWidth : o.altKey ? a = -s.containerWidth : a = -30;
          break;
        case 38:
          o.metaKey ? l = s.contentHeight : o.altKey ? l = s.containerHeight : l = 30;
          break;
        case 39:
          o.metaKey ? a = s.contentWidth : o.altKey ? a = s.containerWidth : a = 30;
          break;
        case 40:
          o.metaKey ? l = -s.contentHeight : o.altKey ? l = -s.containerHeight : l = -30;
          break;
        case 32:
          o.shiftKey ? l = s.containerHeight : l = -s.containerHeight;
          break;
        case 33:
          l = s.containerHeight;
          break;
        case 34:
          l = -s.containerHeight;
          break;
        case 36:
          l = s.contentHeight;
          break;
        case 35:
          l = -s.contentHeight;
          break;
        default:
          return;
      }
      s.settings.suppressScrollX && a !== 0 || s.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, Mt(s), n(a, l) && o.preventDefault());
    }
  });
}
function w_(s) {
  var t = s.element;
  function e(r, a) {
    var l = Math.floor(t.scrollTop), c = t.scrollTop === 0, d = l + t.offsetHeight === t.scrollHeight, _ = t.scrollLeft === 0, f = t.scrollLeft + t.offsetWidth === t.scrollWidth, m;
    return Math.abs(a) > Math.abs(r) ? m = c || d : m = _ || f, m ? !s.settings.wheelPropagation : !0;
  }
  function i(r) {
    var a = r.deltaX, l = -1 * r.deltaY;
    return (typeof a > "u" || typeof l > "u") && (a = -1 * r.wheelDeltaX / 6, l = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = r.wheelDelta), r.shiftKey ? [-l, -a] : [a, l];
  }
  function n(r, a, l) {
    if (!ke.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(r))
      return !1;
    for (var c = r; c && c !== t; ) {
      if (c.classList.contains(j.element.consuming))
        return !0;
      var d = xt(c);
      if (l && d.overflowY.match(/(scroll|auto)/)) {
        var _ = c.scrollHeight - c.clientHeight;
        if (_ > 0 && (c.scrollTop > 0 && l < 0 || c.scrollTop < _ && l > 0))
          return !0;
      }
      if (a && d.overflowX.match(/(scroll|auto)/)) {
        var f = c.scrollWidth - c.clientWidth;
        if (f > 0 && (c.scrollLeft > 0 && a < 0 || c.scrollLeft < f && a > 0))
          return !0;
      }
      c = c.parentNode;
    }
    return !1;
  }
  function o(r) {
    var a = i(r), l = a[0], c = a[1];
    if (!n(r.target, l, c)) {
      var d = !1;
      s.settings.useBothWheelAxes ? s.scrollbarYActive && !s.scrollbarXActive ? (c ? t.scrollTop -= c * s.settings.wheelSpeed : t.scrollTop += l * s.settings.wheelSpeed, d = !0) : s.scrollbarXActive && !s.scrollbarYActive && (l ? t.scrollLeft += l * s.settings.wheelSpeed : t.scrollLeft -= c * s.settings.wheelSpeed, d = !0) : (t.scrollTop -= c * s.settings.wheelSpeed, t.scrollLeft += l * s.settings.wheelSpeed), Mt(s), d = d || e(l, c), d && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? s.event.bind(t, "wheel", o) : typeof window.onmousewheel < "u" && s.event.bind(t, "mousewheel", o);
}
function k_(s) {
  if (!ke.supportsTouch && !ke.supportsIePointer)
    return;
  var t = s.element;
  function e(g, b) {
    var T = Math.floor(t.scrollTop), C = t.scrollLeft, w = Math.abs(g), v = Math.abs(b);
    if (v > w) {
      if (b < 0 && T === s.contentHeight - s.containerHeight || b > 0 && T === 0)
        return window.scrollY === 0 && b > 0 && ke.isChrome;
    } else if (w > v && (g < 0 && C === s.contentWidth - s.containerWidth || g > 0 && C === 0))
      return !0;
    return !0;
  }
  function i(g, b) {
    t.scrollTop -= b, t.scrollLeft -= g, Mt(s);
  }
  var n = {}, o = 0, r = {}, a = null;
  function l(g) {
    return g.targetTouches ? g.targetTouches[0] : g;
  }
  function c(g) {
    return g.pointerType && g.pointerType === "pen" && g.buttons === 0 ? !1 : !!(g.targetTouches && g.targetTouches.length === 1 || g.pointerType && g.pointerType !== "mouse" && g.pointerType !== g.MSPOINTER_TYPE_MOUSE);
  }
  function d(g) {
    if (c(g)) {
      var b = l(g);
      n.pageX = b.pageX, n.pageY = b.pageY, o = (/* @__PURE__ */ new Date()).getTime(), a !== null && clearInterval(a);
    }
  }
  function _(g, b, T) {
    if (!t.contains(g))
      return !1;
    for (var C = g; C && C !== t; ) {
      if (C.classList.contains(j.element.consuming))
        return !0;
      var w = xt(C);
      if (T && w.overflowY.match(/(scroll|auto)/)) {
        var v = C.scrollHeight - C.clientHeight;
        if (v > 0 && (C.scrollTop > 0 && T < 0 || C.scrollTop < v && T > 0))
          return !0;
      }
      if (b && w.overflowX.match(/(scroll|auto)/)) {
        var E = C.scrollWidth - C.clientWidth;
        if (E > 0 && (C.scrollLeft > 0 && b < 0 || C.scrollLeft < E && b > 0))
          return !0;
      }
      C = C.parentNode;
    }
    return !1;
  }
  function f(g) {
    if (c(g)) {
      var b = l(g), T = { pageX: b.pageX, pageY: b.pageY }, C = T.pageX - n.pageX, w = T.pageY - n.pageY;
      if (_(g.target, C, w))
        return;
      i(C, w), n = T;
      var v = (/* @__PURE__ */ new Date()).getTime(), E = v - o;
      E > 0 && (r.x = C / E, r.y = w / E, o = v), e(C, w) && g.preventDefault();
    }
  }
  function m() {
    s.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {
      if (s.isInitialized) {
        clearInterval(a);
        return;
      }
      if (!r.x && !r.y) {
        clearInterval(a);
        return;
      }
      if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {
        clearInterval(a);
        return;
      }
      if (!s.element) {
        clearInterval(a);
        return;
      }
      i(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;
    }, 10));
  }
  ke.supportsTouch ? (s.event.bind(t, "touchstart", d), s.event.bind(t, "touchmove", f), s.event.bind(t, "touchend", m)) : ke.supportsIePointer && (window.PointerEvent ? (s.event.bind(t, "pointerdown", d), s.event.bind(t, "pointermove", f), s.event.bind(t, "pointerup", m)) : window.MSPointerEvent && (s.event.bind(t, "MSPointerDown", d), s.event.bind(t, "MSPointerMove", f), s.event.bind(t, "MSPointerUp", m)));
}
var O_ = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, x_ = {
  "click-rail": C_,
  "drag-thumb": A_,
  keyboard: y_,
  wheel: w_,
  touch: k_
}, Ti = function(t, e) {
  var i = this;
  if (e === void 0 && (e = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = t, t.classList.add(j.main), this.settings = O_();
  for (var n in e)
    this.settings[n] = e[n];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var o = function() {
    return t.classList.add(j.state.focus);
  }, r = function() {
    return t.classList.remove(j.state.focus);
  };
  this.isRtl = xt(t).direction === "rtl", this.isRtl === !0 && t.classList.add(j.rtl), this.isNegativeScroll = function() {
    var c = t.scrollLeft, d = null;
    return t.scrollLeft = -1, d = t.scrollLeft < 0, t.scrollLeft = c, d;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new Ue(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = qi(j.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = qi(j.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", o), this.event.bind(this.scrollbarX, "blur", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var a = xt(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = W(a.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = W(a.borderLeftWidth) + W(a.borderRightWidth), ot(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = W(a.marginLeft) + W(a.marginRight), ot(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = qi(j.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = qi(j.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", o), this.event.bind(this.scrollbarY, "blur", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var l = xt(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = W(l.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? E_(this.scrollbarY) : null, this.railBorderYWidth = W(l.borderTopWidth) + W(l.borderBottomWidth), ot(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = W(l.marginTop) + W(l.marginBottom), ot(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(c) {
    return x_[c](i);
  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(c) {
    return i.onScroll(c);
  }), Mt(this);
};
Ti.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ot(this.scrollbarXRail, { display: "block" }), ot(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = W(xt(this.scrollbarXRail).marginLeft) + W(xt(this.scrollbarXRail).marginRight), this.railYMarginHeight = W(xt(this.scrollbarYRail).marginTop) + W(xt(this.scrollbarYRail).marginBottom), ot(this.scrollbarXRail, { display: "none" }), ot(this.scrollbarYRail, { display: "none" }), Mt(this), ys(this, "top", 0, !1, !0), ys(this, "left", 0, !1, !0), ot(this.scrollbarXRail, { display: "" }), ot(this.scrollbarYRail, { display: "" }));
};
Ti.prototype.onScroll = function(t) {
  this.isAlive && (Mt(this), ys(this, "top", this.element.scrollTop - this.lastScrollTop), ys(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
Ti.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), Se(this.scrollbarX), Se(this.scrollbarY), Se(this.scrollbarXRail), Se(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
Ti.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(t) {
    return !t.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const S_ = {
  threshold: 10,
  direction: "all"
};
class D_ {
  constructor(t, e) {
    this._element = t, this._startPosition = null, this._options = {
      ...S_,
      ...e
    };
  }
  handleTouchStart(t) {
    this._startPosition = this._getCoordinates(t);
  }
  handleTouchMove(t) {
    if (!this._startPosition)
      return;
    const e = this._getCoordinates(t), i = {
      x: e.x - this._startPosition.x,
      y: e.y - this._startPosition.y
    }, n = this._getDirection(i);
    if (this._options.direction === "all") {
      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
        return;
      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;
      u.trigger(this._element, `swipe${r}`), u.trigger(this._element, "swipe", { direction: r }), this._startPosition = null;
      return;
    }
    const o = this._options.direction === "left" || this._options === "right" ? "x" : "y";
    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (u.trigger(this._element, `swipe${n[o].direction}`), this._startPosition = null);
  }
  handleTouchEnd() {
    this._startPosition = null;
  }
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection(t) {
    return {
      x: {
        direction: t.x < 0 ? "left" : "right",
        value: Math.abs(t.x)
      },
      y: {
        direction: t.y < 0 ? "up" : "down",
        value: Math.abs(t.y)
      }
    };
  }
}
class I_ {
  constructor(t, e = "swipe", i = {}) {
    this._element = t, this._event = e, this.swipe = new D_(t, i), this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this);
  }
  dispose() {
    this._element.removeEventListener("touchstart", this._touchStartHandler), this._element.removeEventListener("touchmove", this._touchMoveHandler), window.removeEventListener("touchend", this._touchEndHandler);
  }
  init() {
    this._element.addEventListener(
      "touchstart",
      (t) => this._handleTouchStart(t)
    ), this._element.addEventListener(
      "touchmove",
      (t) => this._handleTouchMove(t)
    ), window.addEventListener("touchend", (t) => this._handleTouchEnd(t));
  }
  _handleTouchStart(t) {
    this[this._event].handleTouchStart(t);
  }
  _handleTouchMove(t) {
    this[this._event].handleTouchMove(t);
  }
  _handleTouchEnd(t) {
    this[this._event].handleTouchEnd(t);
  }
}
const $_ = "group/ps overflow-hidden [overflow-anchor:none] [overflow-style:none] touch-none", L_ = "group/x absolute bottom-0 !top-auto h-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-x]/ps:block group-[&.ps--active-x]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none", M_ = "absolute bottom-[2px] rounded-md h-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:bg-[#999] group-hover/x:h-[11px] group-focus/x:bg-[#999] group-focus/x:h-[11px] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none", N_ = "group/y absolute right-0 !left-auto w-[15px] hidden opacity-0 [transition:background-color_.2s_linear,_opacity_.2s_linear] motion-reduce:transition-none group-[&.ps--active-y]/ps:block group-[&.ps--active-y]/ps:bg-transparent group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 hover:bg-[#eee] focus:!opacity-90 focus:bg-[#eee] [&.ps--clicking]:!opacity-90 [&.ps--clicking]:bg-[#eee] outline-none", R_ = "absolute right-[2px] rounded-md w-1.5 opacity-0 group-hover/ps:opacity-100 group-focus/ps:opacity-100 group-active/ps:opacity-100 bg-[#aaa] [transition:background-color_.2s_linear,_width_.2s_ease-in-out] group-hover/y:bg-[#999] group-hover/y:w-[11px] group-focus/y:bg-[#999] group-focus/y:w-[11px] group-[&.ps--clicking]/y:bg-[#999] group-[&.ps--clicking]/y:w-[11px] outline-none", P_ = (s = document) => {
  [
    { ps: "ps__rail-x", te: L_ },
    { ps: "ps__rail-y", te: N_ },
    { ps: "ps__thumb-x", te: M_ },
    { ps: "ps__thumb-y", te: R_ }
  ].forEach((e) => {
    p.addClass(
      h.findOne(`.${e.ps}`, s),
      e.te
    ), p.removeClass(
      h.findOne(`.${e.ps}`, s),
      e.ps
    );
  }), p.addClass(s, $_), p.removeClass(s, "ps");
}, Gr = "sidenav", Zi = "te.sidenav", H_ = "data-te-sidenav-rotate-icon-ref", An = "[data-te-sidenav-toggle-ref]", B_ = "[data-te-collapse-init]", V_ = '[data-te-sidenav-slim="true"]', W_ = '[data-te-sidenav-slim="false"]', F_ = "[data-te-sidenav-menu-ref]", Ce = "[data-te-sidenav-collapse-ref]", ti = "[data-te-sidenav-link-ref]", Y_ = F() ? 100 : -100, j_ = F() ? -100 : 100, K_ = {
  sidenavAccordion: "(boolean)",
  sidenavBackdrop: "(boolean)",
  sidenavBackdropClass: "(null|string)",
  sidenavCloseOnEsc: "(boolean)",
  sidenavColor: "(string)",
  sidenavContent: "(null|string)",
  sidenavExpandable: "(boolean)",
  sidenavExpandOnHover: "(boolean)",
  sidenavFocusTrap: "(boolean)",
  sidenavHidden: "(boolean)",
  sidenavMode: "(string)",
  sidenavModeBreakpointOver: "(null|string|number)",
  sidenavModeBreakpointSide: "(null|string|number)",
  sidenavModeBreakpointPush: "(null|string|number)",
  sidenavBreakpointSm: "(number)",
  sidenavBreakpointMd: "(number)",
  sidenavBreakpointLg: "(number)",
  sidenavBreakpointXl: "(number)",
  sidenavBreakpoint2xl: "(number)",
  sidenavScrollContainer: "(null|string)",
  sidenavSlim: "(boolean)",
  sidenavSlimCollapsed: "(boolean)",
  sidenavSlimWidth: "(number)",
  sidenavPosition: "(string)",
  sidenavRight: "(boolean)",
  sidenavTransitionDuration: "(number)",
  sidenavWidth: "(number)"
}, U_ = {
  sidenavAccordion: !1,
  sidenavBackdrop: !0,
  sidenavBackdropClass: null,
  sidenavCloseOnEsc: !0,
  sidenavColor: "primary",
  sidenavContent: null,
  sidenavExpandable: !0,
  sidenavExpandOnHover: !1,
  sidenavFocusTrap: !0,
  sidenavHidden: !0,
  sidenavMode: "over",
  sidenavModeBreakpointOver: null,
  sidenavModeBreakpointSide: null,
  sidenavModeBreakpointPush: null,
  sidenavBreakpointSm: 640,
  sidenavBreakpointMd: 768,
  sidenavBreakpointLg: 1024,
  sidenavBreakpointXl: 1280,
  sidenavBreakpoint2xl: 1536,
  sidenavScrollContainer: null,
  sidenavSlim: !1,
  sidenavSlimCollapsed: !1,
  sidenavSlimWidth: 77,
  sidenavPosition: "fixed",
  sidenavRight: !1,
  sidenavTransitionDuration: 300,
  sidenavWidth: 240
};
class ni {
  constructor(t, e = {}) {
    Tt(this, "_addBackdropOnInit", () => {
      this._options.sidenavHidden || (this._backdrop.show(), u.off(this._element, "transitionend", this._addBackdropOnInit));
    });
    this._element = t, this._options = e, this._ID = Ot(""), this._content = null, this._initialContentStyle = null, this._slimCollapsed = !1, this._activeNode = null, this._tempSlim = !1, this._backdrop = this._initializeBackDrop(), this._focusTrap = null, this._perfectScrollbar = null, this._touch = null, this._setModeFromBreakpoints(), this.escHandler = (i) => {
      i.keyCode === Is && this.toggler && St(this.toggler) && (this._update(!1), u.off(window, "keydown", this.escHandler));
    }, this.hashHandler = () => {
      this._setActiveElements();
    }, t && (I.setData(t, Zi, this), this._setup()), this.options.sidenavBackdrop && !this.options.sidenavHidden && this.options.sidenavMode === "over" && u.on(this._element, "transitionend", this._addBackdropOnInit), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return Gr;
  }
  get container() {
    if (this.options.sidenavPosition === "fixed")
      return h.findOne("body");
    const t = (e) => !e.parentNode || e.parentNode === document ? e : e.parentNode.style.position === "relative" || e.parentNode.classList.contains("relative") ? e.parentNode : t(e.parentNode);
    return t(this._element);
  }
  get isVisible() {
    let t = 0, e = window.innerWidth;
    if (this.options.sidenavPosition !== "fixed") {
      const n = this.container.getBoundingClientRect();
      t = n.x, e = n.x + n.width;
    }
    const { x: i } = this._element.getBoundingClientRect();
    return this.options.sidenavRight ? Math.abs(i - e) > 10 : Math.abs(i - t) < 10;
  }
  get links() {
    return h.find(ti, this._element);
  }
  get navigation() {
    return h.find(F_, this._element);
  }
  get options() {
    const t = {
      ...U_,
      ...p.getDataAttributes(this._element),
      ...this._options
    };
    return N(Gr, t, K_), t;
  }
  get sidenavStyle() {
    return {
      width: `${this.width}px`,
      height: this.options.sidenavPosition === "fixed" ? "100vh" : "100%",
      position: this.options.sidenavPosition,
      transition: `all ${this.transitionDuration} linear`
    };
  }
  get toggler() {
    return h.find(An).find(
      (e) => {
        const i = p.getDataAttribute(e, "target");
        return h.findOne(i) === this._element;
      }
    );
  }
  get transitionDuration() {
    return `${this.options.sidenavTransitionDuration / 1e3}s`;
  }
  get translation() {
    return this.options.sidenavRight ? j_ : Y_;
  }
  get width() {
    return this._slimCollapsed ? this.options.sidenavSlimWidth : this.options.sidenavWidth;
  }
  get isBackdropVisible() {
    return !!this._backdrop._element;
  }
  // Public
  changeMode(t) {
    this._setMode(t);
  }
  dispose() {
    u.off(window, "keydown", this.escHandler), this.options.sidenavBackdrop && this._backdrop.dispose(), u.off(window, "hashchange", this.hashHandler), this._touch.dispose(), I.removeData(this._element, Zi), this._element = null;
  }
  hide() {
    this._emitEvents(!1), this._update(!1), this._options.sidenavBackdrop && this.isBackdropVisible && this._backdrop.hide();
  }
  show() {
    this._emitEvents(!0), this._update(!0), this._options.sidenavBackdrop && this._options.sidenavMode === "over" && this._backdrop.show();
  }
  toggle() {
    this._emitEvents(!this.isVisible), this._update(!this.isVisible);
  }
  toggleSlim() {
    this._setSlim(!this._slimCollapsed);
  }
  update(t) {
    this._options = t, this._setup();
  }
  getBreakpoint(t) {
    return this._transformBreakpointValuesToObject()[t];
  }
  // Private
  _init() {
    this._didInit || (u.on(
      document,
      "click",
      An,
      ni.toggleSidenav()
    ), this._didInit = !0);
  }
  _transformBreakpointValuesToObject() {
    return {
      sm: this.options.sidenavBreakpointSm,
      md: this.options.sidenavBreakpointMd,
      lg: this.options.sidenavBreakpointLg,
      xl: this.options.sidenavBreakpointXl,
      "2xl": this.options.sidenavBreakpoint2xl
    };
  }
  _setModeFromBreakpoints() {
    const t = window.innerWidth, e = this._transformBreakpointValuesToObject();
    if (t === void 0 || !e)
      return;
    const i = typeof this.options.sidenavModeBreakpointOver == "number" ? t - this.options.sidenavModeBreakpointOver : t - e[this.options.sidenavModeBreakpointOver], n = typeof this.options.sidenavModeBreakpointSide == "number" ? t - this.options.sidenavModeBreakpointSide : t - e[this.options.sidenavModeBreakpointSide], o = typeof this.options.sidenavModeBreakpointPush == "number" ? t - this.options.sidenavModeBreakpointPush : t - e[this.options.sidenavModeBreakpointPush], r = (l, c) => l - c < 0 ? -1 : c - l < 0 ? 1 : 0, a = [i, n, o].filter((l) => l != null && l >= 0).sort(r)[0];
    i > 0 && i === a ? (this._options.sidenavMode = "over", this._options.sidenavHidden = !0) : n > 0 && n === a ? this._options.sidenavMode = "side" : o > 0 && o === a && (this._options.sidenavMode = "push");
  }
  _collapseItems() {
    this.navigation.forEach((t) => {
      h.find(Ce, t).forEach((i) => {
        Ut.getInstance(i).hide();
      });
    });
  }
  _getOffsetValue(t, { index: e, property: i, offsets: n }) {
    const o = this._getPxValue(
      this._initialContentStyle[e][n[i].property]
    ), r = t ? n[i].value : 0;
    return o + r;
  }
  _getProperty(...t) {
    return t.map((e, i) => i === 0 ? e : e[0].toUpperCase().concat(e.slice(1))).join("");
  }
  _getPxValue(t) {
    return t ? parseFloat(t) : 0;
  }
  _handleSwipe(t, e) {
    e && this._slimCollapsed && this.options.sidenavSlim && this.options.sidenavExpandable ? this.toggleSlim() : e || (this._slimCollapsed || !this.options.sidenavSlim || !this.options.sidenavExpandable ? this.toggler && St(this.toggler) && this.toggle() : this.toggleSlim());
  }
  _isActive(t, e) {
    return e ? e === t : t.attributes.href ? new URL(t, window.location.href).href === window.location.href : !1;
  }
  _isAllToBeCollapsed() {
    return h.find(
      B_,
      this._element
    ).filter(
      (i) => i.getAttribute("aria-expanded") === "true"
    ).length === 0;
  }
  _isAllCollapsed() {
    return h.find(Ce, this._element).filter(
      (t) => St(t)
    ).length === 0;
  }
  _initializeBackDrop() {
    if (!this.options.sidenavBackdrop)
      return;
    const t = this.options.sidenavBackdropClass ? this.options.sidenavBackdropClass.split(" ") : this.options.sidenavPosition ? [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      this.options.sidenavPosition,
      "top-0",
      "left-0",
      "z-50",
      "bg-black/10",
      "dark:bg-black-60",
      "w-full",
      "h-full",
      this._element.id
    ] : null;
    return new lo({
      isVisible: this.options.sidenavBackdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      backdropClasses: t,
      clickCallback: () => this.hide()
    });
  }
  _updateBackdrop(t) {
    if (this.options.sidenavMode === "over") {
      t ? this._backdrop.show() : this.isBackdropVisible && this._backdrop.hide();
      return;
    }
    this.isBackdropVisible && this._backdrop.hide();
  }
  _setup() {
    this._setupTouch(), this.options.sidenavFocusTrap && this._setupFocusTrap(), this._setupCollapse(), this.options.sidenavSlim && this._setupSlim(), this._setupInitialStyling(), this._setupScrolling(), this.options.sidenavContent && this._setupContent(), this._setupActiveState(), this._setupRippleEffect(), this.options.sidenavHidden || this._updateOffsets(!0, !0), this.options.sidenavMode === "over" && this._setTabindex(!0);
  }
  _setupActiveState() {
    this._setActiveElements(), this.links.forEach((t) => {
      u.on(t, "click", () => this._setActiveElements(t)), u.on(t, "keydown", (e) => {
        e.keyCode === lt && this._setActiveElements(t);
      });
    }), u.on(window, "hashchange", this.hashHandler);
  }
  _setupCollapse() {
    this.navigation.forEach((t, e) => {
      h.find(Ce, t).forEach(
        (n, o) => this._setupCollapseList({ list: n, index: o, menu: t, menuIndex: e })
      );
    });
  }
  _generateCollpaseID(t, e) {
    return `sidenav-collapse-${this._ID}-${e}-${t}`;
  }
  _setupCollapseList({ list: t, index: e, menu: i, menuIndex: n }) {
    const o = this._generateCollpaseID(e, n);
    t.setAttribute("id", o), t.setAttribute("data-te-collapse-item", "");
    const [r] = h.prev(t, ti);
    p.setDataAttribute(r, "collapse-init", ""), r.setAttribute("href", `#${o}`), r.setAttribute("role", "button");
    const a = Ut.getInstance(t) || new Ut(t, {
      toggle: !1,
      parent: this.options.sidenavAccordion ? i : t
    });
    (t.dataset.teSidenavStateShow === "" || t.dataset.teCollapseShow === "") && this._rotateArrow(r, !1), u.on(r, "click", (l) => {
      this._toggleCategory(l, a, t), this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), u.on(
      t,
      "show.te.collapse",
      () => this._rotateArrow(r, !1)
    ), u.on(
      t,
      "hide.te.collapse",
      () => this._rotateArrow(r, !0)
    ), u.on(t, "shown.te.collapse", () => {
      this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), u.on(t, "hidden.te.collapse", () => {
      this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    });
  }
  _setupContent() {
    this._content = h.find(this.options.sidenavContent), this._content.forEach((t) => {
      const e = [
        "!p",
        "!m",
        "!px",
        "!pl",
        "!pr",
        "!mx",
        "!ml",
        "!mr",
        "!-p",
        "!-m",
        "!-px",
        "!-pl",
        "!-pr",
        "!-mx",
        "!-ml",
        "!-mr"
      ];
      [...t.classList].filter(
        (n) => e.findIndex((o) => n.includes(o)) >= 0
      ).forEach((n) => t.classList.remove(n));
    }), this._initialContentStyle = this._content.map((t) => {
      const { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r } = window.getComputedStyle(t);
      return { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r };
    });
  }
  _setupFocusTrap() {
    this._focusTrap = new bi(
      this._element,
      {
        event: "keydown",
        condition: (t) => t.keyCode === fi,
        onlyVisible: !0
      },
      this.toggler
    );
  }
  _setupInitialStyling() {
    this._setColor(), p.style(this._element, this.sidenavStyle);
  }
  _setupScrolling() {
    let t = this._element;
    if (this.options.sidenavScrollContainer) {
      t = h.findOne(
        this.options.sidenavScrollContainer,
        this._element
      );
      const i = tc(t.parentNode.children).filter(
        (n) => n !== t
      ).reduce((n, o) => n + o.clientHeight, 0);
      p.style(t, {
        maxHeight: `calc(100% - ${i}px)`,
        position: "relative"
      });
    }
    this._perfectScrollbar = new Ti(t, {
      suppressScrollX: !0,
      handlers: ["click-rail", "drag-thumb", "wheel", "touch"]
    }), P_(t);
  }
  _setupSlim() {
    this._slimCollapsed = this.options.sidenavSlimCollapsed, this._toggleSlimDisplay(this._slimCollapsed), this.options.sidenavExpandOnHover && (this._element.addEventListener("mouseenter", () => {
      this._slimCollapsed && this._setSlim(!1);
    }), this._element.addEventListener("mouseleave", () => {
      this._slimCollapsed || this._setSlim(!0);
    }));
  }
  _setupRippleEffect() {
    this.links.forEach((t) => {
      let e = Cs.getInstance(t), i = this.options.sidenavColor;
      if (e && e._options.sidenavColor !== this.options.sidenavColor)
        e.dispose();
      else if (e)
        return;
      (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (i = "white"), e = new Cs(t, { rippleColor: i });
    });
  }
  _setupTouch() {
    this._touch = new I_(this._element, "swipe", { threshold: 20 }), this._touch.init(), u.on(
      this._element,
      "swipeleft",
      (t) => this._handleSwipe(t, this.options.sidenavRight)
    ), u.on(
      this._element,
      "swiperight",
      (t) => this._handleSwipe(t, !this.options.sidenavRight)
    );
  }
  _setActive(t, e) {
    t.setAttribute("data-te-sidebar-state-active", ""), this._activeNode && t.removeAttribute("data-te-sidebar-state-active"), this._activeNode = t;
    const [i] = h.parents(
      this._activeNode,
      Ce
    );
    if (!i) {
      this._setActiveCategory();
      return;
    }
    const [n] = h.prev(i, ti);
    this._setActiveCategory(n), !e && !this._slimCollapsed && Ut.getInstance(i).show();
  }
  _setActiveCategory(t) {
    this.navigation.forEach((e) => {
      h.find(Ce, e).forEach((n) => {
        const [o] = h.prev(n, ti);
        o !== t ? o.removeAttribute("data-te-sidenav-state-active") : o.setAttribute("data-te-sidenav-state-active", "");
      });
    });
  }
  _setActiveElements(t) {
    this.navigation.forEach((e) => {
      h.find(ti, e).filter((n) => h.next(n, Ce).length === 0).forEach((n) => {
        this._isActive(n, t) && n !== this._activeNode && this._setActive(n, t);
      });
    }), t && this._updateFocus(this.isVisible);
  }
  _setColor() {
    const t = [
      "primary",
      "secondary",
      "success",
      "info",
      "warning",
      "danger",
      "light",
      "dark"
    ], { sidenavColor: e } = this.options, i = t.includes(e) ? e : "primary";
    t.forEach((n) => {
      this._element.classList.remove(`sidenav-${n}`);
    }), p.addClass(this._element, `sidenav-${i}`);
  }
  _setContentOffsets(t, e, i) {
    this._content.forEach((n, o) => {
      const r = this._getOffsetValue(t, {
        index: o,
        property: "padding",
        offsets: e
      }), a = this._getOffsetValue(t, {
        index: o,
        property: "margin",
        offsets: e
      }), l = {};
      if (i || (l.transition = `all ${this.transitionDuration} linear`), l[e.padding.property] = `${r}px`, l[e.margin.property] = `${a}px`, p.style(n, l), !!t) {
        if (i) {
          p.style(n, {
            transition: this._initialContentStyle[o].transition
          });
          return;
        }
        u.on(n, "transitionend", () => {
          p.style(n, {
            transition: this._initialContentStyle[o].transition
          });
        });
      }
    });
  }
  _setMode(t) {
    this.options.sidenavMode !== t && (this._options.sidenavMode = t, this._update(this.isVisible));
  }
  _setSlim(t) {
    const e = t ? ["collapse", "collapsed"] : ["expand", "expanded"];
    this._triggerEvents(...e), t && this._collapseItems(), this._slimCollapsed = t, this._toggleSlimDisplay(t), p.style(this._element, { width: `${this.width}px` }), this._updateOffsets(this.isVisible);
  }
  _setTabindex(t) {
    this.links.forEach((e) => {
      e.tabIndex = t ? 0 : -1;
    });
  }
  _emitEvents(t) {
    const e = t ? ["show", "shown"] : ["hide", "hidden"];
    this._triggerEvents(...e);
  }
  _rotateArrow(t, e) {
    const [i] = h.children(t, `[${H_}]`);
    i && (e ? p.removeClass(i, "rotate-180") : p.addClass(i, "rotate-180"));
  }
  _toggleCategory(t, e) {
    t.preventDefault(), e.toggle(), this._slimCollapsed && this.options.sidenavExpandable && (this._tempSlim = !0, this._setSlim(!1));
  }
  _toggleSlimDisplay(t) {
    const e = h.find(
      V_,
      this._element
    ), i = h.find(
      W_,
      this._element
    ), n = () => {
      e.forEach((o) => {
        p.style(o, {
          display: this._slimCollapsed ? "unset" : "none"
        });
      }), i.forEach((o) => {
        p.style(o, {
          display: this._slimCollapsed ? "none" : "unset"
        });
      });
    };
    t ? setTimeout(
      () => n(),
      this.options.sidenavTransitionDuration
    ) : n();
  }
  async _triggerEvents(t, e) {
    u.trigger(this._element, `${t}.te.sidenav`), e && await setTimeout(() => {
      u.trigger(this._element, `${e}.te.sidenav`);
    }, this.options.sidenavTransitionDuration + 5);
  }
  _update(t) {
    this.toggler && this._updateTogglerAria(t), this._updateDisplay(t), this.options.sidenavBackdrop && this._updateBackdrop(t), this._updateOffsets(t), t && this.options.sidenavCloseOnEsc && this.options.sidenavMode !== "side" && u.on(window, "keydown", this.escHandler), this.options.sidenavFocusTrap && this._updateFocus(t);
  }
  _updateDisplay(t) {
    const e = t ? 0 : this.translation;
    p.style(this._element, {
      transform: `translateX(${e}%)`
    });
  }
  _updateFocus(t) {
    if (this._setTabindex(t), this.options.sidenavMode === "over" && this.options.sidenavFocusTrap) {
      if (t) {
        this._focusTrap.trap();
        return;
      }
      this._focusTrap.disable();
    }
    this._focusTrap.disable();
  }
  _updateOffsets(t, e = !1) {
    const [i, n] = this.options.sidenavRight ? ["right", "left"] : ["left", "right"], o = {
      property: this._getProperty("padding", i),
      value: this.options.sidenavMode === "over" ? 0 : this.width
    }, r = {
      property: this._getProperty("margin", n),
      value: this.options.sidenavMode === "push" ? -1 * this.width : 0
    };
    u.trigger(this._element, "update.te.sidenav", {
      margin: r,
      padding: o
    }), this._content && (this._content.className = "", this._setContentOffsets(t, { padding: o, margin: r }, e));
  }
  _updateTogglerAria(t) {
    this.toggler.setAttribute("aria-expanded", t);
  }
  // Static
  static toggleSidenav() {
    return function(t) {
      const e = h.closest(t.target, An), i = p.getDataAttributes(e).target;
      h.find(i).forEach((n) => {
        (ni.getInstance(n) || new ni(n)).toggle();
      });
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, Zi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new ni(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, Zi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Yn = "stepper", ms = "te.stepper", Ms = `.${ms}`, Ci = `data-te-${Yn}`, oi = "horizontal", yt = "vertical", z_ = {
  stepperType: "string",
  stepperLinear: "boolean",
  stepperNoEditable: "boolean",
  stepperActive: "string",
  stepperCompleted: "string",
  stepperInvalid: "string",
  stepperDisabled: "string",
  stepperVerticalBreakpoint: "number",
  stepperMobileBreakpoint: "number",
  stepperMobileBarBreakpoint: "number"
}, X_ = {
  stepperType: oi,
  stepperLinear: !1,
  stepperNoEditable: !1,
  stepperActive: "",
  stepperCompleted: "",
  stepperInvalid: "",
  stepperDisabled: "",
  stepperVerticalBreakpoint: 0,
  stepperMobileBreakpoint: 0,
  stepperMobileBarBreakpoint: 4
}, qr = `mousedown${Ms}`, Qr = `keydown${Ms}`, G_ = `keyup${Ms}`, Zr = `resize${Ms}`, Vt = `[${Ci}-step-ref]`, G = `[${Ci}-head-ref]`, Jr = `[${Ci}-head-text-ref]`, Ji = `[${Ci}-head-icon-ref]`, st = `[${Ci}-content-ref]`;
class Qg {
  constructor(t, e) {
    this._element = t, this._options = this._getConfig(e), this._elementHeight = 0, this._steps = h.find(`${Vt}`, this._element), this._currentView = "", this._activeStepIndex = 0, this._verticalStepperStyles = [], this._element && (I.setData(t, ms, this), this._init());
  }
  // Getters
  static get NAME() {
    return Yn;
  }
  get activeStep() {
    return this._steps[this._activeStepIndex];
  }
  get activeStepIndex() {
    return this._activeStepIndex;
  }
  // Public
  dispose() {
    this._steps.forEach((t) => {
      u.off(t, qr), u.off(t, Qr);
    }), u.off(window, Zr), I.removeData(this._element, ms), this._element = null;
  }
  changeStep(t) {
    this._toggleStep(t);
  }
  nextStep() {
    this._toggleStep(this._activeStepIndex + 1);
  }
  previousStep() {
    this._toggleStep(this._activeStepIndex - 1);
  }
  // Private
  _init() {
    const t = h.find(`${Vt}`, this._element)[this._activeStepIndex].setAttribute("data-te", "active-step"), e = h.find(
      `${Jr}`,
      this._element
    ), i = h.find(
      `${Ji}`,
      this._element
    );
    switch (t ? (this._activeStepIndex = this._steps.indexOf(t), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    ), e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700")) : (e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    )), this._bindMouseDown(), this._bindKeysNavigation(), this._options.stepperType) {
      case yt:
        this._toggleVertical();
        break;
      default:
        this._toggleHorizontal();
        break;
    }
    (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(), this._bindResize();
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._element);
    return t = {
      ...X_,
      ...e,
      ...t
    }, N(Yn, t, z_), t;
  }
  _bindMouseDown() {
    this._steps.forEach((t) => {
      const e = h.findOne(`${G}`, t);
      u.on(e, qr, (i) => {
        const n = h.parents(i.target, `${Vt}`)[0], o = this._steps.indexOf(n);
        i.preventDefault(), this._toggleStep(o);
      });
    });
  }
  _bindResize() {
    u.on(window, Zr, () => {
      this._currentView === yt && this._setSingleStepHeight(this.activeStep), this._currentView === oi && this._setHeight(this.activeStep), (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView();
    });
  }
  _toggleStepperView() {
    const t = this._options.stepperVerticalBreakpoint < window.innerWidth, e = this._options.stepperVerticalBreakpoint > window.innerWidth, i = this._options.stepperMobileBreakpoint > window.innerWidth;
    t && this._currentView !== oi && this._toggleHorizontal(), e && !i && this._currentView !== yt && (this._steps.forEach((n) => {
      const o = h.findOne(`${st}`, n);
      this._resetStepperHeight(), this._showElement(o);
    }), this._toggleVertical());
  }
  _toggleStep(t) {
    this._activeStepIndex !== t && (this._options.stepperNoEditable && this._toggleDisabled(), this._showElement(
      h.findOne(`${st}`, this._steps[t])
    ), this._toggleActive(t), t > this._activeStepIndex && this._toggleCompleted(this._activeStepIndex), this._currentView === oi ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t), this._setSingleStepHeight(this._steps[t])), this._toggleStepTabIndex(
      h.findOne(`${G}`, this.activeStep),
      h.findOne(`${G}`, this._steps[t])
    ), this._activeStepIndex = t, this._steps[this._activeStepIndex].setAttribute("data-te", "active-step"), this._steps.forEach((e, i) => {
      e[this._activeStepIndex] !== i && e.removeAttribute("data-te");
    }));
  }
  _resetStepperHeight() {
    this._element.style.height = "";
  }
  _setStepsHeight() {
    this._steps.forEach((t) => {
      const e = h.findOne(`${st}`, t), i = window.getComputedStyle(e);
      this._verticalStepperStyles.push({
        paddingTop: parseFloat(i.paddingTop),
        paddingBottom: parseFloat(i.paddingBottom)
      });
      const n = e.scrollHeight;
      e.style.height = `${n}px`;
    });
  }
  _setSingleStepHeight(t) {
    const e = h.findOne(`${st}`, t), i = this.activeStep === t, n = this._steps.indexOf(t);
    let o;
    i ? (e.style.height = "", o = e.scrollHeight) : o = e.scrollHeight + this._verticalStepperStyles[n].paddingTop + this._verticalStepperStyles[n].paddingBottom, e.style.height = `${o}px`;
  }
  _toggleVertical() {
    this._currentView = yt, this._setStepsHeight(), this._hideInactiveSteps();
  }
  _toggleHorizontal() {
    this._currentView = oi, this._setHeight(this.activeStep), this._hideInactiveSteps();
  }
  _toggleStepperClass() {
    h.findOne(
      "[data-te-stepper-type]",
      this._element
    ) !== null && this._steps.forEach((e) => {
      h.findOne(`${st}`, e).classList.remove("!my-0"), h.findOne(`${st}`, e).classList.remove("!py-0"), h.findOne(`${st}`, e).classList.remove("!h-0");
    });
  }
  _toggleStepClass(t, e, i) {
    i && this._steps[t].classList[e](i);
  }
  _bindKeysNavigation() {
    this._toggleStepTabIndex(
      !1,
      h.findOne(`${G}`, this.activeStep)
    ), this._steps.forEach((t) => {
      const e = h.findOne(`${G}`, t);
      u.on(e, Qr, (i) => {
        const n = h.parents(
          i.currentTarget,
          `${Vt}`
        )[0], o = h.next(n, `${Vt}`)[0], r = h.prev(n, `${Vt}`)[0], a = h.findOne(
          `${G}`,
          n
        ), l = h.findOne(
          `${G}`,
          this.activeStep
        );
        let c = null, d = null;
        if (o && (c = h.findOne(`${G}`, o)), r && (d = h.findOne(`${G}`, r)), i.keyCode === Ie && this._currentView !== yt && (d ? (this._toggleStepTabIndex(a, d), this._toggleOutlineStyles(a, d), d.focus()) : c && (this._toggleStepTabIndex(a, c), this._toggleOutlineStyles(a, c), c.focus())), i.keyCode === $e && this._currentView !== yt && (c ? (this._toggleStepTabIndex(a, c), this._toggleOutlineStyles(a, c), c.focus()) : d && (this._toggleStepTabIndex(a, d), this._toggleOutlineStyles(a, d), d.focus())), i.keyCode === U && this._currentView === yt && (i.preventDefault(), c && (this._toggleStepTabIndex(a, c), this._toggleOutlineStyles(a, c), c.focus())), i.keyCode === rt && this._currentView === yt && (i.preventDefault(), d && (this._toggleStepTabIndex(a, d), this._toggleOutlineStyles(a, d), d.focus())), i.keyCode === Le) {
          const _ = h.findOne(
            `${G}`,
            this._steps[0]
          );
          this._toggleStepTabIndex(a, _), this._toggleOutlineStyles(a, _), _.focus();
        }
        if (i.keyCode === Me) {
          const _ = this._steps[this._steps.length - 1], f = h.findOne(`${G}`, _);
          this._toggleStepTabIndex(a, f), this._toggleOutlineStyles(a, f), f.focus();
        }
        (i.keyCode === lt || i.keyCode === ps) && (i.preventDefault(), this.changeStep(this._steps.indexOf(n))), i.keyCode === fi && (this._toggleStepTabIndex(a, l), this._toggleOutlineStyles(a, !1), l.focus());
      }), u.on(e, G_, (i) => {
        const n = h.parents(
          i.currentTarget,
          `${Vt}`
        )[0], o = h.findOne(
          `${G}`,
          n
        ), r = h.findOne(
          `${G}`,
          this.activeStep
        );
        i.keyCode === fi && (this._toggleStepTabIndex(o, r), this._toggleOutlineStyles(!1, r), r.focus());
      });
    });
  }
  _toggleStepTabIndex(t, e) {
    t && t.setAttribute("tabIndex", -1), e && e.setAttribute("tabIndex", 0);
  }
  _toggleOutlineStyles(t, e) {
    t && (t.style.outline = ""), e && (e.style.outline = "revert");
  }
  _toggleDisabled() {
    const t = h.find(`${G}`, this._element), e = h.find(
      `${Ji}`,
      this._element
    );
    t[this._activeStepIndex].classList.add("color-[#858585]"), t[this._activeStepIndex].classList.add("cursor-default"), e[this._activeStepIndex].classList.add("!bg-[#858585]"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperDisabled
    );
  }
  _toggleActive(t) {
    const e = h.find(
      `${Jr}`,
      this._element
    ), i = h.find(
      `${Ji}`,
      this._element
    );
    e[t].classList.add("font-medium"), i[t].classList.add("!bg-primary-100"), i[t].classList.add("!text-primary-700"), i[t].classList.remove("!bg-success-100"), i[t].classList.remove("!text-success-700"), e[this._activeStepIndex].classList.remove("font-medium"), i[this._activeStepIndex].classList.remove("!bg-primary-100"), i[this._activeStepIndex].classList.remove(
      "!text-primary-700"
    ), this._toggleStepClass(t, "add", this._options.stepperActive), this._toggleStepClass(
      this._activeStepIndex,
      "remove",
      this._options.stepperActive
    );
  }
  _toggleCompleted(t) {
    const e = h.find(
      `${Ji}`,
      this._element
    );
    e[t].classList.add("!bg-success-100"), e[t].classList.add("!text-success-700"), e[t].classList.remove("!bg-danger-100"), e[t].classList.remove("!text-danger-700"), this._toggleStepClass(t, "add", this._options.stepperCompleted), this._toggleStepClass(t, "remove", this._options.stepperInvalid);
  }
  _hideInactiveSteps() {
    this._steps.forEach((t) => {
      t.getAttribute("data-te") || this._hideElement(h.findOne(`${st}`, t));
    });
  }
  _setHeight(t) {
    const e = h.findOne(`${st}`, t), i = getComputedStyle(e), n = h.findOne(`${G}`, t), o = getComputedStyle(n), r = e.offsetHeight + parseFloat(i.marginTop) + parseFloat(i.marginBottom), a = n.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);
    this._element.style.height = `${a + r}px`;
  }
  _hideElement(t) {
    !h.parents(
      t,
      `${Vt}`
    )[0].getAttribute("data-te") && this._currentView !== yt || (t.classList.add("!my-0"), t.classList.add("!py-0"), t.classList.add("!h-0"));
  }
  _showElement(t) {
    this._currentView === yt ? (t.classList.remove("!my-0"), t.classList.remove("!py-0"), t.classList.remove("!h-0")) : t.style.display = "block";
  }
  _animateHorizontalStep(t) {
    const e = t > this._activeStepIndex, i = h.findOne(
      `${st}`,
      this._steps[t]
    ), n = h.findOne(
      `${st}`,
      this.activeStep
    );
    let o, r;
    this._steps.forEach((d, _) => {
      const f = h.findOne(`${st}`, d);
      _ !== t && _ !== this._activeStepIndex && this._hideElement(f);
    });
    const a = "translate-x-[150%]", l = "-translate-x-[150%]", c = "translate-0";
    e ? (r = l, o = c, i.classList.remove("translate-x-[150%]"), i.classList.remove("-translate-x-[150%]")) : (r = a, o = c, i.classList.remove("-translate-x-[150%]"), i.classList.remove("translate-x-[150%]")), n.classList.add(r), i.classList.add(o), this._setHeight(this._steps[t]);
  }
  _animateVerticalStep(t) {
    const e = h.findOne(
      `${st}`,
      this._steps[t]
    ), i = h.findOne(
      `${st}`,
      this.activeStep
    );
    this._hideElement(i), this._showElement(e);
  }
  static getInstance(t) {
    return I.getData(t, ms);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const ta = "data-te-input-state-active", ts = "data-te-input-selected", ea = "data-te-input-multiple-active", ia = "[data-te-form-check-input]";
class sa {
  constructor(t, e, i, n, o, r, a, l, c, d, _) {
    this.id = t, this.nativeOption = e, this.multiple = i, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = c, this.groupId = d, this.icon = _, this.node = null, this.active = !1;
  }
  select() {
    this.multiple ? this._selectMultiple() : this._selectSingle();
  }
  _selectSingle() {
    this.selected || (this.node.setAttribute(ts, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0));
  }
  _selectMultiple() {
    if (!this.selected) {
      const t = h.findOne(
        ia,
        this.node
      );
      t.checked = !0, this.node.setAttribute(ts, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0);
    }
  }
  deselect() {
    this.multiple ? this._deselectMultiple() : this._deselectSingle();
  }
  _deselectSingle() {
    this.selected && (this.node.removeAttribute(ts), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1));
  }
  _deselectMultiple() {
    if (this.selected) {
      const t = h.findOne(
        ia,
        this.node
      );
      t.checked = !1, this.node.removeAttribute(ts), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1);
    }
  }
  setNode(t) {
    this.node = t;
  }
  setActiveStyles() {
    if (!this.active) {
      if (this.multiple) {
        this.node.setAttribute(ea, "");
        return;
      }
      this.active = !0, this.node.setAttribute(ta, "");
    }
  }
  removeActiveStyles() {
    this.active && (this.active = !1, this.node.removeAttribute(ta)), this.multiple && this.node.removeAttribute(ea);
  }
}
class q_ {
  constructor(t = !1) {
    this._multiple = t, this._selections = [];
  }
  select(t) {
    this._multiple ? this._selections.push(t) : this._selections = [t];
  }
  deselect(t) {
    if (this._multiple) {
      const e = this._selections.findIndex(
        (i) => t === i
      );
      this._selections.splice(e, 1);
    } else
      this._selections = [];
  }
  clear() {
    this._selections = [];
  }
  get selection() {
    return this._selections[0];
  }
  get selections() {
    return this._selections;
  }
  get label() {
    return this._selections[0] && this.selection.label;
  }
  get labels() {
    return this._selections.map((t) => t.label).join(", ");
  }
  get value() {
    return this.selections[0] && this.selection.value;
  }
  get values() {
    return this._selections.map((t) => t.value);
  }
}
function jn(s) {
  return s.filter((t) => !t.disabled).every((t) => t.selected);
}
const Q_ = "data-te-select-form-outline-ref", Z_ = "data-te-select-wrapper-ref", J_ = "data-te-select-input-ref", tm = "data-te-select-clear-btn-ref", em = "data-te-select-dropdown-container-ref", im = "data-te-select-dropdown-ref", sm = "data-te-select-options-wrapper-ref", nm = "data-te-select-options-list-ref", om = "data-te-select-input-filter-ref", xl = "data-te-select-option-ref", rm = "data-te-select-option-all-ref", am = "data-te-select-option-text-ref", lm = "data-te-form-check-input", cm = "data-te-select-option-group-ref", dm = "data-te-select-option-group-label-ref", Sl = "data-te-select-selected", hm = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
</svg>
`, um = (s) => {
  s.code === "Tab" || s.code === "Esc" || s.preventDefault();
};
function es(s, t, e, i, n) {
  t.selectSize === "default" && p.addClass(s, e), t.selectSize === "sm" && p.addClass(s, i), t.selectSize === "lg" && p.addClass(s, n);
}
function pm(s, t, e, i) {
  const n = document.createElement("div");
  n.setAttribute("id", s), n.setAttribute(Z_, "");
  const o = M("div");
  o.setAttribute(Q_, ""), p.addClass(o, i.formOutline);
  const r = M("input"), a = t.selectFilter ? "combobox" : "listbox", l = t.multiple ? "true" : "false", c = t.disabled ? "true" : "false";
  r.setAttribute(J_, ""), p.addClass(r, i.selectInput), es(
    r,
    t,
    i.selectInputSizeDefault,
    i.selectInputSizeSm,
    i.selectInputSizeLg
  ), t.selectFormWhite && p.addClass(r, i.selectInputWhite), r.setAttribute("type", "text"), r.setAttribute("role", a), r.setAttribute("aria-multiselectable", l), r.setAttribute("aria-disabled", c), r.setAttribute("aria-haspopup", "true"), r.setAttribute("aria-expanded", !1), t.tabIndex && r.setAttribute("tabIndex", t.tabIndex), t.disabled && r.setAttribute("disabled", ""), t.selectPlaceholder !== "" && r.setAttribute("placeholder", t.selectPlaceholder), t.selectValidation ? (p.addStyle(r, {
    "pointer-events": "none",
    "caret-color": "transparent"
  }), p.addStyle(o, { cursor: "pointer" })) : r.setAttribute("readonly", "true"), t.selectValidation && (r.setAttribute("required", "true"), r.setAttribute("aria-required", "true"), r.addEventListener("keydown", um));
  const d = M("div");
  p.addClass(d, i.selectValidationValid);
  const _ = document.createTextNode(
    `${t.selectValidFeedback}`
  );
  d.appendChild(_);
  const f = M("div");
  p.addClass(f, i.selectValidationInvalid);
  const m = document.createTextNode(
    `${t.selectInvalidFeedback}`
  );
  f.appendChild(m);
  const g = M("span");
  g.setAttribute(tm, ""), p.addClass(g, i.selectClearBtn), es(
    g,
    t,
    i.selectClearBtnDefault,
    i.selectClearBtnSm,
    i.selectClearBtnLg
  ), t.selectFormWhite && p.addClass(g, i.selectClearBtnWhite);
  const b = document.createTextNode("âœ•");
  g.appendChild(b), g.setAttribute("tabindex", "0");
  const T = M("span");
  return p.addClass(T, i.selectArrow), es(
    T,
    t,
    i.selectArrowDefault,
    i.selectArrowSm,
    i.selectArrowLg
  ), t.selectFormWhite && p.addClass(T, i.selectArrowWhite), T.innerHTML = hm, o.appendChild(r), e && (p.addClass(e, i.selectLabel), es(
    e,
    t,
    i.selectLabelSizeDefault,
    i.selectLabelSizeSm,
    i.selectLabelSizeLg
  ), t.selectFormWhite && p.addClass(e, i.selectLabelWhite), o.appendChild(e)), t.selectValidation && (o.appendChild(d), o.appendChild(f)), t.selectClearButton && o.appendChild(g), o.appendChild(T), n.appendChild(o), n;
}
function na(s, t, e, i, n, o, r, a) {
  const l = document.createElement("div");
  l.setAttribute(em, ""), p.addClass(l, a.selectDropdownContainer), l.setAttribute("id", `${s}`), l.style.width = `${e}px`;
  const c = document.createElement("div");
  c.setAttribute("tabindex", 0), c.setAttribute(im, ""), p.addClass(c, a.dropdown);
  const d = M("div");
  d.setAttribute(sm, ""), p.addClass(d, a.optionsWrapper), p.addClass(d, a.optionsWrapperScrollbar), d.style.maxHeight = `${i}px`;
  const _ = Dl(
    o,
    n,
    t,
    a
  );
  return d.appendChild(_), t.selectFilter && c.appendChild(
    fm(t.selectSearchPlaceholder, a)
  ), c.appendChild(d), r && c.appendChild(r), l.appendChild(c), l;
}
function Dl(s, t, e, i) {
  const n = M("div");
  n.setAttribute(nm, ""), p.addClass(n, i.optionsList);
  let o;
  return e.multiple ? o = mm(
    s,
    t,
    e,
    i
  ) : o = _m(s, e, i), o.forEach((r) => {
    n.appendChild(r);
  }), n;
}
function fm(s, t) {
  const e = M("div");
  p.addClass(e, t.inputGroup);
  const i = M("input");
  return i.setAttribute(om, ""), p.addClass(i, t.selectFilterInput), i.placeholder = s, i.setAttribute("role", "searchbox"), i.setAttribute("type", "text"), e.appendChild(i), e;
}
function _m(s, t, e) {
  return Il(s, t, e);
}
function mm(s, t, e, i) {
  let n = null;
  e.selectAll && (n = gm(
    t,
    s,
    e,
    i
  ));
  const o = Il(s, e, i);
  return n ? [n, ...o] : o;
}
function Il(s, t, e) {
  const i = [];
  return s.forEach((n) => {
    if (Object.prototype.hasOwnProperty.call(
      n,
      "options"
    )) {
      const r = Tm(n, t, e);
      i.push(r);
    } else
      i.push($l(n, t, e));
  }), i;
}
function gm(s, t, e, i) {
  const n = jn(t), o = M("div");
  return o.setAttribute(xl, ""), p.addClass(o, i.selectOption), o.setAttribute(rm, ""), p.addStyle(o, {
    height: `${e.selectOptionHeight}px`
  }), o.setAttribute("role", "option"), o.setAttribute("aria-selected", n), n && o.setAttribute(Sl, ""), o.appendChild(Ll(s, e, i)), s.setNode(o), o;
}
function $l(s, t, e) {
  if (s.node)
    return s.node;
  const i = M("div");
  return i.setAttribute(xl, ""), p.addClass(i, e.selectOption), p.addStyle(i, {
    height: `${t.selectOptionHeight}px`
  }), p.setDataAttribute(i, "id", s.id), i.setAttribute("role", "option"), i.setAttribute("aria-selected", s.selected), i.setAttribute("aria-disabled", s.disabled), s.selected && i.setAttribute(Sl, ""), s.disabled && i.setAttribute("data-te-select-option-disabled", !0), s.hidden && p.addClass(i, "hidden"), i.appendChild(Ll(s, t, e)), s.icon && i.appendChild(Em(s, e)), s.setNode(i), i;
}
function Ll(s, t, e) {
  const i = M("span");
  i.setAttribute(am, ""), p.addClass(i, e.selectOptionText);
  const n = document.createTextNode(s.label);
  return t.multiple && i.appendChild(vm(s, e)), i.appendChild(n), (s.secondaryText || typeof s.secondaryText == "number") && i.appendChild(
    bm(s.secondaryText, e)
  ), i;
}
function bm(s, t) {
  const e = M("span");
  p.addClass(e, t.selectOptionSecondaryText);
  const i = document.createTextNode(s);
  return e.appendChild(i), e;
}
function vm(s, t) {
  const e = M("input");
  e.setAttribute("type", "checkbox"), p.addClass(e, t.formCheckInput), e.setAttribute(lm, "");
  const i = M("label");
  return s.selected && e.setAttribute("checked", !0), s.disabled && e.setAttribute("disabled", !0), e.appendChild(i), e;
}
function Em(s, t) {
  const e = M("span"), i = M("img");
  return p.addClass(i, t.selectOptionIcon), i.src = s.icon, e.appendChild(i), e;
}
function Tm(s, t, e) {
  const i = M("div");
  i.setAttribute(cm, ""), p.addClass(i, e.selectOptionGroup), i.setAttribute("role", "group"), i.setAttribute("id", s.id), s.hidden && p.addClass(i, "hidden");
  const n = M("label");
  return n.setAttribute(dm, ""), p.addClass(n, e.selectOptionGroupLabel), p.addStyle(n, { height: `${t.selectOptionHeight}px` }), n.setAttribute("for", s.id), n.textContent = s.label, i.appendChild(n), s.options.forEach((o) => {
    i.appendChild($l(o, t, e));
  }), i;
}
function Cm(s, t) {
  const e = M("div");
  return e.innerHTML = s, p.addClass(e, t.selectLabel), p.addClass(e, t.selectFakeValue), e;
}
const yn = "select", ri = "te.select", Ai = `.${ri}`, Am = `close${Ai}`, ym = `open${Ai}`, oa = `optionSelect${Ai}`, ra = `optionDeselect${Ai}`, wm = `valueChange${Ai}`, km = "change", aa = "data-te-select-init", Ml = "data-te-select-no-results-ref", la = "data-te-select-open", q = "data-te-input-state-active", Wt = "data-te-input-focused", wn = "data-te-input-disabled", Om = "data-te-select-option-group-label-ref", xm = "data-te-select-option-all-ref", ei = "data-te-select-selected", Sm = "[data-te-select-label-ref]", ca = "[data-te-select-input-ref]", Dm = "[data-te-select-input-filter-ref]", Im = "[data-te-select-dropdown-ref]", $m = "[data-te-select-options-wrapper-ref]", da = "[data-te-select-options-list-ref]", Lm = "[data-te-select-option-ref]", Mm = "[data-te-select-clear-btn-ref]", Nm = "[data-te-select-custom-content-ref]", Rm = `[${Ml}]`, ha = "[data-te-select-form-outline-ref]", Pm = "[data-te-select-toggle]", kn = "[data-te-input-notch-ref]", Hm = 200, Bm = {
  selectAutoSelect: !1,
  selectContainer: "body",
  selectClearButton: !1,
  disabled: !1,
  selectDisplayedLabels: 5,
  selectFormWhite: !1,
  multiple: !1,
  selectOptionsSelectedLabel: "options selected",
  selectOptionHeight: 38,
  selectAll: !0,
  selectAllLabel: "Select all",
  selectSearchPlaceholder: "Search...",
  selectSize: "default",
  selectVisibleOptions: 5,
  selectFilter: !1,
  selectFilterDebounce: 300,
  selectNoResultText: "No results",
  selectValidation: !1,
  selectValidFeedback: "Valid",
  selectInvalidFeedback: "Invalid",
  selectPlaceholder: ""
}, Vm = {
  selectAutoSelect: "boolean",
  selectContainer: "string",
  selectClearButton: "boolean",
  disabled: "boolean",
  selectDisplayedLabels: "number",
  selectFormWhite: "boolean",
  multiple: "boolean",
  selectOptionsSelectedLabel: "string",
  selectOptionHeight: "number",
  selectAll: "boolean",
  selectAllLabel: "string",
  selectSearchPlaceholder: "string",
  selectSize: "string",
  selectVisibleOptions: "number",
  selectFilter: "boolean",
  selectFilterDebounce: "number",
  selectNoResultText: "string",
  selectValidation: "boolean",
  selectValidFeedback: "string",
  selectInvalidFeedback: "string",
  selectPlaceholder: "string"
}, Wm = {
  dropdown: "relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700",
  formCheckInput: "relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent",
  formOutline: "relative",
  initialized: "hidden",
  inputGroup: "flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200",
  noResult: "flex items-center px-4",
  optionsList: "list-none m-0 p-0",
  optionsWrapper: "overflow-y-auto",
  optionsWrapperScrollbar: "[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded",
  selectArrow: "absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5",
  selectArrowWhite: "text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white",
  selectArrowDefault: "top-2",
  selectArrowLg: "top-[13px]",
  selectArrowSm: "top-1",
  selectClearBtn: "absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200",
  selectClearBtnWhite: "!text-gray-50",
  selectClearBtnDefault: "top-2 text-base",
  selectClearBtnLg: "top-[11px] text-base",
  selectClearBtnSm: "top-1 text-[0.8rem]",
  selectDropdownContainer: "z-[1070]",
  selectFakeValue: "transform-none hidden data-[te-input-state-active]:block",
  selectFilterInput: "relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200",
  selectInput: "peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600",
  selectInputWhite: "!text-gray-50",
  selectInputSizeDefault: "py-[0.32rem] px-3 leading-[1.6]",
  selectInputSizeLg: "py-[0.32rem] px-3 leading-[2.15]",
  selectInputSizeSm: "py-[0.33rem] px-3 text-xs leading-[1.5]",
  selectLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary",
  selectLabelWhite: "!text-gray-50",
  selectLabelSizeDefault: "pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]",
  selectLabelSizeLg: "pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]",
  selectLabelSizeSm: "pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]",
  selectOption: "flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30",
  selectOptionGroup: "group/opt",
  selectOptionGroupLabel: "flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300",
  selectOptionIcon: "w-7 h-7 rounded-full",
  selectOptionSecondaryText: "block text-[0.8rem] text-gray-500 dark:text-gray-300",
  selectOptionText: "group",
  selectValidationValid: "hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block",
  selectValidationInvalid: "hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block"
}, Fm = {
  dropdown: "string",
  formCheckInput: "string",
  formOutline: "string",
  initialized: "string",
  inputGroup: "string",
  noResult: "string",
  optionsList: "string",
  optionsWrapper: "string",
  optionsWrapperScrollbar: "string",
  selectArrow: "string",
  selectArrowDefault: "string",
  selectArrowLg: "string",
  selectArrowSm: "string",
  selectClearBtn: "string",
  selectClearBtnDefault: "string",
  selectClearBtnLg: "string",
  selectClearBtnSm: "string",
  selectDropdownContainer: "string",
  selectFakeValue: "string",
  selectFilterInput: "string",
  selectInput: "string",
  selectInputSizeDefault: "string",
  selectInputSizeLg: "string",
  selectInputSizeSm: "string",
  selectLabel: "string",
  selectLabelSizeDefault: "string",
  selectLabelSizeLg: "string",
  selectLabelSizeSm: "string",
  selectOption: "string",
  selectOptionGroup: "string",
  selectOptionGroupLabel: "string",
  selectOptionIcon: "string",
  selectOptionSecondaryText: "string",
  selectOptionText: "string"
};
class Nl {
  constructor(t, e, i) {
    this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new q_(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = Ot("select-wrapper-"), this._dropdownContainerId = Ot("select-dropdown-container-"), this._selectAllId = Ot("select-all-"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions, this._popper = null, this._input = null, this._label = h.next(this._element, Sm)[0], this._notch = null, this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = h.next(
      t,
      Nm
    )[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), this._element && I.setData(t, ri, this);
  }
  static get NAME() {
    return yn;
  }
  get filterInput() {
    return h.findOne(
      Dm,
      this._dropdownContainer
    );
  }
  get dropdown() {
    return h.findOne(Im, this._dropdownContainer);
  }
  get optionsList() {
    return h.findOne(
      da,
      this._dropdownContainer
    );
  }
  get optionsWrapper() {
    return h.findOne(
      $m,
      this._dropdownContainer
    );
  }
  get clearButton() {
    return h.findOne(Mm, this._wrapper);
  }
  get options() {
    return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;
  }
  get value() {
    return this.multiple ? this._selectionModel.values : this._selectionModel.value;
  }
  get multiple() {
    return this._config.multiple;
  }
  get hasSelectAll() {
    return this.multiple && this._config.selectAll;
  }
  get hasSelection() {
    return this._selectionModel.selection || this._selectionModel.selections.length > 0;
  }
  _getConfig(t) {
    const e = p.getDataAttributes(this._element);
    return t = {
      ...Bm,
      ...e,
      ...t
    }, this._element.hasAttribute("multiple") && (t.multiple = !0), this._element.hasAttribute("disabled") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute("tabIndex")), N(yn, t, Vm), t;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...Wm,
      ...e,
      ...t
    }, N(yn, t, Fm), t;
  }
  _getOptionsToRender(t) {
    const e = [];
    return t.childNodes.forEach((n) => {
      if (n.nodeName === "OPTGROUP") {
        const o = {
          id: Ot("group-"),
          label: n.label,
          disabled: n.hasAttribute("disabled"),
          hidden: n.hasAttribute("hidden"),
          options: []
        };
        n.childNodes.forEach((a) => {
          a.nodeName === "OPTION" && o.options.push(
            this._createOptionObject(a, o)
          );
        }), e.push(o);
      } else
        n.nodeName === "OPTION" && e.push(this._createOptionObject(n));
    }), e;
  }
  _getPlainOptions(t) {
    if (!h.findOne("optgroup", this._element))
      return t;
    const i = [];
    return t.forEach((n) => {
      Object.prototype.hasOwnProperty.call(
        n,
        "options"
      ) ? n.options.forEach((r) => {
        i.push(r);
      }) : i.push(n);
    }), i;
  }
  _createOptionObject(t, e = {}) {
    const i = Ot("option-"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : !1, r = t.selected || t.hasAttribute(ei), a = t.hasAttribute("disabled") || o, l = t.hasAttribute("hidden") || e && e.hidden, c = this.multiple, d = t.value, _ = t.label, f = p.getDataAttribute(
      t,
      "selectSecondaryText"
    ), m = p.getDataAttribute(t, "select-icon");
    return new sa(
      i,
      t,
      c,
      d,
      _,
      r,
      a,
      l,
      f,
      n,
      m
    );
  }
  _getNavigationOptions() {
    const t = this.options.filter((e) => !e.hidden);
    return this.hasSelectAll ? [this._selectAllOption, ...t] : t;
  }
  _init() {
    this._renderMaterialWrapper(), this._wrapper = h.findOne(`#${this._wrapperId}`), this._input = h.findOne(ca, this._wrapper), this._config.disabled && this._input.setAttribute(wn, "");
    const t = this._config.selectContainer;
    t === "body" ? this._container = document.body : this._container = h.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = na(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    ), this._setFirstActiveOption(), this._listenToFocusChange();
  }
  _renderMaterialWrapper() {
    const t = pm(
      this._wrapperId,
      this._config,
      this._label,
      this._classes
    );
    this._element.parentNode.insertBefore(t, this._element), p.addClass(this._element, this._classes.initialized), t.appendChild(this._element);
  }
  _initOutlineInput() {
    const t = h.findOne(
      ha,
      this._wrapper
    );
    new V(t, {
      inputFormWhite: this._config.selectFormWhite
    }).init(), this._notch = h.findOne(kn, this._wrapper);
  }
  _bindComponentEvents() {
    this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();
  }
  _setDefaultSelections() {
    this.options.forEach((t) => {
      t.selected && this._selectionModel.select(t);
    });
  }
  _listenToComponentKeydown() {
    u.on(this._wrapper, "keydown", this._handleKeydown.bind(this));
  }
  _handleKeydown(t) {
    this._isOpen && !this._config.selectFilter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
  }
  _handleOpenKeydown(t) {
    const e = t.keyCode, i = e === Is || e === rt && t.altKey || e === fi;
    if (e === fi && this._config.selectAutoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), i) {
      this.close(), this._input.focus();
      return;
    }
    switch (e) {
      case U:
        this._setNextOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case rt:
        this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case Le:
        this._setFirstOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case Me:
        this._setLastOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case lt:
        t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));
        return;
      default:
        return;
    }
    t.preventDefault();
  }
  _handleClosedKeydown(t) {
    const e = t.keyCode;
    if (e === lt && t.preventDefault(), (e === lt || e === U && t.altKey || e === U && this.multiple) && this.open(), this.multiple)
      switch (e) {
        case U:
          this.open();
          break;
        case rt:
          this.open();
          break;
        default:
          return;
      }
    else
      switch (e) {
        case U:
          this._setNextOptionActive(), this._handleSelection(this._activeOption);
          break;
        case rt:
          this._setPreviousOptionActive(), this._handleSelection(this._activeOption);
          break;
        case Le:
          this._setFirstOptionActive(), this._handleSelection(this._activeOption);
          break;
        case Me:
          this._setLastOptionActive(), this._handleSelection(this._activeOption);
          break;
        default:
          return;
      }
    t.preventDefault();
  }
  _scrollToOption(t) {
    if (!t)
      return;
    let e;
    const i = this.options.filter((d) => !d.hidden);
    this.hasSelectAll ? e = i.indexOf(t) + 1 : e = i.indexOf(t);
    const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.selectOptionHeight, c = r.scrollTop;
    if (e > -1) {
      const d = o * l, _ = d + l > c + a;
      d < c ? r.scrollTop = d : _ ? r.scrollTop = d - a + l : r.scrollTop = c;
    }
  }
  _getNumberOfGroupsBeforeOption(t) {
    const e = this.options.filter((r) => !r.hidden), i = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t - 1 : t;
    let o = 0;
    for (let r = 0; r <= n; r++)
      e[r].groupId && i[o] && i[o].id && e[r].groupId === i[o].id && o++;
    return o;
  }
  _setNextOptionActive() {
    let t = this._activeOptionIndex + 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t += 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setPreviousOptionActive() {
    let t = this._activeOptionIndex - 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t -= 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setFirstOptionActive() {
    const e = this._getNavigationOptions();
    this._updateActiveOption(e[0], 0);
  }
  _setLastOptionActive() {
    const t = this._getNavigationOptions(), e = t.length - 1;
    this._updateActiveOption(t[e], e);
  }
  _updateActiveOption(t, e) {
    const i = this._activeOption;
    i && i.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;
  }
  _listenToWrapperClick() {
    u.on(this._wrapper, "click", () => {
      this.toggle();
    });
  }
  _listenToClearBtnClick() {
    u.on(this.clearButton, "click", (t) => {
      t.preventDefault(), t.stopPropagation(), this._handleClear();
    });
  }
  _listenToClearBtnKeydown() {
    u.on(this.clearButton, "keydown", (t) => {
      t.keyCode === lt && (this._handleClear(), t.preventDefault(), t.stopPropagation());
    });
  }
  _handleClear() {
    if (this.multiple)
      this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();
    else {
      const t = this._selectionModel.selection;
      this._selectionModel.clear(), t.deselect();
    }
    this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();
  }
  _listenToOptionsClick() {
    u.on(this.optionsWrapper, "click", (t) => {
      if (t.target.hasAttribute(
        Om
      ))
        return;
      const i = t.target.nodeName === "DIV" ? t.target : h.closest(t.target, Lm);
      if (i.hasAttribute(xm)) {
        this._handleSelectAll();
        return;
      }
      const o = i.dataset.teId, r = this.options.find((a) => a.id === o);
      r && !r.disabled && this._handleSelection(r);
    });
  }
  _handleSelectAll() {
    this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _selectAllOptions(t) {
    t.forEach((e) => {
      !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());
    });
  }
  _deselectAllOptions(t) {
    t.forEach((e) => {
      e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());
    });
  }
  _handleSelection(t) {
    this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleAutoSelection(t) {
    this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleSingleSelection(t) {
    this._singleOptionSelect(t), this.close(), this._input.focus();
  }
  _singleOptionSelect(t) {
    const e = this._selectionModel.selections[0];
    e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute(ei, !1), u.trigger(this._element, ra, {
      value: e.value
    })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute(ei, !0), u.trigger(this._element, oa, {
      value: t.value
    }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());
  }
  _handleMultiSelection(t) {
    t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute(ei, !1), u.trigger(this._element, ra, {
      value: t.value
    })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute(ei, !0), u.trigger(this._element, oa, {
      value: t.value
    })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _emitValueChangeEvent(t) {
    u.trigger(this._element, wm, { value: t });
  }
  _emitNativeChangeEvent() {
    u.trigger(this._element, km);
  }
  _updateInputValue() {
    const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
    let e;
    this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = "" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label;
  }
  _isSelectionValid(t) {
    return !(t && (t.disabled || t.value === ""));
  }
  _isLabelEmpty(t) {
    return !!(t && t.label === "");
  }
  _appendFakeValue() {
    if (!this._selectionModel.selection || this._selectionModel._multiple)
      return;
    const t = this._selectionModel.selection.label;
    this._fakeValue = Cm(t, this._classes), h.findOne(
      ha,
      this._wrapper
    ).appendChild(this._fakeValue);
  }
  _updateLabelPosition() {
    const t = this._element.hasAttribute(aa), e = this._input.value !== "";
    this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q, "")));
  }
  _updateLabelPositionWhileClosing() {
    this._label && (this._input.value !== "" || this._isFakeValueActive ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q)));
  }
  _updateFakeLabelPosition() {
    this._fakeValue && (this._input.value === "" && this._fakeValue.innerHTML !== "" ? (this._isFakeValueActive = !0, this._fakeValue.setAttribute(q, "")) : (this._isFakeValueActive = !1, this._fakeValue.removeAttribute(q)));
  }
  _updateClearButtonVisibility() {
    if (!this.clearButton)
      return;
    this._selectionModel.selection || this._selectionModel.selections.length > 0 ? p.addStyle(this.clearButton, { display: "block" }) : p.addStyle(this.clearButton, { display: "none" });
  }
  _updateSelectAllState() {
    const t = this._selectAllOption.selected, e = jn(this.options);
    !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();
  }
  toggle() {
    this._isOpen ? this.close() : this.open();
  }
  open() {
    const t = this._config.disabled, e = u.trigger(this._element, ym);
    this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.selectFilter && (setTimeout(() => {
      this.filterInput.focus();
    }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, this._updateLabelPosition(), this._setInputActiveStyles());
  }
  _openDropdown() {
    this._popper = je(this._input, this._dropdownContainer, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {
      this.dropdown.setAttribute(la, "");
    }, 0);
  }
  _updateDropdownWidth() {
    const t = this._input.offsetWidth;
    p.addStyle(this._dropdownContainer, { width: `${t}px` });
  }
  _setFirstActiveOption() {
    const t = this._getNavigationOptions(), e = this._activeOption;
    e && e.removeActiveStyles();
    const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
    i ? (this._activeOption = i, i.setActiveStyles(), this._activeOptionIndex = t.findIndex(
      (n) => n === i
    )) : (this._activeOption = null, this._activeOptionIndex = -1);
  }
  _setInputActiveStyles() {
    this._input.setAttribute(Wt, ""), h.findOne(kn, this._wrapper).setAttribute(
      Wt,
      ""
    );
  }
  _listenToWindowResize() {
    u.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    this._dropdownContainer && this._updateDropdownWidth();
  }
  _listenToSelectSearch() {
    this.filterInput.addEventListener("input", (t) => {
      const e = t.target.value, i = this._config.selectFilterDebounce;
      this._debounceFilter(e, i);
    });
  }
  _debounceFilter(t, e) {
    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
      this._filterOptions(t);
    }, e);
  }
  _filterOptions(t) {
    const e = [];
    this._optionsToRender.forEach((o) => {
      const r = Object.prototype.hasOwnProperty.call(
        o,
        "options"
      ), a = !r && o.label.toLowerCase().includes(t.toLowerCase()), l = {};
      r && (l.label = o.label, l.options = this._filter(t, o.options), l.options.length > 0 && e.push(l)), a && e.push(o);
    });
    const i = this._config.selectNoResultText !== "", n = e.length !== 0;
    if (n)
      this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();
    else if (!n && i) {
      const o = this._getNoResultTemplate();
      this.optionsWrapper.innerHTML = o;
    }
  }
  _updateOptionsListTemplate(t) {
    const e = h.findOne(da, this._dropdownContainer) || h.findOne(Rm, this._dropdownContainer), i = Dl(
      t,
      this._selectAllOption,
      this._config,
      this._classes
    );
    this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(i);
  }
  _getNoResultTemplate() {
    return `<div class="${this._classes.noResult}" ${Ml} style="height: ${this._config.selectOptionHeight}px">${this._config.selectNoResultText}</div>`;
  }
  _filter(t, e) {
    const i = t.toLowerCase();
    return e.filter(
      (n) => n.label.toLowerCase().includes(i)
    );
  }
  _listenToDropdownKeydown() {
    u.on(
      this.dropdown,
      "keydown",
      this._handleOpenKeydown.bind(this)
    );
  }
  _listenToOutsideClick() {
    this._outsideClick = this._handleOutSideClick.bind(this), u.on(document, "click", this._outsideClick);
  }
  _listenToFocusChange(t = !0) {
    if (t === !1) {
      u.remove(
        this._input,
        "focus",
        () => this._notch.setAttribute(Wt, "")
      ), u.remove(
        this._input,
        "blur",
        () => this._notch.removeAttribute(Wt)
      );
      return;
    }
    u.on(
      this._input,
      "focus",
      () => this._notch.setAttribute(Wt, "")
    ), u.on(
      this._input,
      "blur",
      () => this._notch.removeAttribute(Wt)
    );
  }
  _handleOutSideClick(t) {
    const e = this._wrapper && this._wrapper.contains(t.target), i = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
    let o;
    this._toggleButton || (this._elementToggle = h.find(Pm)), this._elementToggle && this._elementToggle.forEach((r) => {
      const a = p.getDataAttribute(
        r,
        "select-toggle"
      );
      (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));
    }), !e && !i && !n && !o && this.close();
  }
  close() {
    const t = u.trigger(this._element, Am);
    !this._isOpen || t.defaultPrevented || (this._config.selectFilter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), this.dropdown.removeAttribute(la), setTimeout(() => {
      this._input.removeAttribute(Wt), this._input.blur(), h.findOne(kn, this._wrapper).removeAttribute(
        Wt
      ), this._label && !this.hasSelection && (this._label.removeAttribute(q), this._notch.setAttribute(q, ""), this._input.removeAttribute(q), this._notch.removeAttribute(q)), this._updateLabelPositionWhileClosing();
    }, 0), setTimeout(() => {
      this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, u.off(this.dropdown, "transitionend");
    }, Hm));
  }
  _resetFilterState() {
    this.filterInput.value = "", this._filteredOptionsList = null;
  }
  _removeDropdownEvents() {
    u.off(document, "click", this._outsideClick), this._config.selectFilter && u.off(this.dropdown, "keydown"), u.off(this.optionsWrapper, "click");
  }
  _addMutationObserver() {
    this._mutationObserver = new MutationObserver(() => {
      this._wrapper && (this._updateSelections(), this._updateDisabledState());
    }), this._observeMutationObserver();
  }
  _updateSelections() {
    this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();
    const t = this._config.filter && this.filterInput && this.filterInput.value;
    this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = na(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    );
  }
  _updateDisabledState() {
    const t = h.findOne(ca, this._wrapper);
    this._element.hasAttribute("disabled") ? (this._config.disabled = !0, t.setAttribute("disabled", ""), t.setAttribute(wn, "")) : (this._config.disabled = !1, t.removeAttribute("disabled"), t.removeAttribute(wn));
  }
  _observeMutationObserver() {
    this._mutationObserver && this._mutationObserver.observe(this._element, {
      attributes: !0,
      childList: !0,
      characterData: !0,
      subtree: !0
    });
  }
  _disconnectMutationObserver() {
    this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);
  }
  _createSelectAllOption() {
    const t = this._selectAllId, e = null, i = !0, n = "select-all", o = this._config.selectAllLabel, r = jn(this.options), a = !1, l = !1, c = null, d = null, _ = null;
    return new sa(
      t,
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      c,
      d,
      _
    );
  }
  dispose() {
    this._removeComponentEvents(), this._destroyMaterialSelect(), this._listenToFocusChange(!1), I.removeData(this._element, ri);
  }
  _removeComponentEvents() {
    u.off(this.input, "click"), u.off(this.wrapper, this._handleKeydown.bind(this)), u.off(this.clearButton, "click"), u.off(this.clearButton, "keydown"), u.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _destroyMaterialSelect() {
    this._isOpen && this.close(), this._destroyMaterialTemplate();
  }
  _destroyMaterialTemplate() {
    const t = this._wrapper.parentNode, e = h.find("label", this._wrapper);
    t.appendChild(this._element), e.forEach((i) => {
      t.appendChild(i);
    }), e.forEach((i) => {
      i.removeAttribute(q);
    }), p.removeClass(this._element, this._classes.initialized), this._element.removeActiveStyles(aa), t.removeChild(this._wrapper);
  }
  setValue(t) {
    this.options.filter((i) => i.selected).forEach((i) => i.nativeOption.selected = !1), Array.isArray(t) ? t.forEach((i) => {
      this._selectByValue(i);
    }) : this._selectByValue(t), this._updateSelections();
  }
  _selectByValue(t) {
    const e = this.options.find(
      (i) => i.value === t
    );
    return e ? (e.nativeOption.selected = !0, !0) : !1;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = I.getData(this, ri);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new Nl(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, ri);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Ym = (s) => {
  Aa(() => {
    const t = Ca();
    if (t) {
      const e = s.NAME, i = t.fn[e];
      t.fn[e] = s.jQueryInterface, t.fn[e].Constructor = s, t.fn[e].noConflict = () => (t.fn[e] = i, s.jQueryInterface);
    }
  });
}, jm = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      e.preventDefault(), s.getOrCreateInstance(this).toggle();
    }
  );
}, Km = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), ue(this))
        return;
      s.getOrCreateInstance(this).show();
    }
  );
}, Um = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      const i = Xt(this);
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), ue(this))
        return;
      u.one(i, s.EVENT_HIDDEN, () => {
        St(this) && this.focus();
      });
      const n = h.findOne(s.OPEN_SELECTOR);
      n && n !== i && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, zm = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}`,
    t,
    (e) => {
      e.preventDefault();
      const i = e.target.closest(t);
      s.getOrCreateInstance(i).toggle();
    }
  );
}, Xm = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      const i = Xt(this);
      ["A", "AREA"].includes(this.tagName) && e.preventDefault(), u.one(i, s.EVENT_SHOW, (r) => {
        r.defaultPrevented || u.one(i, s.EVENT_HIDDEN, () => {
          St(this) && this.focus();
        });
      });
      const n = h.findOne(
        `[${s.OPEN_SELECTOR}="true"]`
      );
      n && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, Gm = (s, t) => {
  u.one(
    document,
    "mousedown",
    t,
    s.autoInitial(new s())
  );
}, qm = (s, t) => {
  u.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      (e.target.tagName === "A" || e.delegateTarget && e.delegateTarget.tagName === "A") && e.preventDefault();
      const i = Xn(this);
      h.find(i).forEach((o) => {
        s.getOrCreateInstance(o, { toggle: !1 }).toggle();
      });
    }
  );
}, Ft = {
  plugins: {
    legend: {
      labels: {
        color: "rgb(102,102,102)"
      }
    }
  }
}, gs = {
  line: {
    options: {
      ...Ft,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.0)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bar: {
    options: {
      ...Ft,
      backgroundColor: "rgb(59, 112, 202)",
      borderWidth: 0,
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !0,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  pie: {
    options: {
      ...Ft,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  doughnut: {
    options: {
      ...Ft,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  polarArea: {
    options: {
      ...Ft,
      elements: {
        arc: { backgroundColor: "rgba(59, 112, 202, 0.5)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  radar: {
    options: {
      ...Ft,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  scatter: {
    options: {
      ...Ft,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bubble: {
    options: {
      ...Ft,
      elements: {
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      scales: {
        x: {
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  }
}, Qm = (s, t) => {
  const e = (o) => o[0] === "{" && o[o.length - 1] === "}" || o[0] === "[" && o[o.length - 1] === "]", i = (o) => typeof o != "string" ? o : e(o) ? JSON.parse(o.replace(/'/g, '"')) : o, n = (o) => {
    const r = {};
    return Object.keys(o).forEach((a) => {
      if (a.match(/dataset.*/)) {
        const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));
        r[l] = i(o[a]);
      }
    }), r;
  };
  h.find(t).forEach((o) => {
    if (p.getDataAttribute(o, "chart") !== "bubble" && p.getDataAttribute(o, "chart") !== "scatter") {
      const r = p.getDataAttributes(o), a = {
        data: {
          datasets: [n(r)]
        }
      };
      return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '"'))), new s(o, {
        ...a,
        ...gs[a.type]
      });
    }
    return null;
  });
}, ai = {
  alert: {
    name: "Alert",
    selector: "[data-te-alert-init]",
    isToggler: !1
  },
  animation: {
    name: "Animate",
    selector: "[data-te-animation-init]",
    isToggler: !1
  },
  carousel: {
    name: "Carousel",
    selector: "[data-te-carousel-init]",
    isToggler: !1
  },
  chips: {
    name: "ChipsInput",
    selector: "[data-te-chips-init]",
    isToggler: !1
  },
  chip: {
    name: "Chip",
    selector: "[data-te-chip-init]",
    isToggler: !1
  },
  datepicker: {
    name: "Datepicker",
    selector: "[data-te-datepicker-init]",
    isToggler: !1
  },
  input: {
    name: "Input",
    selector: "[data-te-input-wrapper-init]",
    isToggler: !1
  },
  scrollspy: {
    name: "ScrollSpy",
    selector: "[data-te-spy='scroll']",
    isToggler: !1
  },
  select: {
    name: "Select",
    selector: "[data-te-select-init]",
    isToggler: !1
  },
  sidenav: {
    name: "Sidenav",
    selector: "[data-te-sidenav-init]",
    isToggler: !1
  },
  stepper: {
    name: "Stepper",
    selector: "[data-te-stepper-init]",
    isToggler: !1
  },
  timepicker: {
    name: "Timepicker",
    selector: "[data-te-timepicker-init]",
    isToggler: !1
  },
  toast: {
    name: "Toast",
    selector: "[data-te-toast-init]",
    isToggler: !1
  },
  // advancedInits
  chart: {
    name: "Chart",
    selector: "[data-te-chart]",
    isToggler: !1,
    advanced: Qm
  },
  // togglers
  button: {
    name: "Button",
    selector: "[data-te-toggle='button']",
    isToggler: !0,
    callback: zm
  },
  collapse: {
    name: "Collapse",
    selector: "[data-te-collapse-init]",
    isToggler: !0,
    callback: qm
  },
  dropdown: {
    name: "Dropdown",
    selector: "[data-te-dropdown-toggle-ref]",
    isToggler: !0,
    callback: jm
  },
  modal: {
    name: "Modal",
    selector: "[data-te-toggle='modal']",
    isToggler: !0,
    callback: Xm
  },
  ripple: {
    name: "Ripple",
    selector: "[data-te-ripple-init]",
    isToggler: !0,
    callback: Gm
  },
  offcanvas: {
    name: "Offcanvas",
    selector: "[data-te-offcanvas-toggle]",
    isToggler: !0,
    callback: Um
  },
  tab: {
    name: "Tab",
    selector: "[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']",
    isToggler: !0,
    callback: Km
  }
}, Zm = (s) => ai[s.NAME] || null, Jm = (s) => {
  if (!s || [].includes(s.NAME))
    return;
  [].push(s.NAME);
  const t = Zm(s), e = (t == null ? void 0 : t.isToggler) || !1;
  if (Ym(s), t != null && t.advanced) {
    t == null || t.advanced(s, t == null ? void 0 : t.selector);
    return;
  }
  if (e) {
    t == null || t.callback(s, t == null ? void 0 : t.selector);
    return;
  }
  h.find(t == null ? void 0 : t.selector).forEach((i) => {
    let n = s.getInstance(i);
    n || (n = new s(i));
  });
}, tg = (s) => {
  s.forEach((t) => Jm(t));
}, eg = (s, t = !1) => {
  const e = Object.keys(ai).map((i) => {
    if (!!document.body.querySelector(ai[i].selector)) {
      const o = s[ai[i].name];
      return !o && ![].includes(i) && t && console.warn(
        `Please import ${ai[i].name} from "tw-elements" package and add it to a object parameter inside "initTE" function`
      ), o;
    }
  });
  tg(e);
}, ig = ({ inputID: s, labelText: t }, e) => (eg({ Input: V }, !1), `<div data-te-chips-input-wrapper data-te-input-wrapper-init class="${e.chipsInputWrapper}">
      <input
          type="text"
          class="${e.chipsInput}"
          id="${s}"
          placeholder="Example label" />
        <label
          for="${s}"
          class="${e.chipsLabel}"
          >${t}
        </label>

        <div data-te-input-notch-ref class="${e.chipsNotchesWrapper}">
        <div class="${e.chipsNotchesLeading}" data-te-input-notch-leading-ref style="width: 9px;"></div>
        <div class="${e.chipsNotchesMiddle}" data-te-input-notch-middle-ref style="width: 87.2px;"></div>
        <div class="${e.chipsNotchesTrailing}" data-te-input-notch-trailing-ref></div>
      </div>
    </div>`), sg = ({ text: s, iconSVG: t }, e) => `<div data-te-chip-init data-te-ripple-init class="${e.chipElement}">
    <span data-te-chip-text>${s}</span> 
      <span data-te-chip-close class="${e.chipCloseIcon}">
        ${t}
      </span>
  </div>`, bs = "chip", ng = `te.${bs}`, Rl = "data-te-chip-close", On = `[${Rl}]`, og = "delete.te.chips", rg = "select.te.chip", ag = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3 h-3"> <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>', lg = {
  text: "string",
  closeIcon: "boolean",
  img: "object",
  iconSVG: "string"
}, cg = {
  text: "",
  closeIcon: !1,
  img: { path: "", alt: "" },
  iconSVG: ag
}, dg = {
  icon: "float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out",
  chipElement: "flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded",
  chipCloseIcon: "w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out"
}, hg = {
  icon: "string",
  chipElement: "string",
  chipCloseIcon: "string"
};
class ii {
  constructor(t, e = {}, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i);
  }
  // Getters
  static get NAME() {
    return bs;
  }
  // Public
  init() {
    this._appendCloseIcon(), this._handleDelete(), this._handleTextChip(), this._handleClickOnChip();
  }
  dispose() {
    this._element = null, this._options = null, u.off(this._element, "click");
  }
  appendChip() {
    const { text: t, closeIcon: e, iconSVG: i } = this._options;
    return sg({ text: t, closeIcon: e, iconSVG: i }, this._classes);
  }
  // Private
  _appendCloseIcon(t = this._element) {
    if (!(h.find(On, this._element).length > 0) && this._options.closeIcon) {
      const e = M("span");
      e.classList = this._classes.icon, e.setAttribute(Rl), e.innerHTML = this._options.iconSVG, t.insertAdjacentElement("beforeend", e);
    }
  }
  _handleClickOnChip() {
    u.on(this._element, "click", (t) => {
      const { textContent: e } = t.target, i = {};
      i.tag = e.trim(), u.trigger(rg, { event: t, obj: i });
    });
  }
  _handleDelete() {
    h.find(
      On,
      this._element
    ).length !== 0 && u.on(this._element, "click", On, () => {
      u.trigger(this._element, og), this._element.remove();
    });
  }
  _handleTextChip() {
    this._element.innerText === "" && (this._element.innerText = this._options.text);
  }
  _getConfig(t) {
    const e = {
      ...cg,
      ...p.getDataAttributes(this._element),
      ...t
    };
    return N(bs, e, lg), e;
  }
  _getClasses(t) {
    const e = p.getDataClassAttributes(this._element);
    return t = {
      ...dg,
      ...e,
      ...t
    }, N(bs, t, hg), t;
  }
  static getInstance(t) {
    return I.getData(t, ng);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const ui = "chips", yi = `data-te-${ui}`, ua = `te.${ui}`, ug = `${yi}-init`, ft = `${yi}-active`, pa = `${yi}-initial`, Pl = `${yi}-placeholder`, pg = `${yi}-input-wrapper`, Kn = "data-te-chip-init", Hl = "data-te-chip-close", Bl = "data-te-chip-text", fg = `[${ft}]`, Un = `[${Kn}]`, _g = `${Un}${fg}`, xn = `[${Hl}]`, mg = `[${pg}]`, gg = `[${Bl}]`, bg = `[${Pl}]`, vg = "data-te-input-notch-leading-ref", Eg = "data-te-input-notch-middle-ref", Tg = `[${vg}]`, Cg = `[${Eg}]`, Ae = "data-te-input-state-active", Sn = "[data-te-input-notch-ref]", Ag = "add.te.chips", yg = "arrowDown.te.chips", wg = "arrowLeft.te.chips", kg = "arrowRight.te.chips", Og = "arrowUp.te.chips", fa = "delete.te.chips", _a = "select.te.chips", xg = {
  inputID: "string",
  parentSelector: "string",
  initialValues: "array",
  editable: "boolean",
  labelText: "string"
}, Sg = {
  inputID: Ot("chips-input-"),
  parentSelector: "",
  initialValues: [{ tag: "init1" }, { tag: "init2" }],
  editable: !1,
  labelText: "Example label"
}, Dg = {
  opacity: "opacity-0",
  inputWrapperPadding: "p-[5px]",
  transition: "transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  contentEditable: "outline-none !border-[3px] !border-solid !border-[#b2b3b4]",
  chipsInputWrapper: "relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  chipsInput: "peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0",
  chipsLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200",
  chipsNotchesWrapper: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
  chipsNotchesLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  chipsNotchesMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  chipsNotchesTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0 border-gray-300 dark:border-gray-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary"
}, Ig = {
  opacity: "string",
  inputWrapperPadding: "string",
  transition: "string",
  contentEditable: "string",
  chipsInputWrapper: "string",
  chipsInput: "string",
  chipsLabel: "string",
  chipsNotchesWrapper: "string",
  chipsNotchesLeading: "string",
  chipsNotchesMiddle: "string",
  chipsNotchesTrailing: "string"
};
class Zg extends ii {
  constructor(e, i = {}, n) {
    super(e, i);
    Tt(this, "_handleBlurInput", ({ target: e }) => {
      e.value.length > 0 && this._handleCreateChip(e, e.value), this.allChips.length > 0 ? (e.setAttribute(ft, ""), this.input.setAttribute(Ae, ""), h.findOne(
        Sn,
        this.input.parentNode
      ).setAttribute(Ae, ""), this.chipsInputWrapper.classList.add(
        ...this._classes.inputWrapperPadding.split(" ")
      )) : (e.removeAttribute(ft), this.input.removeAttribute(Ae), h.findOne(
        Sn,
        this.input.parentNode
      ).removeAttribute(Ae), this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      )), this.allChips.forEach((i) => i.removeAttribute(ft));
    });
    this._element = e, this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._element && I.setData(e, ua, this), this._options = this._getConfig(i), this._classes = this._getClasses(n), this.numberClicks = 0, this.init();
  }
  // Getters
  static get NAME() {
    return ui;
  }
  get activeChip() {
    return h.findOne(_g, this._element);
  }
  get input() {
    return h.findOne("input", this._element);
  }
  get allChips() {
    return h.find(Un, this._element);
  }
  get chipsInputWrapper() {
    return h.findOne(mg, this._element);
  }
  // Public
  init() {
    this._setChipsClass(), this._appendInputToElement(Pl), this._handleInitialValue(), this._handleInputText(), this._handleKeyboard(), this._handleChipsOnSelect(), this._handleEditable(), this._handleChipsFocus(), this._handleClicksOnChips(), this._getLabelData(), this._getLabelWidth(), this._getNotchData(), this._applyNotch();
  }
  dispose() {
    this._element = null, this._options = null;
  }
  // Private
  _getNotchData() {
    this._notchMiddle = h.findOne(
      Cg,
      this._element
    ), this._notchLeading = h.findOne(
      Tg,
      this._element
    );
  }
  _getLabelData() {
    this._label = h.findOne("label", this._element);
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
  }
  _setChipsClass() {
    this._element.setAttribute(ug, "");
  }
  _handleDeleteEvents(e) {
    const [i] = this.allChips.slice(-1);
    if (this.activeChip === null)
      i.remove(), this._handleEvents(e, fa);
    else {
      const n = this.allChips.findIndex((a) => a === this.activeChip), o = this._handleActiveChipAfterRemove(n), r = [];
      if (this.activeChip === null)
        return;
      this.activeChip.remove(), this._handleEvents(e, fa), this.numberClicks = n, o.setAttribute(ft, ""), this.allChips.forEach((a) => {
        a.hasAttribute(ft) && (r.push(a), r.length > 1 && this.allChips.forEach((l) => l.remove()));
      });
    }
  }
  _handleUpEvents(e) {
    this.numberClicks += 1, this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0), this._handleRightKeyboardArrow(this.numberClicks), this._handleEvents(e, kg), this._handleEvents(e, Og);
  }
  _handleDownEvents(e) {
    this.numberClicks -= 1, this.numberClicks <= 0 && (this.numberClicks = this.allChips.length), this._handleLeftKeyboardArrow(this.numberClicks), this._handleEvents(e, wg), this._handleEvents(e, yg);
  }
  _keyboardEvents(e) {
    const { target: i, keyCode: n, ctrlKey: o } = e;
    i.value.length > 0 || this.allChips.length === 0 || (n === Xp || n === Gp ? this._handleDeleteEvents(e) : n === $e || n === rt ? this._handleUpEvents(e) : n === Ie || n === U ? this._handleDownEvents(e) : n === 65 && o && this._handleAddActiveClass());
  }
  _handleKeyboard() {
    u.on(
      this.input,
      "keydown",
      (e) => this._keyboardEvents(e)
    );
  }
  _handleEditable() {
    const { editable: e } = this._options;
    e && this.allChips.forEach((i) => {
      u.on(i, "dblclick", (n) => {
        const o = h.findOne(xn, i);
        i.classList.add(...this._classes.contentEditable.split(" ")), i.contentEditable = !0, i.focus(), setTimeout(() => {
          p.addStyle(o, { display: "none" });
        }, 200), o.classList.add(...this._classes.opacity.split(" ")), n.target.textContent, u.trigger(i, _a, {
          event: n,
          allChips: this.allChips
        });
      }), u.on(document, "click", ({ target: n }) => {
        const o = h.findOne(xn, i), r = h.findOne(gg, i), a = n === i, l = i && i.contains(n);
        !a && !l && (i.contentEditable = !1, i.classList.remove(...this._classes.contentEditable.split(" ")), r.textContent !== "" && setTimeout(() => {
          p.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
        }, 160)), r.textContent === "" && (setTimeout(() => {
          i.classList.add(...this._classes.opacity.split(" "));
        }, 200), setTimeout(() => {
          i.remove();
        }, 300));
      });
    });
  }
  _handleRemoveActiveClass() {
    this.allChips.forEach((e) => e.removeAttribute(ft));
  }
  _handleAddActiveClass() {
    this.allChips.forEach((e) => e.setAttribute(ft, ""));
  }
  _handleRightKeyboardArrow(e) {
    this._handleRemoveActiveClass(), e === 0 && (e = 1), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleLeftKeyboardArrow(e) {
    this._handleRemoveActiveClass(), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleActiveChipAfterRemove(e) {
    const i = e === 0 ? 1 : e - 1;
    return this.allChips[i];
  }
  _handleClicksOnChips() {
    u.on(this._element, "click", () => {
      this.allChips.length === 0 && (this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      ), this.input.removeAttribute(ft));
    });
  }
  _handleTextContent() {
    const e = [];
    return this.allChips.forEach((i) => e.push({ tag: i.textContent.trim() })), e;
  }
  _handleEvents(e, i) {
    const n = this._handleTextContent(), o = this.allChips.filter(
      (r) => r.hasAttribute(ft) && r
    );
    u.trigger(this._element, i, {
      event: e,
      allChips: this.allChips,
      arrOfObjects: n,
      active: o,
      activeObj: {
        tag: o.length <= 0 ? "" : o[0].textContent.trim()
      }
    });
  }
  _handleChipsFocus() {
    u.on(this._element, "click", ({ target: { attributes: e } }) => {
      const i = [...e];
      i.includes(Kn) || i.includes(Hl) || i.includes(Bl) || this.input.focus();
    });
  }
  _handleInitialValue() {
    if (this._appendInputToElement(pa), this._element.hasAttribute(pa)) {
      const { initialValues: e } = this._options;
      e.forEach(
        ({ tag: i }) => this._handleCreateChip(this.input, i)
      ), h.findOne(
        Sn,
        this.input.parentNode
      ).setAttribute(Ae, ""), this.input.setAttribute(ft, ""), this.input.setAttribute(Ae, "");
    }
    this.allChips.length > 0 && (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    ));
  }
  _handleKeysInputToElement(e) {
    const { keyCode: i, target: n } = e;
    if (n.hasAttribute(Kn)) {
      const o = h.findOne(xn, n);
      i === lt && (n.contentEditable = !1, n.classList.remove(...this._classes.contentEditable.split(" ")), n.textContent !== "" ? setTimeout(() => {
        p.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
      }, 160) : n.textContent === "" && (setTimeout(() => {
        n.classList.add(...this._classes.opacity.split(" "));
      }, 200), setTimeout(() => {
        n.remove();
      }, 300)));
      return;
    }
    if (i === lt) {
      if (n.value === "")
        return;
      this._handleCreateChip(n, n.value), this._handleRemoveActiveClass(), this.numberClicks = this.allChips.length + 1, this._handleEvents(e, Ag);
    }
    this.allChips.length > 0 ? (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    )) : this.chipsInputWrapper.classList.remove(
      ...this._classes.inputWrapperPadding.split(" ")
    );
  }
  _handleInputText() {
    const e = h.findOne(
      bg,
      this._element
    );
    u.on(
      this._element,
      "keyup",
      e,
      (i) => this._handleKeysInputToElement(i)
    ), u.on(this.input, "blur", (i) => this._handleBlurInput(i));
  }
  _appendInputToElement(e) {
    if (!this._element.hasAttribute(e))
      return;
    const i = ig(this._options, this._classes);
    this._element.insertAdjacentHTML("beforeend", i);
  }
  _handleCreateChip(e, i) {
    const n = M("div"), o = ii.getInstance(n), r = new ii(o, { text: i }, this._classes);
    this._options.parentSelector !== "" ? document.querySelector(this._options.parentSelector).insertAdjacentHTML("beforeend", r.appendChip()) : e.insertAdjacentHTML("beforebegin", r.appendChip()), e.value = "", h.find(Un).forEach((a) => {
      let l = ii.getInstance(a);
      return l || (l = new ii(a, {}, this._classes)), l.init();
    }), this._handleEditable();
  }
  _handleChipsOnSelect() {
    this.allChips.forEach((e) => {
      u.on(this._element, "click", (i) => {
        u.trigger(e, _a, {
          event: i,
          allChips: this.allChips
        });
      });
    });
  }
  _handleAddActiveClassWithKebyboard(e) {
    let i;
    this.allChips[e - 1] === void 0 ? i = this.allChips[e - 2] : i = this.allChips[e - 1], i.setAttribute(ft);
  }
  _getConfig(e) {
    const i = {
      ...Sg,
      ...p.getDataAttributes(this._element),
      ...e
    };
    return N(ui, i, xg), i;
  }
  _getClasses(e) {
    const i = p.getDataClassAttributes(this._element);
    return e = {
      ...Dg,
      ...i,
      ...e
    }, N(ui, e, Ig), e;
  }
  static getInstance(e) {
    return I.getData(e, ua);
  }
  static getOrCreateInstance(e, i = {}) {
    return this.getInstance(e) || new this(e, typeof i == "object" ? i : null);
  }
}
var $g = function(t) {
  return Lg(t) && !Mg(t);
};
function Lg(s) {
  return !!s && typeof s == "object";
}
function Mg(s) {
  var t = Object.prototype.toString.call(s);
  return t === "[object RegExp]" || t === "[object Date]" || Pg(s);
}
var Ng = typeof Symbol == "function" && Symbol.for, Rg = Ng ? Symbol.for("react.element") : 60103;
function Pg(s) {
  return s.$$typeof === Rg;
}
function Hg(s) {
  return Array.isArray(s) ? [] : {};
}
function _i(s, t) {
  return t.clone !== !1 && t.isMergeableObject(s) ? We(Hg(s), s, t) : s;
}
function Bg(s, t, e) {
  return s.concat(t).map(function(i) {
    return _i(i, e);
  });
}
function Vg(s, t) {
  if (!t.customMerge)
    return We;
  var e = t.customMerge(s);
  return typeof e == "function" ? e : We;
}
function Wg(s) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(s).filter(function(t) {
    return Object.propertyIsEnumerable.call(s, t);
  }) : [];
}
function ma(s) {
  return Object.keys(s).concat(Wg(s));
}
function Vl(s, t) {
  try {
    return t in s;
  } catch {
    return !1;
  }
}
function Fg(s, t) {
  return Vl(s, t) && !(Object.hasOwnProperty.call(s, t) && Object.propertyIsEnumerable.call(s, t));
}
function Yg(s, t, e) {
  var i = {};
  return e.isMergeableObject(s) && ma(s).forEach(function(n) {
    i[n] = _i(s[n], e);
  }), ma(t).forEach(function(n) {
    Fg(s, n) || (Vl(s, n) && e.isMergeableObject(t[n]) ? i[n] = Vg(n, e)(s[n], t[n], e) : i[n] = _i(t[n], e));
  }), i;
}
function We(s, t, e) {
  e = e || {}, e.arrayMerge = e.arrayMerge || Bg, e.isMergeableObject = e.isMergeableObject || $g, e.cloneUnlessOtherwiseSpecified = _i;
  var i = Array.isArray(t), n = Array.isArray(s), o = i === n;
  return o ? i ? e.arrayMerge(s, t, e) : Yg(s, t, e) : _i(t, e);
}
We.all = function(t, e) {
  if (!Array.isArray(t))
    throw new Error("first argument should be an array");
  return t.reduce(function(i, n) {
    return We(i, n, e);
  }, {});
};
var jg = We, zn = jg;
const ga = "chart", is = "te.chart", Kg = "chart", ba = (s, t, e) => {
  const i = (n, o, r) => {
    const a = n.slice();
    return o.forEach((l, c) => {
      typeof a[c] > "u" ? a[c] = r.cloneUnlessOtherwiseSpecified(
        l,
        r
      ) : r.isMergeableObject(l) ? a[c] = zn(n[c], l, r) : n.indexOf(l) === -1 && a.push(l);
    }), a;
  };
  return zn(e[t], s, {
    arrayMerge: i
  });
}, Ug = {
  darkTicksColor: "#fff",
  darkLabelColor: "#fff",
  darkGridLinesColor: "#555",
  darkmodeOff: "undefined",
  darkBgColor: "#262626",
  options: null
}, zg = {
  darkTicksColor: "string",
  darkLabelColor: "string",
  darkGridLinesColor: "string",
  darkmodeOff: "(string|null)",
  darkBgColor: "string",
  options: "(object|null)"
};
class Wl {
  constructor(t, e, i = {}, n = {}) {
    this._waitForCharts(t, e, i, n);
  }
  async _getChartjs() {
    const {
      Chart: t,
      ArcElement: e,
      LineElement: i,
      BarElement: n,
      PointElement: o,
      BarController: r,
      BubbleController: a,
      DoughnutController: l,
      LineController: c,
      PieController: d,
      PolarAreaController: _,
      RadarController: f,
      ScatterController: m,
      CategoryScale: g,
      LinearScale: b,
      LogarithmicScale: T,
      RadialLinearScale: C,
      TimeScale: w,
      TimeSeriesScale: v,
      Decimation: E,
      Filler: A,
      Legend: y,
      Title: S,
      Tooltip: O,
      SubTitle: k
    } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_tw-elements_dist_js_chart_es_js").then(__webpack_require__.bind(__webpack_require__, /*! ./chart.es.js */ "./node_modules/tw-elements/dist/js/chart.es.js")).then((D) => D.f);
    return t.register(
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      c,
      d,
      _,
      f,
      m,
      g,
      b,
      T,
      C,
      w,
      v,
      E,
      A,
      y,
      S,
      O,
      k
    ), t;
  }
  async _getChartDataLabels() {
    const { ChartDataLabels: t } = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_tw-elements_dist_js_chart_es_js"), __webpack_require__.e("vendors-node_modules_tw-elements_dist_js_chartjs-plugin-datalabels_es_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./chartjs-plugin-datalabels.es.js */ "./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js"));
    return t;
  }
  async _waitForCharts(t, e, i = {}, n = {}) {
    this._Chartjs = await this._getChartjs(), this._ChartDataLabels = await this._getChartDataLabels(), this._element = t, this._data = e, this._options = i, this._type = e.type, this._canvas = null, this._chart = null, this._darkOptions = this._getDarkConfig(n), this._darkModeClassContainer = document.querySelector("html"), this._prevConfig = null, this._observer = null, this._element && (I.setData(t, is, this), p.addClass(this._element, Kg), this._chartConstructor()), this._darkOptions.darkmodeOff !== null && (this._handleMode(this.systemColorMode), this._observer = new MutationObserver(this._observerCallback.bind(this)), this._observer.observe(this._darkModeClassContainer, {
      attributes: !0
    }));
  }
  // Getters
  static get NAME() {
    return ga;
  }
  get systemColorMode() {
    return localStorage.theme || (this._darkModeClassContainer.classList.contains("dark") ? "dark" : "light");
  }
  // Public
  dispose() {
    this._observer.disconnect(), I.removeData(this._element, is), this._element = null;
  }
  update(t, e) {
    t && (this._data = { ...this._data, ...t }, this._chart.data = this._data), this._prevConfig = this._chart.options, this._options = { ...this._options, ...e }, this._chart.options = zn(this._chart.options, this._options), this._chart.update();
  }
  // Private
  _getDarkConfig(t) {
    let e = {};
    const i = p.getDataAttributes(this._element);
    Object.keys(i).forEach(
      (c) => c.startsWith("dark") && (e[c] = i[c])
    ), e = {
      ...Ug,
      ...e
    };
    const n = {
      y: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      },
      x: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      }
    }, o = {
      r: {
        ticks: {
          color: e.darkTicksColor,
          backdropColor: e.darkBgColor
        },
        grid: {
          color: e.darkGridLinesColor
        },
        pointLabels: {
          color: e.darkTicksColor
        }
      }
    }, l = {
      scales: ["pie", "doughnut", "polarArea", "radar"].includes(this._type) ? ["polarArea", "radar"].includes(this._type) ? o : {} : n,
      plugins: {
        legend: {
          labels: {
            color: e.darkLabelColor
          }
        }
      }
    };
    return t = {
      ...e,
      options: {
        ...l
      },
      ...t
    }, N(ga, t, zg), t;
  }
  _chartConstructor() {
    if (this._data) {
      this._createCanvas();
      const t = ba(this._options, this._type, gs), e = [];
      t.dataLabelsPlugin && e.push(this._ChartDataLabels), this._chart = new this._Chartjs(this._canvas, {
        ...this._data,
        ...t,
        plugins: e
      });
    }
  }
  _createCanvas() {
    this._canvas || (this._element.nodeName === "CANVAS" ? this._canvas = this._element : (this._canvas = M("canvas"), this._element.appendChild(this._canvas)));
  }
  _handleMode(t) {
    t === "dark" ? (this._changeDatasetBorderColor(), this.update(null, this._darkOptions.options)) : (this._changeDatasetBorderColor(!1), this._prevConfig && this.update(null, this._prevConfig));
  }
  _observerCallback(t) {
    for (const e of t)
      e.type === "attributes" && this._handleMode(this.systemColorMode);
  }
  _changeDatasetBorderColor(t = !0) {
    [...this._data.data.datasets].forEach(
      (e) => ["pie", "doughnut", "polarArea"].includes(this._type) && (e.borderColor = t ? this._darkOptions.darkBgColor : "#fff")
    );
  }
  static jQueryInterface(t, e, i) {
    return this.each(function() {
      let n = I.getData(this, is);
      if (!(!n && /dispose/.test(t))) {
        if (!n) {
          const o = e ? ba(e, i, gs) : gs[i];
          n = new Wl(this, {
            ...t,
            ...o
          });
        }
        if (typeof t == "string") {
          if (typeof n[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          n[t](e, i);
        }
      }
    });
  }
  static getInstance(t) {
    return I.getData(t, is);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}

//# sourceMappingURL=tw-elements.es.min.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "js/" + chunkId + ".inbound_order.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "static:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkstatic"] = self["webpackChunkstatic"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/inbound_order/inbound_order.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFL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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFpQztBQUNuRix5REFBeUQsaUNBQWlDO0FBQzFGO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsc0NBQXNDO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5RUFBeUUscUNBQXFDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0Q0FBNEM7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssMEdBQTBHLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU8sV0FBVyxRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd0NBQXdDO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdNQUF3TTtBQUMzTTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUIsS0FBSztBQUNMLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FB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QUFDTDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsR0FBRztBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0MsR0FBRztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEVBQUUsK0JBQStCLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELEdBQUcsaUNBQWlDLEdBQUcsRUFBRSxHQUFHO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9GQUFvRixHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRywwQkFBMEIsR0FBRztBQUM5SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2VEFBNlQsR0FBRztBQUNoVTtBQUNBLG9GQUFvRixrQkFBa0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILEdBQUc7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQThDLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCLEdBQUc7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9EQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QixHQUFHLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QWdFLHNCQUFzQjtBQUNqTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLE9BQU8sV0FBVyxFQUFFO0FBQ2hJLHlEQUF5RCxFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRyxJQUFJLHFCQUFxQjtBQUN0QztBQUNBLFVBQVUsR0FBRyxJQUFJLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUssSUFBSSxNQUFNLEVBQUUsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQThEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEM7QUFDQTtBQUNBLHVCQUF1Qiw4REFBOEQ7QUFDckY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDRDQUE0QyxFQUFFLGdCQUFnQjtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0Q0FBNEMsRUFBRSxnQkFBZ0I7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQkFBc0IsSUFBSSxvQkFBb0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQixJQUFJLG9CQUFvQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNENBQTRDLEVBQUUsZ0JBQWdCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEksZ0JBQWdCO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSUFBMEksc0JBQXNCLElBQUksb0JBQW9CO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixHQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUU7QUFDL0Isb0JBQW9CLGNBQWM7QUFDbEMsNkNBQTZDLDJCQUEyQix5Q0FBeUMsMkJBQTJCLDZEQUE2RCwyQkFBMkI7QUFDcE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3QkFBd0IsRUFBRSxXQUFXLG9CQUFvQjtBQUN6RCxvQkFBb0Isc0JBQXNCO0FBQzFDLHNCQUFzQixxQkFBcUI7QUFDM0MsbUJBQW1CLEVBQUUsV0FBVyxpQkFBaUIseUJBQXlCLFlBQVk7QUFDdEYsc0JBQXNCLHdCQUF3QjtBQUM5QywwQkFBMEIsMkJBQTJCO0FBQ3JELDZCQUE2QixpQ0FBaUM7QUFDOUQsK0NBQStDLDBCQUEwQjtBQUN6RTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0QsMkJBQTJCLGlDQUFpQztBQUM1RCw2Q0FBNkMsMEJBQTBCO0FBQ3ZFO0FBQ0E7QUFDQSxjQUFjLHdCQUF3Qix3QkFBd0I7QUFDOUQsaURBQWlELG1CQUFtQix3RkFBd0YsRUFBRTtBQUM5SixtQ0FBbUMsbUJBQW1CLHdGQUF3RixFQUFFO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUJBQXFCLEVBQUUsV0FBVyx5QkFBeUI7QUFDbkUsMEJBQTBCLGtCQUFrQjtBQUM1Qyw2QkFBNkIsc0JBQXNCO0FBQ25ELDRCQUE0Qix3QkFBd0I7QUFDcEQsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUUsV0FBVywwQkFBMEI7QUFDdEQsb0JBQW9CLG1CQUFtQjtBQUN2QyxVQUFVLG9DQUFvQyx5QkFBeUIsOERBQThELEVBQUU7QUFDdkksdUNBQXVDLHlCQUF5QiwrREFBK0QsRUFBRTtBQUNqSSx1Q0FBdUMseUJBQXlCLCtEQUErRCxFQUFFO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixFQUFFLFdBQVcsMEJBQTBCO0FBQ2hFLHNCQUFzQiw0QkFBNEI7QUFDbEQsd0JBQXdCLDJCQUEyQjtBQUNuRCxxQkFBcUIsRUFBRSxXQUFXLHVCQUF1QjtBQUN6RDtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQsNEJBQTRCLDJCQUEyQjtBQUN2RCwrQkFBK0IsOEJBQThCO0FBQzdELGlDQUFpQyx5QkFBeUI7QUFDMUQsbUNBQW1DLDBCQUEwQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdDQUFnQztBQUNqRixpQ0FBaUMsMkJBQTJCO0FBQzVELG1DQUFtQywwQkFBMEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNCQUFzQjtBQUNyRSw2QkFBNkIsaUNBQWlDO0FBQzlELCtCQUErQix5QkFBeUI7QUFDeEQsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdDQUFnQztBQUMvRSwrQkFBK0IsMkJBQTJCO0FBQzFELGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCLDhCQUE4QjtBQUN0RSxxREFBcUQseUJBQXlCLHdGQUF3RixFQUFFO0FBQ3hLLHVDQUF1Qyx5QkFBeUIsd0ZBQXdGLEVBQUU7QUFDMUoscURBQXFELCtCQUErQiwrREFBK0QsRUFBRTtBQUNySjtBQUNBLGdCQUFnQixzQkFBc0IsK0JBQStCLCtEQUErRCxFQUFFO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLGFBQWE7QUFDdkI7QUFDQSxnQkFBZ0IsRUFBRSxzQ0FBc0MseUJBQXlCO0FBQ2pGLE1BQU07QUFDTjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZMQUE2TCxFQUFFO0FBQy9MO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxVQUFVO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxXQUFXLG9DQUFvQztBQUNoRCxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVksRUFBRSxHQUFHLGFBQWEsRUFBRSxNQUFNO0FBQ3RDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWSxHQUFHLGVBQWUsRUFBRSxhQUFhO0FBQ25FLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWSxHQUFHLGVBQWUsRUFBRSxhQUFhO0FBQ25FLENBQUMsVUFBVSx1RUFBdUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLG9HQUFvRyxHQUFHLHVDQUF1QyxHQUFHLFlBQVksR0FBRyxrQ0FBa0MsR0FBRyxFQUFFLEdBQUcsa0JBQWtCLEdBQUcsRUFBRSxHQUFHLG9CQUFvQixHQUFHLEVBQUUsR0FBRyxrQkFBa0IsR0FBRyxFQUFFLEdBQUcsb0JBQW9CLEdBQUcsRUFBRSxHQUFHLHFCQUFxQixHQUFHLEVBQUUsR0FBRyxvQkFBb0IsR0FBRyxFQUFFLEdBQUcsb0JBQW9CLEdBQUcsRUFBRSxHQUFHLG1CQUFtQixHQUFHLEVBQUUsR0FBRyxxQkFBcUIsR0FBRyxFQUFFLEdBQUcsWUFBWSxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLHNCQUFzQixFQUFFLHFCQUFxQixFQUFFLHVCQUF1QixFQUFFLDBCQUEwQixFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLG1CQUFtQixFQUFFLHFCQUFxQixFQUFFLDRCQUE0QixFQUFFLDhCQUE4QixFQUFFLDZCQUE2QixFQUFFLDJDQUEyQyxFQUFFLDRCQUE0QixFQUFFLHNCQUFzQixFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLHVCQUF1QixFQUFFLG1CQUFtQixFQUFFLHlCQUF5QixFQUFFLGdCQUFnQixFQUFFLGtCQUFrQixFQUFFLHVCQUF1QixFQUFFLHFCQUFxQixFQUFFLHdCQUF3QixFQUFFLHNCQUFzQixFQUFFLDhCQUE4QixFQUFFLHNCQUFzQixFQUFFLHdCQUF3QixFQUFFLGtCQUFrQixFQUFFO0FBQ3p4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1Q0FBdUMsRUFBRSxHQUFHLEVBQUU7QUFDOUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztB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QztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVKQUF1Six3Q0FBd0MsRUFBRSx3Q0FBd0M7QUFDek87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCxrQkFBa0IsbUNBQW1DLGlCQUFpQjtBQUN4TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVLEVBQUUsS0FBSztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QixJQUFJLElBQUksaUJBQWlCLGdDQUFnQyxNQUFNLGdDQUFnQztBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxRQUFRLHdOQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCLFFB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QTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNLHFCQUFxQjtXQUMzQjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7O1dBRUE7V0FDQTtXQUNBOzs7OztVRXJGQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvY3JlYXRlUG9wcGVyLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNMYXlvdXRWaWV3cG9ydC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2luZGV4LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL29mZnNldC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci1saXRlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9leHBhbmRUb0hhc2hNYXAuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy91bmlxdWVCeS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3VzZXJBZ2VudC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvYWNjb3JkaW9uL2luZGV4LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvYWNjb3JkaW9uL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2FjY29yZGlvbi90eXBlcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2Nhcm91c2VsL2luZGV4LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvY2Fyb3VzZWwvaW50ZXJmYWNlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvY2Fyb3VzZWwvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9jb2xsYXBzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2NvbGxhcHNlL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2NvbGxhcHNlL3R5cGVzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvZGlhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2RpYWwvaW50ZXJmYWNlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvZGlhbC90eXBlcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2Rpc21pc3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kaXNtaXNzL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2Rpc21pc3MvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kcmF3ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kcmF3ZXIvaW50ZXJmYWNlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvZHJhd2VyL3R5cGVzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvZHJvcGRvd24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kcm9wZG93bi9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kcm9wZG93bi90eXBlcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2luZGV4LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvbW9kYWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9tb2RhbC9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9tb2RhbC90eXBlcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL3BvcG92ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9wb3BvdmVyL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL3BvcG92ZXIvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy90YWJzL2luZGV4LmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvdGFicy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy90YWJzL3R5cGVzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvdG9vbHRpcC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL3Rvb2x0aXAvaW50ZXJmYWNlLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvdG9vbHRpcC90eXBlcy5qcyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9kb20vZXZlbnRzLmpzIiwid2VicGFjazovL3N0YXRpYy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2luZGV4LmpzIiwid2VicGFjazovL3N0YXRpYy8uL3NyYy9pbmJvdW5kX29yZGVyL2FkZC50cyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9zcmMvaW5ib3VuZF9vcmRlci9lZGl0LnRzIiwid2VicGFjazovL3N0YXRpYy8uL3NyYy9pbmJvdW5kX29yZGVyL2luYm91bmRfb3JkZXIudHMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vc3JjL2luYm91bmRfb3JkZXIvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vc3RhdGljLy4vc3JjL2luYm91bmRfb3JkZXIvdmlldy50cyIsIndlYnBhY2s6Ly9zdGF0aWMvLi9ub2RlX21vZHVsZXMvdHctZWxlbWVudHMvZGlzdC9qcy90dy1lbGVtZW50cy5lcy5taW4uanMiLCJ3ZWJwYWNrOi8vc3RhdGljL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3N0YXRpYy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vc3RhdGljL3dlYnBhY2svcnVudGltZS9lbnN1cmUgY2h1bmsiLCJ3ZWJwYWNrOi8vc3RhdGljL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9zdGF0aWMvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9zdGF0aWMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9zdGF0aWMvd2VicGFjay9ydW50aW1lL2xvYWQgc2NyaXB0Iiwid2VicGFjazovL3N0YXRpYy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3N0YXRpYy93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9zdGF0aWMvd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vc3RhdGljL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vc3RhdGljL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9zdGF0aWMvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcIi4vdXRpbHMvZGVib3VuY2UuanNcIjtcbmltcG9ydCB2YWxpZGF0ZU1vZGlmaWVycyBmcm9tIFwiLi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IHVuaXF1ZUJ5IGZyb20gXCIuL3V0aWxzL3VuaXF1ZUJ5LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi9lbnVtcy5qc1wiO1xudmFyIElOVkFMSURfRUxFTUVOVF9FUlJPUiA9ICdQb3BwZXI6IEludmFsaWQgcmVmZXJlbmNlIG9yIHBvcHBlciBhcmd1bWVudCBwcm92aWRlZC4gVGhleSBtdXN0IGJlIGVpdGhlciBhIERPTSBlbGVtZW50IG9yIHZpcnR1YWwgZWxlbWVudC4nO1xudmFyIElORklOSVRFX0xPT1BfRVJST1IgPSAnUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC4nO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pOyAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbW9kaWZpZXJzIHNvIHRoYXQgdGhlIGNvbnN1bWVyIHdpbGwgZ2V0IHdhcm5lZFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSB1bmlxdWVCeShbXS5jb25jYXQob3JkZXJlZE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpO1xuXG4gICAgICAgICAgaWYgKGdldEJhc2VQbGFjZW1lbnQoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICAgICAgICB2YXIgZmxpcE1vZGlmaWVyID0gc3RhdGUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSAnZmxpcCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmbGlwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsICdwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuJ10uam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBvcHBlciksXG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCxcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luTGVmdDsgLy8gV2Ugbm8gbG9uZ2VyIHRha2UgaW50byBhY2NvdW50IGBtYXJnaW5zYCBvbiB0aGUgcG9wcGVyLCBhbmQgaXQgY2FuXG4gICAgICAgICAgLy8gY2F1c2UgYnVncyB3aXRoIHBvc2l0aW9uaW5nLCBzbyB3ZSdsbCB3YXJuIHRoZSBjb25zdW1lclxuXG5cbiAgICAgICAgICBpZiAoW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZShmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXJnaW4pO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgJ2JldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LicsICdUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzJywgJ3RoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgJywgJ21vZGlmaWVycy4nXS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChfX2RlYnVnX2xvb3BzX18gPiAxMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgICAgICBfcmVmMyRvcHRpb25zID0gX3JlZjMub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmMyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuZXhwb3J0IHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgZGV0ZWN0T3ZlcmZsb3cgfTsiLCJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsImltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldE5vZGVTY3JvbGwgZnJvbSBcIi4vZ2V0Tm9kZVNjcm9sbC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQsIGlzRml4ZWQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iLCJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufSIsImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFVBU3RyaW5nIGZyb20gXCIuLi91dGlscy91c2VyQWdlbnQuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn0iLCJpbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSBcIi4vaXNMYXlvdXRWaWV3cG9ydC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyIsImltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59IiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsImV4cG9ydCB2YXIgdG9wID0gJ3RvcCc7XG5leHBvcnQgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuZXhwb3J0IHZhciByaWdodCA9ICdyaWdodCc7XG5leHBvcnQgdmFyIGxlZnQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIGF1dG8gPSAnYXV0byc7XG5leHBvcnQgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5leHBvcnQgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbmV4cG9ydCB2YXIgZW5kID0gJ2VuZCc7XG5leHBvcnQgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuZXhwb3J0IHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbmV4cG9ydCB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCB2YXIgcmVhZCA9ICdyZWFkJztcbmV4cG9ydCB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbmV4cG9ydCB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCB2YXIgbWFpbiA9ICdtYWluJztcbmV4cG9ydCB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuZXhwb3J0IHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgdmFyIHdyaXRlID0gJ3dyaXRlJztcbmV4cG9ydCB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gVGhpcyBtb2RpZmllciB0YWtlcyB0aGUgc3R5bGVzIHByZXBhcmVkIGJ5IHRoZSBgY29tcHV0ZVN0eWxlc2AgbW9kaWZpZXJcbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcbiAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6ICcwJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgbWFyZ2luOiAnMCdcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cblxuICAgICAgdmFyIHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59OyIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi4vZG9tLXV0aWxzL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHdpdGhpbiB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXCI7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogcGFkZGluZztcbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XG5cbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCAnVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcycsICd0aGUgYXJyb3cuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBtb2RpZmllclxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgJ2VsZW1lbnQuJ10uam9pbignICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGFycm93LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59OyIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYsIHdpbikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9LCBnZXRXaW5kb3cocG9wcGVyKSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gZ2V0Q29tcHV0ZWRTdHlsZShzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCAnJztcblxuICAgIGlmIChhZGFwdGl2ZSAmJiBbJ3RyYW5zZm9ybScsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5zb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25Qcm9wZXJ0eS5pbmRleE9mKHByb3BlcnR5KSA+PSAwO1xuICAgIH0pKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZycsICdDU1MgcHJvcGVydGllczogXCJ0cmFuc2Zvcm1cIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIi4nLCAnXFxuXFxuJywgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsICdmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1MnLCAndHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nJywgJ29wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS4nLCAnXFxuXFxuJywgJ1dlIHJlY29tbWVuZCB1c2luZyB0aGUgcG9wcGVyIGVsZW1lbnQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBpbm5lcicsICdlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0LFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgYm90dG9tLCB0b3AsIHN0YXJ0LCByaWdodCwgbGVmdCwgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7XG4gICAgX3NraXA6IGZhbHNlXG4gIH1cbn07IiwiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIGFwcGx5U3R5bGVzIH0gZnJvbSBcIi4vYXBwbHlTdHlsZXMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXJyb3cgfSBmcm9tIFwiLi9hcnJvdy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb21wdXRlU3R5bGVzIH0gZnJvbSBcIi4vY29tcHV0ZVN0eWxlcy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBldmVudExpc3RlbmVycyB9IGZyb20gXCIuL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZsaXAgfSBmcm9tIFwiLi9mbGlwLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGhpZGUgfSBmcm9tIFwiLi9oaWRlLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG9mZnNldCB9IGZyb20gXCIuL29mZnNldC5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwb3BwZXJPZmZzZXRzIH0gZnJvbSBcIi4vcG9wcGVyT2Zmc2V0cy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcmV2ZW50T3ZlcmZsb3cgfSBmcm9tIFwiLi9wcmV2ZW50T3ZlcmZsb3cuanNcIjsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59OyIsImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gXCIuLi91dGlscy9nZXRBbHRBeGlzLmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4sIHdpdGhpbk1heENsYW1wIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4uL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuaW1wb3J0IHsgbWluIGFzIG1hdGhNaW4sIG1heCBhcyBtYXRoTWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcbiAgICBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZVxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkO1xuXG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCA9IG9mZnNldCAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICB2YXIgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW21haW5BeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJCA6IDA7XG4gICAgdmFyIHRldGhlck1pbiA9IG9mZnNldCArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IG9mZnNldCArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG4gICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heCk7XG4gICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDI7XG5cbiAgICB2YXIgX21haW5TaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IHRvcCA6IGxlZnQ7XG5cbiAgICB2YXIgX2FsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICB2YXIgX2xlbiA9IGFsdEF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHZhciBfbWluID0gX29mZnNldCArIG92ZXJmbG93W19tYWluU2lkZV07XG5cbiAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICB2YXIgaXNPcmlnaW5TaWRlID0gW3RvcCwgbGVmdF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICB2YXIgX29mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkMiA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbYWx0QXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIDogMDtcblxuICAgIHZhciBfdGV0aGVyTWluID0gaXNPcmlnaW5TaWRlID8gX21pbiA6IF9vZmZzZXQgLSByZWZlcmVuY2VSZWN0W19sZW5dIC0gcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXM7XG5cbiAgICB2YXIgX3RldGhlck1heCA9IGlzT3JpZ2luU2lkZSA/IF9vZmZzZXQgKyByZWZlcmVuY2VSZWN0W19sZW5dICsgcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXMgOiBfbWF4O1xuXG4gICAgdmFyIF9wcmV2ZW50ZWRPZmZzZXQgPSB0ZXRoZXIgJiYgaXNPcmlnaW5TaWRlID8gd2l0aGluTWF4Q2xhbXAoX3RldGhlck1pbiwgX29mZnNldCwgX3RldGhlck1heCkgOiB3aXRoaW4odGV0aGVyID8gX3RldGhlck1pbiA6IF9taW4sIF9vZmZzZXQsIHRldGhlciA/IF90ZXRoZXJNYXggOiBfbWF4KTtcblxuICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlc107XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyIsImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tIFwiLi9jcmVhdGVQb3BwZXIuanNcIjtcbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tIFwiLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gXCIuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXCI7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiO1xuaW1wb3J0IG9mZnNldCBmcm9tIFwiLi9tb2RpZmllcnMvb2Zmc2V0LmpzXCI7XG5pbXBvcnQgZmxpcCBmcm9tIFwiLi9tb2RpZmllcnMvZmxpcC5qc1wiO1xuaW1wb3J0IHByZXZlbnRPdmVyZmxvdyBmcm9tIFwiLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgYXJyb3cgZnJvbSBcIi4vbW9kaWZpZXJzL2Fycm93LmpzXCI7XG5pbXBvcnQgaGlkZSBmcm9tIFwiLi9tb2RpZmllcnMvaGlkZS5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzLCBvZmZzZXQsIGZsaXAsIHByZXZlbnRPdmVyZmxvdywgYXJyb3csIGhpZGVdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIgYXMgY3JlYXRlUG9wcGVyTGl0ZSB9IGZyb20gXCIuL3BvcHBlci1saXRlLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0ICogZnJvbSBcIi4vbW9kaWZpZXJzL2luZGV4LmpzXCI7IiwiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnknLCAncGxhY2VtZW50cy4gRW5zdXJlIHRoZSBgcGxhY2VtZW50YCBvcHRpb24gbWF0Y2hlcyB0aGUgdmFyaWF0aW9uJywgJ29mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuJywgJ0ZvciBleGFtcGxlLCBcImF1dG9cIiBjYW5ub3QgYmUgdXNlZCB0byBhbGxvdyBcImJvdHRvbS1zdGFydFwiLicsICdVc2UgXCJhdXRvLXN0YXJ0XCIgaW5zdGVhZC4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsImltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBzdHJhdGVneSA9IF9vcHRpb25zJHN0cmF0ZWd5ID09PSB2b2lkIDAgPyBzdGF0ZS5zdHJhdGVneSA6IF9vcHRpb25zJHN0cmF0ZWd5LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gaGFzaE1hcDtcbiAgfSwge30pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdChzdHIpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIFtdLmNvbmNhdChhcmdzKS5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHtcbiAgICByZXR1cm4gcC5yZXBsYWNlKC8lcy8sIGMpO1xuICB9LCBzdHIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsImltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59IiwidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwidmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufSIsImV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59IiwiaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuaXF1ZUJ5KGFyciwgZm4pIHtcbiAgdmFyIGlkZW50aWZpZXJzID0gbmV3IFNldCgpO1xuICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpZGVudGlmaWVyID0gZm4oaXRlbSk7XG5cbiAgICBpZiAoIWlkZW50aWZpZXJzLmhhcyhpZGVudGlmaWVyKSkge1xuICAgICAgaWRlbnRpZmllcnMuYWRkKGlkZW50aWZpZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVQVN0cmluZygpIHtcbiAgdmFyIHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuXG4gIGlmICh1YURhdGEgIT0gbnVsbCAmJiB1YURhdGEuYnJhbmRzICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmJyYW5kICsgXCIvXCIgKyBpdGVtLnZlcnNpb247XG4gICAgfSkuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59IiwiaW1wb3J0IGZvcm1hdCBmcm9tIFwiLi9mb3JtYXQuanNcIjtcbmltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG52YXIgSU5WQUxJRF9NT0RJRklFUl9FUlJPUiA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiBwcm92aWRlZCBhbiBpbnZhbGlkICVzIHByb3BlcnR5LCBleHBlY3RlZCAlcyBidXQgZ290ICVzJztcbnZhciBNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcmVxdWlyZXMgXCIlc1wiLCBidXQgXCIlc1wiIG1vZGlmaWVyIGlzIG5vdCBhdmFpbGFibGUnO1xudmFyIFZBTElEX1BST1BFUlRJRVMgPSBbJ25hbWUnLCAnZW5hYmxlZCcsICdwaGFzZScsICdmbicsICdlZmZlY3QnLCAncmVxdWlyZXMnLCAnb3B0aW9ucyddO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIFtdLmNvbmNhdChPYmplY3Qua2V5cyhtb2RpZmllciksIFZBTElEX1BST1BFUlRJRVMpIC8vIElFMTEtY29tcGF0aWJsZSByZXBsYWNlbWVudCBmb3IgYG5ldyBTZXQoaXRlcmFibGUpYFxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4O1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgU3RyaW5nKG1vZGlmaWVyLm5hbWUpLCAnXCJuYW1lXCInLCAnXCJzdHJpbmdcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLm5hbWUpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlbmFibGVkJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmVuYWJsZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZW5hYmxlZFwiJywgJ1wiYm9vbGVhblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZW5hYmxlZCkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BoYXNlJzpcbiAgICAgICAgICBpZiAobW9kaWZpZXJQaGFzZXMuaW5kZXhPZihtb2RpZmllci5waGFzZSkgPCAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJwaGFzZVwiJywgXCJlaXRoZXIgXCIgKyBtb2RpZmllclBoYXNlcy5qb2luKCcsICcpLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5waGFzZSkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2ZuJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJmblwiJywgJ1wiZnVuY3Rpb25cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmZuKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZWZmZWN0JzpcbiAgICAgICAgICBpZiAobW9kaWZpZXIuZWZmZWN0ICE9IG51bGwgJiYgdHlwZW9mIG1vZGlmaWVyLmVmZmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZWZmZWN0XCInLCAnXCJmdW5jdGlvblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZm4pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZXF1aXJlcyc6XG4gICAgICAgICAgaWYgKG1vZGlmaWVyLnJlcXVpcmVzICE9IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJyZXF1aXJlc1wiJywgJ1wiYXJyYXlcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmVxdWlyZXNJZkV4aXN0cyc6XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJyZXF1aXJlc0lmRXhpc3RzXCInLCAnXCJhcnJheVwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cykgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ29wdGlvbnMnOlxuICAgICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQb3BwZXJKUzogYW4gaW52YWxpZCBwcm9wZXJ0eSBoYXMgYmVlbiBwcm92aWRlZCB0byB0aGUgXFxcIlwiICsgbW9kaWZpZXIubmFtZSArIFwiXFxcIiBtb2RpZmllciwgdmFsaWQgcHJvcGVydGllcyBhcmUgXCIgKyBWQUxJRF9QUk9QRVJUSUVTLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcIlwiICsgcyArIFwiXFxcIlwiO1xuICAgICAgICAgIH0pLmpvaW4oJywgJykgKyBcIjsgYnV0IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgcHJvdmlkZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICBtb2RpZmllci5yZXF1aXJlcyAmJiBtb2RpZmllci5yZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1aXJlbWVudCkge1xuICAgICAgICBpZiAobW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgIHJldHVybiBtb2QubmFtZSA9PT0gcmVxdWlyZW1lbnQ7XG4gICAgICAgIH0pID09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IsIFN0cmluZyhtb2RpZmllci5uYW1lKSwgcmVxdWlyZW1lbnQsIHJlcXVpcmVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0iLCJpbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gbWF0aE1heChtaW4sIG1hdGhNaW4odmFsdWUsIG1heCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59IiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBEZWZhdWx0ID0ge1xuICAgIGFsd2F5c09wZW46IGZhbHNlLFxuICAgIGFjdGl2ZUNsYXNzZXM6ICdiZy1ncmF5LTEwMCBkYXJrOmJnLWdyYXktODAwIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlJyxcbiAgICBpbmFjdGl2ZUNsYXNzZXM6ICd0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC1ncmF5LTQwMCcsXG4gICAgb25PcGVuOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25DbG9zZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uVG9nZ2xlOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIEFjY29yZGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBY2NvcmRpb24oaXRlbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSBbXTsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIEFjY29yZGlvbi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNob3cgYWNjb3JkaW9uIGl0ZW0gYmFzZWQgb24gY2xpY2tcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcGVuKGl0ZW0uaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtLnRyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKGl0ZW0uaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFjY29yZGlvbi5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmlkID09PSBpZDsgfSlbMF07XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpO1xuICAgICAgICAvLyBkb24ndCBoaWRlIG90aGVyIGFjY29yZGlvbnMgaWYgYWx3YXlzIG9wZW5cbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmFsd2F5c09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gaS50cmlnZ2VyRWwuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2EsIF90aGlzLl9vcHRpb25zLmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IGkudHJpZ2dlckVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9iLCBfdGhpcy5fb3B0aW9ucy5pbmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICAgICAgICAgIGkudGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgIGkudHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgICAgICAgICAgICAgICBpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyByb3RhdGUgaWNvbiBpZiBzZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkuaWNvbkVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLmljb25FbC5jbGFzc0xpc3QucmVtb3ZlKCdyb3RhdGUtMTgwJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaG93IGFjdGl2ZSBpdGVtXG4gICAgICAgIChfYSA9IGl0ZW0udHJpZ2dlckVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9hLCB0aGlzLl9vcHRpb25zLmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgIChfYiA9IGl0ZW0udHJpZ2dlckVsLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9iLCB0aGlzLl9vcHRpb25zLmluYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgaXRlbS50cmlnZ2VyRWwuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICAgICAgaXRlbS50YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgaXRlbS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAvLyByb3RhdGUgaWNvbiBpZiBzZXRcbiAgICAgICAgaWYgKGl0ZW0uaWNvbkVsKSB7XG4gICAgICAgICAgICBpdGVtLmljb25FbC5jbGFzc0xpc3QuYWRkKCdyb3RhdGUtMTgwJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbk9wZW4odGhpcywgaXRlbSk7XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShpZCk7XG4gICAgICAgIGlmIChpdGVtLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oaWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25Ub2dnbGUodGhpcywgaXRlbSk7XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKGlkKTtcbiAgICAgICAgKF9hID0gaXRlbS50cmlnZ2VyRWwuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2EsIHRoaXMuX29wdGlvbnMuYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgKF9iID0gaXRlbS50cmlnZ2VyRWwuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2IsIHRoaXMuX29wdGlvbnMuaW5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICBpdGVtLnRhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICBpdGVtLnRyaWdnZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgaXRlbS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLy8gcm90YXRlIGljb24gaWYgc2V0XG4gICAgICAgIGlmIChpdGVtLmljb25FbCkge1xuICAgICAgICAgICAgaXRlbS5pY29uRWwuY2xhc3NMaXN0LnJlbW92ZSgncm90YXRlLTE4MCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25DbG9zZSh0aGlzLCBpdGVtKTtcbiAgICB9O1xuICAgIHJldHVybiBBY2NvcmRpb247XG59KCkpO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LkFjY29yZGlvbiA9IEFjY29yZGlvbjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbml0QWNjb3JkaW9ucygpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1hY2NvcmRpb25dJykuZm9yRWFjaChmdW5jdGlvbiAoJGFjY29yZGlvbkVsKSB7XG4gICAgICAgIHZhciBhbHdheXNPcGVuID0gJGFjY29yZGlvbkVsLmdldEF0dHJpYnV0ZSgnZGF0YS1hY2NvcmRpb24nKTtcbiAgICAgICAgdmFyIGFjdGl2ZUNsYXNzZXMgPSAkYWNjb3JkaW9uRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWFjdGl2ZS1jbGFzc2VzJyk7XG4gICAgICAgIHZhciBpbmFjdGl2ZUNsYXNzZXMgPSAkYWNjb3JkaW9uRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWluYWN0aXZlLWNsYXNzZXMnKTtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgICRhY2NvcmRpb25FbFxuICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWFjY29yZGlvbi10YXJnZXRdJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICBpZDogJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWNjb3JkaW9uLXRhcmdldCcpLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJFbDogJHRyaWdnZXJFbCxcbiAgICAgICAgICAgICAgICB0YXJnZXRFbDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcigkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1hY2NvcmRpb24tdGFyZ2V0JykpLFxuICAgICAgICAgICAgICAgIGljb25FbDogJHRyaWdnZXJFbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hY2NvcmRpb24taWNvbl0nKSxcbiAgICAgICAgICAgICAgICBhY3RpdmU6ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJykgPT09ICd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbmV3IEFjY29yZGlvbihpdGVtcywge1xuICAgICAgICAgICAgYWx3YXlzT3BlbjogYWx3YXlzT3BlbiA9PT0gJ29wZW4nID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgYWN0aXZlQ2xhc3NlczogYWN0aXZlQ2xhc3Nlc1xuICAgICAgICAgICAgICAgID8gYWN0aXZlQ2xhc3Nlc1xuICAgICAgICAgICAgICAgIDogRGVmYXVsdC5hY3RpdmVDbGFzc2VzLFxuICAgICAgICAgICAgaW5hY3RpdmVDbGFzc2VzOiBpbmFjdGl2ZUNsYXNzZXNcbiAgICAgICAgICAgICAgICA/IGluYWN0aXZlQ2xhc3Nlc1xuICAgICAgICAgICAgICAgIDogRGVmYXVsdC5pbmFjdGl2ZUNsYXNzZXMsXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgQWNjb3JkaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgRGVmYXVsdCA9IHtcbiAgICBkZWZhdWx0UG9zaXRpb246IDAsXG4gICAgaW5kaWNhdG9yczoge1xuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGFjdGl2ZUNsYXNzZXM6ICdiZy13aGl0ZSBkYXJrOmJnLWdyYXktODAwJyxcbiAgICAgICAgaW5hY3RpdmVDbGFzc2VzOiAnYmctd2hpdGUvNTAgZGFyazpiZy1ncmF5LTgwMC81MCBob3ZlcjpiZy13aGl0ZSBkYXJrOmhvdmVyOmJnLWdyYXktODAwJyxcbiAgICB9LFxuICAgIGludGVydmFsOiAzMDAwLFxuICAgIG9uTmV4dDogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uUHJldjogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIENhcm91c2VsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhcm91c2VsKGl0ZW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChpdGVtcyA9PT0gdm9pZCAwKSB7IGl0ZW1zID0gW107IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKSwgeyBpbmRpY2F0b3JzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdC5pbmRpY2F0b3JzKSwgb3B0aW9ucy5pbmRpY2F0b3JzKSB9KTtcbiAgICAgICAgdGhpcy5fYWN0aXZlSXRlbSA9IHRoaXMuZ2V0SXRlbSh0aGlzLl9vcHRpb25zLmRlZmF1bHRQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2luZGljYXRvcnMgPSB0aGlzLl9vcHRpb25zLmluZGljYXRvcnMuaXRlbXM7XG4gICAgICAgIHRoaXMuX2ludGVydmFsRHVyYXRpb24gPSB0aGlzLl9vcHRpb25zLmludGVydmFsO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplIGNhcm91c2VsIGFuZCBpdGVtcyBiYXNlZCBvbiBhY3RpdmUgb25lXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9pdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0uZWwuY2xhc3NMaXN0LmFkZCgnYWJzb2x1dGUnLCAnaW5zZXQtMCcsICd0cmFuc2l0aW9uLXRyYW5zZm9ybScsICd0cmFuc2Zvcm0nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIG5vIGFjdGl2ZSBpdGVtIGlzIHNldCB0aGVuIGZpcnN0IHBvc2l0aW9uIGlzIGRlZmF1bHRcbiAgICAgICAgaWYgKHRoaXMuX2dldEFjdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgdGhpcy5zbGlkZVRvKHRoaXMuX2dldEFjdGl2ZUl0ZW0oKS5wb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNsaWRlVG8oMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5kaWNhdG9ycy5tYXAoZnVuY3Rpb24gKGluZGljYXRvciwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGluZGljYXRvci5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zbGlkZVRvKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1twb3NpdGlvbl07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTbGlkZSB0byB0aGUgZWxlbWVudCBiYXNlZCBvbiBpZFxuICAgICAqIEBwYXJhbSB7Kn0gcG9zaXRpb25cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuc2xpZGVUbyA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgbmV4dEl0ZW0gPSB0aGlzLl9pdGVtc1twb3NpdGlvbl07XG4gICAgICAgIHZhciByb3RhdGlvbkl0ZW1zID0ge1xuICAgICAgICAgICAgbGVmdDogbmV4dEl0ZW0ucG9zaXRpb24gPT09IDBcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9pdGVtc1tuZXh0SXRlbS5wb3NpdGlvbiAtIDFdLFxuICAgICAgICAgICAgbWlkZGxlOiBuZXh0SXRlbSxcbiAgICAgICAgICAgIHJpZ2h0OiBuZXh0SXRlbS5wb3NpdGlvbiA9PT0gdGhpcy5faXRlbXMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgID8gdGhpcy5faXRlbXNbMF1cbiAgICAgICAgICAgICAgICA6IHRoaXMuX2l0ZW1zW25leHRJdGVtLnBvc2l0aW9uICsgMV0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3JvdGF0ZShyb3RhdGlvbkl0ZW1zKTtcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlSXRlbShuZXh0SXRlbSk7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcnZhbEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkNoYW5nZSh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIHRoZSBjdXJyZW50bHkgYWN0aXZlIGl0ZW0gaXQgd2lsbCBnbyB0byB0aGUgbmV4dCBwb3NpdGlvblxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aXZlSXRlbSA9IHRoaXMuX2dldEFjdGl2ZUl0ZW0oKTtcbiAgICAgICAgdmFyIG5leHRJdGVtID0gbnVsbDtcbiAgICAgICAgLy8gY2hlY2sgaWYgbGFzdCBpdGVtXG4gICAgICAgIGlmIChhY3RpdmVJdGVtLnBvc2l0aW9uID09PSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBuZXh0SXRlbSA9IHRoaXMuX2l0ZW1zWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV4dEl0ZW0gPSB0aGlzLl9pdGVtc1thY3RpdmVJdGVtLnBvc2l0aW9uICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zbGlkZVRvKG5leHRJdGVtLnBvc2l0aW9uKTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbk5leHQodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtIGl0IHdpbGwgZ28gdG8gdGhlIHByZXZpb3VzIHBvc2l0aW9uXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3RpdmVJdGVtID0gdGhpcy5fZ2V0QWN0aXZlSXRlbSgpO1xuICAgICAgICB2YXIgcHJldkl0ZW0gPSBudWxsO1xuICAgICAgICAvLyBjaGVjayBpZiBmaXJzdCBpdGVtXG4gICAgICAgIGlmIChhY3RpdmVJdGVtLnBvc2l0aW9uID09PSAwKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldkl0ZW0gPSB0aGlzLl9pdGVtc1thY3RpdmVJdGVtLnBvc2l0aW9uIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zbGlkZVRvKHByZXZJdGVtLnBvc2l0aW9uKTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblByZXYodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBhcHBsaWVzIHRoZSB0cmFuc2Zvcm0gY2xhc3NlcyBiYXNlZCBvbiB0aGUgbGVmdCwgbWlkZGxlLCBhbmQgcmlnaHQgcm90YXRpb24gY2Fyb3VzZWwgaXRlbXNcbiAgICAgKiBAcGFyYW0geyp9IHJvdGF0aW9uSXRlbXNcbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3JvdGF0ZSA9IGZ1bmN0aW9uIChyb3RhdGlvbkl0ZW1zKSB7XG4gICAgICAgIC8vIHJlc2V0XG4gICAgICAgIHRoaXMuX2l0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS5lbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGxlZnQgaXRlbSAocHJldmlvdXNseSBhY3RpdmUpXG4gICAgICAgIHJvdGF0aW9uSXRlbXMubGVmdC5lbC5jbGFzc0xpc3QucmVtb3ZlKCctdHJhbnNsYXRlLXgtZnVsbCcsICd0cmFuc2xhdGUteC1mdWxsJywgJ3RyYW5zbGF0ZS14LTAnLCAnaGlkZGVuJywgJ3otMjAnKTtcbiAgICAgICAgcm90YXRpb25JdGVtcy5sZWZ0LmVsLmNsYXNzTGlzdC5hZGQoJy10cmFuc2xhdGUteC1mdWxsJywgJ3otMTAnKTtcbiAgICAgICAgLy8gY3VycmVudGx5IGFjdGl2ZSBpdGVtXG4gICAgICAgIHJvdGF0aW9uSXRlbXMubWlkZGxlLmVsLmNsYXNzTGlzdC5yZW1vdmUoJy10cmFuc2xhdGUteC1mdWxsJywgJ3RyYW5zbGF0ZS14LWZ1bGwnLCAndHJhbnNsYXRlLXgtMCcsICdoaWRkZW4nLCAnei0xMCcpO1xuICAgICAgICByb3RhdGlvbkl0ZW1zLm1pZGRsZS5lbC5jbGFzc0xpc3QuYWRkKCd0cmFuc2xhdGUteC0wJywgJ3otMjAnKTtcbiAgICAgICAgLy8gcmlnaHQgaXRlbSAodXBjb21pbmcgYWN0aXZlKVxuICAgICAgICByb3RhdGlvbkl0ZW1zLnJpZ2h0LmVsLmNsYXNzTGlzdC5yZW1vdmUoJy10cmFuc2xhdGUteC1mdWxsJywgJ3RyYW5zbGF0ZS14LWZ1bGwnLCAndHJhbnNsYXRlLXgtMCcsICdoaWRkZW4nLCAnei0yMCcpO1xuICAgICAgICByb3RhdGlvbkl0ZW1zLnJpZ2h0LmVsLmNsYXNzTGlzdC5hZGQoJ3RyYW5zbGF0ZS14LWZ1bGwnLCAnei0xMCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGFuIGludGVydmFsIHRvIGN5Y2xlIHRocm91Z2ggdGhlIGNhcm91c2VsIGl0ZW1zXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLmN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVydmFsSW5zdGFuY2UgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH0sIHRoaXMuX2ludGVydmFsRHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGN5Y2xpbmcgaW50ZXJ2YWxcbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJbnN0YW5jZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgaXRlbVxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fZ2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUl0ZW07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgaXRlbSBhbmQgZGF0YSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0geyp9IHBvc2l0aW9uXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9zZXRBY3RpdmVJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYWN0aXZlSXRlbSA9IGl0ZW07XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb247XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgaW5kaWNhdG9ycyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKHRoaXMuX2luZGljYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmRpY2F0b3JzLm1hcChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3IuZWwuc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgICAgICAoX2EgPSBpbmRpY2F0b3IuZWwuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2EsIF90aGlzLl9vcHRpb25zLmluZGljYXRvcnMuYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgICAgICAgICAoX2IgPSBpbmRpY2F0b3IuZWwuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2IsIF90aGlzLl9vcHRpb25zLmluZGljYXRvcnMuaW5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9pbmRpY2F0b3JzW3Bvc2l0aW9uXS5lbC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYSwgdGhpcy5fb3B0aW9ucy5pbmRpY2F0b3JzLmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLl9pbmRpY2F0b3JzW3Bvc2l0aW9uXS5lbC5jbGFzc0xpc3QpLnJlbW92ZS5hcHBseShfYiwgdGhpcy5fb3B0aW9ucy5pbmRpY2F0b3JzLmluYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgICAgIHRoaXMuX2luZGljYXRvcnNbcG9zaXRpb25dLmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50JywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhcm91c2VsO1xufSgpKTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5DYXJvdXNlbCA9IENhcm91c2VsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluaXRDYXJvdXNlbHMoKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY2Fyb3VzZWxdJykuZm9yRWFjaChmdW5jdGlvbiAoJGNhcm91c2VsRWwpIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gJGNhcm91c2VsRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNhcm91c2VsLWludGVydmFsJyk7XG4gICAgICAgIHZhciBzbGlkZSA9ICRjYXJvdXNlbEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jYXJvdXNlbCcpID09PSAnc2xpZGUnXG4gICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICB2YXIgZGVmYXVsdFBvc2l0aW9uID0gMDtcbiAgICAgICAgaWYgKCRjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsLWl0ZW1dJykubGVuZ3RoKSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKCRjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsLWl0ZW1dJykpLm1hcChmdW5jdGlvbiAoJGNhcm91c2VsSXRlbUVsLCBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGVsOiAkY2Fyb3VzZWxJdGVtRWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCRjYXJvdXNlbEl0ZW1FbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2Fyb3VzZWwtaXRlbScpID09PVxuICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJykge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kaWNhdG9ycyA9IFtdO1xuICAgICAgICBpZiAoJGNhcm91c2VsRWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY2Fyb3VzZWwtc2xpZGUtdG9dJykubGVuZ3RoKSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKCRjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsLXNsaWRlLXRvXScpKS5tYXAoZnVuY3Rpb24gKCRpbmRpY2F0b3JFbCkge1xuICAgICAgICAgICAgICAgIGluZGljYXRvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwYXJzZUludCgkaW5kaWNhdG9yRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNhcm91c2VsLXNsaWRlLXRvJykpLFxuICAgICAgICAgICAgICAgICAgICBlbDogJGluZGljYXRvckVsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhcm91c2VsID0gbmV3IENhcm91c2VsKGl0ZW1zLCB7XG4gICAgICAgICAgICBkZWZhdWx0UG9zaXRpb246IGRlZmF1bHRQb3NpdGlvbixcbiAgICAgICAgICAgIGluZGljYXRvcnM6IHtcbiAgICAgICAgICAgICAgICBpdGVtczogaW5kaWNhdG9ycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnRlcnZhbDogaW50ZXJ2YWwgPyBpbnRlcnZhbCA6IERlZmF1bHQuaW50ZXJ2YWwsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2xpZGUpIHtcbiAgICAgICAgICAgIGNhcm91c2VsLmN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIGNvbnRyb2xzXG4gICAgICAgIHZhciBjYXJvdXNlbE5leHRFbCA9ICRjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWNhcm91c2VsLW5leHRdJyk7XG4gICAgICAgIHZhciBjYXJvdXNlbFByZXZFbCA9ICRjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWNhcm91c2VsLXByZXZdJyk7XG4gICAgICAgIGlmIChjYXJvdXNlbE5leHRFbCkge1xuICAgICAgICAgICAgY2Fyb3VzZWxOZXh0RWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2Fyb3VzZWwubmV4dCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcm91c2VsUHJldkVsKSB7XG4gICAgICAgICAgICBjYXJvdXNlbFByZXZFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYXJvdXNlbC5wcmV2KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgQ2Fyb3VzZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBEZWZhdWx0ID0ge1xuICAgIG9uQ29sbGFwc2U6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvbkV4cGFuZDogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uVG9nZ2xlOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIENvbGxhcHNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbGxhcHNlKHRhcmdldEVsLCB0cmlnZ2VyRWwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRhcmdldEVsID09PSB2b2lkIDApIHsgdGFyZ2V0RWwgPSBudWxsOyB9XG4gICAgICAgIGlmICh0cmlnZ2VyRWwgPT09IHZvaWQgMCkgeyB0cmlnZ2VyRWwgPSBudWxsOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbDtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckVsID0gdHJpZ2dlckVsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIENvbGxhcHNlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJykgPT09ICd0cnVlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZpeCB1bnRpbCB2MiBub3QgdG8gYnJlYWsgcHJldmlvdXMgc2luZ2xlIGNvbGxhcHNlcyB3aGljaCBiZWNhbWUgZGlzbWlzc1xuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSAhdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuY29sbGFwc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsKSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRWwuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uQ29sbGFwc2UodGhpcyk7XG4gICAgfTtcbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25FeHBhbmQodGhpcyk7XG4gICAgfTtcbiAgICBDb2xsYXBzZS5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uVG9nZ2xlKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbGxhcHNlO1xufSgpKTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5Db2xsYXBzZSA9IENvbGxhcHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluaXRDb2xsYXBzZXMoKSB7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNvbGxhcHNlLXRvZ2dsZV0nKVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgdGFyZ2V0SWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsYXBzZS10b2dnbGUnKTtcbiAgICAgICAgdmFyICR0YXJnZXRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldElkKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHRhcmdldCBlbGVtZW50IGV4aXN0c1xuICAgICAgICBpZiAoJHRhcmdldEVsKSB7XG4gICAgICAgICAgICBuZXcgQ29sbGFwc2UoJHRhcmdldEVsLCAkdHJpZ2dlckVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgdGFyZ2V0IGVsZW1lbnQgd2l0aCBpZCBcXFwiXCIuY29uY2F0KHRhcmdldElkLCBcIlxcXCIgZG9lcyBub3QgZXhpc3QuIFBsZWFzZSBjaGVjayB0aGUgZGF0YS1jb2xsYXBzZS10b2dnbGUgYXR0cmlidXRlLlwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IENvbGxhcHNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgRGVmYXVsdCA9IHtcbiAgICB0cmlnZ2VyVHlwZTogJ2hvdmVyJyxcbiAgICBvblNob3c6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblRvZ2dsZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBEaWFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpYWwocGFyZW50RWwsIHRyaWdnZXJFbCwgdGFyZ2V0RWwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHBhcmVudEVsID09PSB2b2lkIDApIHsgcGFyZW50RWwgPSBudWxsOyB9XG4gICAgICAgIGlmICh0cmlnZ2VyRWwgPT09IHZvaWQgMCkgeyB0cmlnZ2VyRWwgPSBudWxsOyB9XG4gICAgICAgIGlmICh0YXJnZXRFbCA9PT0gdm9pZCAwKSB7IHRhcmdldEVsID0gbnVsbDsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIHRoaXMuX3BhcmVudEVsID0gcGFyZW50RWw7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJFbCA9IHRyaWdnZXJFbDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBEZWZhdWx0KSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICBEaWFsLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJFdmVudFR5cGVzID0gdGhpcy5fZ2V0VHJpZ2dlckV2ZW50VHlwZXModGhpcy5fb3B0aW9ucy50cmlnZ2VyVHlwZSk7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRUeXBlcy5zaG93RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudFR5cGVzLmhpZGVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcGFyZW50RWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9wYXJlbnRFbC5tYXRjaGVzKCc6aG92ZXInKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlhbC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25IaWRlKHRoaXMpO1xuICAgIH07XG4gICAgRGlhbC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uU2hvdyh0aGlzKTtcbiAgICB9O1xuICAgIERpYWwucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpYWwucHJvdG90eXBlLmlzSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX3Zpc2libGU7XG4gICAgfTtcbiAgICBEaWFsLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH07XG4gICAgRGlhbC5wcm90b3R5cGUuX2dldFRyaWdnZXJFdmVudFR5cGVzID0gZnVuY3Rpb24gKHRyaWdnZXJUeXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHJpZ2dlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hvdmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ21vdXNlZW50ZXInLCAnZm9jdXMnXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogWydtb3VzZWxlYXZlJywgJ2JsdXInXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFsnY2xpY2snLCAnZm9jdXMnXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogWydmb2N1c291dCcsICdibHVyJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ21vdXNlZW50ZXInLCAnZm9jdXMnXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogWydtb3VzZWxlYXZlJywgJ2JsdXInXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlhbDtcbn0oKSk7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuRGlhbCA9IERpYWw7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5pdERpYWxzKCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWRpYWwtaW5pdF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkcGFyZW50RWwpIHtcbiAgICAgICAgdmFyICR0cmlnZ2VyRWwgPSAkcGFyZW50RWwucXVlcnlTZWxlY3RvcignW2RhdGEtZGlhbC10b2dnbGVdJyk7XG4gICAgICAgIGlmICgkdHJpZ2dlckVsKSB7XG4gICAgICAgICAgICB2YXIgZGlhbElkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlhbC10b2dnbGUnKTtcbiAgICAgICAgICAgIHZhciAkZGlhbEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGlhbElkKTtcbiAgICAgICAgICAgIGlmICgkZGlhbEVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyaWdnZXJUeXBlID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlhbC10cmlnZ2VyJyk7XG4gICAgICAgICAgICAgICAgbmV3IERpYWwoJHBhcmVudEVsLCAkdHJpZ2dlckVsLCAkZGlhbEVsLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJUeXBlOiB0cmlnZ2VyVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0cmlnZ2VyVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LnRyaWdnZXJUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRpYWwgd2l0aCBpZCBcIi5jb25jYXQoZGlhbElkLCBcIiBkb2VzIG5vdCBleGlzdC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtZGlhbC10b2dnbGUgYXR0cmlidXRlIHBvaW50cyB0byB0aGUgY29ycmVjdCBtb2RhbCBpZD9cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRpYWwgd2l0aCBpZCBcIi5jb25jYXQoJHBhcmVudEVsLmlkLCBcIiBkb2VzIG5vdCBoYXZlIGEgdHJpZ2dlciBlbGVtZW50LiBBcmUgeW91IHN1cmUgdGhhdCB0aGUgZGF0YS1kaWFsLXRvZ2dsZSBhdHRyaWJ1dGUgZXhpc3RzP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IERpYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBEZWZhdWx0ID0ge1xuICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uLW9wYWNpdHknLFxuICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgdGltaW5nOiAnZWFzZS1vdXQnLFxuICAgIG9uSGlkZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBEaXNtaXNzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpc21pc3ModGFyZ2V0RWwsIHRyaWdnZXJFbCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGFyZ2V0RWwgPT09IHZvaWQgMCkgeyB0YXJnZXRFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRyaWdnZXJFbCA9PT0gdm9pZCAwKSB7IHRyaWdnZXJFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgICB0aGlzLl90cmlnZ2VyRWwgPSB0cmlnZ2VyRWw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIERpc21pc3MucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsKSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpc21pc3MucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQodGhpcy5fb3B0aW9ucy50cmFuc2l0aW9uLCBcImR1cmF0aW9uLVwiLmNvbmNhdCh0aGlzLl9vcHRpb25zLmR1cmF0aW9uKSwgdGhpcy5fb3B0aW9ucy50aW1pbmcsICdvcGFjaXR5LTAnKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIH0sIHRoaXMuX29wdGlvbnMuZHVyYXRpb24pO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uSGlkZSh0aGlzLCB0aGlzLl90YXJnZXRFbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlzbWlzcztcbn0oKSk7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuRGlzbWlzcyA9IERpc21pc3M7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5pdERpc21pc3NlcygpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1kaXNtaXNzLXRhcmdldF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciB0YXJnZXRJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc21pc3MtdGFyZ2V0Jyk7XG4gICAgICAgIHZhciAkZGlzbWlzc0VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXRJZCk7XG4gICAgICAgIGlmICgkZGlzbWlzc0VsKSB7XG4gICAgICAgICAgICBuZXcgRGlzbWlzcygkZGlzbWlzc0VsLCAkdHJpZ2dlckVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgZGlzbWlzcyBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdCh0YXJnZXRJZCwgXCJcXFwiIGRvZXMgbm90IGV4aXN0LiBQbGVhc2UgY2hlY2sgdGhlIGRhdGEtZGlzbWlzcy10YXJnZXQgYXR0cmlidXRlLlwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IERpc21pc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBEZWZhdWx0ID0ge1xuICAgIHBsYWNlbWVudDogJ2xlZnQnLFxuICAgIGJvZHlTY3JvbGxpbmc6IGZhbHNlLFxuICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIGVkZ2U6IGZhbHNlLFxuICAgIGVkZ2VPZmZzZXQ6ICdib3R0b20tWzYwcHhdJyxcbiAgICBiYWNrZHJvcENsYXNzZXM6ICdiZy1ncmF5LTkwMCBiZy1vcGFjaXR5LTUwIGRhcms6Ymctb3BhY2l0eS04MCBmaXhlZCBpbnNldC0wIHotMzAnLFxuICAgIG9uU2hvdzogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uSGlkZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uVG9nZ2xlOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIERyYXdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcmF3ZXIodGFyZ2V0RWwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRhcmdldEVsID09PSB2b2lkIDApIHsgdGFyZ2V0RWwgPSBudWxsOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBEZWZhdWx0KSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICBEcmF3ZXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBzZXQgaW5pdGlhbCBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldEVsKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ3RyYW5zaXRpb24tdHJhbnNmb3JtJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGJhc2UgcGxhY2VtZW50IGNsYXNzZXNcbiAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3Nlcyh0aGlzLl9vcHRpb25zLnBsYWNlbWVudCkuYmFzZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWRkIGtleWJvYXJkIGV2ZW50IGxpc3RlbmVyIHRvIGRvY3VtZW50XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgJ0VzY2FwZScga2V5IGlzIHByZXNzZWRcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIERyYXdlciBpcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTsgLy8gaGlkZSB0aGUgRHJhd2VyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gYmFzZWQgb24gdGhlIGVkZ2Ugb3B0aW9uIHNob3cgcGxhY2VtZW50IGNsYXNzZXNcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZWRnZSkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3Nlcyh0aGlzLl9vcHRpb25zLnBsYWNlbWVudCArICctZWRnZScpLmFjdGl2ZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3Nlcyh0aGlzLl9vcHRpb25zLnBsYWNlbWVudCArICctZWRnZScpLmluYWN0aXZlLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRQbGFjZW1lbnRDbGFzc2VzKHRoaXMuX29wdGlvbnMucGxhY2VtZW50KS5hY3RpdmUubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2dldFBsYWNlbWVudENsYXNzZXModGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQpLmluYWN0aXZlLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlc1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgICAgICAvLyBlbmFibGUgYm9keSBzY3JvbGxcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmJvZHlTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnb3ZlcmZsb3ctaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVzdHJveSBiYWNrZHJvcFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5iYWNrZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUJhY2tkcm9wRWwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25IaWRlKHRoaXMpO1xuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5lZGdlKSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRQbGFjZW1lbnRDbGFzc2VzKHRoaXMuX29wdGlvbnMucGxhY2VtZW50ICsgJy1lZGdlJykuYWN0aXZlLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9nZXRQbGFjZW1lbnRDbGFzc2VzKHRoaXMuX29wdGlvbnMucGxhY2VtZW50ICsgJy1lZGdlJykuaW5hY3RpdmUubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFBsYWNlbWVudENsYXNzZXModGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQpLmFjdGl2ZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3Nlcyh0aGlzLl9vcHRpb25zLnBsYWNlbWVudCkuaW5hY3RpdmUubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzXG4gICAgICAgIHRoaXMuX3RhcmdldEVsLnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsICd0cnVlJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAvLyBkaXNhYmxlIGJvZHkgc2Nyb2xsXG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5ib2R5U2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ292ZXJmbG93LWhpZGRlbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNob3cgYmFja2Ryb3BcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYmFja2Ryb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tkcm9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25TaG93KHRoaXMpO1xuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLl9jcmVhdGVCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICAgIHZhciBiYWNrZHJvcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBiYWNrZHJvcEVsLnNldEF0dHJpYnV0ZSgnZHJhd2VyLWJhY2tkcm9wJywgJycpO1xuICAgICAgICAgICAgKF9hID0gYmFja2Ryb3BFbC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYSwgdGhpcy5fb3B0aW9ucy5iYWNrZHJvcENsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykuYXBwZW5kKGJhY2tkcm9wRWwpO1xuICAgICAgICAgICAgYmFja2Ryb3BFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS5fZGVzdHJveUJhY2tkcm9wRWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZHJhd2VyLWJhY2tkcm9wXScpLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLl9nZXRQbGFjZW1lbnRDbGFzc2VzID0gZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICBzd2l0Y2ggKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYXNlOiBbJ3RvcC0wJywgJ2xlZnQtMCcsICdyaWdodC0wJ10sXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogWyd0cmFuc2Zvcm0tbm9uZSddLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZTogWyctdHJhbnNsYXRlLXktZnVsbCddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogWydyaWdodC0wJywgJ3RvcC0wJ10sXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogWyd0cmFuc2Zvcm0tbm9uZSddLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZTogWyd0cmFuc2xhdGUteC1mdWxsJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogWydib3R0b20tMCcsICdsZWZ0LTAnLCAncmlnaHQtMCddLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IFsndHJhbnNmb3JtLW5vbmUnXSxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6IFsndHJhbnNsYXRlLXktZnVsbCddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYXNlOiBbJ2xlZnQtMCcsICd0b3AtMCddLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IFsndHJhbnNmb3JtLW5vbmUnXSxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6IFsnLXRyYW5zbGF0ZS14LWZ1bGwnXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tLWVkZ2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IFsnbGVmdC0wJywgJ3RvcC0wJ10sXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogWyd0cmFuc2Zvcm0tbm9uZSddLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZTogWyd0cmFuc2xhdGUteS1mdWxsJywgdGhpcy5fb3B0aW9ucy5lZGdlT2Zmc2V0XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYXNlOiBbJ2xlZnQtMCcsICd0b3AtMCddLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IFsndHJhbnNmb3JtLW5vbmUnXSxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6IFsnLXRyYW5zbGF0ZS14LWZ1bGwnXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLmlzSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX3Zpc2libGU7XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfTtcbiAgICByZXR1cm4gRHJhd2VyO1xufSgpKTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5EcmF3ZXIgPSBEcmF3ZXI7XG59XG52YXIgZ2V0RHJhd2VySW5zdGFuY2UgPSBmdW5jdGlvbiAoaWQsIGluc3RhbmNlcykge1xuICAgIGlmIChpbnN0YW5jZXMuc29tZShmdW5jdGlvbiAoZHJhd2VySW5zdGFuY2UpIHsgcmV0dXJuIGRyYXdlckluc3RhbmNlLmlkID09PSBpZDsgfSkpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlcy5maW5kKGZ1bmN0aW9uIChkcmF3ZXJJbnN0YW5jZSkgeyByZXR1cm4gZHJhd2VySW5zdGFuY2UuaWQgPT09IGlkOyB9KTtcbiAgICB9XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGluaXREcmF3ZXJzKCkge1xuICAgIHZhciBkcmF3ZXJJbnN0YW5jZXMgPSBbXTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1kcmF3ZXItdGFyZ2V0XScpLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgLy8gbWFuZGF0b3J5XG4gICAgICAgIHZhciBkcmF3ZXJJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci10YXJnZXQnKTtcbiAgICAgICAgdmFyICRkcmF3ZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRyYXdlcklkKTtcbiAgICAgICAgaWYgKCRkcmF3ZXJFbCkge1xuICAgICAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcmF3ZXItcGxhY2VtZW50Jyk7XG4gICAgICAgICAgICB2YXIgYm9keVNjcm9sbGluZyA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci1ib2R5LXNjcm9sbGluZycpO1xuICAgICAgICAgICAgdmFyIGJhY2tkcm9wID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhd2VyLWJhY2tkcm9wJyk7XG4gICAgICAgICAgICB2YXIgZWRnZSA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci1lZGdlJyk7XG4gICAgICAgICAgICB2YXIgZWRnZU9mZnNldCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci1lZGdlLW9mZnNldCcpO1xuICAgICAgICAgICAgaWYgKCFnZXREcmF3ZXJJbnN0YW5jZShkcmF3ZXJJZCwgZHJhd2VySW5zdGFuY2VzKSkge1xuICAgICAgICAgICAgICAgIGRyYXdlckluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGRyYXdlcklkLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG5ldyBEcmF3ZXIoJGRyYXdlckVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCA/IHBsYWNlbWVudCA6IERlZmF1bHQucGxhY2VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keVNjcm9sbGluZzogYm9keVNjcm9sbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYm9keVNjcm9sbGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LmJvZHlTY3JvbGxpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcDogYmFja2Ryb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGJhY2tkcm9wID09PSAndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHQuYmFja2Ryb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlOiBlZGdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlZGdlID09PSAndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHQuZWRnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VPZmZzZXQ6IGVkZ2VPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVkZ2VPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHQuZWRnZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRHJhd2VyIHdpdGggaWQgXCIuY29uY2F0KGRyYXdlcklkLCBcIiBub3QgZm91bmQuIEFyZSB5b3Ugc3VyZSB0aGF0IHRoZSBkYXRhLWRyYXdlci10YXJnZXQgYXR0cmlidXRlIHBvaW50cyB0byB0aGUgY29ycmVjdCBkcmF3ZXIgaWQ/XCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWRyYXdlci10b2dnbGVdJykuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgZHJhd2VySWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcmF3ZXItdG9nZ2xlJyk7XG4gICAgICAgIHZhciAkZHJhd2VyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcmF3ZXJJZCk7XG4gICAgICAgIGlmICgkZHJhd2VyRWwpIHtcbiAgICAgICAgICAgIHZhciBkcmF3ZXJfMSA9IGdldERyYXdlckluc3RhbmNlKGRyYXdlcklkLCBkcmF3ZXJJbnN0YW5jZXMpO1xuICAgICAgICAgICAgaWYgKGRyYXdlcl8xKSB7XG4gICAgICAgICAgICAgICAgJHRyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyXzEub2JqZWN0LnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyYXdlciB3aXRoIGlkIFwiLmNvbmNhdChkcmF3ZXJJZCwgXCIgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLiBQbGVhc2UgaW5pdGlhbGl6ZSBpdCB1c2luZyB0aGUgZGF0YS1kcmF3ZXItdGFyZ2V0IGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyYXdlciB3aXRoIGlkIFwiLmNvbmNhdChkcmF3ZXJJZCwgXCIgbm90IGZvdW5kLiBBcmUgeW91IHN1cmUgdGhhdCB0aGUgZGF0YS1kcmF3ZXItdGFyZ2V0IGF0dHJpYnV0ZSBwb2ludHMgdG8gdGhlIGNvcnJlY3QgZHJhd2VyIGlkP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkb2N1bWVudFxuICAgICAgICAucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZHJhd2VyLWRpc21pc3NdLCBbZGF0YS1kcmF3ZXItaGlkZV0nKVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgZHJhd2VySWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcmF3ZXItZGlzbWlzcycpXG4gICAgICAgICAgICA/ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci1kaXNtaXNzJylcbiAgICAgICAgICAgIDogJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhd2VyLWhpZGUnKTtcbiAgICAgICAgdmFyICRkcmF3ZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRyYXdlcklkKTtcbiAgICAgICAgaWYgKCRkcmF3ZXJFbCkge1xuICAgICAgICAgICAgdmFyIGRyYXdlcl8yID0gZ2V0RHJhd2VySW5zdGFuY2UoZHJhd2VySWQsIGRyYXdlckluc3RhbmNlcyk7XG4gICAgICAgICAgICBpZiAoZHJhd2VyXzIpIHtcbiAgICAgICAgICAgICAgICAkdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkcmF3ZXJfMi5vYmplY3QuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyYXdlciB3aXRoIGlkIFwiLmNvbmNhdChkcmF3ZXJJZCwgXCIgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLiBQbGVhc2UgaW5pdGlhbGl6ZSBpdCB1c2luZyB0aGUgZGF0YS1kcmF3ZXItdGFyZ2V0IGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyYXdlciB3aXRoIGlkIFwiLmNvbmNhdChkcmF3ZXJJZCwgXCIgbm90IGZvdW5kLiBBcmUgeW91IHN1cmUgdGhhdCB0aGUgZGF0YS1kcmF3ZXItdGFyZ2V0IGF0dHJpYnV0ZSBwb2ludHMgdG8gdGhlIGNvcnJlY3QgZHJhd2VyIGlkXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWRyYXdlci1zaG93XScpLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgdmFyIGRyYXdlcklkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhd2VyLXNob3cnKTtcbiAgICAgICAgdmFyICRkcmF3ZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRyYXdlcklkKTtcbiAgICAgICAgaWYgKCRkcmF3ZXJFbCkge1xuICAgICAgICAgICAgdmFyIGRyYXdlcl8zID0gZ2V0RHJhd2VySW5zdGFuY2UoZHJhd2VySWQsIGRyYXdlckluc3RhbmNlcyk7XG4gICAgICAgICAgICBpZiAoZHJhd2VyXzMpIHtcbiAgICAgICAgICAgICAgICAkdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkcmF3ZXJfMy5vYmplY3Quc2hvdygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyYXdlciB3aXRoIGlkIFwiLmNvbmNhdChkcmF3ZXJJZCwgXCIgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLiBQbGVhc2UgaW5pdGlhbGl6ZSBpdCB1c2luZyB0aGUgZGF0YS1kcmF3ZXItdGFyZ2V0IGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyYXdlciB3aXRoIGlkIFwiLmNvbmNhdChkcmF3ZXJJZCwgXCIgbm90IGZvdW5kLiBBcmUgeW91IHN1cmUgdGhhdCB0aGUgZGF0YS1kcmF3ZXItdGFyZ2V0IGF0dHJpYnV0ZSBwb2ludHMgdG8gdGhlIGNvcnJlY3QgZHJhd2VyIGlkP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IERyYXdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uICovXG5pbXBvcnQgeyBjcmVhdGVQb3BwZXIgfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG52YXIgRGVmYXVsdCA9IHtcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgIHRyaWdnZXJUeXBlOiAnY2xpY2snLFxuICAgIG9mZnNldFNraWRkaW5nOiAwLFxuICAgIG9mZnNldERpc3RhbmNlOiAxMCxcbiAgICBkZWxheTogMzAwLFxuICAgIG9uU2hvdzogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uSGlkZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uVG9nZ2xlOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIERyb3Bkb3duID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERyb3Bkb3duKHRhcmdldEVsZW1lbnQsIHRyaWdnZXJFbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0YXJnZXRFbGVtZW50ID09PSB2b2lkIDApIHsgdGFyZ2V0RWxlbWVudCA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRyaWdnZXJFbGVtZW50ID09PSB2b2lkIDApIHsgdHJpZ2dlckVsZW1lbnQgPSBudWxsOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbGVtZW50O1xuICAgICAgICB0aGlzLl90cmlnZ2VyRWwgPSB0cmlnZ2VyRWxlbWVudDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBEZWZhdWx0KSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlID0gdGhpcy5fY3JlYXRlUG9wcGVySW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIERyb3Bkb3duLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuX3NldHVwRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0cmlnZ2VyRXZlbnRzID0gdGhpcy5fZ2V0VHJpZ2dlckV2ZW50cygpO1xuICAgICAgICAvLyBjbGljayBldmVudCBoYW5kbGluZyBmb3IgdHJpZ2dlciBlbGVtZW50XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnRyaWdnZXJUeXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzLnNob3dFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBob3ZlciBldmVudCBoYW5kbGluZyBmb3IgdHJpZ2dlciBlbGVtZW50XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnRyaWdnZXJUeXBlID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzLnNob3dFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIF90aGlzLl9vcHRpb25zLmRlbGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cy5oaWRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fdGFyZ2V0RWwubWF0Y2hlcygnOmhvdmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF90aGlzLl9vcHRpb25zLmRlbGF5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3RyaWdnZXJFbC5tYXRjaGVzKCc6aG92ZXInKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMuX29wdGlvbnMuZGVsYXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5fY3JlYXRlUG9wcGVySW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3BwZXIodGhpcy5fdHJpZ2dlckVsLCB0aGlzLl90YXJnZXRFbCwge1xuICAgICAgICAgICAgcGxhY2VtZW50OiB0aGlzLl9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgICAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub2Zmc2V0U2tpZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vZmZzZXREaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9zZXR1cENsaWNrT3V0c2lkZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jbGlja091dHNpZGVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlQ2xpY2tPdXRzaWRlKGV2LCBfdGhpcy5fdGFyZ2V0RWwpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuX3JlbW92ZUNsaWNrT3V0c2lkZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuX2hhbmRsZUNsaWNrT3V0c2lkZSA9IGZ1bmN0aW9uIChldiwgdGFyZ2V0RWwpIHtcbiAgICAgICAgdmFyIGNsaWNrZWRFbCA9IGV2LnRhcmdldDtcbiAgICAgICAgaWYgKGNsaWNrZWRFbCAhPT0gdGFyZ2V0RWwgJiZcbiAgICAgICAgICAgICF0YXJnZXRFbC5jb250YWlucyhjbGlja2VkRWwpICYmXG4gICAgICAgICAgICAhdGhpcy5fdHJpZ2dlckVsLmNvbnRhaW5zKGNsaWNrZWRFbCkgJiZcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuX2dldFRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fb3B0aW9ucy50cmlnZ2VyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaG92ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFsnbW91c2VlbnRlcicsICdjbGljayddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbJ21vdXNlbGVhdmUnXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFsnY2xpY2snXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ2NsaWNrJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25Ub2dnbGUodGhpcyk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnYmxvY2snKTtcbiAgICAgICAgLy8gRW5hYmxlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2Uuc2V0T3B0aW9ucyhmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtb2RpZmllcnM6IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb3B0aW9ucy5tb2RpZmllcnMsIHRydWUpLCBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLCBlbmFibGVkOiB0cnVlIH0sXG4gICAgICAgICAgICBdLCBmYWxzZSkgfSkpOyB9KTtcbiAgICAgICAgdGhpcy5fc2V0dXBDbGlja091dHNpZGVMaXN0ZW5lcigpO1xuICAgICAgICAvLyBVcGRhdGUgaXRzIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3codGhpcyk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnYmxvY2snKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS5zZXRPcHRpb25zKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1vZGlmaWVyczogX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBvcHRpb25zLm1vZGlmaWVycywgdHJ1ZSksIFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdldmVudExpc3RlbmVycycsIGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICBdLCBmYWxzZSkgfSkpOyB9KTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZW1vdmVDbGlja091dHNpZGVMaXN0ZW5lcigpO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uSGlkZSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBEcm9wZG93bjtcbn0oKSk7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuRHJvcGRvd24gPSBEcm9wZG93bjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbml0RHJvcGRvd25zKCkge1xuICAgIGRvY3VtZW50XG4gICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1kcm9wZG93bi10b2dnbGVdJylcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgdmFyIGRyb3Bkb3duSWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcm9wZG93bi10b2dnbGUnKTtcbiAgICAgICAgdmFyICRkcm9wZG93bkVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHJvcGRvd25JZCk7XG4gICAgICAgIGlmICgkZHJvcGRvd25FbCkge1xuICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyb3Bkb3duLXBsYWNlbWVudCcpO1xuICAgICAgICAgICAgdmFyIG9mZnNldFNraWRkaW5nID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJvcGRvd24tb2Zmc2V0LXNraWRkaW5nJyk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0RGlzdGFuY2UgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcm9wZG93bi1vZmZzZXQtZGlzdGFuY2UnKTtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyVHlwZSA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyb3Bkb3duLXRyaWdnZXInKTtcbiAgICAgICAgICAgIHZhciBkZWxheSA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyb3Bkb3duLWRlbGF5Jyk7XG4gICAgICAgICAgICBuZXcgRHJvcGRvd24oJGRyb3Bkb3duRWwsICR0cmlnZ2VyRWwsIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCA/IHBsYWNlbWVudCA6IERlZmF1bHQucGxhY2VtZW50LFxuICAgICAgICAgICAgICAgIHRyaWdnZXJUeXBlOiB0cmlnZ2VyVHlwZVxuICAgICAgICAgICAgICAgICAgICA/IHRyaWdnZXJUeXBlXG4gICAgICAgICAgICAgICAgICAgIDogRGVmYXVsdC50cmlnZ2VyVHlwZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRTa2lkZGluZzogb2Zmc2V0U2tpZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJzZUludChvZmZzZXRTa2lkZGluZylcbiAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0Lm9mZnNldFNraWRkaW5nLFxuICAgICAgICAgICAgICAgIG9mZnNldERpc3RhbmNlOiBvZmZzZXREaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICA/IHBhcnNlSW50KG9mZnNldERpc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHQub2Zmc2V0RGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgZGVsYXk6IGRlbGF5ID8gcGFyc2VJbnQoZGVsYXkpIDogRGVmYXVsdC5kZWxheSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRoZSBkcm9wZG93biBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdChkcm9wZG93bklkLCBcIlxcXCIgZG9lcyBub3QgZXhpc3QuIFBsZWFzZSBjaGVjayB0aGUgZGF0YS1kcm9wZG93bi10b2dnbGUgYXR0cmlidXRlLlwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IERyb3Bkb3duO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsImltcG9ydCB7IGluaXRBY2NvcmRpb25zIH0gZnJvbSAnLi9hY2NvcmRpb24nO1xuaW1wb3J0IHsgaW5pdENhcm91c2VscyB9IGZyb20gJy4vY2Fyb3VzZWwnO1xuaW1wb3J0IHsgaW5pdENvbGxhcHNlcyB9IGZyb20gJy4vY29sbGFwc2UnO1xuaW1wb3J0IHsgaW5pdERpYWxzIH0gZnJvbSAnLi9kaWFsJztcbmltcG9ydCB7IGluaXREaXNtaXNzZXMgfSBmcm9tICcuL2Rpc21pc3MnO1xuaW1wb3J0IHsgaW5pdERyYXdlcnMgfSBmcm9tICcuL2RyYXdlcic7XG5pbXBvcnQgeyBpbml0RHJvcGRvd25zIH0gZnJvbSAnLi9kcm9wZG93bic7XG5pbXBvcnQgeyBpbml0TW9kYWxzIH0gZnJvbSAnLi9tb2RhbCc7XG5pbXBvcnQgeyBpbml0UG9wb3ZlcnMgfSBmcm9tICcuL3BvcG92ZXInO1xuaW1wb3J0IHsgaW5pdFRhYnMgfSBmcm9tICcuL3RhYnMnO1xuaW1wb3J0IHsgaW5pdFRvb2x0aXBzIH0gZnJvbSAnLi90b29sdGlwJztcbmV4cG9ydCBmdW5jdGlvbiBpbml0Rmxvd2JpdGUoKSB7XG4gICAgaW5pdEFjY29yZGlvbnMoKTtcbiAgICBpbml0Q29sbGFwc2VzKCk7XG4gICAgaW5pdENhcm91c2VscygpO1xuICAgIGluaXREaXNtaXNzZXMoKTtcbiAgICBpbml0RHJvcGRvd25zKCk7XG4gICAgaW5pdE1vZGFscygpO1xuICAgIGluaXREcmF3ZXJzKCk7XG4gICAgaW5pdFRhYnMoKTtcbiAgICBpbml0VG9vbHRpcHMoKTtcbiAgICBpbml0UG9wb3ZlcnMoKTtcbiAgICBpbml0RGlhbHMoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgRGVmYXVsdCA9IHtcbiAgICBwbGFjZW1lbnQ6ICdjZW50ZXInLFxuICAgIGJhY2tkcm9wQ2xhc3NlczogJ2JnLWdyYXktOTAwIGJnLW9wYWNpdHktNTAgZGFyazpiZy1vcGFjaXR5LTgwIGZpeGVkIGluc2V0LTAgei00MCcsXG4gICAgYmFja2Ryb3A6ICdkeW5hbWljJyxcbiAgICBjbG9zYWJsZTogdHJ1ZSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblNob3c6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblRvZ2dsZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBNb2RhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RhbCh0YXJnZXRFbCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGFyZ2V0RWwgPT09IHZvaWQgMCkgeyB0YXJnZXRFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faXNIaWRkZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICBNb2RhbC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl90YXJnZXRFbCkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3NlcygpLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5fY3JlYXRlQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2lzSGlkZGVuKSB7XG4gICAgICAgICAgICB2YXIgYmFja2Ryb3BFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgYmFja2Ryb3BFbC5zZXRBdHRyaWJ1dGUoJ21vZGFsLWJhY2tkcm9wJywgJycpO1xuICAgICAgICAgICAgKF9hID0gYmFja2Ryb3BFbC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYSwgdGhpcy5fb3B0aW9ucy5iYWNrZHJvcENsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykuYXBwZW5kKGJhY2tkcm9wRWwpO1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BFbCA9IGJhY2tkcm9wRWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5fZGVzdHJveUJhY2tkcm9wRWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNIaWRkZW4pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1ttb2RhbC1iYWNrZHJvcF0nKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLl9zZXR1cE1vZGFsQ2xvc2VFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYmFja2Ryb3AgPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVPdXRzaWRlQ2xpY2soZXYudGFyZ2V0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrT3V0c2lkZUV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2tleWRvd25FdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLl9yZW1vdmVNb2RhbENsb3NlRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmJhY2tkcm9wID09PSAnZHluYW1pYycpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLl9oYW5kbGVPdXRzaWRlQ2xpY2sgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuX3RhcmdldEVsIHx8XG4gICAgICAgICAgICAodGFyZ2V0ID09PSB0aGlzLl9iYWNrZHJvcEVsICYmIHRoaXMuaXNWaXNpYmxlKCkpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLl9nZXRQbGFjZW1lbnRDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMucGxhY2VtZW50KSB7XG4gICAgICAgICAgICAvLyB0b3BcbiAgICAgICAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LXN0YXJ0JywgJ2l0ZW1zLXN0YXJ0J107XG4gICAgICAgICAgICBjYXNlICd0b3AtY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWNlbnRlcicsICdpdGVtcy1zdGFydCddO1xuICAgICAgICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWVuZCcsICdpdGVtcy1zdGFydCddO1xuICAgICAgICAgICAgLy8gY2VudGVyXG4gICAgICAgICAgICBjYXNlICdjZW50ZXItbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1zdGFydCcsICdpdGVtcy1jZW50ZXInXTtcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1jZW50ZXInLCAnaXRlbXMtY2VudGVyJ107XG4gICAgICAgICAgICBjYXNlICdjZW50ZXItcmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktZW5kJywgJ2l0ZW1zLWNlbnRlciddO1xuICAgICAgICAgICAgLy8gYm90dG9tXG4gICAgICAgICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1zdGFydCcsICdpdGVtcy1lbmQnXTtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1jZW50ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktY2VudGVyJywgJ2l0ZW1zLWVuZCddO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWVuZCcsICdpdGVtcy1lbmQnXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1jZW50ZXInLCAnaXRlbXMtY2VudGVyJ107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0hpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uVG9nZ2xlKHRoaXMpO1xuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdmbGV4Jyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsICd0cnVlJyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVCYWNrZHJvcCgpO1xuICAgICAgICAgICAgdGhpcy5faXNIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgYm9keSBzY3JvbGxcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnb3ZlcmZsb3ctaGlkZGVuJyk7XG4gICAgICAgICAgICAvLyBBZGQga2V5Ym9hcmQgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGRvY3VtZW50XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5jbG9zYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldHVwTW9kYWxDbG9zZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3codGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnZmxleCcpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUJhY2tkcm9wRWwoKTtcbiAgICAgICAgICAgIHRoaXMuX2lzSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHJlLWFwcGx5IGJvZHkgc2Nyb2xsXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ292ZXJmbG93LWhpZGRlbicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuY2xvc2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVNb2RhbENsb3NlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uSGlkZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9pc0hpZGRlbjtcbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5pc0hpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSGlkZGVuO1xuICAgIH07XG4gICAgcmV0dXJuIE1vZGFsO1xufSgpKTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5Nb2RhbCA9IE1vZGFsO1xufVxudmFyIGdldE1vZGFsSW5zdGFuY2UgPSBmdW5jdGlvbiAoaWQsIGluc3RhbmNlcykge1xuICAgIGlmIChpbnN0YW5jZXMuc29tZShmdW5jdGlvbiAobW9kYWxJbnN0YW5jZSkgeyByZXR1cm4gbW9kYWxJbnN0YW5jZS5pZCA9PT0gaWQ7IH0pKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXMuZmluZChmdW5jdGlvbiAobW9kYWxJbnN0YW5jZSkgeyByZXR1cm4gbW9kYWxJbnN0YW5jZS5pZCA9PT0gaWQ7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnQgZnVuY3Rpb24gaW5pdE1vZGFscygpIHtcbiAgICB2YXIgbW9kYWxJbnN0YW5jZXMgPSBbXTtcbiAgICAvLyBpbml0aWF0ZSBtb2RhbCBiYXNlZCBvbiBkYXRhLW1vZGFsLXRhcmdldFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1vZGFsLXRhcmdldF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciBtb2RhbElkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwtdGFyZ2V0Jyk7XG4gICAgICAgIHZhciAkbW9kYWxFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1vZGFsSWQpO1xuICAgICAgICBpZiAoJG1vZGFsRWwpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkbW9kYWxFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwtcGxhY2VtZW50Jyk7XG4gICAgICAgICAgICB2YXIgYmFja2Ryb3AgPSAkbW9kYWxFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwtYmFja2Ryb3AnKTtcbiAgICAgICAgICAgIGlmICghZ2V0TW9kYWxJbnN0YW5jZShtb2RhbElkLCBtb2RhbEluc3RhbmNlcykpIHtcbiAgICAgICAgICAgICAgICBtb2RhbEluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG1vZGFsSWQsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogbmV3IE1vZGFsKCRtb2RhbEVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LnBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wOiBiYWNrZHJvcCA/IGJhY2tkcm9wIDogRGVmYXVsdC5iYWNrZHJvcCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW9kYWwgd2l0aCBpZCBcIi5jb25jYXQobW9kYWxJZCwgXCIgZG9lcyBub3QgZXhpc3QuIEFyZSB5b3Ugc3VyZSB0aGF0IHRoZSBkYXRhLW1vZGFsLXRhcmdldCBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IG1vZGFsIGlkPy5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gc3VwcG9ydCBwcmUgdjEuNi4wIGRhdGEtbW9kYWwtdG9nZ2xlIGluaXRpYWxpemF0aW9uXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbW9kYWwtdG9nZ2xlXScpLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgdmFyIG1vZGFsSWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RhbC10b2dnbGUnKTtcbiAgICAgICAgdmFyICRtb2RhbEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobW9kYWxJZCk7XG4gICAgICAgIGlmICgkbW9kYWxFbCkge1xuICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9ICRtb2RhbEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RhbC1wbGFjZW1lbnQnKTtcbiAgICAgICAgICAgIHZhciBiYWNrZHJvcCA9ICRtb2RhbEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RhbC1iYWNrZHJvcCcpO1xuICAgICAgICAgICAgdmFyIG1vZGFsXzEgPSBnZXRNb2RhbEluc3RhbmNlKG1vZGFsSWQsIG1vZGFsSW5zdGFuY2VzKTtcbiAgICAgICAgICAgIGlmICghbW9kYWxfMSkge1xuICAgICAgICAgICAgICAgIG1vZGFsXzEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBtb2RhbElkLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG5ldyBNb2RhbCgkbW9kYWxFbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogRGVmYXVsdC5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcDogYmFja2Ryb3AgPyBiYWNrZHJvcCA6IERlZmF1bHQuYmFja2Ryb3AsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbW9kYWxJbnN0YW5jZXMucHVzaChtb2RhbF8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR0cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbW9kYWxfMS5vYmplY3QudG9nZ2xlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb2RhbCB3aXRoIGlkIFwiLmNvbmNhdChtb2RhbElkLCBcIiBkb2VzIG5vdCBleGlzdC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtbW9kYWwtdG9nZ2xlIGF0dHJpYnV0ZSBwb2ludHMgdG8gdGhlIGNvcnJlY3QgbW9kYWwgaWQ/XCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHNob3cgbW9kYWwgb24gY2xpY2sgaWYgZXhpc3RzIGJhc2VkIG9uIGlkXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbW9kYWwtc2hvd10nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciBtb2RhbElkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwtc2hvdycpO1xuICAgICAgICB2YXIgJG1vZGFsRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtb2RhbElkKTtcbiAgICAgICAgaWYgKCRtb2RhbEVsKSB7XG4gICAgICAgICAgICB2YXIgbW9kYWxfMiA9IGdldE1vZGFsSW5zdGFuY2UobW9kYWxJZCwgbW9kYWxJbnN0YW5jZXMpO1xuICAgICAgICAgICAgaWYgKG1vZGFsXzIpIHtcbiAgICAgICAgICAgICAgICAkdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kYWxfMi5vYmplY3QuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsXzIub2JqZWN0LnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1vZGFsIHdpdGggaWQgXCIuY29uY2F0KG1vZGFsSWQsIFwiIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4gUGxlYXNlIGluaXRpYWxpemUgaXQgdXNpbmcgdGhlIGRhdGEtbW9kYWwtdGFyZ2V0IGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1vZGFsIHdpdGggaWQgXCIuY29uY2F0KG1vZGFsSWQsIFwiIGRvZXMgbm90IGV4aXN0LiBBcmUgeW91IHN1cmUgdGhhdCB0aGUgZGF0YS1tb2RhbC1zaG93IGF0dHJpYnV0ZSBwb2ludHMgdG8gdGhlIGNvcnJlY3QgbW9kYWwgaWQ/XCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGhpZGUgbW9kYWwgb24gY2xpY2sgaWYgZXhpc3RzIGJhc2VkIG9uIGlkXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbW9kYWwtaGlkZV0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciBtb2RhbElkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwtaGlkZScpO1xuICAgICAgICB2YXIgJG1vZGFsRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtb2RhbElkKTtcbiAgICAgICAgaWYgKCRtb2RhbEVsKSB7XG4gICAgICAgICAgICB2YXIgbW9kYWxfMyA9IGdldE1vZGFsSW5zdGFuY2UobW9kYWxJZCwgbW9kYWxJbnN0YW5jZXMpO1xuICAgICAgICAgICAgaWYgKG1vZGFsXzMpIHtcbiAgICAgICAgICAgICAgICAkdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kYWxfMy5vYmplY3QuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RhbF8zLm9iamVjdC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb2RhbCB3aXRoIGlkIFwiLmNvbmNhdChtb2RhbElkLCBcIiBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIFBsZWFzZSBpbml0aWFsaXplIGl0IHVzaW5nIHRoZSBkYXRhLW1vZGFsLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb2RhbCB3aXRoIGlkIFwiLmNvbmNhdChtb2RhbElkLCBcIiBkb2VzIG5vdCBleGlzdC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtbW9kYWwtaGlkZSBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IG1vZGFsIGlkP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IE1vZGFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24gKi9cbmltcG9ydCB7IGNyZWF0ZVBvcHBlciB9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcbnZhciBEZWZhdWx0ID0ge1xuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgb2Zmc2V0OiAxMCxcbiAgICB0cmlnZ2VyVHlwZTogJ2hvdmVyJyxcbiAgICBvblNob3c6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblRvZ2dsZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBQb3BvdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvcG92ZXIodGFyZ2V0RWwsIHRyaWdnZXJFbCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGFyZ2V0RWwgPT09IHZvaWQgMCkgeyB0YXJnZXRFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRyaWdnZXJFbCA9PT0gdm9pZCAwKSB7IHRyaWdnZXJFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgICB0aGlzLl90cmlnZ2VyRWwgPSB0cmlnZ2VyRWw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZSA9IHRoaXMuX2NyZWF0ZVBvcHBlckluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5fc2V0dXBFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRyaWdnZXJFdmVudHMgPSB0aGlzLl9nZXRUcmlnZ2VyRXZlbnRzKCk7XG4gICAgICAgIHRyaWdnZXJFdmVudHMuc2hvd0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJpZ2dlckV2ZW50cy5oaWRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5fdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fdGFyZ2V0RWwubWF0Y2hlcygnOmhvdmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3RyaWdnZXJFbC5tYXRjaGVzKCc6aG92ZXInKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLl9jcmVhdGVQb3BwZXJJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcHBlcih0aGlzLl90cmlnZ2VyRWwsIHRoaXMuX3RhcmdldEVsLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBbMCwgdGhpcy5fb3B0aW9ucy5vZmZzZXRdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLl9nZXRUcmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMudHJpZ2dlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hvdmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ21vdXNlZW50ZXInLCAnZm9jdXMnXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogWydtb3VzZWxlYXZlJywgJ2JsdXInXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFsnY2xpY2snLCAnZm9jdXMnXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogWydmb2N1c291dCcsICdibHVyJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ21vdXNlZW50ZXInLCAnZm9jdXMnXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogWydtb3VzZWxlYXZlJywgJ2JsdXInXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5fc2V0dXBLZXlkb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2tleWRvd25FdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX3JlbW92ZUtleWRvd25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX3NldHVwQ2xpY2tPdXRzaWRlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NsaWNrT3V0c2lkZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVDbGlja091dHNpZGUoZXYsIF90aGlzLl90YXJnZXRFbCk7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jbGlja091dHNpZGVFdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLl9yZW1vdmVDbGlja091dHNpZGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrT3V0c2lkZUV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX2hhbmRsZUNsaWNrT3V0c2lkZSA9IGZ1bmN0aW9uIChldiwgdGFyZ2V0RWwpIHtcbiAgICAgICAgdmFyIGNsaWNrZWRFbCA9IGV2LnRhcmdldDtcbiAgICAgICAgaWYgKGNsaWNrZWRFbCAhPT0gdGFyZ2V0RWwgJiZcbiAgICAgICAgICAgICF0YXJnZXRFbC5jb250YWlucyhjbGlja2VkRWwpICYmXG4gICAgICAgICAgICAhdGhpcy5fdHJpZ2dlckVsLmNvbnRhaW5zKGNsaWNrZWRFbCkgJiZcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uVG9nZ2xlKHRoaXMpO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnb3BhY2l0eS0wJywgJ2ludmlzaWJsZScpO1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdvcGFjaXR5LTEwMCcsICd2aXNpYmxlJyk7XG4gICAgICAgIC8vIEVuYWJsZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnNldE9wdGlvbnMoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgbW9kaWZpZXJzOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG9wdGlvbnMubW9kaWZpZXJzLCB0cnVlKSwgW1xuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJywgZW5hYmxlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgXSwgZmFsc2UpIH0pKTsgfSk7XG4gICAgICAgIC8vIGhhbmRsZSBjbGljayBvdXRzaWRlXG4gICAgICAgIHRoaXMuX3NldHVwQ2xpY2tPdXRzaWRlTGlzdGVuZXIoKTtcbiAgICAgICAgLy8gaGFuZGxlIGVzYyBrZXlkb3duXG4gICAgICAgIHRoaXMuX3NldHVwS2V5ZG93bkxpc3RlbmVyKCk7XG4gICAgICAgIC8vIFVwZGF0ZSBpdHMgcG9zaXRpb25cbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgIC8vIHNldCB2aXNpYmlsaXR5IHRvIHRydWVcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25TaG93KHRoaXMpO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnb3BhY2l0eS0xMDAnLCAndmlzaWJsZScpO1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdvcGFjaXR5LTAnLCAnaW52aXNpYmxlJyk7XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS5zZXRPcHRpb25zKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1vZGlmaWVyczogX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBvcHRpb25zLm1vZGlmaWVycywgdHJ1ZSksIFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdldmVudExpc3RlbmVycycsIGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICBdLCBmYWxzZSkgfSkpOyB9KTtcbiAgICAgICAgLy8gaGFuZGxlIGNsaWNrIG91dHNpZGVcbiAgICAgICAgdGhpcy5fcmVtb3ZlQ2xpY2tPdXRzaWRlTGlzdGVuZXIoKTtcbiAgICAgICAgLy8gaGFuZGxlIGVzYyBrZXlkb3duXG4gICAgICAgIHRoaXMuX3JlbW92ZUtleWRvd25MaXN0ZW5lcigpO1xuICAgICAgICAvLyBzZXQgdmlzaWJpbGl0eSB0byBmYWxzZVxuICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25IaWRlKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcG92ZXI7XG59KCkpO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LlBvcG92ZXIgPSBQb3BvdmVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluaXRQb3BvdmVycygpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1wb3BvdmVyLXRhcmdldF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciBwb3BvdmVySUQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wb3BvdmVyLXRhcmdldCcpO1xuICAgICAgICB2YXIgJHBvcG92ZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBvcG92ZXJJRCk7XG4gICAgICAgIGlmICgkcG9wb3ZlckVsKSB7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlclR5cGUgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wb3BvdmVyLXRyaWdnZXInKTtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wb3BvdmVyLXBsYWNlbWVudCcpO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXBvcG92ZXItb2Zmc2V0Jyk7XG4gICAgICAgICAgICBuZXcgUG9wb3ZlcigkcG9wb3ZlckVsLCAkdHJpZ2dlckVsLCB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQgPyBwbGFjZW1lbnQgOiBEZWZhdWx0LnBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCA/IHBhcnNlSW50KG9mZnNldCkgOiBEZWZhdWx0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVHlwZTogdHJpZ2dlclR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyB0cmlnZ2VyVHlwZVxuICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHQudHJpZ2dlclR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgcG9wb3ZlciBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdChwb3BvdmVySUQsIFwiXFxcIiBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIGNoZWNrIHRoZSBkYXRhLXBvcG92ZXItdGFyZ2V0IGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBQb3BvdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgRGVmYXVsdCA9IHtcbiAgICBkZWZhdWx0VGFiSWQ6IG51bGwsXG4gICAgYWN0aXZlQ2xhc3NlczogJ3RleHQtYmx1ZS02MDAgaG92ZXI6dGV4dC1ibHVlLTYwMCBkYXJrOnRleHQtYmx1ZS01MDAgZGFyazpob3Zlcjp0ZXh0LWJsdWUtNTAwIGJvcmRlci1ibHVlLTYwMCBkYXJrOmJvcmRlci1ibHVlLTUwMCcsXG4gICAgaW5hY3RpdmVDbGFzc2VzOiAnZGFyazpib3JkZXItdHJhbnNwYXJlbnQgdGV4dC1ncmF5LTUwMCBob3Zlcjp0ZXh0LWdyYXktNjAwIGRhcms6dGV4dC1ncmF5LTQwMCBib3JkZXItZ3JheS0xMDAgaG92ZXI6Ym9yZGVyLWdyYXktMzAwIGRhcms6Ym9yZGVyLWdyYXktNzAwIGRhcms6aG92ZXI6dGV4dC1ncmF5LTMwMCcsXG4gICAgb25TaG93OiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIFRhYnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFicyhpdGVtcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXRlbXMgPT09IHZvaWQgMCkgeyBpdGVtcyA9IFtdOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy5fYWN0aXZlVGFiID0gb3B0aW9ucyA/IHRoaXMuZ2V0VGFiKG9wdGlvbnMuZGVmYXVsdFRhYklkKSA6IG51bGw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIFRhYnMucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGZpcnN0IHRhYiBhcyBhY3RpdmUgaWYgbm90IHNldCBieSBleHBsaWNpdGx5XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZVRhYikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZVRhYih0aGlzLl9pdGVtc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3JjZSBzaG93IHRoZSBmaXJzdCBkZWZhdWx0IHRhYlxuICAgICAgICAgICAgdGhpcy5zaG93KHRoaXMuX2FjdGl2ZVRhYi5pZCwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBzaG93IHRhYiBjb250ZW50IGJhc2VkIG9uIGNsaWNrXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5tYXAoZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAgICAgICAgIHRhYi50cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNob3codGFiLmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJzLnByb3RvdHlwZS5nZXRBY3RpdmVUYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVUYWI7XG4gICAgfTtcbiAgICBUYWJzLnByb3RvdHlwZS5fc2V0QWN0aXZlVGFiID0gZnVuY3Rpb24gKHRhYikge1xuICAgICAgICB0aGlzLl9hY3RpdmVUYWIgPSB0YWI7XG4gICAgfTtcbiAgICBUYWJzLnByb3RvdHlwZS5nZXRUYWIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5pZCA9PT0gaWQ7IH0pWzBdO1xuICAgIH07XG4gICAgVGFicy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChpZCwgZm9yY2VTaG93KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChmb3JjZVNob3cgPT09IHZvaWQgMCkgeyBmb3JjZVNob3cgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgdGFiID0gdGhpcy5nZXRUYWIoaWQpO1xuICAgICAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiBhbHJlYWR5IGFjdGl2ZVxuICAgICAgICBpZiAodGFiID09PSB0aGlzLl9hY3RpdmVUYWIgJiYgIWZvcmNlU2hvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhpZGUgb3RoZXIgdGFic1xuICAgICAgICB0aGlzLl9pdGVtcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAodCAhPT0gdGFiKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdC50cmlnZ2VyRWwuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2EsIF90aGlzLl9vcHRpb25zLmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICAgICAgKF9iID0gdC50cmlnZ2VyRWwuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2IsIF90aGlzLl9vcHRpb25zLmluYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgICAgICAgICB0LnRhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIHQudHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICdmYWxzZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2hvdyBhY3RpdmUgdGFiXG4gICAgICAgIChfYSA9IHRhYi50cmlnZ2VyRWwuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2EsIHRoaXMuX29wdGlvbnMuYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgKF9iID0gdGFiLnRyaWdnZXJFbC5jbGFzc0xpc3QpLnJlbW92ZS5hcHBseShfYiwgdGhpcy5fb3B0aW9ucy5pbmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgIHRhYi50cmlnZ2VyRWwuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICAgICAgdGFiLnRhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICB0aGlzLl9zZXRBY3RpdmVUYWIodGFiKTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3codGhpcywgdGFiKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJzO1xufSgpKTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5UYWJzID0gVGFicztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbml0VGFicygpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10YWJzLXRvZ2dsZV0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciB0YWJJdGVtcyA9IFtdO1xuICAgICAgICB2YXIgZGVmYXVsdFRhYklkID0gbnVsbDtcbiAgICAgICAgJHRyaWdnZXJFbFxuICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwidGFiXCJdJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgICAgICB2YXIgaXNBY3RpdmUgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcpID09PSAndHJ1ZSc7XG4gICAgICAgICAgICB2YXIgdGFiID0ge1xuICAgICAgICAgICAgICAgIGlkOiAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS10YWJzLXRhcmdldCcpLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJFbDogJHRyaWdnZXJFbCxcbiAgICAgICAgICAgICAgICB0YXJnZXRFbDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcigkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS10YWJzLXRhcmdldCcpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0YWJJdGVtcy5wdXNoKHRhYik7XG4gICAgICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFiSWQgPSB0YWIuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBuZXcgVGFicyh0YWJJdGVtcywge1xuICAgICAgICAgICAgZGVmYXVsdFRhYklkOiBkZWZhdWx0VGFiSWQsXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgVGFicztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uICovXG5pbXBvcnQgeyBjcmVhdGVQb3BwZXIgfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG52YXIgRGVmYXVsdCA9IHtcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHRyaWdnZXJUeXBlOiAnaG92ZXInLFxuICAgIG9uU2hvdzogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uSGlkZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uVG9nZ2xlOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIFRvb2x0aXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9vbHRpcCh0YXJnZXRFbCwgdHJpZ2dlckVsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0YXJnZXRFbCA9PT0gdm9pZCAwKSB7IHRhcmdldEVsID0gbnVsbDsgfVxuICAgICAgICBpZiAodHJpZ2dlckVsID09PSB2b2lkIDApIHsgdHJpZ2dlckVsID0gbnVsbDsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIHRoaXMuX3RhcmdldEVsID0gdGFyZ2V0RWw7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJFbCA9IHRyaWdnZXJFbDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBEZWZhdWx0KSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlID0gdGhpcy5fY3JlYXRlUG9wcGVySW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLl9zZXR1cEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHJpZ2dlckV2ZW50cyA9IHRoaXMuX2dldFRyaWdnZXJFdmVudHMoKTtcbiAgICAgICAgdHJpZ2dlckV2ZW50cy5zaG93RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5fdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyaWdnZXJFdmVudHMuaGlkZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2NyZWF0ZVBvcHBlckluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9wcGVyKHRoaXMuX3RyaWdnZXJFbCwgdGhpcy5fdGFyZ2V0RWwsIHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogdGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICAgICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IFswLCA4XSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5fZ2V0VHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLnRyaWdnZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdob3Zlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydtb3VzZWVudGVyJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnbW91c2VsZWF2ZScsICdibHVyJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ2NsaWNrJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnZm9jdXNvdXQnLCAnYmx1ciddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydtb3VzZWVudGVyJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnbW91c2VsZWF2ZScsICdibHVyJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX3NldHVwS2V5ZG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9rZXlkb3duRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25FdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLl9yZW1vdmVLZXlkb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25FdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLl9zZXR1cENsaWNrT3V0c2lkZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jbGlja091dHNpZGVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlQ2xpY2tPdXRzaWRlKGV2LCBfdGhpcy5fdGFyZ2V0RWwpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5fcmVtb3ZlQ2xpY2tPdXRzaWRlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jbGlja091dHNpZGVFdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLl9oYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoZXYsIHRhcmdldEVsKSB7XG4gICAgICAgIHZhciBjbGlja2VkRWwgPSBldi50YXJnZXQ7XG4gICAgICAgIGlmIChjbGlja2VkRWwgIT09IHRhcmdldEVsICYmXG4gICAgICAgICAgICAhdGFyZ2V0RWwuY29udGFpbnMoY2xpY2tlZEVsKSAmJlxuICAgICAgICAgICAgIXRoaXMuX3RyaWdnZXJFbC5jb250YWlucyhjbGlja2VkRWwpICYmXG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ29wYWNpdHktMCcsICdpbnZpc2libGUnKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnb3BhY2l0eS0xMDAnLCAndmlzaWJsZScpO1xuICAgICAgICAvLyBFbmFibGUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS5zZXRPcHRpb25zKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1vZGlmaWVyczogX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBvcHRpb25zLm1vZGlmaWVycywgdHJ1ZSksIFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdldmVudExpc3RlbmVycycsIGVuYWJsZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIF0sIGZhbHNlKSB9KSk7IH0pO1xuICAgICAgICAvLyBoYW5kbGUgY2xpY2sgb3V0c2lkZVxuICAgICAgICB0aGlzLl9zZXR1cENsaWNrT3V0c2lkZUxpc3RlbmVyKCk7XG4gICAgICAgIC8vIGhhbmRsZSBlc2Mga2V5ZG93blxuICAgICAgICB0aGlzLl9zZXR1cEtleWRvd25MaXN0ZW5lcigpO1xuICAgICAgICAvLyBVcGRhdGUgaXRzIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICAvLyBzZXQgdmlzaWJpbGl0eVxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3codGhpcyk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdvcGFjaXR5LTEwMCcsICd2aXNpYmxlJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ29wYWNpdHktMCcsICdpbnZpc2libGUnKTtcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnNldE9wdGlvbnMoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgbW9kaWZpZXJzOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG9wdGlvbnMubW9kaWZpZXJzLCB0cnVlKSwgW1xuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJywgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIF0sIGZhbHNlKSB9KSk7IH0pO1xuICAgICAgICAvLyBoYW5kbGUgY2xpY2sgb3V0c2lkZVxuICAgICAgICB0aGlzLl9yZW1vdmVDbGlja091dHNpZGVMaXN0ZW5lcigpO1xuICAgICAgICAvLyBoYW5kbGUgZXNjIGtleWRvd25cbiAgICAgICAgdGhpcy5fcmVtb3ZlS2V5ZG93bkxpc3RlbmVyKCk7XG4gICAgICAgIC8vIHNldCB2aXNpYmlsaXR5XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbHRpcDtcbn0oKSk7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuVG9vbHRpcCA9IFRvb2x0aXA7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5pdFRvb2x0aXBzKCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRvb2x0aXAtdGFyZ2V0XScpLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgdmFyIHRvb2x0aXBJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRvb2x0aXAtdGFyZ2V0Jyk7XG4gICAgICAgIHZhciAkdG9vbHRpcEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodG9vbHRpcElkKTtcbiAgICAgICAgaWYgKCR0b29sdGlwRWwpIHtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyVHlwZSA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRvb2x0aXAtdHJpZ2dlcicpO1xuICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRvb2x0aXAtcGxhY2VtZW50Jyk7XG4gICAgICAgICAgICBuZXcgVG9vbHRpcCgkdG9vbHRpcEVsLCAkdHJpZ2dlckVsLCB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQgPyBwbGFjZW1lbnQgOiBEZWZhdWx0LnBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVHlwZTogdHJpZ2dlclR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyB0cmlnZ2VyVHlwZVxuICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHQudHJpZ2dlclR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgdG9vbHRpcCBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdCh0b29sdGlwSWQsIFwiXFxcIiBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIGNoZWNrIHRoZSBkYXRhLXRvb2x0aXAtdGFyZ2V0IGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBUb29sdGlwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsInZhciBFdmVudHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRzKGV2ZW50VHlwZSwgZXZlbnRGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKGV2ZW50RnVuY3Rpb25zID09PSB2b2lkIDApIHsgZXZlbnRGdW5jdGlvbnMgPSBbXTsgfVxuICAgICAgICB0aGlzLl9ldmVudFR5cGUgPSBldmVudFR5cGU7XG4gICAgICAgIHRoaXMuX2V2ZW50RnVuY3Rpb25zID0gZXZlbnRGdW5jdGlvbnM7XG4gICAgfVxuICAgIEV2ZW50cy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZXZlbnRGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoX3RoaXMuX2V2ZW50VHlwZSwgZXZlbnRGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50cztcbn0oKSk7XG5leHBvcnQgZGVmYXVsdCBFdmVudHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudHMuanMubWFwIiwiaW1wb3J0IEV2ZW50cyBmcm9tICcuL2RvbS9ldmVudHMnO1xuaW1wb3J0IHsgaW5pdEFjY29yZGlvbnMgfSBmcm9tICcuL2NvbXBvbmVudHMvYWNjb3JkaW9uJztcbmltcG9ydCB7IGluaXRDb2xsYXBzZXMgfSBmcm9tICcuL2NvbXBvbmVudHMvY29sbGFwc2UnO1xuaW1wb3J0IHsgaW5pdENhcm91c2VscyB9IGZyb20gJy4vY29tcG9uZW50cy9jYXJvdXNlbCc7XG5pbXBvcnQgeyBpbml0RGlzbWlzc2VzIH0gZnJvbSAnLi9jb21wb25lbnRzL2Rpc21pc3MnO1xuaW1wb3J0IHsgaW5pdERyb3Bkb3ducyB9IGZyb20gJy4vY29tcG9uZW50cy9kcm9wZG93bic7XG5pbXBvcnQgeyBpbml0TW9kYWxzIH0gZnJvbSAnLi9jb21wb25lbnRzL21vZGFsJztcbmltcG9ydCB7IGluaXREcmF3ZXJzIH0gZnJvbSAnLi9jb21wb25lbnRzL2RyYXdlcic7XG5pbXBvcnQgeyBpbml0VGFicyB9IGZyb20gJy4vY29tcG9uZW50cy90YWJzJztcbmltcG9ydCB7IGluaXRUb29sdGlwcyB9IGZyb20gJy4vY29tcG9uZW50cy90b29sdGlwJztcbmltcG9ydCB7IGluaXRQb3BvdmVycyB9IGZyb20gJy4vY29tcG9uZW50cy9wb3BvdmVyJztcbmltcG9ydCB7IGluaXREaWFscyB9IGZyb20gJy4vY29tcG9uZW50cy9kaWFsJztcbi8vIHNldHVwIGV2ZW50cyBmb3IgZGF0YSBhdHRyaWJ1dGVzXG52YXIgZXZlbnRzID0gbmV3IEV2ZW50cygnbG9hZCcsIFtcbiAgICBpbml0QWNjb3JkaW9ucyxcbiAgICBpbml0Q29sbGFwc2VzLFxuICAgIGluaXRDYXJvdXNlbHMsXG4gICAgaW5pdERpc21pc3NlcyxcbiAgICBpbml0RHJvcGRvd25zLFxuICAgIGluaXRNb2RhbHMsXG4gICAgaW5pdERyYXdlcnMsXG4gICAgaW5pdFRhYnMsXG4gICAgaW5pdFRvb2x0aXBzLFxuICAgIGluaXRQb3BvdmVycyxcbiAgICBpbml0RGlhbHMsXG5dKTtcbmV2ZW50cy5pbml0KCk7XG4vLyBleHBvcnQgYWxsIGNvbXBvbmVudHNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQWNjb3JkaW9uIH0gZnJvbSAnLi9jb21wb25lbnRzL2FjY29yZGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENhcm91c2VsIH0gZnJvbSAnLi9jb21wb25lbnRzL2Nhcm91c2VsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sbGFwc2UgfSBmcm9tICcuL2NvbXBvbmVudHMvY29sbGFwc2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEaWFsIH0gZnJvbSAnLi9jb21wb25lbnRzL2RpYWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEaXNtaXNzIH0gZnJvbSAnLi9jb21wb25lbnRzL2Rpc21pc3MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEcmF3ZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvZHJhd2VyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRHJvcGRvd24gfSBmcm9tICcuL2NvbXBvbmVudHMvZHJvcGRvd24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNb2RhbCB9IGZyb20gJy4vY29tcG9uZW50cy9tb2RhbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvcG92ZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvcG9wb3Zlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYnMgfSBmcm9tICcuL2NvbXBvbmVudHMvdGFicyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRvb2x0aXAgfSBmcm9tICcuL2NvbXBvbmVudHMvdG9vbHRpcCc7XG4vLyBleHBvcnQgYWxsIHR5cGVzXG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvYWNjb3JkaW9uL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9jYXJvdXNlbC90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvY29sbGFwc2UvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2RpYWwvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2Rpc21pc3MvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2RyYXdlci90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvZHJvcGRvd24vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL21vZGFsL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9wb3BvdmVyL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy90YWJzL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy90b29sdGlwL3R5cGVzJztcbi8vIGV4cG9ydCBhbGwgaW50ZXJmYWNlc1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2FjY29yZGlvbi9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2Nhcm91c2VsL2ludGVyZmFjZSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvY29sbGFwc2UvaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9kaWFsL2ludGVyZmFjZSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvZGlzbWlzcy9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2RyYXdlci9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2Ryb3Bkb3duL2ludGVyZmFjZSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvbW9kYWwvaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9wb3BvdmVyL2ludGVyZmFjZSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvdGFicy9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL3Rvb2x0aXAvaW50ZXJmYWNlJztcbi8vIGV4cG9ydCBpbml0IGZ1bmN0aW9uc1xuZXhwb3J0IHsgaW5pdEFjY29yZGlvbnMgfSBmcm9tICcuL2NvbXBvbmVudHMvYWNjb3JkaW9uJztcbmV4cG9ydCB7IGluaXRDYXJvdXNlbHMgfSBmcm9tICcuL2NvbXBvbmVudHMvY2Fyb3VzZWwnO1xuZXhwb3J0IHsgaW5pdENvbGxhcHNlcyB9IGZyb20gJy4vY29tcG9uZW50cy9jb2xsYXBzZSc7XG5leHBvcnQgeyBpbml0RGlhbHMgfSBmcm9tICcuL2NvbXBvbmVudHMvZGlhbCc7XG5leHBvcnQgeyBpbml0RGlzbWlzc2VzIH0gZnJvbSAnLi9jb21wb25lbnRzL2Rpc21pc3MnO1xuZXhwb3J0IHsgaW5pdERyYXdlcnMgfSBmcm9tICcuL2NvbXBvbmVudHMvZHJhd2VyJztcbmV4cG9ydCB7IGluaXREcm9wZG93bnMgfSBmcm9tICcuL2NvbXBvbmVudHMvZHJvcGRvd24nO1xuZXhwb3J0IHsgaW5pdE1vZGFscyB9IGZyb20gJy4vY29tcG9uZW50cy9tb2RhbCc7XG5leHBvcnQgeyBpbml0UG9wb3ZlcnMgfSBmcm9tICcuL2NvbXBvbmVudHMvcG9wb3Zlcic7XG5leHBvcnQgeyBpbml0VGFicyB9IGZyb20gJy4vY29tcG9uZW50cy90YWJzJztcbmV4cG9ydCB7IGluaXRUb29sdGlwcyB9IGZyb20gJy4vY29tcG9uZW50cy90b29sdGlwJztcbi8vIGV4cG9ydCBhbGwgaW5pdCBmdW5jdGlvbnNcbmV4cG9ydCB7IGluaXRGbG93Yml0ZSB9IGZyb20gJy4vY29tcG9uZW50cy9pbmRleCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQge01vZGFsLCBNb2RhbEludGVyZmFjZSwgTW9kYWxPcHRpb25zIH0gZnJvbSBcImZsb3diaXRlXCI7XG5pbXBvcnQgeyBJUHJvZHVjdEFsbG9jYXRlZEJhc2UgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5jb25zdCBjcmVhdGVJbmJvdW5kT3JkZXJIYW5kbGVyID0gKCkgPT4ge1xuICBjb25zdCBjcmVhdGVJbmJvdW5kT3JkZXJCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5ib3VuZC1vcmRlci1jcmVhdGUtYnRuJykgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gIGNvbnN0IGNyZWF0ZUluYm91bmRPcmRlckJ0blN1Ym1pdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbmJvdW5kLW9yZGVyLWFkZC1zdWJtaXQtYnRuJykgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gIGlmKCFjcmVhdGVJbmJvdW5kT3JkZXJCdG4pIHtcbiAgICBjb25zb2xlLmxvZyhcIkVycm9yOiBubyBjcmVhdGUgaW5ib3VuZCBvcmRlciBidXR0b25cIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3JlYXRlSW5ib3VuZE9yZGVyQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGNvbnN0IGFsbG9jYXRlZFByb2R1Y3RzRGF0YTogSVByb2R1Y3RBbGxvY2F0ZWRCYXNlW10gPSBbXVxuICAgIC8vIFNldCBwcm9kdWN0cyBhcyBKU09OIHRvIGZpZWxkXG4gICAgY29uc3QgcHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnByb2R1Y3QtYWxsb2NhdGVkJyk7XG5cbiAgICBwcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lcnMuZm9yRWFjaCgocHJvZHVjdENvbnRhaW5lcikgPT4ge1xuICAgICAgLy8gR2V0IEhUTUwgbm9kZXMgd2l0aCBwcm9kdWN0IHZhbHVlc1xuICAgICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZFNlbGVjdEhUTUwgPSBwcm9kdWN0Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LWFsbG9jYXRlZC1hZGQnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRRdWFudGl0eUlucHV0ID0gcHJvZHVjdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1hbGxvY2F0ZWQtcXVhbnRpdHknKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZVN0YXJ0SW5wdXQgPSBwcm9kdWN0Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LWFsbG9jYXRlZC1zaGVsZi1saWZlLXN0YXJ0JykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRTaGVsZkxpZmVFbmRJbnB1dCA9IHByb2R1Y3RDb250YWluZXIucXVlcnlTZWxlY3RvcignLnByb2R1Y3QtYWxsb2NhdGVkLXNoZWxmLWxpZmUtZW5kJykgYXMgSFRNTElucHV0RWxlbWVudDtcblxuICAgICAgLy8gUmV0cmlldmUgdmFsdWVzIGZyb20gTm9kZXNcbiAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRJZCA9IHBhcnNlSW50KHByb2R1Y3RBbGxvY2F0ZWRTZWxlY3RIVE1MLnZhbHVlKTtcbiAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRRdWFudGl0eSA9IHBhcnNlSW50KHByb2R1Y3RBbGxvY2F0ZWRRdWFudGl0eUlucHV0LnZhbHVlKTtcbiAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRTaGVsZkxpZmVTdGFydCA9IHByb2R1Y3RBbGxvY2F0ZWRTaGVsZkxpZmVTdGFydElucHV0LnZhbHVlO1xuICAgICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZUVuZCA9IHByb2R1Y3RBbGxvY2F0ZWRTaGVsZkxpZmVFbmRJbnB1dC52YWx1ZTtcblxuICAgICAgYWxsb2NhdGVkUHJvZHVjdHNEYXRhLnB1c2goe1xuICAgICAgICBpZDogcHJvZHVjdEFsbG9jYXRlZElkLFxuICAgICAgICBxdWFudGl0eTogcHJvZHVjdEFsbG9jYXRlZFF1YW50aXR5LFxuICAgICAgICBzaGVsZkxpZmVTdGFydDogcHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZVN0YXJ0LFxuICAgICAgICBzaGVsZkxpZmVFbmQ6IHByb2R1Y3RBbGxvY2F0ZWRTaGVsZkxpZmVFbmQsXG4gICAgICB9KVxuICAgIH0pO1xuXG4gICAgY29uc3QgaW5wdXRQcm9kdWN0czogSFRNTElucHV0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCNpbmJvdW5kLW9yZGVyLWFkZC1wcm9kdWN0c2ApXG4gICAgaW5wdXRQcm9kdWN0cy52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KGFsbG9jYXRlZFByb2R1Y3RzRGF0YSlcbiAgICBjcmVhdGVJbmJvdW5kT3JkZXJCdG5TdWJtaXQuY2xpY2soKVxuICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRBZGRJbmJvdW5kT3JkZXJNb2RhbCA9ICgpID0+IHtcbiAgY29uc3QgYWRkTW9kYWxCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci1hZGQtbW9kYWwtYnV0dG9uJyk7XG4gIGNvbnN0IGFkZEluYm91bmRPcmRlck1vZGFsRWxlbWVudDogSFRNTEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYWRkLWluYm91bmQtb3JkZXItbW9kYWwnKVxuICBjb25zdCBhZGRNb2RhbE9wdGlvbnM6IE1vZGFsT3B0aW9ucyA9IHtcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20tcmlnaHQnLFxuICAgIGJhY2tkcm9wOiAnZHluYW1pYycsXG4gICAgYmFja2Ryb3BDbGFzc2VzOiAnYmctZ3JheS05MDAgYmctb3BhY2l0eS01MCBkYXJrOmJnLW9wYWNpdHktODAgZml4ZWQgaW5zZXQtMCB6LTQwJyxcbiAgICBjbG9zYWJsZTogdHJ1ZSxcbiAgICBvbkhpZGU6ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdpbmJvdW5kLW9yZGVyIGlkOiAnKVxuICAgIH0sXG4gICAgb25TaG93OiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnaW5ib3VuZC1vcmRlciBpZDogJylcbiAgICB9LFxuICAgIG9uVG9nZ2xlOiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnbW9kYWwgaGFzIGJlZW4gdG9nZ2xlZCcpXG4gICAgfSxcbiAgfVxuXG4gIGNvbnN0IGFkZE1vZGFsOiBNb2RhbEludGVyZmFjZSA9IG5ldyBNb2RhbChhZGRJbmJvdW5kT3JkZXJNb2RhbEVsZW1lbnQsIGFkZE1vZGFsT3B0aW9ucyk7XG4gIGFkZE1vZGFsQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4geyAgICBcbiAgICBhZGRNb2RhbC5zaG93KCk7XG4gIH0pO1xuXG4gIGNvbnN0IGFkZE1vZGFsQ2xvc2VCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYWRkLW1vZGFsLWJ0bi1oaWRlJykgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gIGFkZE1vZGFsQ2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgYWRkTW9kYWwuaGlkZSgpO1xuICB9KVxuXG4gIGNyZWF0ZUluYm91bmRPcmRlckhhbmRsZXIoKTtcbn0iLCJpbXBvcnQgeyBNb2RhbE9wdGlvbnMsIE1vZGFsIH0gZnJvbSBcImZsb3diaXRlXCI7XG5pbXBvcnQgeyBJSW5ib3VuZE9yZGVyT3V0LCBJUHJvZHVjdEdyb3VwQ3JlYXRlIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGdldERhdGVwaWNrZXJEYXRlRm9ybWF0IH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuXG5cbmNvbnN0IHNldE5ld1F1YW50aXR5VmlldyA9IChxdWFudGl0eUdyb3VwQ29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCkgPT4ge1xuICBjb25zdCBxdWFudGl0aWVzUGVyR3JvdXAgPSBxdWFudGl0eUdyb3VwQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5pbmJvdW5kLW9yZGVyLWVkaXQtYWRkLXF1YW50aXR5JykgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgY29uc3QgcXVhbnRpdHlWaWV3ID0gcXVhbnRpdHlHcm91cENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuaW5ib3VuZC1vcmRlci1lZGl0LWNoZWNrLXF1YW50aXR5JykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gIGxldCBxdWFudGl0eUF2YWlsYWJsZSA9IHBhcnNlSW50KHF1YW50aXR5Vmlldy5nZXRBdHRyaWJ1dGUoJ2RhdGEtcXVhbnRpdHknKSk7XG5cblxuICBsZXQgcXVhbnRpdHlUb3RhbCA9IDA7XG5cbiAgcXVhbnRpdGllc1Blckdyb3VwLmZvckVhY2gocXVhbnRpdHlQZXJHcm91cCA9PiB7XG4gICAgaWYgKHF1YW50aXR5UGVyR3JvdXAudmFsdWUpe1xuICAgICAgcXVhbnRpdHlUb3RhbCArPSBwYXJzZUludChxdWFudGl0eVBlckdyb3VwLnZhbHVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHF1YW50aXR5Vmlldy5pbm5lckhUTUwgPSAocXVhbnRpdHlBdmFpbGFibGUgLSBxdWFudGl0eVRvdGFsKS50b1N0cmluZygpO1xufVxuXG5jb25zdCBjcmVhdGVQcm9kdWN0R3JvdXAgPSAoYWxsb2NhdGVkUHJvZHVjdENvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBncm91cEl0ZW1UZW1wbGF0ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ncm91cC1xdWFudGl0eS1pdGVtJykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgY29uc3QgZ3JvdXBRdWFudGl0eUl0ZW1OZXcgPSBncm91cEl0ZW1UZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgZ3JvdXBRdWFudGl0eUl0ZW1OZXcuY2xhc3NMaXN0LnJlbW92ZSgnaW52aXNpYmxlJyk7XG5cbiAgICBjb25zdCBidXR0b25EZWxldGVRdWFudGl0eUdyb3VwID0gZ3JvdXBRdWFudGl0eUl0ZW1OZXcucXVlcnlTZWxlY3RvcignLnF1YW50aXR5LWdyb3VwLWRlbGV0ZS1idXR0b24nKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcblxuICAgIGJ1dHRvbkRlbGV0ZVF1YW50aXR5R3JvdXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgZ3JvdXBRdWFudGl0eUl0ZW1OZXcucmVtb3ZlKCk7XG4gICAgICBzZXROZXdRdWFudGl0eVZpZXcoYWxsb2NhdGVkUHJvZHVjdENvbnRhaW5lcik7XG4gICAgfSlcblxuICAgIGNvbnN0IHF1YW50aXR5SW5wdXQgPSBncm91cFF1YW50aXR5SXRlbU5ldy5xdWVyeVNlbGVjdG9yKCcuaW5ib3VuZC1vcmRlci1lZGl0LWFkZC1xdWFudGl0eScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgY29uc3QgcXVhbnRpdHlWaWV3ID0gYWxsb2NhdGVkUHJvZHVjdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuaW5ib3VuZC1vcmRlci1lZGl0LWNoZWNrLXF1YW50aXR5Jyk7XG4gICAgY29uc3QgcXVhbnRpdGllc0dyb3VwSW5wdXRzID0gYWxsb2NhdGVkUHJvZHVjdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuaW5ib3VuZC1vcmRlci1lZGl0LWFkZC1xdWFudGl0eScpIGFzIE5vZGVMaXN0T2Y8SFRNTElucHV0RWxlbWVudD47XG5cbiAgICBsZXQgcXVhbnRpdHlMZWZ0ID0gcGFyc2VJbnQocXVhbnRpdHlWaWV3LmdldEF0dHJpYnV0ZSgnZGF0YS1xdWFudGl0eScpKVxuICAgIHF1YW50aXRpZXNHcm91cElucHV0cy5mb3JFYWNoKHF1YW50aXR5R3JvdXBJbnB1dCA9PiB7XG4gICAgICBpZihxdWFudGl0eUdyb3VwSW5wdXQudmFsdWUpIHtcbiAgICAgICAgcXVhbnRpdHlMZWZ0IC09IHBhcnNlSW50KHF1YW50aXR5R3JvdXBJbnB1dC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSlcbiAgICBxdWFudGl0eUlucHV0LnZhbHVlID0gcXVhbnRpdHlMZWZ0LnRvU3RyaW5nKCk7XG4gICAgKGFsbG9jYXRlZFByb2R1Y3RDb250YWluZXIucXVlcnlTZWxlY3RvcignLmluYm91bmQtb3JkZXItYWRkLXByb2R1Y3QtZ3JvdXAtYnRuJykgYXMgSFRNTEJ1dHRvbkVsZW1lbnQpLmJlZm9yZShncm91cFF1YW50aXR5SXRlbU5ldyk7XG5cbiAgICBxdWFudGl0eUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcbiAgICAgIHNldE5ld1F1YW50aXR5VmlldyhhbGxvY2F0ZWRQcm9kdWN0Q29udGFpbmVyKTtcbiAgICB9KVxuICAgIHNldE5ld1F1YW50aXR5VmlldyhhbGxvY2F0ZWRQcm9kdWN0Q29udGFpbmVyKTtcbiAgICByZXR1cm4gZ3JvdXBRdWFudGl0eUl0ZW1OZXc7XG59XG5cblxuZXhwb3J0IGNvbnN0IGluaXRFZGl0T3JkZXJNb2RhbCA9ICgpID0+IHtcbiAgICAvLyBOb2Rlc1xuICAgIGNvbnN0IG9yZGVyRWRpdFByb2R1Y3RzQWxsb2NhdGVkQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItZWRpdC1jaGVjay1jb250YWluZXInKSBhcyBIVE1MRWxlbWVudDtcbiAgICBjb25zdCBvcmRlckVkaXRNb2RhbEhUTUwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZWRpdC1pbmJvdW5kLW9yZGVyLW1vZGFsJykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgY29uc3Qgb3JkZXJFZGl0QnV0dG9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5pbmJvdW5kLW9yZGVyLWVkaXQtYnV0dG9uJykgYXMgTm9kZUxpc3RPZjxIVE1MQnV0dG9uRWxlbWVudD47XG4gICAgY29uc3Qgb3JkZXJVdWlkSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci11dWlkJykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICBjb25zdCBvcmRlclN0YXR1c1NlbGVjdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLWVkaXQtc3RhdHVzJykgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XG4gICAgY29uc3Qgb3JkZXJUaXRsZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItZWRpdC1vcmRlci10aXRsZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgY29uc3Qgb3JkZXJBY3RpdmVEYXRlSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci1lZGl0LWFjdGl2ZS1kYXRlJykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICBjb25zdCBvcmRlckFjdGl2ZVRpbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLWVkaXQtYWN0aXZlLXRpbWUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGNvbnN0IG9yZGVyRGVsaXZlcnlEYXRlSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci1lZGl0LWRlbGl2ZXJ5LWRhdGUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGNvbnN0IG9yZGVyU3VwcGxpZXJJZFNlbGVjdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLWVkaXQtc3VwcGxpZXItaWQnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBjb25zdCBvcmRlcldhcmVob3VzZUlkU2VsZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItZWRpdC13YXJlaG91c2UtaWQnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBjb25zdCBvcmRlckVkaXRBZGRHcm91cEJ1dHRvblRlbXBsYXRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmluYm91bmQtb3JkZXItYWRkLXByb2R1Y3QtZ3JvdXAtYnRuJyk7XG5cbiAgICBjb25zdCBtb2RhbEVkaXRPcHRpb25zOiBNb2RhbE9wdGlvbnMgPSB7XG4gICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbS1yaWdodCcsXG4gICAgICAgIGJhY2tkcm9wOiAnZHluYW1pYycsXG4gICAgICAgIGJhY2tkcm9wQ2xhc3NlczogJ2JnLWdyYXktOTAwIGJnLW9wYWNpdHktNTAgZGFyazpiZy1vcGFjaXR5LTgwIGZpeGVkIGluc2V0LTAgei00MCcsXG4gICAgICAgIGNsb3NhYmxlOiB0cnVlLFxuICAgICAgICBvbkhpZGU6ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhvcmRlckVkaXRQcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lcik7XG4gICAgICAgICAgd2hpbGUgKG9yZGVyRWRpdFByb2R1Y3RzQWxsb2NhdGVkQ29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG9yZGVyRWRpdFByb2R1Y3RzQWxsb2NhdGVkQ29udGFpbmVyLnJlbW92ZUNoaWxkKG9yZGVyRWRpdFByb2R1Y3RzQWxsb2NhdGVkQ29udGFpbmVyLmxhc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGdyb3Vwc1F1YW50aXR5ID0gb3JkZXJFZGl0UHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLmdyb3VwLXF1YW50aXR5LWl0ZW0nKSBhcyBOb2RlTGlzdE9mPEhUTUxEaXZFbGVtZW50PjtcbiAgICAgICAgICBncm91cHNRdWFudGl0eS5mb3JFYWNoKGdyb3VwID0+IGdyb3VwLnJlbW92ZSgpKTtcblxuICAgICAgICAgIGNvbnN0IGJ1dHRvbnNBZGRHcm91cFF1YW50aXR5ID0gb3JkZXJFZGl0UHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLmluYm91bmQtb3JkZXItYWRkLXByb2R1Y3QtZ3JvdXAtYnRuJykgYXMgTm9kZUxpc3RPZjxIVE1MQnV0dG9uRWxlbWVudD47XG4gICAgICAgICAgYnV0dG9uc0FkZEdyb3VwUXVhbnRpdHkuZm9yRWFjaChidXR0b24gPT4gYnV0dG9uLnJlbW92ZSgpKTtcbiAgICAgICAgfSxcbiAgICB9XG4gICAgY29uc3Qgb3JkZXJFZGl0TW9kYWwgPSBuZXcgTW9kYWwob3JkZXJFZGl0TW9kYWxIVE1MLCBtb2RhbEVkaXRPcHRpb25zKTtcblxuICAgIGNvbnN0IGVkaXRNb2RhbENsb3NlQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2VkaXQtbW9kYWwtYnRuLWhpZGUnKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICBlZGl0TW9kYWxDbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIG9yZGVyRWRpdE1vZGFsLmhpZGUoKTtcbiAgICB9KVxuXG4gICAgb3JkZXJFZGl0QnV0dG9ucy5mb3JFYWNoKG9yZGVyRWRpdEJ1dHRvbiA9PiB7XG4gICAgICBjb25zdCBpbmJvdW5kT3JkZXJEYXRhID0gSlNPTi5wYXJzZShvcmRlckVkaXRCdXR0b24uZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpKSBhcyBJSW5ib3VuZE9yZGVyT3V0O1xuICAgICAgb3JkZXJFZGl0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAvLyBTZXQgb3JkZXIgZWRpdCBtb2RhbCB2YWx1ZXNcbiAgICAgICAgb3JkZXJVdWlkSW5wdXQudmFsdWUgPSBpbmJvdW5kT3JkZXJEYXRhLnV1aWQ7XG4gICAgICAgIG9yZGVyU3RhdHVzU2VsZWN0LnZhbHVlID0gaW5ib3VuZE9yZGVyRGF0YS5zdGF0dXM7XG4gICAgICAgIG9yZGVyVGl0bGVJbnB1dC52YWx1ZSA9IGluYm91bmRPcmRlckRhdGEudGl0bGU7XG4gICAgICAgIG9yZGVyQWN0aXZlRGF0ZUlucHV0LnZhbHVlID0gZ2V0RGF0ZXBpY2tlckRhdGVGb3JtYXQoaW5ib3VuZE9yZGVyRGF0YS5hY3RpdmVEYXRlKTtcbiAgICAgICAgb3JkZXJBY3RpdmVUaW1lSW5wdXQudmFsdWUgPSBpbmJvdW5kT3JkZXJEYXRhLmFjdGl2ZVRpbWU7XG4gICAgICAgIG9yZGVyRGVsaXZlcnlEYXRlSW5wdXQudmFsdWUgPSBnZXREYXRlcGlja2VyRGF0ZUZvcm1hdChpbmJvdW5kT3JkZXJEYXRhLmRlbGl2ZXJ5RGF0ZSk7XG4gICAgICAgIG9yZGVyU3VwcGxpZXJJZFNlbGVjdC52YWx1ZSA9IGluYm91bmRPcmRlckRhdGEuc3VwcGxpZXIuaWQudG9TdHJpbmcoKTtcbiAgICAgICAgb3JkZXJXYXJlaG91c2VJZFNlbGVjdC52YWx1ZSA9IGluYm91bmRPcmRlckRhdGEud2FyZWhvdXNlLmlkLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmJvdW5kT3JkZXJEYXRhLnByb2R1Y3RzQWxsb2NhdGVkLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgICAgICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZEVkaXRWaWV3ID0gb3JkZXJFZGl0UHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIuY2hpbGRyZW5bMF0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgIG9yZGVyRWRpdFByb2R1Y3RzQWxsb2NhdGVkQ29udGFpbmVyLmFwcGVuZENoaWxkKHByb2R1Y3RBbGxvY2F0ZWRFZGl0Vmlldyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmJvdW5kT3JkZXJEYXRhLnByb2R1Y3RzQWxsb2NhdGVkLmZvckVhY2goKHByb2R1Y3RBbGxvY2F0ZWQsIGkpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50UHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lciA9IG9yZGVyRWRpdFByb2R1Y3RzQWxsb2NhdGVkQ29udGFpbmVyLmNoaWxkcmVuW2ldO1xuICAgICAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRJZElucHV0ID0gY3VycmVudFByb2R1Y3RBbGxvY2F0ZWRDb250YWluZXIucXVlcnlTZWxlY3RvcignLnByb2R1Y3QtYWxsb2NhdGVkLWlkJykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkTmFtZURpdiA9IGN1cnJlbnRQcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbmJvdW5kLW9yZGVyLWVkaXQtY2hlY2stcHJvZHVjdCcpIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgICAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRRdWFudGl0eURpdiA9IGN1cnJlbnRQcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbmJvdW5kLW9yZGVyLWVkaXQtY2hlY2stcXVhbnRpdHknKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkU2hlbGZMaWZlRnJvbURpdiA9IGN1cnJlbnRQcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbmJvdW5kLW9yZGVyLWVkaXQtc2hlbGYtbGlmZS1mcm9tJykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgICAgICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZVRvRGl2ID0gY3VycmVudFByb2R1Y3RBbGxvY2F0ZWRDb250YWluZXIucXVlcnlTZWxlY3RvcignLmluYm91bmQtb3JkZXItZWRpdC1zaGVsZi1saWZlLXRvJykgYXMgSFRNTERpdkVsZW1lbnQ7XG5cbiAgICAgICAgICBwcm9kdWN0QWxsb2NhdGVkSWRJbnB1dC52YWx1ZSA9IHByb2R1Y3RBbGxvY2F0ZWQuaWQudG9TdHJpbmcoKTtcblxuICAgICAgICAgIHByb2R1Y3RBbGxvY2F0ZWROYW1lRGl2LmlubmVySFRNTCA9IHByb2R1Y3RBbGxvY2F0ZWQucHJvZHVjdC5uYW1lO1xuICAgICAgICAgIHByb2R1Y3RBbGxvY2F0ZWRRdWFudGl0eURpdi5pbm5lckhUTUwgPSBwcm9kdWN0QWxsb2NhdGVkLnF1YW50aXR5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgcHJvZHVjdEFsbG9jYXRlZFF1YW50aXR5RGl2LnNldEF0dHJpYnV0ZSgnZGF0YS1xdWFudGl0eScsIHByb2R1Y3RBbGxvY2F0ZWQucXVhbnRpdHkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgcHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZUZyb21EaXYuaW5uZXJIVE1MID0gZ2V0RGF0ZXBpY2tlckRhdGVGb3JtYXQocHJvZHVjdEFsbG9jYXRlZC5zaGVsZkxpZmVTdGFydCk7XG4gICAgICAgICAgcHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZVRvRGl2LmlubmVySFRNTCA9IGdldERhdGVwaWNrZXJEYXRlRm9ybWF0KHByb2R1Y3RBbGxvY2F0ZWQuc2hlbGZMaWZlRW5kKTtcblxuICAgICAgICAgIGNvbnN0IGJ1dHRvbkFkZE5ld0dyb3VwID0gb3JkZXJFZGl0QWRkR3JvdXBCdXR0b25UZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgICAgICAgLy8gY3VycmVudCBwb2ludFxuICAgICAgICAgIGJ1dHRvbkFkZE5ld0dyb3VwLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gY3JlYXRlUHJvZHVjdEdyb3VwKGN1cnJlbnRQcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyIGFzIEhUTUxEaXZFbGVtZW50KSk7XG5cbiAgICAgICAgICAocHJvZHVjdEFsbG9jYXRlZFNoZWxmTGlmZVRvRGl2LnBhcmVudE5vZGUucGFyZW50Tm9kZSBhcyBIVE1MRGl2RWxlbWVudCkuYWZ0ZXIoYnV0dG9uQWRkTmV3R3JvdXApO1xuICAgICAgICAgIGJ1dHRvbkFkZE5ld0dyb3VwLmNsYXNzTGlzdC5yZW1vdmUoJ2ludmlzaWJsZScpO1xuXG4gICAgICAgICAgcHJvZHVjdEFsbG9jYXRlZC5wcm9kdWN0UXVhbnRpdHlHcm91cHMuZm9yRWFjaChxdWFudGl0eUdyb3VwID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5R3JvdXBDb250YWluZXIgPSBjcmVhdGVQcm9kdWN0R3JvdXAoY3VycmVudFByb2R1Y3RBbGxvY2F0ZWRDb250YWluZXIgYXMgSFRNTERpdkVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBTZWxlY3QgPSBxdWFudGl0eUdyb3VwQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbmJvdW5kLW9yZGVyLWVkaXQtYWRkLWdyb3VwJykgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBncm91cFF1YW50aXR5SW5wdXQgPSBxdWFudGl0eUdyb3VwQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbmJvdW5kLW9yZGVyLWVkaXQtYWRkLXF1YW50aXR5JykgYXMgSFRNTElucHV0RWxlbWVudDtcblxuICAgICAgICAgICAgZ3JvdXBTZWxlY3QudmFsdWUgPSBxdWFudGl0eUdyb3VwLmdyb3VwLmlkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBncm91cFF1YW50aXR5SW5wdXQudmFsdWUgPSBxdWFudGl0eUdyb3VwLnF1YW50aXR5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0TmV3UXVhbnRpdHlWaWV3KGN1cnJlbnRQcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyIGFzIEhUTUxEaXZFbGVtZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb3JkZXJFZGl0TW9kYWwuc2hvdygpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBzdWJtaXQgdXBkYXRlIG9yZGVyXG4gICAgY29uc3QgYnV0dG9uU2F2ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLXNhdmUtcHJvZHVjdHMtYnRuJykgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgYnV0dG9uU2F2ZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRHcm91cHNDb250YWluZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnByb2R1Y3QtYWxsb2NhdGVkLWdyb3Vwcy1jb250YWluZXInKSBhcyBOb2RlTGlzdE9mPEhUTUxEaXZFbGVtZW50PjtcbiAgICAgIGNvbnN0IHByb2R1Y3RHcm91cHM6IElQcm9kdWN0R3JvdXBDcmVhdGVbXSA9IFtdO1xuXG4gICAgICBwcm9kdWN0QWxsb2NhdGVkR3JvdXBzQ29udGFpbmVycy5mb3JFYWNoKHByb2R1Y3RHcm91cENvbnRhaW5lciA9PiB7XG4gICAgICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWRJZElucHV0ID0gcHJvZHVjdEdyb3VwQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LWFsbG9jYXRlZC1pZCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gIFxuICAgICAgICBjb25zdCBwcm9kdWN0R3JvdXBDcmVhdGU6IElQcm9kdWN0R3JvdXBDcmVhdGUgPSB7XG4gICAgICAgICAgcHJvZHVjdEFsbG9jYXRlZElkOiBwYXJzZUludChwcm9kdWN0QWxsb2NhdGVkSWRJbnB1dC52YWx1ZSksXG4gICAgICAgICAgcHJvZHVjdEFsbG9jYXRlZEdyb3VwczogW10sXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGdyb3VwUXVhbnRpdHlJdGVtcyA9IHByb2R1Y3RHcm91cENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcuZ3JvdXAtcXVhbnRpdHktaXRlbScpIGFzIE5vZGVMaXN0T2Y8SFRNTERpdkVsZW1lbnQ+O1xuICAgICAgICBncm91cFF1YW50aXR5SXRlbXMuZm9yRWFjaChxdWFudGl0eUl0ZW0gPT4ge1xuICAgICAgICAgIGNvbnN0IGdyb3VwSWRTZWxlY3QgPSBxdWFudGl0eUl0ZW0ucXVlcnlTZWxlY3RvcignLmluYm91bmQtb3JkZXItZWRpdC1hZGQtZ3JvdXAnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICAgICAgICBjb25zdCBncm91cFF1YW50aXR5SW5wdXQgPSBxdWFudGl0eUl0ZW0ucXVlcnlTZWxlY3RvcignLmluYm91bmQtb3JkZXItZWRpdC1hZGQtcXVhbnRpdHknKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXG4gICAgICAgICAgaWYgKGdyb3VwSWRTZWxlY3QudmFsdWUgJiYgZ3JvdXBRdWFudGl0eUlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cElkID0gcGFyc2VJbnQoZ3JvdXBJZFNlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBncm91cFF1YW50aXR5ID0gcGFyc2VJbnQoZ3JvdXBRdWFudGl0eUlucHV0LnZhbHVlKVxuXG4gICAgICAgICAgICBwcm9kdWN0R3JvdXBDcmVhdGUucHJvZHVjdEFsbG9jYXRlZEdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgICAgICAgICAgcXVhbnRpdHk6IGdyb3VwUXVhbnRpdHksXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9kdWN0R3JvdXBzLnB1c2gocHJvZHVjdEdyb3VwQ3JlYXRlKTtcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHByb2R1Y3RHcm91cHNRdWFudGl0aWVzSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci1lZGl0LXByb2R1Y3QtcXVhbnRpdGllcycpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICBwcm9kdWN0R3JvdXBzUXVhbnRpdGllc0lucHV0LnZhbHVlID0gSlNPTi5zdHJpbmdpZnkocHJvZHVjdEdyb3Vwcyk7XG5cbiAgICAgIGNvbnN0IGJ1dHRvblN1Ym1pdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLXN1Ym1pdC1idG4nKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICAgIGJ1dHRvblN1Ym1pdC5jbGljaygpO1xuICAgIH0pO1xufSIsImltcG9ydCB7IElucHV0LCBUaW1lcGlja2VyLCBpbml0VEUgfSBmcm9tICd0dy1lbGVtZW50cydcbmltcG9ydCB7IElJbmJvdW5kT3JkZXJCYXNlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBpbml0QWRkSW5ib3VuZE9yZGVyTW9kYWwgfSBmcm9tICcuL2FkZCc7XG5pbXBvcnQgeyBpbml0Vmlld0luYm91bmRPcmRlck1vZGFsIH0gZnJvbSAnLi92aWV3JztcbmltcG9ydCB7aW5pdEVkaXRPcmRlck1vZGFsfSBmcm9tICcuL2VkaXQnO1xuXG5pbml0VEUoeyBJbnB1dCwgVGltZXBpY2tlciB9KVxuXG5jb25zdCAkYnV0dG9uRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaW5ib3VuZC1vcmRlci1lZGl0LWJ1dHRvbicpO1xuJGJ1dHRvbkVsZW1lbnRzLmZvckVhY2goKGUpID0+XG4gICAgZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgY29uc3QgaW5ib3VuZE9yZGVyOiBJSW5ib3VuZE9yZGVyQmFzZSA9IEpTT04ucGFyc2UoZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykpXG4gICAgfSlcbik7XG5cbi8vIHNlYXJjaCBmbG93XG5jb25zdCBzZWFyY2hJbnB1dDogSFRNTElucHV0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0YWJsZS1zZWFyY2gtaW5ib3VuZC1vcmRlcnMnKTtcbmNvbnN0IHNlYXJjaElucHV0QnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RhYmxlLXNlYXJjaC1pbmJvdW5kLW9yZGVyLWJ1dHRvbicpO1xuaWYgKHNlYXJjaElucHV0QnV0dG9uICYmIHNlYXJjaElucHV0KSB7XG4gICAgc2VhcmNoSW5wdXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgncScsIHNlYXJjaElucHV0LnZhbHVlKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBgJHt1cmwuaHJlZn1gO1xuICAgIH0pXG59XG5jb25zdCBkZWxldGVCdXR0b25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRlbGV0ZS1pbmJvdW5kLW9yZGVyLWJ0bicpO1xuXG5kZWxldGVCdXR0b25zLmZvckVhY2goKGUpID0+IHtcbiAgICBlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoY29uZmlybSgnQXJlIHN1cmU/JykpIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGUuZ2V0QXR0cmlidXRlKCdkYXRhLWluYm91bmQtb3JkZXItaWQnKVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2luYm91bmRfb3JkZXIvZGVsZXRlLyR7aWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcbn0pXG5cblxuXG5jb25zdCBvcGVuQ3VycmVudE9yZGVyID0gKCkgPT57XG4gIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gIGNvbnN0IG9yZGVyVXVpZCA9IHVybFBhcmFtcy5nZXQoJ2N1cnJlbnRfb3JkZXJfdXVpZCcpO1xuICBjb25zb2xlLmxvZyhvcmRlclV1aWQpO1xuICBpZighb3JkZXJVdWlkKXtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBvcmRlckNvbHVtbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCNpbmJvdW5kLW9yZGVyLSR7b3JkZXJVdWlkfWApO1xuXG4gIGlmICghb3JkZXJDb2x1bW4pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBvcmRlckVkaXRCdXR0b24gPSBvcmRlckNvbHVtbi5xdWVyeVNlbGVjdG9yKCcuaW5ib3VuZC1vcmRlci1lZGl0LWJ1dHRvbicpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICBvcmRlckVkaXRCdXR0b24uY2xpY2soKTsgIFxufVxuXG5jb25zdCBkZWxldGVBbGxvY2F0ZWRQcm9kdWN0ID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyID0gKGUuY3VycmVudFRhcmdldCBhcyBIVE1MU3BhbkVsZW1lbnQpLnBhcmVudE5vZGUgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgY29uc3QgcHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIgPSBwcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyLnBhcmVudE5vZGUgYXMgSFRNTERpdkVsZW1lbnQ7XG5cbiAgICBwcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyLnJlbW92ZSgpXG4gICAgY29uc29sZS5sb2cocHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoKVxuICAgIGlmIChwcm9kdWN0c0FsbG9jYXRlZENvbnRhaW5lci5jaGlsZHJlbi5sZW5ndGggPT0gMikge1xuICAgICAgICBjb25zdCBwcm9kdWN0QWxsb2NhdGVkRGVsZXRlQnV0dG9uID0gcHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIucXVlcnlTZWxlY3RvcignLnByb2R1Y3QtYWxsb2NhdGVkLWRlbGV0ZS1idXR0b24nKTtcbiAgICAgICAgY29uc29sZS5sb2cocHJvZHVjdEFsbG9jYXRlZERlbGV0ZUJ1dHRvbilcbiAgICAgICAgcHJvZHVjdEFsbG9jYXRlZERlbGV0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdpbnZpc2libGUnKTtcbiAgICB9XG59XG5cbmNvbnN0IGNyZWF0ZUFsbG9jYXRpb25Qcm9kdWN0Q29udGFpbmVyID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBjb25zdCBidG4gPSBlLmN1cnJlbnRUYXJnZXQgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgY29uc3QgcHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LWFsbG9jYXRlZCcpLnBhcmVudE5vZGUgYXMgSFRNTERpdkVsZW1lbnQ7XG5cbiAgICBpZihwcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyLnBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoID09IDIpe1xuICAgICAgICBjb25zdCBidXR0b25SZW1vdmVQcm9kdWN0QWxsb2NhdGVkID0gcHJvZHVjdEFsbG9jYXRlZENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1hbGxvY2F0ZWQtZGVsZXRlLWJ1dHRvbicpO1xuICAgICAgICBidXR0b25SZW1vdmVQcm9kdWN0QWxsb2NhdGVkLmNsYXNzTGlzdC5yZW1vdmUoJ2ludmlzaWJsZScpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2R1Y3RBbGxvY2F0ZWROZXcgPSBwcm9kdWN0QWxsb2NhdGVkQ29udGFpbmVyLmNsb25lTm9kZSh0cnVlKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAvLyBDbGVhciBpbnB1dHNcbiAgICBwcm9kdWN0QWxsb2NhdGVkTmV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JykuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgfSlcblxuICAgIGNvbnN0IGJ1dHRvbkRlbGV0ZUFsbG9jYXRlZFByb2R1Y3QgPSBwcm9kdWN0QWxsb2NhdGVkTmV3LnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LWFsbG9jYXRlZC1kZWxldGUtYnV0dG9uJyk7XG4gICAgYnV0dG9uRGVsZXRlQWxsb2NhdGVkUHJvZHVjdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGRlbGV0ZUFsbG9jYXRlZFByb2R1Y3QpO1xuXG4gICAgY29uc3QgcHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIgPSBidG4ucGFyZW50Tm9kZS5wYXJlbnROb2RlIGFzIEhUTUxEaXZFbGVtZW50O1xuXG4gICAgcHJvZHVjdHNBbGxvY2F0ZWRDb250YWluZXIuaW5zZXJ0QmVmb3JlKHByb2R1Y3RBbGxvY2F0ZWROZXcsIGJ0bi5wYXJlbnROb2RlKTtcbn1cblxuLy8gIyBOT1RFOiBkZXBlbmRzIG9uIGZsYXNoIGZyb20gY3JlYXRlIHJvdXRlIG9uIGluYm91bmRfb3JkZXJfYmx1ZXByaW50XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgIC8vIHZpZXcgb3JkZXJcbiAgICBpbml0Vmlld0luYm91bmRPcmRlck1vZGFsKCk7XG4gICAgLy8gQWRkIG5ldyBpbmJvdW5kIG9yZGVyIGhhbmRsZXJcbiAgICBpbml0QWRkSW5ib3VuZE9yZGVyTW9kYWwoKTtcbiAgICAvLyBBZGQgZWRpdCBpbmJvdW5kIG9yZGVyIGhhbmRsZXJcbiAgICBpbml0RWRpdE9yZGVyTW9kYWwoKVxuICBcbiAgICBjb25zdCBidXR0b25BbGxvY2F0ZVByb2R1Y3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5ib3VuZC1vcmRlci1hbGxvY2F0ZS1wcm9kdWN0LWJ0bicpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICAgIGJ1dHRvbkFsbG9jYXRlUHJvZHVjdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNyZWF0ZUFsbG9jYXRpb25Qcm9kdWN0Q29udGFpbmVyKTtcblxuICAgIGNvbnN0IGJ1dHRvbkRlbGV0ZUFsbG9jYXRlZFByb2R1Y3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1hbGxvY2F0ZWQtZGVsZXRlLWJ1dHRvbicpO1xuICAgIGJ1dHRvbkRlbGV0ZUFsbG9jYXRlZFByb2R1Y3QuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBkZWxldGVBbGxvY2F0ZWRQcm9kdWN0KTtcblxuICAgIC8vIE9wZW4gY3VycmVudCBvcmRlclxuICAgIG9wZW5DdXJyZW50T3JkZXIoKTtcbn0pOyIsImV4cG9ydCBjb25zdCBnZXREYXRlcGlja2VyRGF0ZUZvcm1hdCA9IChkYXRlU3RyaW5nOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHJpbmcpO1xuICBjb25zdCBkYXRlUGFydHMgPSBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpLnNwbGl0KCcvJyk7XG5cbiAgY29uc3QgdG1wID0gZGF0ZVBhcnRzWzBdO1xuICBkYXRlUGFydHNbMF0gPSBkYXRlUGFydHNbMV07XG4gIGRhdGVQYXJ0c1sxXSA9IHRtcDtcblxuICByZXR1cm4gZGF0ZVBhcnRzLmpvaW4oJy8nKTtcbn0iLCJpbXBvcnQgeyBNb2RhbCB9IGZyb20gJ2Zsb3diaXRlJ1xuaW1wb3J0IHR5cGUgeyBNb2RhbE9wdGlvbnMgfSBmcm9tICdmbG93Yml0ZSdcbmltcG9ydCB7IElJbmJvdW5kT3JkZXJPdXQgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGdldERhdGVwaWNrZXJEYXRlRm9ybWF0IH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjb25zdCBpbml0Vmlld0luYm91bmRPcmRlck1vZGFsID0gKCkgPT4ge1xuICAgIC8vIG1vZGFsIE5vZGVzXG4gICAgY29uc3Qgdmlld0luYm91bmRPcmRlck1vZGFsRWxlbWVudDogSFRNTERpdkVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdmlldy1pbmJvdW5kLW9yZGVyLW1vZGFsJykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgY29uc3Qgb3JkZXJJZFZpZXcgPSB2aWV3SW5ib3VuZE9yZGVyTW9kYWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLXZpZXctb3JkZXJfaWQnKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICBjb25zdCBvcmRlclN0YXR1cyA9IHZpZXdJbmJvdW5kT3JkZXJNb2RhbEVsZW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItdmlldy1zdGF0dXMnKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICBjb25zdCBvcmRlckFjdGl2ZURhdGUgPSB2aWV3SW5ib3VuZE9yZGVyTW9kYWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLXZpZXctYWN0aXZlX2RhdGUnKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICBjb25zdCBvcmRlckFjdGl2ZVRpbWUgPSB2aWV3SW5ib3VuZE9yZGVyTW9kYWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLXZpZXctYWN0aXZlX3RpbWUnKSBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICBjb25zdCBvcmRlclRpdGxlID0gdmlld0luYm91bmRPcmRlck1vZGFsRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci12aWV3LW9yZGVyX3RpdGxlJykgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgY29uc3Qgb3JkZXJEZWxpdmVyeURhdGUgPSB2aWV3SW5ib3VuZE9yZGVyTW9kYWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmJvdW5kLW9yZGVyLXZpZXctZGVsaXZlcnlfZGF0ZScpIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgIGNvbnN0IG9yZGVyV2FyZWhvdXNlTmFtZSA9IHZpZXdJbmJvdW5kT3JkZXJNb2RhbEVsZW1lbnQucXVlcnlTZWxlY3RvcignI2luYm91bmQtb3JkZXItdmlldy13YXJlaG91c2UtbmFtZScpIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgIGNvbnN0IG9yZGVyU3VwcGxpZXJOYW1lID0gdmlld0luYm91bmRPcmRlck1vZGFsRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci12aWV3LXN1cHBsaWVyLW5hbWUnKVxuICAgIGNvbnN0IG9yZGVyU3VwcGxpZXJBZGRyZXNzID0gdmlld0luYm91bmRPcmRlck1vZGFsRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcjaW5ib3VuZC1vcmRlci12aWV3LXN1cHBsaWVyLWFkZHJlc3MnKVxuXG4gICAgY29uc3QgbW9kYWxWaWV3RGl2cyA9IFtvcmRlcklkVmlldywgb3JkZXJTdGF0dXMsIG9yZGVyQWN0aXZlRGF0ZSwgb3JkZXJBY3RpdmVUaW1lLCBvcmRlclRpdGxlLCBvcmRlckRlbGl2ZXJ5RGF0ZSwgb3JkZXJXYXJlaG91c2VOYW1lLCBvcmRlclN1cHBsaWVyTmFtZSwgb3JkZXJTdXBwbGllckFkZHJlc3NdO1xuICAgIC8vIGNyZWF0ZSBtb2RhbFxuICAgIGNvbnN0IHZpZXdNb2RhbE9wdGlvbnM6IE1vZGFsT3B0aW9ucyA9IHtcbiAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tLXJpZ2h0JyxcbiAgICAgICAgYmFja2Ryb3A6ICdkeW5hbWljJyxcbiAgICAgICAgYmFja2Ryb3BDbGFzc2VzOiAnYmctZ3JheS05MDAgYmctb3BhY2l0eS01MCBkYXJrOmJnLW9wYWNpdHktODAgZml4ZWQgaW5zZXQtMCB6LTQwJyxcbiAgICAgICAgY2xvc2FibGU6IHRydWUsXG4gICAgICAgIG9uSGlkZTogKCkgPT4ge1xuICAgICAgICAgICAgbW9kYWxWaWV3RGl2cy5mb3JFYWNoKG1vZGFsRGl2ID0+IHtcbiAgICAgICAgICAgICAgbW9kYWxEaXYuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCB2aWV3TW9kYWwgPSBuZXcgTW9kYWwodmlld0luYm91bmRPcmRlck1vZGFsRWxlbWVudCwgdmlld01vZGFsT3B0aW9ucyk7XG4gICAgY29uc3Qgb3JkZXJWaWV3QnV0dG9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5pbmJvdW5kLW9yZGVyLXZpZXctYnV0dG9uJyk7XG4gICAgb3JkZXJWaWV3QnV0dG9ucy5mb3JFYWNoKCh2aWV3QnV0dG9uKSA9PiB7XG4gICAgICBjb25zdCBpbmJvdW5kT3JkZXJEYXRhID0gSlNPTi5wYXJzZSh2aWV3QnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKSkgYXMgSUluYm91bmRPcmRlck91dDtcbiAgICAgIC8vIE5vZGVzXG4gICAgICB2aWV3QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAvLyBGaWxsIG9yZGVyIHZpZXcgbW9kYWwgZGF0YVxuICAgICAgICBvcmRlcklkVmlldy5pbm5lckhUTUwgPSBpbmJvdW5kT3JkZXJEYXRhLm9yZGVySWQ7XG4gICAgICAgIG9yZGVyU3RhdHVzLmlubmVySFRNTCA9IGluYm91bmRPcmRlckRhdGEuc3RhdHVzO1xuICAgICAgICBvcmRlckFjdGl2ZURhdGUuaW5uZXJIVE1MID0gZ2V0RGF0ZXBpY2tlckRhdGVGb3JtYXQoaW5ib3VuZE9yZGVyRGF0YS5hY3RpdmVEYXRlKTtcbiAgICAgICAgb3JkZXJBY3RpdmVUaW1lLmlubmVySFRNTCA9IGluYm91bmRPcmRlckRhdGEuYWN0aXZlVGltZTtcbiAgICAgICAgb3JkZXJUaXRsZS5pbm5lckhUTUwgPSBpbmJvdW5kT3JkZXJEYXRhLnRpdGxlO1xuICAgICAgICBvcmRlckRlbGl2ZXJ5RGF0ZS5pbm5lckhUTUwgPSBnZXREYXRlcGlja2VyRGF0ZUZvcm1hdChpbmJvdW5kT3JkZXJEYXRhLmRlbGl2ZXJ5RGF0ZSk7XG4gICAgICAgIG9yZGVyV2FyZWhvdXNlTmFtZS5pbm5lckhUTUwgPSBpbmJvdW5kT3JkZXJEYXRhLndhcmVob3VzZS5uYW1lO1xuICAgICAgICBvcmRlclN1cHBsaWVyTmFtZS5pbm5lckhUTUwgPSBpbmJvdW5kT3JkZXJEYXRhLnN1cHBsaWVyLm5hbWU7XG4gICAgICAgIG9yZGVyU3VwcGxpZXJBZGRyZXNzLmlubmVySFRNTCA9IGluYm91bmRPcmRlckRhdGEuc3VwcGxpZXIuYWRkcmVzcztcblxuICAgICAgICB2aWV3TW9kYWwuc2hvdygpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB2aWV3TW9kYWxDbG9zZUJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN2aWV3LW1vZGFsLWJ0bi1oaWRlJykgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgdmlld01vZGFsQ2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB2aWV3TW9kYWwuaGlkZSgpO1xuICAgIH0pXG59IiwiLyohXG4qIFRhbGl3aW5kIEVsZW1lbnRzIDEuMC4wLWJldGEyXG4qIFxuKiBUYWlsd2luZCBFbGVtZW50cyBpcyBhbiBvcGVuLXNvdXJjZSBVSSBraXQgb2YgYWR2YW5jZWQgY29tcG9uZW50cyBmb3IgVGFpbHdpbmRDU1MuXG4qIENvcHlyaWdodCDCqSAyMDIzIE1EQm9vdHN0cmFwLmNvbVxuKiBcbiogVW5sZXNzIGEgY3VzdG9tLCBpbmRpdmlkdWFsbHkgYXNzaWduZWQgbGljZW5zZSBoYXMgYmVlbiBncmFudGVkLCB0aGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiogSW4gYWRkaXRpb24sIGEgY3VzdG9tIGxpY2Vuc2UgbWF5IGJlIGF2YWlsYWJsZSB1cG9uIHJlcXVlc3QsIHN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mIHRoYXQgbGljZW5zZS4gUGxlYXNlIGNvbnRhY3QgdGFpbHdpbmRAbWRib290c3RyYXAuY29tIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIG9idGFpbmluZyBhIGN1c3RvbSBsaWNlbnNlLlxuKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuKiBcbiovXG52YXIgWGwgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgR2wgPSAocywgdCwgZSkgPT4gdCBpbiBzID8gWGwocywgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogZSB9KSA6IHNbdF0gPSBlO1xudmFyIFR0ID0gKHMsIHQsIGUpID0+IChHbChzLCB0eXBlb2YgdCAhPSBcInN5bWJvbFwiID8gdCArIFwiXCIgOiB0LCBlKSwgZSk7XG5jb25zdCBCcyA9ICgoKSA9PiB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgbGV0IHQgPSAxO1xuICByZXR1cm4ge1xuICAgIHNldChlLCBpLCBuKSB7XG4gICAgICB0eXBlb2YgZVtpXSA+IFwidVwiICYmIChlW2ldID0ge1xuICAgICAgICBrZXk6IGksXG4gICAgICAgIGlkOiB0XG4gICAgICB9LCB0KyspLCBzW2VbaV0uaWRdID0gbjtcbiAgICB9LFxuICAgIGdldChlLCBpKSB7XG4gICAgICBpZiAoIWUgfHwgdHlwZW9mIGVbaV0gPiBcInVcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBuID0gZVtpXTtcbiAgICAgIHJldHVybiBuLmtleSA9PT0gaSA/IHNbbi5pZF0gOiBudWxsO1xuICAgIH0sXG4gICAgZGVsZXRlKGUsIGkpIHtcbiAgICAgIGlmICh0eXBlb2YgZVtpXSA+IFwidVwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBuID0gZVtpXTtcbiAgICAgIG4ua2V5ID09PSBpICYmIChkZWxldGUgc1tuLmlkXSwgZGVsZXRlIGVbaV0pO1xuICAgIH1cbiAgfTtcbn0pKCksIEkgPSB7XG4gIHNldERhdGEocywgdCwgZSkge1xuICAgIEJzLnNldChzLCB0LCBlKTtcbiAgfSxcbiAgZ2V0RGF0YShzLCB0KSB7XG4gICAgcmV0dXJuIEJzLmdldChzLCB0KTtcbiAgfSxcbiAgcmVtb3ZlRGF0YShzLCB0KSB7XG4gICAgQnMuZGVsZXRlKHMsIHQpO1xuICB9XG59LCBxbCA9IDFlNiwgUWwgPSAxZTMsIERuID0gXCJ0cmFuc2l0aW9uZW5kXCIsIFpsID0gKHMpID0+IHMgPT0gbnVsbCA/IGAke3N9YCA6IHt9LnRvU3RyaW5nLmNhbGwocykubWF0Y2goL1xccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCksIE90ID0gKHMpID0+IHtcbiAgZG9cbiAgICBzICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHFsKTtcbiAgd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHMpKTtcbiAgcmV0dXJuIHM7XG59LCB2YSA9IChzKSA9PiB7XG4gIGxldCB0ID0gcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXRhcmdldFwiKTtcbiAgaWYgKCF0IHx8IHQgPT09IFwiI1wiKSB7XG4gICAgbGV0IGUgPSBzLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgaWYgKCFlIHx8ICFlLmluY2x1ZGVzKFwiI1wiKSAmJiAhZS5zdGFydHNXaXRoKFwiLlwiKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGUuaW5jbHVkZXMoXCIjXCIpICYmICFlLnN0YXJ0c1dpdGgoXCIjXCIpICYmIChlID0gYCMke2Uuc3BsaXQoXCIjXCIpWzFdfWApLCB0ID0gZSAmJiBlICE9PSBcIiNcIiA/IGUudHJpbSgpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gdDtcbn0sIFhuID0gKHMpID0+IHtcbiAgY29uc3QgdCA9IHZhKHMpO1xuICByZXR1cm4gdCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpID8gdCA6IG51bGw7XG59LCBYdCA9IChzKSA9PiB7XG4gIGNvbnN0IHQgPSB2YShzKTtcbiAgcmV0dXJuIHQgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpIDogbnVsbDtcbn0sIEpsID0gKHMpID0+IHtcbiAgaWYgKCFzKVxuICAgIHJldHVybiAwO1xuICBsZXQgeyB0cmFuc2l0aW9uRHVyYXRpb246IHQsIHRyYW5zaXRpb25EZWxheTogZSB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocyk7XG4gIGNvbnN0IGkgPSBOdW1iZXIucGFyc2VGbG9hdCh0KSwgbiA9IE51bWJlci5wYXJzZUZsb2F0KGUpO1xuICByZXR1cm4gIWkgJiYgIW4gPyAwIDogKHQgPSB0LnNwbGl0KFwiLFwiKVswXSwgZSA9IGUuc3BsaXQoXCIsXCIpWzBdLCAoTnVtYmVyLnBhcnNlRmxvYXQodCkgKyBOdW1iZXIucGFyc2VGbG9hdChlKSkgKiBRbCk7XG59LCBFYSA9IChzKSA9PiB7XG4gIHMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRG4pKTtcbn0sIE5lID0gKHMpID0+ICFzIHx8IHR5cGVvZiBzICE9IFwib2JqZWN0XCIgPyAhMSA6ICh0eXBlb2Ygcy5qcXVlcnkgPCBcInVcIiAmJiAocyA9IHNbMF0pLCB0eXBlb2Ygcy5ub2RlVHlwZSA8IFwidVwiKSwgR3QgPSAocykgPT4gTmUocykgPyBzLmpxdWVyeSA/IHNbMF0gOiBzIDogdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiAmJiBzLmxlbmd0aCA+IDAgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHMpIDogbnVsbCwgTiA9IChzLCB0LCBlKSA9PiB7XG4gIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGkpID0+IHtcbiAgICBjb25zdCBuID0gZVtpXSwgbyA9IHRbaV0sIHIgPSBvICYmIE5lKG8pID8gXCJlbGVtZW50XCIgOiBabChvKTtcbiAgICBpZiAoIW5ldyBSZWdFeHAobikudGVzdChyKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7cy50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwiJHtpfVwiIHByb3ZpZGVkIHR5cGUgXCIke3J9XCIgYnV0IGV4cGVjdGVkIHR5cGUgXCIke259XCIuYFxuICAgICAgKTtcbiAgfSk7XG59LCBTdCA9IChzKSA9PiB7XG4gIGlmICghcyB8fCBzLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHMuc3R5bGUgJiYgcy5wYXJlbnROb2RlICYmIHMucGFyZW50Tm9kZS5zdHlsZSkge1xuICAgIGNvbnN0IHQgPSBnZXRDb21wdXRlZFN0eWxlKHMpLCBlID0gZ2V0Q29tcHV0ZWRTdHlsZShzLnBhcmVudE5vZGUpO1xuICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHMpLmdldFByb3BlcnR5VmFsdWUoXCJ2aXNpYmlsaXR5XCIpID09PSBcInZpc2libGVcIiB8fCB0LmRpc3BsYXkgIT09IFwibm9uZVwiICYmIGUuZGlzcGxheSAhPT0gXCJub25lXCIgJiYgdC52aXNpYmlsaXR5ICE9PSBcImhpZGRlblwiO1xuICB9XG4gIHJldHVybiAhMTtcbn0sIHVlID0gKHMpID0+ICFzIHx8IHMubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFIHx8IHMuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIikgPyAhMCA6IHR5cGVvZiBzLmRpc2FibGVkIDwgXCJ1XCIgPyBzLmRpc2FibGVkIDogcy5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSAmJiBzLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpICE9PSBcImZhbHNlXCIsIFRhID0gKHMpID0+IHtcbiAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KVxuICAgIHJldHVybiBudWxsO1xuICBpZiAodHlwZW9mIHMuZ2V0Um9vdE5vZGUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgdCA9IHMuZ2V0Um9vdE5vZGUoKTtcbiAgICByZXR1cm4gdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyB0IDogbnVsbDtcbiAgfVxuICByZXR1cm4gcyBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyBzIDogcy5wYXJlbnROb2RlID8gVGEocy5wYXJlbnROb2RlKSA6IG51bGw7XG59LCB2cyA9ICgpID0+IGZ1bmN0aW9uKCkge1xufSwgRmUgPSAocykgPT4ge1xuICBzLm9mZnNldEhlaWdodDtcbn0sIENhID0gKCkgPT4ge1xuICBjb25zdCB7IGpRdWVyeTogcyB9ID0gd2luZG93O1xuICByZXR1cm4gcyAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXRlLW5vLWpxdWVyeVwiKSA/IHMgOiBudWxsO1xufSwgVnMgPSBbXSwgQWEgPSAocykgPT4ge1xuICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIiA/IChWcy5sZW5ndGggfHwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICAgIFZzLmZvckVhY2goKHQpID0+IHQoKSk7XG4gIH0pLCBWcy5wdXNoKHMpKSA6IHMoKTtcbn0sIEYgPSAoKSA9PiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGlyID09PSBcInJ0bFwiLCB0YyA9IChzKSA9PiBBcnJheS5mcm9tKHMpLCBNID0gKHMpID0+IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocyksIGhlID0gKHMpID0+IHtcbiAgdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiICYmIHMoKTtcbn0sIHlhID0gKHMsIHQsIGUgPSAhMCkgPT4ge1xuICBpZiAoIWUpIHtcbiAgICBoZShzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaSA9IDUsIG4gPSBKbCh0KSArIGk7XG4gIGxldCBvID0gITE7XG4gIGNvbnN0IHIgPSAoeyB0YXJnZXQ6IGEgfSkgPT4ge1xuICAgIGEgPT09IHQgJiYgKG8gPSAhMCwgdC5yZW1vdmVFdmVudExpc3RlbmVyKERuLCByKSwgaGUocykpO1xuICB9O1xuICB0LmFkZEV2ZW50TGlzdGVuZXIoRG4sIHIpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBvIHx8IEVhKHQpO1xuICB9LCBuKTtcbn0sIHdhID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgbGV0IG4gPSBzLmluZGV4T2YodCk7XG4gIGlmIChuID09PSAtMSlcbiAgICByZXR1cm4gc1shZSAmJiBpID8gcy5sZW5ndGggLSAxIDogMF07XG4gIGNvbnN0IG8gPSBzLmxlbmd0aDtcbiAgcmV0dXJuIG4gKz0gZSA/IDEgOiAtMSwgaSAmJiAobiA9IChuICsgbykgJSBvKSwgc1tNYXRoLm1heCgwLCBNYXRoLm1pbihuLCBvIC0gMSkpXTtcbn0sIGVjID0gL1teLl0qKD89XFwuLiopXFwufC4qLywgaWMgPSAvXFwuLiovLCBzYyA9IC86OlxcZCskLywgV3MgPSB7fTtcbmxldCBFbyA9IDE7XG5jb25zdCBuYyA9IHtcbiAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcbiAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiXG59LCBvYyA9IC9eKG1vdXNlZW50ZXJ8bW91c2VsZWF2ZSkvaSwga2EgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY2xpY2tcIixcbiAgXCJkYmxjbGlja1wiLFxuICBcIm1vdXNldXBcIixcbiAgXCJtb3VzZWRvd25cIixcbiAgXCJjb250ZXh0bWVudVwiLFxuICBcIm1vdXNld2hlZWxcIixcbiAgXCJET01Nb3VzZVNjcm9sbFwiLFxuICBcIm1vdXNlb3ZlclwiLFxuICBcIm1vdXNlb3V0XCIsXG4gIFwibW91c2Vtb3ZlXCIsXG4gIFwic2VsZWN0c3RhcnRcIixcbiAgXCJzZWxlY3RlbmRcIixcbiAgXCJrZXlkb3duXCIsXG4gIFwia2V5cHJlc3NcIixcbiAgXCJrZXl1cFwiLFxuICBcIm9yaWVudGF0aW9uY2hhbmdlXCIsXG4gIFwidG91Y2hzdGFydFwiLFxuICBcInRvdWNobW92ZVwiLFxuICBcInRvdWNoZW5kXCIsXG4gIFwidG91Y2hjYW5jZWxcIixcbiAgXCJwb2ludGVyZG93blwiLFxuICBcInBvaW50ZXJtb3ZlXCIsXG4gIFwicG9pbnRlcnVwXCIsXG4gIFwicG9pbnRlcmxlYXZlXCIsXG4gIFwicG9pbnRlcmNhbmNlbFwiLFxuICBcImdlc3R1cmVzdGFydFwiLFxuICBcImdlc3R1cmVjaGFuZ2VcIixcbiAgXCJnZXN0dXJlZW5kXCIsXG4gIFwiZm9jdXNcIixcbiAgXCJibHVyXCIsXG4gIFwiY2hhbmdlXCIsXG4gIFwicmVzZXRcIixcbiAgXCJzZWxlY3RcIixcbiAgXCJzdWJtaXRcIixcbiAgXCJmb2N1c2luXCIsXG4gIFwiZm9jdXNvdXRcIixcbiAgXCJsb2FkXCIsXG4gIFwidW5sb2FkXCIsXG4gIFwiYmVmb3JldW5sb2FkXCIsXG4gIFwicmVzaXplXCIsXG4gIFwibW92ZVwiLFxuICBcIkRPTUNvbnRlbnRMb2FkZWRcIixcbiAgXCJyZWFkeXN0YXRlY2hhbmdlXCIsXG4gIFwiZXJyb3JcIixcbiAgXCJhYm9ydFwiLFxuICBcInNjcm9sbFwiXG5dKTtcbmZ1bmN0aW9uIE9hKHMsIHQpIHtcbiAgcmV0dXJuIHQgJiYgYCR7dH06OiR7RW8rK31gIHx8IHMudWlkRXZlbnQgfHwgRW8rKztcbn1cbmZ1bmN0aW9uIHhhKHMpIHtcbiAgY29uc3QgdCA9IE9hKHMpO1xuICByZXR1cm4gcy51aWRFdmVudCA9IHQsIFdzW3RdID0gV3NbdF0gfHwge30sIFdzW3RdO1xufVxuZnVuY3Rpb24gcmMocywgdCkge1xuICByZXR1cm4gZnVuY3Rpb24gZShpKSB7XG4gICAgcmV0dXJuIGkuZGVsZWdhdGVUYXJnZXQgPSBzLCBlLm9uZU9mZiAmJiB1Lm9mZihzLCBpLnR5cGUsIHQpLCB0LmFwcGx5KHMsIFtpXSk7XG4gIH07XG59XG5mdW5jdGlvbiBhYyhzLCB0LCBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpKG4pIHtcbiAgICBjb25zdCBvID0gcy5xdWVyeVNlbGVjdG9yQWxsKHQpO1xuICAgIGZvciAobGV0IHsgdGFyZ2V0OiByIH0gPSBuOyByICYmIHIgIT09IHRoaXM7IHIgPSByLnBhcmVudE5vZGUpXG4gICAgICBmb3IgKGxldCBhID0gby5sZW5ndGg7IGEtLTsgXCJcIilcbiAgICAgICAgaWYgKG9bYV0gPT09IHIpXG4gICAgICAgICAgcmV0dXJuIG4uZGVsZWdhdGVUYXJnZXQgPSByLCBpLm9uZU9mZiAmJiB1Lm9mZihzLCBuLnR5cGUsIGUpLCBlLmFwcGx5KHIsIFtuXSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5mdW5jdGlvbiBTYShzLCB0LCBlID0gbnVsbCkge1xuICBjb25zdCBpID0gT2JqZWN0LmtleXMocyk7XG4gIGZvciAobGV0IG4gPSAwLCBvID0gaS5sZW5ndGg7IG4gPCBvOyBuKyspIHtcbiAgICBjb25zdCByID0gc1tpW25dXTtcbiAgICBpZiAoci5vcmlnaW5hbEhhbmRsZXIgPT09IHQgJiYgci5kZWxlZ2F0aW9uU2VsZWN0b3IgPT09IGUpXG4gICAgICByZXR1cm4gcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIERhKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwic3RyaW5nXCIsIG4gPSBpID8gZSA6IHQ7XG4gIGxldCBvID0gSWEocyk7XG4gIHJldHVybiBrYS5oYXMobykgfHwgKG8gPSBzKSwgW2ksIG4sIG9dO1xufVxuZnVuY3Rpb24gVG8ocywgdCwgZSwgaSwgbikge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIiB8fCAhcylcbiAgICByZXR1cm47XG4gIGlmIChlIHx8IChlID0gaSwgaSA9IG51bGwpLCBvYy50ZXN0KHQpKSB7XG4gICAgY29uc3QgbSA9IChnKSA9PiBmdW5jdGlvbihiKSB7XG4gICAgICBpZiAoIWIucmVsYXRlZFRhcmdldCB8fCBiLnJlbGF0ZWRUYXJnZXQgIT09IGIuZGVsZWdhdGVUYXJnZXQgJiYgIWIuZGVsZWdhdGVUYXJnZXQuY29udGFpbnMoYi5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuIGcuY2FsbCh0aGlzLCBiKTtcbiAgICB9O1xuICAgIGkgPyBpID0gbShpKSA6IGUgPSBtKGUpO1xuICB9XG4gIGNvbnN0IFtvLCByLCBhXSA9IERhKFxuICAgIHQsXG4gICAgZSxcbiAgICBpXG4gICksIGwgPSB4YShzKSwgYyA9IGxbYV0gfHwgKGxbYV0gPSB7fSksIGQgPSBTYShcbiAgICBjLFxuICAgIHIsXG4gICAgbyA/IGUgOiBudWxsXG4gICk7XG4gIGlmIChkKSB7XG4gICAgZC5vbmVPZmYgPSBkLm9uZU9mZiAmJiBuO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBfID0gT2EoXG4gICAgcixcbiAgICB0LnJlcGxhY2UoZWMsIFwiXCIpXG4gICksIGYgPSBvID8gYWMocywgZSwgaSkgOiByYyhzLCBlKTtcbiAgZi5kZWxlZ2F0aW9uU2VsZWN0b3IgPSBvID8gZSA6IG51bGwsIGYub3JpZ2luYWxIYW5kbGVyID0gciwgZi5vbmVPZmYgPSBuLCBmLnVpZEV2ZW50ID0gXywgY1tfXSA9IGYsIHMuYWRkRXZlbnRMaXN0ZW5lcihhLCBmLCBvKTtcbn1cbmZ1bmN0aW9uIEluKHMsIHQsIGUsIGksIG4pIHtcbiAgY29uc3QgbyA9IFNhKHRbZV0sIGksIG4pO1xuICBvICYmIChzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgbywgISFuKSwgZGVsZXRlIHRbZV1bby51aWRFdmVudF0pO1xufVxuZnVuY3Rpb24gbGMocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0gdFtlXSB8fCB7fTtcbiAgT2JqZWN0LmtleXMobikuZm9yRWFjaCgobykgPT4ge1xuICAgIGlmIChvLmluY2x1ZGVzKGkpKSB7XG4gICAgICBjb25zdCByID0gbltvXTtcbiAgICAgIEluKFxuICAgICAgICBzLFxuICAgICAgICB0LFxuICAgICAgICBlLFxuICAgICAgICByLm9yaWdpbmFsSGFuZGxlcixcbiAgICAgICAgci5kZWxlZ2F0aW9uU2VsZWN0b3JcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIElhKHMpIHtcbiAgcmV0dXJuIHMgPSBzLnJlcGxhY2UoaWMsIFwiXCIpLCBuY1tzXSB8fCBzO1xufVxuY29uc3QgdSA9IHtcbiAgb24ocywgdCwgZSwgaSkge1xuICAgIFRvKHMsIHQsIGUsIGksICExKTtcbiAgfSxcbiAgb25lKHMsIHQsIGUsIGkpIHtcbiAgICBUbyhzLCB0LCBlLCBpLCAhMCk7XG4gIH0sXG4gIG9mZihzLCB0LCBlLCBpKSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgfHwgIXMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW24sIG8sIHJdID0gRGEoXG4gICAgICB0LFxuICAgICAgZSxcbiAgICAgIGlcbiAgICApLCBhID0gciAhPT0gdCwgbCA9IHhhKHMpLCBjID0gdC5zdGFydHNXaXRoKFwiLlwiKTtcbiAgICBpZiAodHlwZW9mIG8gPCBcInVcIikge1xuICAgICAgaWYgKCFsIHx8ICFsW3JdKVxuICAgICAgICByZXR1cm47XG4gICAgICBJbihcbiAgICAgICAgcyxcbiAgICAgICAgbCxcbiAgICAgICAgcixcbiAgICAgICAgbyxcbiAgICAgICAgbiA/IGUgOiBudWxsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjICYmIE9iamVjdC5rZXlzKGwpLmZvckVhY2goKF8pID0+IHtcbiAgICAgIGxjKFxuICAgICAgICBzLFxuICAgICAgICBsLFxuICAgICAgICBfLFxuICAgICAgICB0LnNsaWNlKDEpXG4gICAgICApO1xuICAgIH0pO1xuICAgIGNvbnN0IGQgPSBsW3JdIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGQpLmZvckVhY2goKF8pID0+IHtcbiAgICAgIGNvbnN0IGYgPSBfLnJlcGxhY2Uoc2MsIFwiXCIpO1xuICAgICAgaWYgKCFhIHx8IHQuaW5jbHVkZXMoZikpIHtcbiAgICAgICAgY29uc3QgbSA9IGRbX107XG4gICAgICAgIEluKFxuICAgICAgICAgIHMsXG4gICAgICAgICAgbCxcbiAgICAgICAgICByLFxuICAgICAgICAgIG0ub3JpZ2luYWxIYW5kbGVyLFxuICAgICAgICAgIG0uZGVsZWdhdGlvblNlbGVjdG9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHRyaWdnZXIocywgdCwgZSkge1xuICAgIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFzKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaSA9IENhKCksIG4gPSBJYSh0KSwgbyA9IHQgIT09IG4sIHIgPSBrYS5oYXMobik7XG4gICAgbGV0IGEsIGwgPSAhMCwgYyA9ICEwLCBkID0gITEsIF8gPSBudWxsO1xuICAgIHJldHVybiBvICYmIGkgJiYgKGEgPSBpLkV2ZW50KHQsIGUpLCBpKHMpLnRyaWdnZXIoYSksIGwgPSAhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpLCBjID0gIWEuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSwgZCA9IGEuaXNEZWZhdWx0UHJldmVudGVkKCkpLCByID8gKF8gPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkhUTUxFdmVudHNcIiksIF8uaW5pdEV2ZW50KG4sIGwsICEwKSkgOiBfID0gbmV3IEN1c3RvbUV2ZW50KHQsIHtcbiAgICAgIGJ1YmJsZXM6IGwsXG4gICAgICBjYW5jZWxhYmxlOiAhMFxuICAgIH0pLCB0eXBlb2YgZSA8IFwidVwiICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGYpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBmLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gZVtmXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksIGQgJiYgXy5wcmV2ZW50RGVmYXVsdCgpLCBjICYmIHMuZGlzcGF0Y2hFdmVudChfKSwgXy5kZWZhdWx0UHJldmVudGVkICYmIHR5cGVvZiBhIDwgXCJ1XCIgJiYgYS5wcmV2ZW50RGVmYXVsdCgpLCBfO1xuICB9XG59LCBlZSA9IHtcbiAgb24ocywgdCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSB0LnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IG4ubGVuZ3RoOyBvKyspXG4gICAgICB1Lm9uKHMsIG5bb10sIGUsIGkpO1xuICB9LFxuICBvZmYocywgdCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSB0LnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IG4ubGVuZ3RoOyBvKyspXG4gICAgICB1Lm9mZihzLCBuW29dLCBlLCBpKTtcbiAgfVxufSwgY2MgPSBcIjUuMS4zXCI7XG5jbGFzcyB2dCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0ID0gR3QodCksIHQgJiYgKHRoaXMuX2VsZW1lbnQgPSB0LCBJLnNldERhdGEodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcykpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpLCB1Lm9mZih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHRoaXNbdF0gPSBudWxsO1xuICAgIH0pO1xuICB9XG4gIF9xdWV1ZUNhbGxiYWNrKHQsIGUsIGkgPSAhMCkge1xuICAgIHlhKHQsIGUsIGkpO1xuICB9XG4gIC8qKiBTdGF0aWMgKi9cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKEd0KHQpLCB0aGlzLkRBVEFfS0VZKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gY2M7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdZb3UgaGF2ZSB0byBpbXBsZW1lbnQgdGhlIHN0YXRpYyBtZXRob2QgXCJOQU1FXCIsIGZvciBlYWNoIGNvbXBvbmVudCEnXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xuICAgIHJldHVybiBgdGUuJHt0aGlzLk5BTUV9YDtcbiAgfVxuICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICByZXR1cm4gYC4ke3RoaXMuREFUQV9LRVl9YDtcbiAgfVxufVxuY29uc3QgZGMgPSBcImJ1dHRvblwiLCBoYyA9IFwiYWN0aXZlXCI7XG5jbGFzcyAkYSBleHRlbmRzIHZ0IHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGRjO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtcHJlc3NlZFwiLFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGhjKVxuICAgICk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gJGEuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIHQgPT09IFwidG9nZ2xlXCIgJiYgZVt0XSgpO1xuICAgIH0pO1xuICB9XG59XG52YXIgWiA9IFwidG9wXCIsIGR0ID0gXCJib3R0b21cIiwgaHQgPSBcInJpZ2h0XCIsIEogPSBcImxlZnRcIiwgbWkgPSBcImF1dG9cIiwgWWUgPSBbWiwgZHQsIGh0LCBKXSwgX2UgPSBcInN0YXJ0XCIsIFJlID0gXCJlbmRcIiwgTGEgPSBcImNsaXBwaW5nUGFyZW50c1wiLCBHbiA9IFwidmlld3BvcnRcIiwgeWUgPSBcInBvcHBlclwiLCBNYSA9IFwicmVmZXJlbmNlXCIsICRuID0gLyogQF9fUFVSRV9fICovIFllLnJlZHVjZShmdW5jdGlvbihzLCB0KSB7XG4gIHJldHVybiBzLmNvbmNhdChbdCArIFwiLVwiICsgX2UsIHQgKyBcIi1cIiArIFJlXSk7XG59LCBbXSksIHFuID0gLyogQF9fUFVSRV9fICovIFtdLmNvbmNhdChZZSwgW21pXSkucmVkdWNlKGZ1bmN0aW9uKHMsIHQpIHtcbiAgcmV0dXJuIHMuY29uY2F0KFt0LCB0ICsgXCItXCIgKyBfZSwgdCArIFwiLVwiICsgUmVdKTtcbn0sIFtdKSwgTmEgPSBcImJlZm9yZVJlYWRcIiwgUmEgPSBcInJlYWRcIiwgUGEgPSBcImFmdGVyUmVhZFwiLCBIYSA9IFwiYmVmb3JlTWFpblwiLCBCYSA9IFwibWFpblwiLCBWYSA9IFwiYWZ0ZXJNYWluXCIsIFdhID0gXCJiZWZvcmVXcml0ZVwiLCBGYSA9IFwid3JpdGVcIiwgWWEgPSBcImFmdGVyV3JpdGVcIiwgRXMgPSBbTmEsIFJhLCBQYSwgSGEsIEJhLCBWYSwgV2EsIEZhLCBZYV07XG5mdW5jdGlvbiBJdChzKSB7XG4gIHJldHVybiBzID8gKHMubm9kZU5hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59XG5mdW5jdGlvbiB1dChzKSB7XG4gIGlmIChzID09IG51bGwpXG4gICAgcmV0dXJuIHdpbmRvdztcbiAgaWYgKHMudG9TdHJpbmcoKSAhPT0gXCJbb2JqZWN0IFdpbmRvd11cIikge1xuICAgIHZhciB0ID0gcy5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiB0ICYmIHQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gbWUocykge1xuICB2YXIgdCA9IHV0KHMpLkVsZW1lbnQ7XG4gIHJldHVybiBzIGluc3RhbmNlb2YgdCB8fCBzIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGN0KHMpIHtcbiAgdmFyIHQgPSB1dChzKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0IHx8IHMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIFFuKHMpIHtcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID4gXCJ1XCIpXG4gICAgcmV0dXJuICExO1xuICB2YXIgdCA9IHV0KHMpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBzIGluc3RhbmNlb2YgdCB8fCBzIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cbmZ1bmN0aW9uIHVjKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlO1xuICBPYmplY3Qua2V5cyh0LmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaSA9IHQuc3R5bGVzW2VdIHx8IHt9LCBuID0gdC5hdHRyaWJ1dGVzW2VdIHx8IHt9LCBvID0gdC5lbGVtZW50c1tlXTtcbiAgICAhY3QobykgfHwgIUl0KG8pIHx8IChPYmplY3QuYXNzaWduKG8uc3R5bGUsIGkpLCBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciBhID0gbltyXTtcbiAgICAgIGEgPT09ICExID8gby5yZW1vdmVBdHRyaWJ1dGUocikgOiBvLnNldEF0dHJpYnV0ZShyLCBhID09PSAhMCA/IFwiXCIgOiBhKTtcbiAgICB9KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcGMocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogdC5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogXCIwXCIsXG4gICAgICB0b3A6IFwiMFwiLFxuICAgICAgbWFyZ2luOiBcIjBcIlxuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odC5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGUucG9wcGVyKSwgdC5zdHlsZXMgPSBlLCB0LmVsZW1lbnRzLmFycm93ICYmIE9iamVjdC5hc3NpZ24odC5lbGVtZW50cy5hcnJvdy5zdHlsZSwgZS5hcnJvdyksIGZ1bmN0aW9uKCkge1xuICAgIE9iamVjdC5rZXlzKHQuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIG4gPSB0LmVsZW1lbnRzW2ldLCBvID0gdC5hdHRyaWJ1dGVzW2ldIHx8IHt9LCByID0gT2JqZWN0LmtleXModC5zdHlsZXMuaGFzT3duUHJvcGVydHkoaSkgPyB0LnN0eWxlc1tpXSA6IGVbaV0pLCBhID0gci5yZWR1Y2UoZnVuY3Rpb24obCwgYykge1xuICAgICAgICByZXR1cm4gbFtjXSA9IFwiXCIsIGw7XG4gICAgICB9LCB7fSk7XG4gICAgICAhY3QobikgfHwgIUl0KG4pIHx8IChPYmplY3QuYXNzaWduKG4uc3R5bGUsIGEpLCBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgbi5yZW1vdmVBdHRyaWJ1dGUobCk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG59XG5jb25zdCBabiA9IHtcbiAgbmFtZTogXCJhcHBseVN0eWxlc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwid3JpdGVcIixcbiAgZm46IHVjLFxuICBlZmZlY3Q6IHBjLFxuICByZXF1aXJlczogW1wiY29tcHV0ZVN0eWxlc1wiXVxufTtcbmZ1bmN0aW9uIGd0KHMpIHtcbiAgcmV0dXJuIHMuc3BsaXQoXCItXCIpWzBdO1xufVxudmFyIHBlID0gTWF0aC5tYXgsIFRzID0gTWF0aC5taW4sIFBlID0gTWF0aC5yb3VuZDtcbmZ1bmN0aW9uIExuKCkge1xuICB2YXIgcyA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICByZXR1cm4gcyAhPSBudWxsICYmIHMuYnJhbmRzICYmIEFycmF5LmlzQXJyYXkocy5icmFuZHMpID8gcy5icmFuZHMubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5icmFuZCArIFwiL1wiICsgdC52ZXJzaW9uO1xuICB9KS5qb2luKFwiIFwiKSA6IG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG5mdW5jdGlvbiBqYSgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KExuKCkpO1xufVxuZnVuY3Rpb24gSGUocywgdCwgZSkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSAhMSksIGUgPT09IHZvaWQgMCAmJiAoZSA9ICExKTtcbiAgdmFyIGkgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBuID0gMSwgbyA9IDE7XG4gIHQgJiYgY3QocykgJiYgKG4gPSBzLm9mZnNldFdpZHRoID4gMCAmJiBQZShpLndpZHRoKSAvIHMub2Zmc2V0V2lkdGggfHwgMSwgbyA9IHMub2Zmc2V0SGVpZ2h0ID4gMCAmJiBQZShpLmhlaWdodCkgLyBzLm9mZnNldEhlaWdodCB8fCAxKTtcbiAgdmFyIHIgPSBtZShzKSA/IHV0KHMpIDogd2luZG93LCBhID0gci52aXN1YWxWaWV3cG9ydCwgbCA9ICFqYSgpICYmIGUsIGMgPSAoaS5sZWZ0ICsgKGwgJiYgYSA/IGEub2Zmc2V0TGVmdCA6IDApKSAvIG4sIGQgPSAoaS50b3AgKyAobCAmJiBhID8gYS5vZmZzZXRUb3AgOiAwKSkgLyBvLCBfID0gaS53aWR0aCAvIG4sIGYgPSBpLmhlaWdodCAvIG87XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IF8sXG4gICAgaGVpZ2h0OiBmLFxuICAgIHRvcDogZCxcbiAgICByaWdodDogYyArIF8sXG4gICAgYm90dG9tOiBkICsgZixcbiAgICBsZWZ0OiBjLFxuICAgIHg6IGMsXG4gICAgeTogZFxuICB9O1xufVxuZnVuY3Rpb24gSm4ocykge1xuICB2YXIgdCA9IEhlKHMpLCBlID0gcy5vZmZzZXRXaWR0aCwgaSA9IHMub2Zmc2V0SGVpZ2h0O1xuICByZXR1cm4gTWF0aC5hYnModC53aWR0aCAtIGUpIDw9IDEgJiYgKGUgPSB0LndpZHRoKSwgTWF0aC5hYnModC5oZWlnaHQgLSBpKSA8PSAxICYmIChpID0gdC5oZWlnaHQpLCB7XG4gICAgeDogcy5vZmZzZXRMZWZ0LFxuICAgIHk6IHMub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiBlLFxuICAgIGhlaWdodDogaVxuICB9O1xufVxuZnVuY3Rpb24gS2EocywgdCkge1xuICB2YXIgZSA9IHQuZ2V0Um9vdE5vZGUgJiYgdC5nZXRSb290Tm9kZSgpO1xuICBpZiAocy5jb250YWlucyh0KSlcbiAgICByZXR1cm4gITA7XG4gIGlmIChlICYmIFFuKGUpKSB7XG4gICAgdmFyIGkgPSB0O1xuICAgIGRvIHtcbiAgICAgIGlmIChpICYmIHMuaXNTYW1lTm9kZShpKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaSA9IGkucGFyZW50Tm9kZSB8fCBpLmhvc3Q7XG4gICAgfSB3aGlsZSAoaSk7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gYnQocykge1xuICByZXR1cm4gdXQocykuZ2V0Q29tcHV0ZWRTdHlsZShzKTtcbn1cbmZ1bmN0aW9uIGZjKHMpIHtcbiAgcmV0dXJuIFtcInRhYmxlXCIsIFwidGRcIiwgXCJ0aFwiXS5pbmRleE9mKEl0KHMpKSA+PSAwO1xufVxuZnVuY3Rpb24gcXQocykge1xuICByZXR1cm4gKChtZShzKSA/IHMub3duZXJEb2N1bWVudCA6IChcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBzLmRvY3VtZW50XG4gICkpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gd3Mocykge1xuICByZXR1cm4gSXQocykgPT09IFwiaHRtbFwiID8gcyA6IChcbiAgICAvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBzLmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIHMucGFyZW50Tm9kZSB8fCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIChRbihzKSA/IHMuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgcXQocylcbiAgKTtcbn1cbmZ1bmN0aW9uIENvKHMpIHtcbiAgcmV0dXJuICFjdChzKSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBidChzKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gbnVsbCA6IHMub2Zmc2V0UGFyZW50O1xufVxuZnVuY3Rpb24gX2Mocykge1xuICB2YXIgdCA9IC9maXJlZm94L2kudGVzdChMbigpKSwgZSA9IC9UcmlkZW50L2kudGVzdChMbigpKTtcbiAgaWYgKGUgJiYgY3QocykpIHtcbiAgICB2YXIgaSA9IGJ0KHMpO1xuICAgIGlmIChpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbiA9IHdzKHMpO1xuICBmb3IgKFFuKG4pICYmIChuID0gbi5ob3N0KTsgY3QobikgJiYgW1wiaHRtbFwiLCBcImJvZHlcIl0uaW5kZXhPZihJdChuKSkgPCAwOyApIHtcbiAgICB2YXIgbyA9IGJ0KG4pO1xuICAgIGlmIChvLnRyYW5zZm9ybSAhPT0gXCJub25lXCIgfHwgby5wZXJzcGVjdGl2ZSAhPT0gXCJub25lXCIgfHwgby5jb250YWluID09PSBcInBhaW50XCIgfHwgW1widHJhbnNmb3JtXCIsIFwicGVyc3BlY3RpdmVcIl0uaW5kZXhPZihvLndpbGxDaGFuZ2UpICE9PSAtMSB8fCB0ICYmIG8ud2lsbENoYW5nZSA9PT0gXCJmaWx0ZXJcIiB8fCB0ICYmIG8uZmlsdGVyICYmIG8uZmlsdGVyICE9PSBcIm5vbmVcIilcbiAgICAgIHJldHVybiBuO1xuICAgIG4gPSBuLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnaShzKSB7XG4gIGZvciAodmFyIHQgPSB1dChzKSwgZSA9IENvKHMpOyBlICYmIGZjKGUpICYmIGJ0KGUpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiOyApXG4gICAgZSA9IENvKGUpO1xuICByZXR1cm4gZSAmJiAoSXQoZSkgPT09IFwiaHRtbFwiIHx8IEl0KGUpID09PSBcImJvZHlcIiAmJiBidChlKS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikgPyB0IDogZSB8fCBfYyhzKSB8fCB0O1xufVxuZnVuY3Rpb24gdG8ocykge1xuICByZXR1cm4gW1widG9wXCIsIFwiYm90dG9tXCJdLmluZGV4T2YocykgPj0gMCA/IFwieFwiIDogXCJ5XCI7XG59XG5mdW5jdGlvbiBsaShzLCB0LCBlKSB7XG4gIHJldHVybiBwZShzLCBUcyh0LCBlKSk7XG59XG5mdW5jdGlvbiBtYyhzLCB0LCBlKSB7XG4gIHZhciBpID0gbGkocywgdCwgZSk7XG4gIHJldHVybiBpID4gZSA/IGUgOiBpO1xufVxuZnVuY3Rpb24gVWEoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59XG5mdW5jdGlvbiB6YShzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBVYSgpLCBzKTtcbn1cbmZ1bmN0aW9uIFhhKHMsIHQpIHtcbiAgcmV0dXJuIHQucmVkdWNlKGZ1bmN0aW9uKGUsIGkpIHtcbiAgICByZXR1cm4gZVtpXSA9IHMsIGU7XG4gIH0sIHt9KTtcbn1cbnZhciBnYyA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuIHQgPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0KE9iamVjdC5hc3NpZ24oe30sIGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IGUucGxhY2VtZW50XG4gIH0pKSA6IHQsIHphKHR5cGVvZiB0ICE9IFwibnVtYmVyXCIgPyB0IDogWGEodCwgWWUpKTtcbn07XG5mdW5jdGlvbiBiYyhzKSB7XG4gIHZhciB0LCBlID0gcy5zdGF0ZSwgaSA9IHMubmFtZSwgbiA9IHMub3B0aW9ucywgbyA9IGUuZWxlbWVudHMuYXJyb3csIHIgPSBlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cywgYSA9IGd0KGUucGxhY2VtZW50KSwgbCA9IHRvKGEpLCBjID0gW0osIGh0XS5pbmRleE9mKGEpID49IDAsIGQgPSBjID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgaWYgKCEoIW8gfHwgIXIpKSB7XG4gICAgdmFyIF8gPSBnYyhuLnBhZGRpbmcsIGUpLCBmID0gSm4obyksIG0gPSBsID09PSBcInlcIiA/IFogOiBKLCBnID0gbCA9PT0gXCJ5XCIgPyBkdCA6IGh0LCBiID0gZS5yZWN0cy5yZWZlcmVuY2VbZF0gKyBlLnJlY3RzLnJlZmVyZW5jZVtsXSAtIHJbbF0gLSBlLnJlY3RzLnBvcHBlcltkXSwgVCA9IHJbbF0gLSBlLnJlY3RzLnJlZmVyZW5jZVtsXSwgQyA9IGdpKG8pLCB3ID0gQyA/IGwgPT09IFwieVwiID8gQy5jbGllbnRIZWlnaHQgfHwgMCA6IEMuY2xpZW50V2lkdGggfHwgMCA6IDAsIHYgPSBiIC8gMiAtIFQgLyAyLCBFID0gX1ttXSwgQSA9IHcgLSBmW2RdIC0gX1tnXSwgeSA9IHcgLyAyIC0gZltkXSAvIDIgKyB2LCBTID0gbGkoRSwgeSwgQSksIE8gPSBsO1xuICAgIGUubW9kaWZpZXJzRGF0YVtpXSA9ICh0ID0ge30sIHRbT10gPSBTLCB0LmNlbnRlck9mZnNldCA9IFMgLSB5LCB0KTtcbiAgfVxufVxuZnVuY3Rpb24gdmMocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBlLmVsZW1lbnQsIG4gPSBpID09PSB2b2lkIDAgPyBcIltkYXRhLXBvcHBlci1hcnJvd11cIiA6IGk7XG4gIGlmIChuICE9IG51bGwgJiYgISh0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIChuID0gdC5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihuKSwgIW4pKSkge1xuICAgIGlmICh7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGN0KG4pIHx8IGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCBcIlRvIHVzZSBhbiBTVkcgYXJyb3csIHdyYXAgaXQgaW4gYW4gSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXNcIiwgXCJ0aGUgYXJyb3cuXCJdLmpvaW4oXCIgXCIpKSksICFLYSh0LmVsZW1lbnRzLnBvcHBlciwgbikpIHtcbiAgICAgICh7fSkuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBtb2RpZmllclxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgXCJlbGVtZW50LlwiXS5qb2luKFwiIFwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQuZWxlbWVudHMuYXJyb3cgPSBuO1xuICB9XG59XG5jb25zdCBHYSA9IHtcbiAgbmFtZTogXCJhcnJvd1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICBmbjogYmMsXG4gIGVmZmVjdDogdmMsXG4gIHJlcXVpcmVzOiBbXCJwb3BwZXJPZmZzZXRzXCJdLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJwcmV2ZW50T3ZlcmZsb3dcIl1cbn07XG5mdW5jdGlvbiBCZShzKSB7XG4gIHJldHVybiBzLnNwbGl0KFwiLVwiKVsxXTtcbn1cbnZhciBFYyA9IHtcbiAgdG9wOiBcImF1dG9cIixcbiAgcmlnaHQ6IFwiYXV0b1wiLFxuICBib3R0b206IFwiYXV0b1wiLFxuICBsZWZ0OiBcImF1dG9cIlxufTtcbmZ1bmN0aW9uIFRjKHMsIHQpIHtcbiAgdmFyIGUgPSBzLngsIGkgPSBzLnksIG4gPSB0LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiBQZShlICogbikgLyBuIHx8IDAsXG4gICAgeTogUGUoaSAqIG4pIC8gbiB8fCAwXG4gIH07XG59XG5mdW5jdGlvbiBBbyhzKSB7XG4gIHZhciB0LCBlID0gcy5wb3BwZXIsIGkgPSBzLnBvcHBlclJlY3QsIG4gPSBzLnBsYWNlbWVudCwgbyA9IHMudmFyaWF0aW9uLCByID0gcy5vZmZzZXRzLCBhID0gcy5wb3NpdGlvbiwgbCA9IHMuZ3B1QWNjZWxlcmF0aW9uLCBjID0gcy5hZGFwdGl2ZSwgZCA9IHMucm91bmRPZmZzZXRzLCBfID0gcy5pc0ZpeGVkLCBmID0gci54LCBtID0gZiA9PT0gdm9pZCAwID8gMCA6IGYsIGcgPSByLnksIGIgPSBnID09PSB2b2lkIDAgPyAwIDogZywgVCA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIiA/IGQoe1xuICAgIHg6IG0sXG4gICAgeTogYlxuICB9KSA6IHtcbiAgICB4OiBtLFxuICAgIHk6IGJcbiAgfTtcbiAgbSA9IFQueCwgYiA9IFQueTtcbiAgdmFyIEMgPSByLmhhc093blByb3BlcnR5KFwieFwiKSwgdyA9IHIuaGFzT3duUHJvcGVydHkoXCJ5XCIpLCB2ID0gSiwgRSA9IFosIEEgPSB3aW5kb3c7XG4gIGlmIChjKSB7XG4gICAgdmFyIHkgPSBnaShlKSwgUyA9IFwiY2xpZW50SGVpZ2h0XCIsIE8gPSBcImNsaWVudFdpZHRoXCI7XG4gICAgaWYgKHkgPT09IHV0KGUpICYmICh5ID0gcXQoZSksIGJ0KHkpLnBvc2l0aW9uICE9PSBcInN0YXRpY1wiICYmIGEgPT09IFwiYWJzb2x1dGVcIiAmJiAoUyA9IFwic2Nyb2xsSGVpZ2h0XCIsIE8gPSBcInNjcm9sbFdpZHRoXCIpKSwgeSA9IHksIG4gPT09IFogfHwgKG4gPT09IEogfHwgbiA9PT0gaHQpICYmIG8gPT09IFJlKSB7XG4gICAgICBFID0gZHQ7XG4gICAgICB2YXIgayA9IF8gJiYgeSA9PT0gQSAmJiBBLnZpc3VhbFZpZXdwb3J0ID8gQS52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAoXG4gICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICB5W1NdXG4gICAgICApO1xuICAgICAgYiAtPSBrIC0gaS5oZWlnaHQsIGIgKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gICAgaWYgKG4gPT09IEogfHwgKG4gPT09IFogfHwgbiA9PT0gZHQpICYmIG8gPT09IFJlKSB7XG4gICAgICB2ID0gaHQ7XG4gICAgICB2YXIgRCA9IF8gJiYgeSA9PT0gQSAmJiBBLnZpc3VhbFZpZXdwb3J0ID8gQS52aXN1YWxWaWV3cG9ydC53aWR0aCA6IChcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIHlbT11cbiAgICAgICk7XG4gICAgICBtIC09IEQgLSBpLndpZHRoLCBtICo9IGwgPyAxIDogLTE7XG4gICAgfVxuICB9XG4gIHZhciB4ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IGFcbiAgfSwgYyAmJiBFYyksICQgPSBkID09PSAhMCA/IFRjKHtcbiAgICB4OiBtLFxuICAgIHk6IGJcbiAgfSwgdXQoZSkpIDoge1xuICAgIHg6IG0sXG4gICAgeTogYlxuICB9O1xuICBpZiAobSA9ICQueCwgYiA9ICQueSwgbCkge1xuICAgIHZhciBQO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB4LCAoUCA9IHt9LCBQW0VdID0gdyA/IFwiMFwiIDogXCJcIiwgUFt2XSA9IEMgPyBcIjBcIiA6IFwiXCIsIFAudHJhbnNmb3JtID0gKEEuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyBtICsgXCJweCwgXCIgKyBiICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyBtICsgXCJweCwgXCIgKyBiICsgXCJweCwgMClcIiwgUCkpO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB4LCAodCA9IHt9LCB0W0VdID0gdyA/IGIgKyBcInB4XCIgOiBcIlwiLCB0W3ZdID0gQyA/IG0gKyBcInB4XCIgOiBcIlwiLCB0LnRyYW5zZm9ybSA9IFwiXCIsIHQpKTtcbn1cbmZ1bmN0aW9uIENjKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5vcHRpb25zLCBpID0gZS5ncHVBY2NlbGVyYXRpb24sIG4gPSBpID09PSB2b2lkIDAgPyAhMCA6IGksIG8gPSBlLmFkYXB0aXZlLCByID0gbyA9PT0gdm9pZCAwID8gITAgOiBvLCBhID0gZS5yb3VuZE9mZnNldHMsIGwgPSBhID09PSB2b2lkIDAgPyAhMCA6IGE7XG4gIGlmICh7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgYyA9IGJ0KHQuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgXCJcIjtcbiAgICByICYmIFtcInRyYW5zZm9ybVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXS5zb21lKGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBjLmluZGV4T2YoXykgPj0gMDtcbiAgICB9KSAmJiBjb25zb2xlLndhcm4oW1wiUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmdcIiwgJ0NTUyBwcm9wZXJ0aWVzOiBcInRyYW5zZm9ybVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLicsIGBcblxuYCwgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsIFwiZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTXCIsIFwidHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nXCIsIFwib3BhY2l0eSBvciBiYWNrZ3JvdW5kLWNvbG9yIGZvciBleGFtcGxlLlwiLCBgXG5cbmAsIFwiV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBwb3BwZXIgZWxlbWVudCBhcyBhIHdyYXBwZXIgYXJvdW5kIGFuIGlubmVyXCIsIFwiZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLlwiXS5qb2luKFwiIFwiKSk7XG4gIH1cbiAgdmFyIGQgPSB7XG4gICAgcGxhY2VtZW50OiBndCh0LnBsYWNlbWVudCksXG4gICAgdmFyaWF0aW9uOiBCZSh0LnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiB0LmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiB0LnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IG4sXG4gICAgaXNGaXhlZDogdC5vcHRpb25zLnN0cmF0ZWd5ID09PSBcImZpeGVkXCJcbiAgfTtcbiAgdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCAmJiAodC5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5zdHlsZXMucG9wcGVyLCBBbyhPYmplY3QuYXNzaWduKHt9LCBkLCB7XG4gICAgb2Zmc2V0czogdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgcG9zaXRpb246IHQub3B0aW9ucy5zdHJhdGVneSxcbiAgICBhZGFwdGl2ZTogcixcbiAgICByb3VuZE9mZnNldHM6IGxcbiAgfSkpKSksIHQubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsICYmICh0LnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHQuc3R5bGVzLmFycm93LCBBbyhPYmplY3QuYXNzaWduKHt9LCBkLCB7XG4gICAgb2Zmc2V0czogdC5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgYWRhcHRpdmU6ICExLFxuICAgIHJvdW5kT2Zmc2V0czogbFxuICB9KSkpKSwgdC5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICBcImRhdGEtcG9wcGVyLXBsYWNlbWVudFwiOiB0LnBsYWNlbWVudFxuICB9KTtcbn1cbmNvbnN0IGVvID0ge1xuICBuYW1lOiBcImNvbXB1dGVTdHlsZXNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcImJlZm9yZVdyaXRlXCIsXG4gIGZuOiBDYyxcbiAgZGF0YToge31cbn07XG52YXIgRGkgPSB7XG4gIHBhc3NpdmU6ICEwXG59O1xuZnVuY3Rpb24gQWMocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLmluc3RhbmNlLCBpID0gcy5vcHRpb25zLCBuID0gaS5zY3JvbGwsIG8gPSBuID09PSB2b2lkIDAgPyAhMCA6IG4sIHIgPSBpLnJlc2l6ZSwgYSA9IHIgPT09IHZvaWQgMCA/ICEwIDogciwgbCA9IHV0KHQuZWxlbWVudHMucG9wcGVyKSwgYyA9IFtdLmNvbmNhdCh0LnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCB0LnNjcm9sbFBhcmVudHMucG9wcGVyKTtcbiAgcmV0dXJuIG8gJiYgYy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICBkLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgZS51cGRhdGUsIERpKTtcbiAgfSksIGEgJiYgbC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGUudXBkYXRlLCBEaSksIGZ1bmN0aW9uKCkge1xuICAgIG8gJiYgYy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgIGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBlLnVwZGF0ZSwgRGkpO1xuICAgIH0pLCBhICYmIGwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBlLnVwZGF0ZSwgRGkpO1xuICB9O1xufVxuY29uc3QgaW8gPSB7XG4gIG5hbWU6IFwiZXZlbnRMaXN0ZW5lcnNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIndyaXRlXCIsXG4gIGZuOiBmdW5jdGlvbigpIHtcbiAgfSxcbiAgZWZmZWN0OiBBYyxcbiAgZGF0YToge31cbn07XG52YXIgeWMgPSB7XG4gIGxlZnQ6IFwicmlnaHRcIixcbiAgcmlnaHQ6IFwibGVmdFwiLFxuICBib3R0b206IFwidG9wXCIsXG4gIHRvcDogXCJib3R0b21cIlxufTtcbmZ1bmN0aW9uIHNzKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4geWNbdF07XG4gIH0pO1xufVxudmFyIHdjID0ge1xuICBzdGFydDogXCJlbmRcIixcbiAgZW5kOiBcInN0YXJ0XCJcbn07XG5mdW5jdGlvbiB5byhzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHdjW3RdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNvKHMpIHtcbiAgdmFyIHQgPSB1dChzKSwgZSA9IHQucGFnZVhPZmZzZXQsIGkgPSB0LnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGUsXG4gICAgc2Nyb2xsVG9wOiBpXG4gIH07XG59XG5mdW5jdGlvbiBubyhzKSB7XG4gIHJldHVybiBIZShxdChzKSkubGVmdCArIHNvKHMpLnNjcm9sbExlZnQ7XG59XG5mdW5jdGlvbiBrYyhzLCB0KSB7XG4gIHZhciBlID0gdXQocyksIGkgPSBxdChzKSwgbiA9IGUudmlzdWFsVmlld3BvcnQsIG8gPSBpLmNsaWVudFdpZHRoLCByID0gaS5jbGllbnRIZWlnaHQsIGEgPSAwLCBsID0gMDtcbiAgaWYgKG4pIHtcbiAgICBvID0gbi53aWR0aCwgciA9IG4uaGVpZ2h0O1xuICAgIHZhciBjID0gamEoKTtcbiAgICAoYyB8fCAhYyAmJiB0ID09PSBcImZpeGVkXCIpICYmIChhID0gbi5vZmZzZXRMZWZ0LCBsID0gbi5vZmZzZXRUb3ApO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IG8sXG4gICAgaGVpZ2h0OiByLFxuICAgIHg6IGEgKyBubyhzKSxcbiAgICB5OiBsXG4gIH07XG59XG5mdW5jdGlvbiBPYyhzKSB7XG4gIHZhciB0LCBlID0gcXQocyksIGkgPSBzbyhzKSwgbiA9ICh0ID0gcy5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogdC5ib2R5LCBvID0gcGUoZS5zY3JvbGxXaWR0aCwgZS5jbGllbnRXaWR0aCwgbiA/IG4uc2Nyb2xsV2lkdGggOiAwLCBuID8gbi5jbGllbnRXaWR0aCA6IDApLCByID0gcGUoZS5zY3JvbGxIZWlnaHQsIGUuY2xpZW50SGVpZ2h0LCBuID8gbi5zY3JvbGxIZWlnaHQgOiAwLCBuID8gbi5jbGllbnRIZWlnaHQgOiAwKSwgYSA9IC1pLnNjcm9sbExlZnQgKyBubyhzKSwgbCA9IC1pLnNjcm9sbFRvcDtcbiAgcmV0dXJuIGJ0KG4gfHwgZSkuZGlyZWN0aW9uID09PSBcInJ0bFwiICYmIChhICs9IHBlKGUuY2xpZW50V2lkdGgsIG4gPyBuLmNsaWVudFdpZHRoIDogMCkgLSBvKSwge1xuICAgIHdpZHRoOiBvLFxuICAgIGhlaWdodDogcixcbiAgICB4OiBhLFxuICAgIHk6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIG9vKHMpIHtcbiAgdmFyIHQgPSBidChzKSwgZSA9IHQub3ZlcmZsb3csIGkgPSB0Lm92ZXJmbG93WCwgbiA9IHQub3ZlcmZsb3dZO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KGUgKyBuICsgaSk7XG59XG5mdW5jdGlvbiBxYShzKSB7XG4gIHJldHVybiBbXCJodG1sXCIsIFwiYm9keVwiLCBcIiNkb2N1bWVudFwiXS5pbmRleE9mKEl0KHMpKSA+PSAwID8gcy5vd25lckRvY3VtZW50LmJvZHkgOiBjdChzKSAmJiBvbyhzKSA/IHMgOiBxYSh3cyhzKSk7XG59XG5mdW5jdGlvbiBjaShzLCB0KSB7XG4gIHZhciBlO1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSBbXSk7XG4gIHZhciBpID0gcWEocyksIG4gPSBpID09PSAoKGUgPSBzLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBlLmJvZHkpLCBvID0gdXQoaSksIHIgPSBuID8gW29dLmNvbmNhdChvLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBvbyhpKSA/IGkgOiBbXSkgOiBpLCBhID0gdC5jb25jYXQocik7XG4gIHJldHVybiBuID8gYSA6IChcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgICBhLmNvbmNhdChjaSh3cyhyKSkpXG4gICk7XG59XG5mdW5jdGlvbiBNbihzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzLCB7XG4gICAgbGVmdDogcy54LFxuICAgIHRvcDogcy55LFxuICAgIHJpZ2h0OiBzLnggKyBzLndpZHRoLFxuICAgIGJvdHRvbTogcy55ICsgcy5oZWlnaHRcbiAgfSk7XG59XG5mdW5jdGlvbiB4YyhzLCB0KSB7XG4gIHZhciBlID0gSGUocywgITEsIHQgPT09IFwiZml4ZWRcIik7XG4gIHJldHVybiBlLnRvcCA9IGUudG9wICsgcy5jbGllbnRUb3AsIGUubGVmdCA9IGUubGVmdCArIHMuY2xpZW50TGVmdCwgZS5ib3R0b20gPSBlLnRvcCArIHMuY2xpZW50SGVpZ2h0LCBlLnJpZ2h0ID0gZS5sZWZ0ICsgcy5jbGllbnRXaWR0aCwgZS53aWR0aCA9IHMuY2xpZW50V2lkdGgsIGUuaGVpZ2h0ID0gcy5jbGllbnRIZWlnaHQsIGUueCA9IGUubGVmdCwgZS55ID0gZS50b3AsIGU7XG59XG5mdW5jdGlvbiB3byhzLCB0LCBlKSB7XG4gIHJldHVybiB0ID09PSBHbiA/IE1uKGtjKHMsIGUpKSA6IG1lKHQpID8geGModCwgZSkgOiBNbihPYyhxdChzKSkpO1xufVxuZnVuY3Rpb24gU2Mocykge1xuICB2YXIgdCA9IGNpKHdzKHMpKSwgZSA9IFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0uaW5kZXhPZihidChzKS5wb3NpdGlvbikgPj0gMCwgaSA9IGUgJiYgY3QocykgPyBnaShzKSA6IHM7XG4gIHJldHVybiBtZShpKSA/IHQuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gbWUobikgJiYgS2EobiwgaSkgJiYgSXQobikgIT09IFwiYm9keVwiO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gRGMocywgdCwgZSwgaSkge1xuICB2YXIgbiA9IHQgPT09IFwiY2xpcHBpbmdQYXJlbnRzXCIgPyBTYyhzKSA6IFtdLmNvbmNhdCh0KSwgbyA9IFtdLmNvbmNhdChuLCBbZV0pLCByID0gb1swXSwgYSA9IG8ucmVkdWNlKGZ1bmN0aW9uKGwsIGMpIHtcbiAgICB2YXIgZCA9IHdvKHMsIGMsIGkpO1xuICAgIHJldHVybiBsLnRvcCA9IHBlKGQudG9wLCBsLnRvcCksIGwucmlnaHQgPSBUcyhkLnJpZ2h0LCBsLnJpZ2h0KSwgbC5ib3R0b20gPSBUcyhkLmJvdHRvbSwgbC5ib3R0b20pLCBsLmxlZnQgPSBwZShkLmxlZnQsIGwubGVmdCksIGw7XG4gIH0sIHdvKHMsIHIsIGkpKTtcbiAgcmV0dXJuIGEud2lkdGggPSBhLnJpZ2h0IC0gYS5sZWZ0LCBhLmhlaWdodCA9IGEuYm90dG9tIC0gYS50b3AsIGEueCA9IGEubGVmdCwgYS55ID0gYS50b3AsIGE7XG59XG5mdW5jdGlvbiBRYShzKSB7XG4gIHZhciB0ID0gcy5yZWZlcmVuY2UsIGUgPSBzLmVsZW1lbnQsIGkgPSBzLnBsYWNlbWVudCwgbiA9IGkgPyBndChpKSA6IG51bGwsIG8gPSBpID8gQmUoaSkgOiBudWxsLCByID0gdC54ICsgdC53aWR0aCAvIDIgLSBlLndpZHRoIC8gMiwgYSA9IHQueSArIHQuaGVpZ2h0IC8gMiAtIGUuaGVpZ2h0IC8gMiwgbDtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSBaOlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcixcbiAgICAgICAgeTogdC55IC0gZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIGR0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcixcbiAgICAgICAgeTogdC55ICsgdC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIGh0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54ICsgdC53aWR0aCxcbiAgICAgICAgeTogYVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSjpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHQueCAtIGUud2lkdGgsXG4gICAgICAgIHk6IGFcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54LFxuICAgICAgICB5OiB0LnlcbiAgICAgIH07XG4gIH1cbiAgdmFyIGMgPSBuID8gdG8obikgOiBudWxsO1xuICBpZiAoYyAhPSBudWxsKSB7XG4gICAgdmFyIGQgPSBjID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG4gICAgc3dpdGNoIChvKSB7XG4gICAgICBjYXNlIF9lOlxuICAgICAgICBsW2NdID0gbFtjXSAtICh0W2RdIC8gMiAtIGVbZF0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJlOlxuICAgICAgICBsW2NdID0gbFtjXSArICh0W2RdIC8gMiAtIGVbZF0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBsO1xufVxuZnVuY3Rpb24gVmUocywgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIHZhciBlID0gdCwgaSA9IGUucGxhY2VtZW50LCBuID0gaSA9PT0gdm9pZCAwID8gcy5wbGFjZW1lbnQgOiBpLCBvID0gZS5zdHJhdGVneSwgciA9IG8gPT09IHZvaWQgMCA/IHMuc3RyYXRlZ3kgOiBvLCBhID0gZS5ib3VuZGFyeSwgbCA9IGEgPT09IHZvaWQgMCA/IExhIDogYSwgYyA9IGUucm9vdEJvdW5kYXJ5LCBkID0gYyA9PT0gdm9pZCAwID8gR24gOiBjLCBfID0gZS5lbGVtZW50Q29udGV4dCwgZiA9IF8gPT09IHZvaWQgMCA/IHllIDogXywgbSA9IGUuYWx0Qm91bmRhcnksIGcgPSBtID09PSB2b2lkIDAgPyAhMSA6IG0sIGIgPSBlLnBhZGRpbmcsIFQgPSBiID09PSB2b2lkIDAgPyAwIDogYiwgQyA9IHphKHR5cGVvZiBUICE9IFwibnVtYmVyXCIgPyBUIDogWGEoVCwgWWUpKSwgdyA9IGYgPT09IHllID8gTWEgOiB5ZSwgdiA9IHMucmVjdHMucG9wcGVyLCBFID0gcy5lbGVtZW50c1tnID8gdyA6IGZdLCBBID0gRGMobWUoRSkgPyBFIDogRS5jb250ZXh0RWxlbWVudCB8fCBxdChzLmVsZW1lbnRzLnBvcHBlciksIGwsIGQsIHIpLCB5ID0gSGUocy5lbGVtZW50cy5yZWZlcmVuY2UpLCBTID0gUWEoe1xuICAgIHJlZmVyZW5jZTogeSxcbiAgICBlbGVtZW50OiB2LFxuICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCIsXG4gICAgcGxhY2VtZW50OiBuXG4gIH0pLCBPID0gTW4oT2JqZWN0LmFzc2lnbih7fSwgdiwgUykpLCBrID0gZiA9PT0geWUgPyBPIDogeSwgRCA9IHtcbiAgICB0b3A6IEEudG9wIC0gay50b3AgKyBDLnRvcCxcbiAgICBib3R0b206IGsuYm90dG9tIC0gQS5ib3R0b20gKyBDLmJvdHRvbSxcbiAgICBsZWZ0OiBBLmxlZnQgLSBrLmxlZnQgKyBDLmxlZnQsXG4gICAgcmlnaHQ6IGsucmlnaHQgLSBBLnJpZ2h0ICsgQy5yaWdodFxuICB9LCB4ID0gcy5tb2RpZmllcnNEYXRhLm9mZnNldDtcbiAgaWYgKGYgPT09IHllICYmIHgpIHtcbiAgICB2YXIgJCA9IHhbbl07XG4gICAgT2JqZWN0LmtleXMoRCkuZm9yRWFjaChmdW5jdGlvbihQKSB7XG4gICAgICB2YXIgdHQgPSBbaHQsIGR0XS5pbmRleE9mKFApID49IDAgPyAxIDogLTEsIGV0ID0gW1osIGR0XS5pbmRleE9mKFApID49IDAgPyBcInlcIiA6IFwieFwiO1xuICAgICAgRFtQXSArPSAkW2V0XSAqIHR0O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBEO1xufVxuZnVuY3Rpb24gSWMocywgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIHZhciBlID0gdCwgaSA9IGUucGxhY2VtZW50LCBuID0gZS5ib3VuZGFyeSwgbyA9IGUucm9vdEJvdW5kYXJ5LCByID0gZS5wYWRkaW5nLCBhID0gZS5mbGlwVmFyaWF0aW9ucywgbCA9IGUuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLCBjID0gbCA9PT0gdm9pZCAwID8gcW4gOiBsLCBkID0gQmUoaSksIF8gPSBkID8gYSA/ICRuIDogJG4uZmlsdGVyKGZ1bmN0aW9uKGcpIHtcbiAgICByZXR1cm4gQmUoZykgPT09IGQ7XG4gIH0pIDogWWUsIGYgPSBfLmZpbHRlcihmdW5jdGlvbihnKSB7XG4gICAgcmV0dXJuIGMuaW5kZXhPZihnKSA+PSAwO1xuICB9KTtcbiAgZi5sZW5ndGggPT09IDAgJiYgKGYgPSBfLCB7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihbXCJQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnlcIiwgXCJwbGFjZW1lbnRzLiBFbnN1cmUgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbiBtYXRjaGVzIHRoZSB2YXJpYXRpb25cIiwgXCJvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLlwiLCAnRm9yIGV4YW1wbGUsIFwiYXV0b1wiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFwiYm90dG9tLXN0YXJ0XCIuJywgJ1VzZSBcImF1dG8tc3RhcnRcIiBpbnN0ZWFkLiddLmpvaW4oXCIgXCIpKSk7XG4gIHZhciBtID0gZi5yZWR1Y2UoZnVuY3Rpb24oZywgYikge1xuICAgIHJldHVybiBnW2JdID0gVmUocywge1xuICAgICAgcGxhY2VtZW50OiBiLFxuICAgICAgYm91bmRhcnk6IG4sXG4gICAgICByb290Qm91bmRhcnk6IG8sXG4gICAgICBwYWRkaW5nOiByXG4gICAgfSlbZ3QoYildLCBnO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtKS5zb3J0KGZ1bmN0aW9uKGcsIGIpIHtcbiAgICByZXR1cm4gbVtnXSAtIG1bYl07XG4gIH0pO1xufVxuZnVuY3Rpb24gJGMocykge1xuICBpZiAoZ3QocykgPT09IG1pKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHQgPSBzcyhzKTtcbiAgcmV0dXJuIFt5byhzKSwgdCwgeW8odCldO1xufVxuZnVuY3Rpb24gTGMocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBzLm5hbWU7XG4gIGlmICghdC5tb2RpZmllcnNEYXRhW2ldLl9za2lwKSB7XG4gICAgZm9yICh2YXIgbiA9IGUubWFpbkF4aXMsIG8gPSBuID09PSB2b2lkIDAgPyAhMCA6IG4sIHIgPSBlLmFsdEF4aXMsIGEgPSByID09PSB2b2lkIDAgPyAhMCA6IHIsIGwgPSBlLmZhbGxiYWNrUGxhY2VtZW50cywgYyA9IGUucGFkZGluZywgZCA9IGUuYm91bmRhcnksIF8gPSBlLnJvb3RCb3VuZGFyeSwgZiA9IGUuYWx0Qm91bmRhcnksIG0gPSBlLmZsaXBWYXJpYXRpb25zLCBnID0gbSA9PT0gdm9pZCAwID8gITAgOiBtLCBiID0gZS5hbGxvd2VkQXV0b1BsYWNlbWVudHMsIFQgPSB0Lm9wdGlvbnMucGxhY2VtZW50LCBDID0gZ3QoVCksIHcgPSBDID09PSBULCB2ID0gbCB8fCAodyB8fCAhZyA/IFtzcyhUKV0gOiAkYyhUKSksIEUgPSBbVF0uY29uY2F0KHYpLnJlZHVjZShmdW5jdGlvbihiZSwgTnQpIHtcbiAgICAgIHJldHVybiBiZS5jb25jYXQoZ3QoTnQpID09PSBtaSA/IEljKHQsIHtcbiAgICAgICAgcGxhY2VtZW50OiBOdCxcbiAgICAgICAgYm91bmRhcnk6IGQsXG4gICAgICAgIHJvb3RCb3VuZGFyeTogXyxcbiAgICAgICAgcGFkZGluZzogYyxcbiAgICAgICAgZmxpcFZhcmlhdGlvbnM6IGcsXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYlxuICAgICAgfSkgOiBOdCk7XG4gICAgfSwgW10pLCBBID0gdC5yZWN0cy5yZWZlcmVuY2UsIHkgPSB0LnJlY3RzLnBvcHBlciwgUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIE8gPSAhMCwgayA9IEVbMF0sIEQgPSAwOyBEIDwgRS5sZW5ndGg7IEQrKykge1xuICAgICAgdmFyIHggPSBFW0RdLCAkID0gZ3QoeCksIFAgPSBCZSh4KSA9PT0gX2UsIHR0ID0gW1osIGR0XS5pbmRleE9mKCQpID49IDAsIGV0ID0gdHQgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCB6ID0gVmUodCwge1xuICAgICAgICBwbGFjZW1lbnQ6IHgsXG4gICAgICAgIGJvdW5kYXJ5OiBkLFxuICAgICAgICByb290Qm91bmRhcnk6IF8sXG4gICAgICAgIGFsdEJvdW5kYXJ5OiBmLFxuICAgICAgICBwYWRkaW5nOiBjXG4gICAgICB9KSwgX3QgPSB0dCA/IFAgPyBodCA6IEogOiBQID8gZHQgOiBaO1xuICAgICAgQVtldF0gPiB5W2V0XSAmJiAoX3QgPSBzcyhfdCkpO1xuICAgICAgdmFyIHdpID0gc3MoX3QpLCBadCA9IFtdO1xuICAgICAgaWYgKG8gJiYgWnQucHVzaCh6WyRdIDw9IDApLCBhICYmIFp0LnB1c2goeltfdF0gPD0gMCwgelt3aV0gPD0gMCksIFp0LmV2ZXJ5KGZ1bmN0aW9uKGJlKSB7XG4gICAgICAgIHJldHVybiBiZTtcbiAgICAgIH0pKSB7XG4gICAgICAgIGsgPSB4LCBPID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgUy5zZXQoeCwgWnQpO1xuICAgIH1cbiAgICBpZiAoTylcbiAgICAgIGZvciAodmFyIGtpID0gZyA/IDMgOiAxLCBOcyA9IGZ1bmN0aW9uKE50KSB7XG4gICAgICAgIHZhciBYZSA9IEUuZmluZChmdW5jdGlvbih4aSkge1xuICAgICAgICAgIHZhciBKdCA9IFMuZ2V0KHhpKTtcbiAgICAgICAgICBpZiAoSnQpXG4gICAgICAgICAgICByZXR1cm4gSnQuc2xpY2UoMCwgTnQpLmV2ZXJ5KGZ1bmN0aW9uKFJzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBScztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKFhlKVxuICAgICAgICAgIHJldHVybiBrID0gWGUsIFwiYnJlYWtcIjtcbiAgICAgIH0sIHplID0ga2k7IHplID4gMDsgemUtLSkge1xuICAgICAgICB2YXIgT2kgPSBOcyh6ZSk7XG4gICAgICAgIGlmIChPaSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIHQucGxhY2VtZW50ICE9PSBrICYmICh0Lm1vZGlmaWVyc0RhdGFbaV0uX3NraXAgPSAhMCwgdC5wbGFjZW1lbnQgPSBrLCB0LnJlc2V0ID0gITApO1xuICB9XG59XG5jb25zdCBaYSA9IHtcbiAgbmFtZTogXCJmbGlwXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIGZuOiBMYyxcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wib2Zmc2V0XCJdLFxuICBkYXRhOiB7XG4gICAgX3NraXA6ICExXG4gIH1cbn07XG5mdW5jdGlvbiBrbyhzLCB0LCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0pLCB7XG4gICAgdG9wOiBzLnRvcCAtIHQuaGVpZ2h0IC0gZS55LFxuICAgIHJpZ2h0OiBzLnJpZ2h0IC0gdC53aWR0aCArIGUueCxcbiAgICBib3R0b206IHMuYm90dG9tIC0gdC5oZWlnaHQgKyBlLnksXG4gICAgbGVmdDogcy5sZWZ0IC0gdC53aWR0aCAtIGUueFxuICB9O1xufVxuZnVuY3Rpb24gT28ocykge1xuICByZXR1cm4gW1osIGh0LCBkdCwgSl0uc29tZShmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHNbdF0gPj0gMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBNYyhzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMubmFtZSwgaSA9IHQucmVjdHMucmVmZXJlbmNlLCBuID0gdC5yZWN0cy5wb3BwZXIsIG8gPSB0Lm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93LCByID0gVmUodCwge1xuICAgIGVsZW1lbnRDb250ZXh0OiBcInJlZmVyZW5jZVwiXG4gIH0pLCBhID0gVmUodCwge1xuICAgIGFsdEJvdW5kYXJ5OiAhMFxuICB9KSwgbCA9IGtvKHIsIGkpLCBjID0ga28oYSwgbiwgbyksIGQgPSBPbyhsKSwgXyA9IE9vKGMpO1xuICB0Lm1vZGlmaWVyc0RhdGFbZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiBsLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IGMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGQsXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogX1xuICB9LCB0LmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgIFwiZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlblwiOiBkLFxuICAgIFwiZGF0YS1wb3BwZXItZXNjYXBlZFwiOiBfXG4gIH0pO1xufVxuY29uc3QgSmEgPSB7XG4gIG5hbWU6IFwiaGlkZVwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJwcmV2ZW50T3ZlcmZsb3dcIl0sXG4gIGZuOiBNY1xufTtcbmZ1bmN0aW9uIE5jKHMsIHQsIGUpIHtcbiAgdmFyIGkgPSBndChzKSwgbiA9IFtKLCBaXS5pbmRleE9mKGkpID49IDAgPyAtMSA6IDEsIG8gPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKE9iamVjdC5hc3NpZ24oe30sIHQsIHtcbiAgICBwbGFjZW1lbnQ6IHNcbiAgfSkpIDogZSwgciA9IG9bMF0sIGEgPSBvWzFdO1xuICByZXR1cm4gciA9IHIgfHwgMCwgYSA9IChhIHx8IDApICogbiwgW0osIGh0XS5pbmRleE9mKGkpID49IDAgPyB7XG4gICAgeDogYSxcbiAgICB5OiByXG4gIH0gOiB7XG4gICAgeDogcixcbiAgICB5OiBhXG4gIH07XG59XG5mdW5jdGlvbiBSYyhzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IHMubmFtZSwgbiA9IGUub2Zmc2V0LCBvID0gbiA9PT0gdm9pZCAwID8gWzAsIDBdIDogbiwgciA9IHFuLnJlZHVjZShmdW5jdGlvbihkLCBfKSB7XG4gICAgcmV0dXJuIGRbX10gPSBOYyhfLCB0LnJlY3RzLCBvKSwgZDtcbiAgfSwge30pLCBhID0gclt0LnBsYWNlbWVudF0sIGwgPSBhLngsIGMgPSBhLnk7XG4gIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwgJiYgKHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0gbCwgdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSBjKSwgdC5tb2RpZmllcnNEYXRhW2ldID0gcjtcbn1cbmNvbnN0IHRsID0ge1xuICBuYW1lOiBcIm9mZnNldFwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICByZXF1aXJlczogW1wicG9wcGVyT2Zmc2V0c1wiXSxcbiAgZm46IFJjXG59O1xuZnVuY3Rpb24gUGMocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm5hbWU7XG4gIHQubW9kaWZpZXJzRGF0YVtlXSA9IFFhKHtcbiAgICByZWZlcmVuY2U6IHQucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHQucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCIsXG4gICAgcGxhY2VtZW50OiB0LnBsYWNlbWVudFxuICB9KTtcbn1cbmNvbnN0IHJvID0ge1xuICBuYW1lOiBcInBvcHBlck9mZnNldHNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcInJlYWRcIixcbiAgZm46IFBjLFxuICBkYXRhOiB7fVxufTtcbmZ1bmN0aW9uIEhjKHMpIHtcbiAgcmV0dXJuIHMgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbn1cbmZ1bmN0aW9uIEJjKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5vcHRpb25zLCBpID0gcy5uYW1lLCBuID0gZS5tYWluQXhpcywgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgciA9IGUuYWx0QXhpcywgYSA9IHIgPT09IHZvaWQgMCA/ICExIDogciwgbCA9IGUuYm91bmRhcnksIGMgPSBlLnJvb3RCb3VuZGFyeSwgZCA9IGUuYWx0Qm91bmRhcnksIF8gPSBlLnBhZGRpbmcsIGYgPSBlLnRldGhlciwgbSA9IGYgPT09IHZvaWQgMCA/ICEwIDogZiwgZyA9IGUudGV0aGVyT2Zmc2V0LCBiID0gZyA9PT0gdm9pZCAwID8gMCA6IGcsIFQgPSBWZSh0LCB7XG4gICAgYm91bmRhcnk6IGwsXG4gICAgcm9vdEJvdW5kYXJ5OiBjLFxuICAgIHBhZGRpbmc6IF8sXG4gICAgYWx0Qm91bmRhcnk6IGRcbiAgfSksIEMgPSBndCh0LnBsYWNlbWVudCksIHcgPSBCZSh0LnBsYWNlbWVudCksIHYgPSAhdywgRSA9IHRvKEMpLCBBID0gSGMoRSksIHkgPSB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cywgUyA9IHQucmVjdHMucmVmZXJlbmNlLCBPID0gdC5yZWN0cy5wb3BwZXIsIGsgPSB0eXBlb2YgYiA9PSBcImZ1bmN0aW9uXCIgPyBiKE9iamVjdC5hc3NpZ24oe30sIHQucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHQucGxhY2VtZW50XG4gIH0pKSA6IGIsIEQgPSB0eXBlb2YgayA9PSBcIm51bWJlclwiID8ge1xuICAgIG1haW5BeGlzOiBrLFxuICAgIGFsdEF4aXM6IGtcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgayksIHggPSB0Lm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gdC5tb2RpZmllcnNEYXRhLm9mZnNldFt0LnBsYWNlbWVudF0gOiBudWxsLCAkID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBpZiAoeSkge1xuICAgIGlmIChvKSB7XG4gICAgICB2YXIgUCwgdHQgPSBFID09PSBcInlcIiA/IFogOiBKLCBldCA9IEUgPT09IFwieVwiID8gZHQgOiBodCwgeiA9IEUgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgX3QgPSB5W0VdLCB3aSA9IF90ICsgVFt0dF0sIFp0ID0gX3QgLSBUW2V0XSwga2kgPSBtID8gLU9bel0gLyAyIDogMCwgTnMgPSB3ID09PSBfZSA/IFNbel0gOiBPW3pdLCB6ZSA9IHcgPT09IF9lID8gLU9bel0gOiAtU1t6XSwgT2kgPSB0LmVsZW1lbnRzLmFycm93LCBiZSA9IG0gJiYgT2kgPyBKbihPaSkgOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sIE50ID0gdC5tb2RpZmllcnNEYXRhW1wiYXJyb3cjcGVyc2lzdGVudFwiXSA/IHQubW9kaWZpZXJzRGF0YVtcImFycm93I3BlcnNpc3RlbnRcIl0ucGFkZGluZyA6IFVhKCksIFhlID0gTnRbdHRdLCB4aSA9IE50W2V0XSwgSnQgPSBsaSgwLCBTW3pdLCBiZVt6XSksIFJzID0gdiA/IFNbel0gLyAyIC0ga2kgLSBKdCAtIFhlIC0gRC5tYWluQXhpcyA6IE5zIC0gSnQgLSBYZSAtIEQubWFpbkF4aXMsIEZsID0gdiA/IC1TW3pdIC8gMiArIGtpICsgSnQgKyB4aSArIEQubWFpbkF4aXMgOiB6ZSArIEp0ICsgeGkgKyBELm1haW5BeGlzLCBQcyA9IHQuZWxlbWVudHMuYXJyb3cgJiYgZ2kodC5lbGVtZW50cy5hcnJvdyksIFlsID0gUHMgPyBFID09PSBcInlcIiA/IFBzLmNsaWVudFRvcCB8fCAwIDogUHMuY2xpZW50TGVmdCB8fCAwIDogMCwgaG8gPSAoUCA9IHggPT0gbnVsbCA/IHZvaWQgMCA6IHhbRV0pICE9IG51bGwgPyBQIDogMCwgamwgPSBfdCArIFJzIC0gaG8gLSBZbCwgS2wgPSBfdCArIEZsIC0gaG8sIHVvID0gbGkobSA/IFRzKHdpLCBqbCkgOiB3aSwgX3QsIG0gPyBwZShadCwgS2wpIDogWnQpO1xuICAgICAgeVtFXSA9IHVvLCAkW0VdID0gdW8gLSBfdDtcbiAgICB9XG4gICAgaWYgKGEpIHtcbiAgICAgIHZhciBwbywgVWwgPSBFID09PSBcInhcIiA/IFogOiBKLCB6bCA9IEUgPT09IFwieFwiID8gZHQgOiBodCwgdGUgPSB5W0FdLCBTaSA9IEEgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgZm8gPSB0ZSArIFRbVWxdLCBfbyA9IHRlIC0gVFt6bF0sIEhzID0gW1osIEpdLmluZGV4T2YoQykgIT09IC0xLCBtbyA9IChwbyA9IHggPT0gbnVsbCA/IHZvaWQgMCA6IHhbQV0pICE9IG51bGwgPyBwbyA6IDAsIGdvID0gSHMgPyBmbyA6IHRlIC0gU1tTaV0gLSBPW1NpXSAtIG1vICsgRC5hbHRBeGlzLCBibyA9IEhzID8gdGUgKyBTW1NpXSArIE9bU2ldIC0gbW8gLSBELmFsdEF4aXMgOiBfbywgdm8gPSBtICYmIEhzID8gbWMoZ28sIHRlLCBibykgOiBsaShtID8gZ28gOiBmbywgdGUsIG0gPyBibyA6IF9vKTtcbiAgICAgIHlbQV0gPSB2bywgJFtBXSA9IHZvIC0gdGU7XG4gICAgfVxuICAgIHQubW9kaWZpZXJzRGF0YVtpXSA9ICQ7XG4gIH1cbn1cbmNvbnN0IGVsID0ge1xuICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICBmbjogQmMsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcIm9mZnNldFwiXVxufTtcbmZ1bmN0aW9uIFZjKHMpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzLnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzLnNjcm9sbFRvcFxuICB9O1xufVxuZnVuY3Rpb24gV2Mocykge1xuICByZXR1cm4gcyA9PT0gdXQocykgfHwgIWN0KHMpID8gc28ocykgOiBWYyhzKTtcbn1cbmZ1bmN0aW9uIEZjKHMpIHtcbiAgdmFyIHQgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBlID0gUGUodC53aWR0aCkgLyBzLm9mZnNldFdpZHRoIHx8IDEsIGkgPSBQZSh0LmhlaWdodCkgLyBzLm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gZSAhPT0gMSB8fCBpICE9PSAxO1xufVxuZnVuY3Rpb24gWWMocywgdCwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAhMSk7XG4gIHZhciBpID0gY3QodCksIG4gPSBjdCh0KSAmJiBGYyh0KSwgbyA9IHF0KHQpLCByID0gSGUocywgbiwgZSksIGEgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfSwgbCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgcmV0dXJuIChpIHx8ICFpICYmICFlKSAmJiAoKEl0KHQpICE9PSBcImJvZHlcIiB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgb28obykpICYmIChhID0gV2ModCkpLCBjdCh0KSA/IChsID0gSGUodCwgITApLCBsLnggKz0gdC5jbGllbnRMZWZ0LCBsLnkgKz0gdC5jbGllbnRUb3ApIDogbyAmJiAobC54ID0gbm8obykpKSwge1xuICAgIHg6IHIubGVmdCArIGEuc2Nyb2xsTGVmdCAtIGwueCxcbiAgICB5OiByLnRvcCArIGEuc2Nyb2xsVG9wIC0gbC55LFxuICAgIHdpZHRoOiByLndpZHRoLFxuICAgIGhlaWdodDogci5oZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGpjKHMpIHtcbiAgdmFyIHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgaSA9IFtdO1xuICBzLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgIHQuc2V0KG8ubmFtZSwgbyk7XG4gIH0pO1xuICBmdW5jdGlvbiBuKG8pIHtcbiAgICBlLmFkZChvLm5hbWUpO1xuICAgIHZhciByID0gW10uY29uY2F0KG8ucmVxdWlyZXMgfHwgW10sIG8ucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgci5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGlmICghZS5oYXMoYSkpIHtcbiAgICAgICAgdmFyIGwgPSB0LmdldChhKTtcbiAgICAgICAgbCAmJiBuKGwpO1xuICAgICAgfVxuICAgIH0pLCBpLnB1c2gobyk7XG4gIH1cbiAgcmV0dXJuIHMuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgZS5oYXMoby5uYW1lKSB8fCBuKG8pO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIEtjKHMpIHtcbiAgdmFyIHQgPSBqYyhzKTtcbiAgcmV0dXJuIEVzLnJlZHVjZShmdW5jdGlvbihlLCBpKSB7XG4gICAgcmV0dXJuIGUuY29uY2F0KHQuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBuLnBoYXNlID09PSBpO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gVWMocykge1xuICB2YXIgdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0IHx8ICh0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24oZSkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgdCA9IHZvaWQgMCwgZShzKCkpO1xuICAgICAgfSk7XG4gICAgfSkpLCB0O1xuICB9O1xufVxuZnVuY3Rpb24gUnQocykge1xuICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgZSA9IG5ldyBBcnJheSh0ID4gMSA/IHQgLSAxIDogMCksIGkgPSAxOyBpIDwgdDsgaSsrKVxuICAgIGVbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICByZXR1cm4gW10uY29uY2F0KGUpLnJlZHVjZShmdW5jdGlvbihuLCBvKSB7XG4gICAgcmV0dXJuIG4ucmVwbGFjZSgvJXMvLCBvKTtcbiAgfSwgcyk7XG59XG52YXIgaWUgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcHJvdmlkZWQgYW4gaW52YWxpZCAlcyBwcm9wZXJ0eSwgZXhwZWN0ZWQgJXMgYnV0IGdvdCAlcycsIHpjID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHJlcXVpcmVzIFwiJXNcIiwgYnV0IFwiJXNcIiBtb2RpZmllciBpcyBub3QgYXZhaWxhYmxlJywgeG8gPSBbXCJuYW1lXCIsIFwiZW5hYmxlZFwiLCBcInBoYXNlXCIsIFwiZm5cIiwgXCJlZmZlY3RcIiwgXCJyZXF1aXJlc1wiLCBcIm9wdGlvbnNcIl07XG5mdW5jdGlvbiBYYyhzKSB7XG4gIHMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgW10uY29uY2F0KE9iamVjdC5rZXlzKHQpLCB4bykuZmlsdGVyKGZ1bmN0aW9uKGUsIGksIG4pIHtcbiAgICAgIHJldHVybiBuLmluZGV4T2YoZSkgPT09IGk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICB0eXBlb2YgdC5uYW1lICE9IFwic3RyaW5nXCIgJiYgY29uc29sZS5lcnJvcihSdChpZSwgU3RyaW5nKHQubmFtZSksICdcIm5hbWVcIicsICdcInN0cmluZ1wiJywgJ1wiJyArIFN0cmluZyh0Lm5hbWUpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW5hYmxlZFwiOlxuICAgICAgICAgIHR5cGVvZiB0LmVuYWJsZWQgIT0gXCJib29sZWFuXCIgJiYgY29uc29sZS5lcnJvcihSdChpZSwgdC5uYW1lLCAnXCJlbmFibGVkXCInLCAnXCJib29sZWFuXCInLCAnXCInICsgU3RyaW5nKHQuZW5hYmxlZCkgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwaGFzZVwiOlxuICAgICAgICAgIEVzLmluZGV4T2YodC5waGFzZSkgPCAwICYmIGNvbnNvbGUuZXJyb3IoUnQoaWUsIHQubmFtZSwgJ1wicGhhc2VcIicsIFwiZWl0aGVyIFwiICsgRXMuam9pbihcIiwgXCIpLCAnXCInICsgU3RyaW5nKHQucGhhc2UpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZm5cIjpcbiAgICAgICAgICB0eXBlb2YgdC5mbiAhPSBcImZ1bmN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihSdChpZSwgdC5uYW1lLCAnXCJmblwiJywgJ1wiZnVuY3Rpb25cIicsICdcIicgKyBTdHJpbmcodC5mbikgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlZmZlY3RcIjpcbiAgICAgICAgICB0LmVmZmVjdCAhPSBudWxsICYmIHR5cGVvZiB0LmVmZmVjdCAhPSBcImZ1bmN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihSdChpZSwgdC5uYW1lLCAnXCJlZmZlY3RcIicsICdcImZ1bmN0aW9uXCInLCAnXCInICsgU3RyaW5nKHQuZm4pICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVxdWlyZXNcIjpcbiAgICAgICAgICB0LnJlcXVpcmVzICE9IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodC5yZXF1aXJlcykgJiYgY29uc29sZS5lcnJvcihSdChpZSwgdC5uYW1lLCAnXCJyZXF1aXJlc1wiJywgJ1wiYXJyYXlcIicsICdcIicgKyBTdHJpbmcodC5yZXF1aXJlcykgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZXF1aXJlc0lmRXhpc3RzXCI6XG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh0LnJlcXVpcmVzSWZFeGlzdHMpIHx8IGNvbnNvbGUuZXJyb3IoUnQoaWUsIHQubmFtZSwgJ1wicmVxdWlyZXNJZkV4aXN0c1wiJywgJ1wiYXJyYXlcIicsICdcIicgKyBTdHJpbmcodC5yZXF1aXJlc0lmRXhpc3RzKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9wdGlvbnNcIjpcbiAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdQb3BwZXJKUzogYW4gaW52YWxpZCBwcm9wZXJ0eSBoYXMgYmVlbiBwcm92aWRlZCB0byB0aGUgXCInICsgdC5uYW1lICsgJ1wiIG1vZGlmaWVyLCB2YWxpZCBwcm9wZXJ0aWVzIGFyZSAnICsgeG8ubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCInICsgaSArICdcIic7XG4gICAgICAgICAgfSkuam9pbihcIiwgXCIpICsgJzsgYnV0IFwiJyArIGUgKyAnXCIgd2FzIHByb3ZpZGVkLicpO1xuICAgICAgfVxuICAgICAgdC5yZXF1aXJlcyAmJiB0LnJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBzLmZpbmQoZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuLm5hbWUgPT09IGk7XG4gICAgICAgIH0pID09IG51bGwgJiYgY29uc29sZS5lcnJvcihSdCh6YywgU3RyaW5nKHQubmFtZSksIGksIGkpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIEdjKHMsIHQpIHtcbiAgdmFyIGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICByZXR1cm4gcy5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgIHZhciBuID0gdChpKTtcbiAgICBpZiAoIWUuaGFzKG4pKVxuICAgICAgcmV0dXJuIGUuYWRkKG4pLCAhMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBxYyhzKSB7XG4gIHZhciB0ID0gcy5yZWR1Y2UoZnVuY3Rpb24oZSwgaSkge1xuICAgIHZhciBuID0gZVtpLm5hbWVdO1xuICAgIHJldHVybiBlW2kubmFtZV0gPSBuID8gT2JqZWN0LmFzc2lnbih7fSwgbiwgaSwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgbi5vcHRpb25zLCBpLm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgbi5kYXRhLCBpLmRhdGEpXG4gICAgfSkgOiBpLCBlO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0KS5tYXAoZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0W2VdO1xuICB9KTtcbn1cbnZhciBTbyA9IFwiUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuXCIsIFFjID0gXCJQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLlwiLCBEbyA9IHtcbiAgcGxhY2VtZW50OiBcImJvdHRvbVwiLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiXG59O1xuZnVuY3Rpb24gSW8oKSB7XG4gIGZvciAodmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KHMpLCBlID0gMDsgZSA8IHM7IGUrKylcbiAgICB0W2VdID0gYXJndW1lbnRzW2VdO1xuICByZXR1cm4gIXQuc29tZShmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuICEoaSAmJiB0eXBlb2YgaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT0gXCJmdW5jdGlvblwiKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBrcyhzKSB7XG4gIHMgPT09IHZvaWQgMCAmJiAocyA9IHt9KTtcbiAgdmFyIHQgPSBzLCBlID0gdC5kZWZhdWx0TW9kaWZpZXJzLCBpID0gZSA9PT0gdm9pZCAwID8gW10gOiBlLCBuID0gdC5kZWZhdWx0T3B0aW9ucywgbyA9IG4gPT09IHZvaWQgMCA/IERvIDogbjtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGwsIGMpIHtcbiAgICBjID09PSB2b2lkIDAgJiYgKGMgPSBvKTtcbiAgICB2YXIgZCA9IHtcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgRG8sIG8pLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IGEsXG4gICAgICAgIHBvcHBlcjogbFxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH0sIF8gPSBbXSwgZiA9ICExLCBtID0ge1xuICAgICAgc3RhdGU6IGQsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihDKSB7XG4gICAgICAgIHZhciB3ID0gdHlwZW9mIEMgPT0gXCJmdW5jdGlvblwiID8gQyhkLm9wdGlvbnMpIDogQztcbiAgICAgICAgYigpLCBkLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvLCBkLm9wdGlvbnMsIHcpLCBkLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBtZShhKSA/IGNpKGEpIDogYS5jb250ZXh0RWxlbWVudCA/IGNpKGEuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBjaShsKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdiA9IEtjKHFjKFtdLmNvbmNhdChpLCBkLm9wdGlvbnMubW9kaWZpZXJzKSkpO1xuICAgICAgICBpZiAoZC5vcmRlcmVkTW9kaWZpZXJzID0gdi5maWx0ZXIoZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHJldHVybiB4LmVuYWJsZWQ7XG4gICAgICAgIH0pLCB7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgRSA9IEdjKFtdLmNvbmNhdCh2LCBkLm9wdGlvbnMubW9kaWZpZXJzKSwgZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgdmFyICQgPSB4Lm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gJDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoWGMoRSksIGd0KGQub3B0aW9ucy5wbGFjZW1lbnQpID09PSBtaSkge1xuICAgICAgICAgICAgdmFyIEEgPSBkLm9yZGVyZWRNb2RpZmllcnMuZmluZChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICAgIHZhciAkID0geC5uYW1lO1xuICAgICAgICAgICAgICByZXR1cm4gJCA9PT0gXCJmbGlwXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEEgfHwgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsIFwicHJlc2VudCBhbmQgZW5hYmxlZCB0byB3b3JrLlwiXS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB5ID0gYnQobCksIFMgPSB5Lm1hcmdpblRvcCwgTyA9IHkubWFyZ2luUmlnaHQsIGsgPSB5Lm1hcmdpbkJvdHRvbSwgRCA9IHkubWFyZ2luTGVmdDtcbiAgICAgICAgICBbUywgTywgaywgRF0uc29tZShmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh4KTtcbiAgICAgICAgICB9KSAmJiBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgXCJiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudCBvciBib3VuZGFyeS5cIiwgXCJUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzXCIsIFwidGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGBcIiwgXCJtb2RpZmllcnMuXCJdLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZygpLCBtLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFmKSB7XG4gICAgICAgICAgdmFyIEMgPSBkLmVsZW1lbnRzLCB3ID0gQy5yZWZlcmVuY2UsIHYgPSBDLnBvcHBlcjtcbiAgICAgICAgICBpZiAoIUlvKHcsIHYpKSB7XG4gICAgICAgICAgICAoe30pLk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFNvKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZC5yZWN0cyA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZTogWWModywgZ2kodiksIGQub3B0aW9ucy5zdHJhdGVneSA9PT0gXCJmaXhlZFwiKSxcbiAgICAgICAgICAgIHBvcHBlcjogSm4odilcbiAgICAgICAgICB9LCBkLnJlc2V0ID0gITEsIGQucGxhY2VtZW50ID0gZC5vcHRpb25zLnBsYWNlbWVudCwgZC5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgcmV0dXJuIGQubW9kaWZpZXJzRGF0YVt4Lm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgeC5kYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKHZhciBFID0gMCwgQSA9IDA7IEEgPCBkLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBBKyspIHtcbiAgICAgICAgICAgIGlmICh7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKEUgKz0gMSwgRSA+IDEwMCkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihRYyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQucmVzZXQgPT09ICEwKSB7XG4gICAgICAgICAgICAgIGQucmVzZXQgPSAhMSwgQSA9IC0xO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ID0gZC5vcmRlcmVkTW9kaWZpZXJzW0FdLCBTID0geS5mbiwgTyA9IHkub3B0aW9ucywgayA9IE8gPT09IHZvaWQgMCA/IHt9IDogTywgRCA9IHkubmFtZTtcbiAgICAgICAgICAgIHR5cGVvZiBTID09IFwiZnVuY3Rpb25cIiAmJiAoZCA9IFMoe1xuICAgICAgICAgICAgICBzdGF0ZTogZCxcbiAgICAgICAgICAgICAgb3B0aW9uczogayxcbiAgICAgICAgICAgICAgbmFtZTogRCxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IG1cbiAgICAgICAgICAgIH0pIHx8IGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IFVjKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oVCkge1xuICAgICAgICAgIG0uZm9yY2VVcGRhdGUoKSwgVChkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBiKCksIGYgPSAhMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghSW8oYSwgbCkpXG4gICAgICByZXR1cm4ge30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoU28pLCBtO1xuICAgIG0uc2V0T3B0aW9ucyhjKS50aGVuKGZ1bmN0aW9uKFQpIHtcbiAgICAgICFmICYmIGMub25GaXJzdFVwZGF0ZSAmJiBjLm9uRmlyc3RVcGRhdGUoVCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZygpIHtcbiAgICAgIGQub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgdmFyIEMgPSBULm5hbWUsIHcgPSBULm9wdGlvbnMsIHYgPSB3ID09PSB2b2lkIDAgPyB7fSA6IHcsIEUgPSBULmVmZmVjdDtcbiAgICAgICAgaWYgKHR5cGVvZiBFID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHZhciBBID0gRSh7XG4gICAgICAgICAgICBzdGF0ZTogZCxcbiAgICAgICAgICAgIG5hbWU6IEMsXG4gICAgICAgICAgICBpbnN0YW5jZTogbSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHZcbiAgICAgICAgICB9KSwgeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIH07XG4gICAgICAgICAgXy5wdXNoKEEgfHwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiKCkge1xuICAgICAgXy5mb3JFYWNoKGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgcmV0dXJuIFQoKTtcbiAgICAgIH0pLCBfID0gW107XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9O1xufVxudmFyIFpjID0gLyogQF9fUFVSRV9fICovIGtzKCksIEpjID0gW2lvLCBybywgZW8sIFpuXSwgdGQgPSAvKiBAX19QVVJFX18gKi8ga3Moe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBKY1xufSksIGVkID0gW2lvLCBybywgZW8sIFpuLCB0bCwgWmEsIGVsLCBHYSwgSmFdLCBqZSA9IC8qIEBfX1BVUkVfXyAqLyBrcyh7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGVkXG59KTtcbmNvbnN0IGlsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYWZ0ZXJNYWluOiBWYSxcbiAgYWZ0ZXJSZWFkOiBQYSxcbiAgYWZ0ZXJXcml0ZTogWWEsXG4gIGFwcGx5U3R5bGVzOiBabixcbiAgYXJyb3c6IEdhLFxuICBhdXRvOiBtaSxcbiAgYmFzZVBsYWNlbWVudHM6IFllLFxuICBiZWZvcmVNYWluOiBIYSxcbiAgYmVmb3JlUmVhZDogTmEsXG4gIGJlZm9yZVdyaXRlOiBXYSxcbiAgYm90dG9tOiBkdCxcbiAgY2xpcHBpbmdQYXJlbnRzOiBMYSxcbiAgY29tcHV0ZVN0eWxlczogZW8sXG4gIGNyZWF0ZVBvcHBlcjogamUsXG4gIGNyZWF0ZVBvcHBlckJhc2U6IFpjLFxuICBjcmVhdGVQb3BwZXJMaXRlOiB0ZCxcbiAgZGV0ZWN0T3ZlcmZsb3c6IFZlLFxuICBlbmQ6IFJlLFxuICBldmVudExpc3RlbmVyczogaW8sXG4gIGZsaXA6IFphLFxuICBoaWRlOiBKYSxcbiAgbGVmdDogSixcbiAgbWFpbjogQmEsXG4gIG1vZGlmaWVyUGhhc2VzOiBFcyxcbiAgb2Zmc2V0OiB0bCxcbiAgcGxhY2VtZW50czogcW4sXG4gIHBvcHBlcjogeWUsXG4gIHBvcHBlckdlbmVyYXRvcjoga3MsXG4gIHBvcHBlck9mZnNldHM6IHJvLFxuICBwcmV2ZW50T3ZlcmZsb3c6IGVsLFxuICByZWFkOiBSYSxcbiAgcmVmZXJlbmNlOiBNYSxcbiAgcmlnaHQ6IGh0LFxuICBzdGFydDogX2UsXG4gIHRvcDogWixcbiAgdmFyaWF0aW9uUGxhY2VtZW50czogJG4sXG4gIHZpZXdwb3J0OiBHbixcbiAgd3JpdGU6IEZhXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuZnVuY3Rpb24gRnMocykge1xuICByZXR1cm4gcyA9PT0gXCJ0cnVlXCIgPyAhMCA6IHMgPT09IFwiZmFsc2VcIiA/ICExIDogcyA9PT0gTnVtYmVyKHMpLnRvU3RyaW5nKCkgPyBOdW1iZXIocykgOiBzID09PSBcIlwiIHx8IHMgPT09IFwibnVsbFwiID8gbnVsbCA6IHM7XG59XG5mdW5jdGlvbiBZcyhzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1tBLVpdL2csICh0KSA9PiBgLSR7dC50b0xvd2VyQ2FzZSgpfWApO1xufVxuY29uc3QgcCA9IHtcbiAgc2V0RGF0YUF0dHJpYnV0ZShzLCB0LCBlKSB7XG4gICAgcy5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtJHtZcyh0KX1gLCBlKTtcbiAgfSxcbiAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShzLCB0KSB7XG4gICAgcy5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdGUtJHtZcyh0KX1gKTtcbiAgfSxcbiAgZ2V0RGF0YUF0dHJpYnV0ZXMocykge1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB0ID0ge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHMuZGF0YXNldCkuZmlsdGVyKChlKSA9PiBlLnN0YXJ0c1dpdGgoXCJ0ZVwiKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaWYgKGUuc3RhcnRzV2l0aChcInRlQ2xhc3NcIikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBpID0gZS5yZXBsYWNlKC9edGUvLCBcIlwiKTtcbiAgICAgIGkgPSBpLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgaS5zbGljZSgxLCBpLmxlbmd0aCksIHRbaV0gPSBGcyhzLmRhdGFzZXRbZV0pO1xuICAgIH0pLCB0O1xuICB9LFxuICBnZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHMpIHtcbiAgICBpZiAoIXMpXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLnMuZGF0YXNldFxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLmZpbHRlcigoZSkgPT4gZS5zdGFydHNXaXRoKFwidGVDbGFzc1wiKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgbGV0IGkgPSBlLnJlcGxhY2UoL150ZUNsYXNzLywgXCJcIik7XG4gICAgICBpID0gaS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIGkuc2xpY2UoMSwgaS5sZW5ndGgpLCB0W2ldID0gRnModFtlXSk7XG4gICAgfSksIHQ7XG4gIH0sXG4gIGdldERhdGFBdHRyaWJ1dGUocywgdCkge1xuICAgIHJldHVybiBGcyhcbiAgICAgIHMuZ2V0QXR0cmlidXRlKGBkYXRhLXRlLSR7WXModCl9YClcbiAgICApO1xuICB9LFxuICBvZmZzZXQocykge1xuICAgIGNvbnN0IHQgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHQudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICBsZWZ0OiB0LmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnRcbiAgICB9O1xuICB9LFxuICBwb3NpdGlvbihzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcy5vZmZzZXRUb3AsXG4gICAgICBsZWZ0OiBzLm9mZnNldExlZnRcbiAgICB9O1xuICB9LFxuICBzdHlsZShzLCB0KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzLnN0eWxlLCB0KTtcbiAgfSxcbiAgdG9nZ2xlQ2xhc3MocywgdCkge1xuICAgIHMgJiYganModCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgcy5jbGFzc0xpc3QuY29udGFpbnMoZSkgPyBzLmNsYXNzTGlzdC5yZW1vdmUoZSkgOiBzLmNsYXNzTGlzdC5hZGQoZSk7XG4gICAgfSk7XG4gIH0sXG4gIGFkZENsYXNzKHMsIHQpIHtcbiAgICBqcyh0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+ICFzLmNsYXNzTGlzdC5jb250YWlucyhlKSAmJiBzLmNsYXNzTGlzdC5hZGQoZSlcbiAgICApO1xuICB9LFxuICBhZGRTdHlsZShzLCB0KSB7XG4gICAgT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgcy5zdHlsZVtlXSA9IHRbZV07XG4gICAgfSk7XG4gIH0sXG4gIHJlbW92ZUNsYXNzKHMsIHQpIHtcbiAgICBqcyh0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+IHMuY2xhc3NMaXN0LmNvbnRhaW5zKGUpICYmIHMuY2xhc3NMaXN0LnJlbW92ZShlKVxuICAgICk7XG4gIH0sXG4gIGhhc0NsYXNzKHMsIHQpIHtcbiAgICByZXR1cm4gcy5jbGFzc0xpc3QuY29udGFpbnModCk7XG4gIH1cbn07XG5mdW5jdGlvbiBqcyhzKSB7XG4gIHJldHVybiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gcy5zcGxpdChcIiBcIikgOiBBcnJheS5pc0FycmF5KHMpID8gcyA6ICExO1xufVxuY29uc3QgaWQgPSAzLCBoID0ge1xuICBjbG9zZXN0KHMsIHQpIHtcbiAgICByZXR1cm4gcy5jbG9zZXN0KHQpO1xuICB9LFxuICBtYXRjaGVzKHMsIHQpIHtcbiAgICByZXR1cm4gcy5tYXRjaGVzKHQpO1xuICB9LFxuICBmaW5kKHMsIHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KFxuICAgICAgLi4uRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbC5jYWxsKHQsIHMpXG4gICAgKTtcbiAgfSxcbiAgZmluZE9uZShzLCB0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbCh0LCBzKTtcbiAgfSxcbiAgY2hpbGRyZW4ocywgdCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoLi4ucy5jaGlsZHJlbikuZmlsdGVyKChpKSA9PiBpLm1hdGNoZXModCkpO1xuICB9LFxuICBwYXJlbnRzKHMsIHQpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgbGV0IGkgPSBzLnBhcmVudE5vZGU7XG4gICAgZm9yICg7IGkgJiYgaS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgaS5ub2RlVHlwZSAhPT0gaWQ7IClcbiAgICAgIHRoaXMubWF0Y2hlcyhpLCB0KSAmJiBlLnB1c2goaSksIGkgPSBpLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIGU7XG4gIH0sXG4gIHByZXYocywgdCkge1xuICAgIGxldCBlID0gcy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGZvciAoOyBlOyApIHtcbiAgICAgIGlmIChlLm1hdGNoZXModCkpXG4gICAgICAgIHJldHVybiBbZV07XG4gICAgICBlID0gZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIG5leHQocywgdCkge1xuICAgIGxldCBlID0gcy5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgZm9yICg7IGU7ICkge1xuICAgICAgaWYgKHRoaXMubWF0Y2hlcyhlLCB0KSlcbiAgICAgICAgcmV0dXJuIFtlXTtcbiAgICAgIGUgPSBlLm5leHRFbGVtZW50U2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBmb2N1c2FibGVDaGlsZHJlbihzKSB7XG4gICAgY29uc3QgdCA9IFtcbiAgICAgIFwiYVwiLFxuICAgICAgXCJidXR0b25cIixcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIFwidGV4dGFyZWFcIixcbiAgICAgIFwic2VsZWN0XCIsXG4gICAgICBcImRldGFpbHNcIixcbiAgICAgIFwiW3RhYmluZGV4XVwiLFxuICAgICAgJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJ1xuICAgIF0ubWFwKChlKSA9PiBgJHtlfTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pYCkuam9pbihcIiwgXCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmQodCwgcykuZmlsdGVyKFxuICAgICAgKGUpID0+ICF1ZShlKSAmJiBTdChlKVxuICAgICk7XG4gIH1cbn0sIEtzID0gXCJkcm9wZG93blwiLCBzZCA9IFwidGUuZHJvcGRvd25cIiwgZ2UgPSBgLiR7c2R9YCwgYW8gPSBcIi5kYXRhLWFwaVwiLCBucyA9IFwiRXNjYXBlXCIsICRvID0gXCJTcGFjZVwiLCBMbyA9IFwiVGFiXCIsIE5uID0gXCJBcnJvd1VwXCIsIG9zID0gXCJBcnJvd0Rvd25cIiwgbmQgPSAyLCBvZCA9IG5ldyBSZWdFeHAoXG4gIGAke05ufXwke29zfXwke25zfWBcbiksIHJkID0gYGhpZGUke2dlfWAsIGFkID0gYGhpZGRlbiR7Z2V9YCwgbGQgPSBgc2hvdyR7Z2V9YCwgY2QgPSBgc2hvd24ke2dlfWAsIGRkID0gYGNsaWNrJHtnZX0ke2FvfWAsIE1vID0gYGtleWRvd24ke2dlfSR7YW99YCwgaGQgPSBga2V5dXAke2dlfSR7YW99YCwgUHQgPSBcInNob3dcIiwgdWQgPSBcImRyb3B1cFwiLCBwZCA9IFwiZHJvcGVuZFwiLCBmZCA9IFwiZHJvcHN0YXJ0XCIsIF9kID0gXCJbZGF0YS10ZS1uYXZiYXItcmVmXVwiLCBJaSA9IFwiW2RhdGEtdGUtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIiwgVXMgPSBcIltkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXVwiLCBtZCA9IFwiW2RhdGEtdGUtbmF2YmFyLW5hdi1yZWZdXCIsIGdkID0gXCJbZGF0YS10ZS1kcm9wZG93bi1tZW51LXJlZl0gW2RhdGEtdGUtZHJvcGRvd24taXRlbS1yZWZdOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpXCIsIGJkID0gRigpID8gXCJ0b3AtZW5kXCIgOiBcInRvcC1zdGFydFwiLCB2ZCA9IEYoKSA/IFwidG9wLXN0YXJ0XCIgOiBcInRvcC1lbmRcIiwgRWQgPSBGKCkgPyBcImJvdHRvbS1lbmRcIiA6IFwiYm90dG9tLXN0YXJ0XCIsIFRkID0gRigpID8gXCJib3R0b20tc3RhcnRcIiA6IFwiYm90dG9tLWVuZFwiLCBDZCA9IEYoKSA/IFwibGVmdC1zdGFydFwiIDogXCJyaWdodC1zdGFydFwiLCBBZCA9IEYoKSA/IFwicmlnaHQtc3RhcnRcIiA6IFwibGVmdC1zdGFydFwiLCB5ZCA9IFt7IG9wYWNpdHk6IFwiMFwiIH0sIHsgb3BhY2l0eTogXCIxXCIgfV0sIHdkID0gW3sgb3BhY2l0eTogXCIxXCIgfSwgeyBvcGFjaXR5OiBcIjBcIiB9XSwgJGkgPSB7XG4gIGR1cmF0aW9uOiA1NTAsXG4gIGl0ZXJhdGlvbnM6IDEsXG4gIGVhc2luZzogXCJlYXNlXCIsXG4gIGZpbGw6IFwiYm90aFwiXG59LCBrZCA9IHtcbiAgb2Zmc2V0OiBbMCwgMl0sXG4gIGJvdW5kYXJ5OiBcImNsaXBwaW5nUGFyZW50c1wiLFxuICByZWZlcmVuY2U6IFwidG9nZ2xlXCIsXG4gIGRpc3BsYXk6IFwiZHluYW1pY1wiLFxuICBwb3BwZXJDb25maWc6IG51bGwsXG4gIGF1dG9DbG9zZTogITAsXG4gIGRyb3Bkb3duQW5pbWF0aW9uOiBcIm9uXCJcbn0sIE9kID0ge1xuICBvZmZzZXQ6IFwiKGFycmF5fHN0cmluZ3xmdW5jdGlvbilcIixcbiAgYm91bmRhcnk6IFwiKHN0cmluZ3xlbGVtZW50KVwiLFxuICByZWZlcmVuY2U6IFwiKHN0cmluZ3xlbGVtZW50fG9iamVjdClcIixcbiAgZGlzcGxheTogXCJzdHJpbmdcIixcbiAgcG9wcGVyQ29uZmlnOiBcIihudWxsfG9iamVjdHxmdW5jdGlvbilcIixcbiAgYXV0b0Nsb3NlOiBcIihib29sZWFufHN0cmluZylcIixcbiAgZHJvcGRvd25BbmltYXRpb246IFwic3RyaW5nXCJcbn07XG5jbGFzcyB3dCBleHRlbmRzIHZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpLCB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpLCB0aGlzLl9mYWRlT3V0QW5pbWF0ZSA9IG51bGw7XG4gICAgY29uc3QgaSA9IHdpbmRvdy5tYXRjaE1lZGlhKFxuICAgICAgXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiXG4gICAgKS5tYXRjaGVzO1xuICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPSB0aGlzLl9jb25maWcuZHJvcGRvd25BbmltYXRpb24gPT09IFwib25cIiAmJiAhaSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIGtkO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIE9kO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gS3M7XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh1ZSh0aGlzLl9lbGVtZW50KSB8fCB0aGlzLl9pc1Nob3duKHRoaXMuX21lbnUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfTtcbiAgICBpZiAodS50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGxkLFxuICAgICAgdFxuICAgICkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gd3QuZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgdGhpcy5faW5OYXZiYXIgPyBwLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgXCJwb3BwZXJcIiwgXCJub25lXCIpIDogdGhpcy5fY3JlYXRlUG9wcGVyKGkpLCBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhaS5jbG9zZXN0KG1kKSAmJiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgobikgPT4gdS5vbihuLCBcIm1vdXNlb3ZlclwiLCB2cykpLCB0aGlzLl9lbGVtZW50LmZvY3VzKCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCAhMCksIHRoaXMuX21lbnUuc2V0QXR0cmlidXRlKGBkYXRhLXRlLWRyb3Bkb3duLSR7UHR9YCwgXCJcIiksIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgJiYgdGhpcy5fbWVudS5hbmltYXRlKHlkLCAkaSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLXRlLWRyb3Bkb3duLSR7UHR9YCwgXCJcIiksIHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBjZCwgdCk7XG4gICAgICB9LFxuICAgICAgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSA/ICRpLmR1cmF0aW9uIDogMFxuICAgICk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodWUodGhpcy5fZWxlbWVudCkgfHwgIXRoaXMuX2lzU2hvd24odGhpcy5fbWVudSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9O1xuICAgIHRoaXMuX2NvbXBsZXRlSGlkZSh0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCksIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8ICh1Lm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBNbyxcbiAgICAgIElpLFxuICAgICAgd3QuZGF0YUFwaUtleWRvd25IYW5kbGVyXG4gICAgKSwgdS5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgTW8sXG4gICAgICBVcyxcbiAgICAgIHd0LmRhdGFBcGlLZXlkb3duSGFuZGxlclxuICAgICksIHUub24oZG9jdW1lbnQsIGRkLCB3dC5jbGVhck1lbnVzKSwgdS5vbihkb2N1bWVudCwgaGQsIHd0LmNsZWFyTWVudXMpLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9jb21wbGV0ZUhpZGUodCkge1xuICAgIHRoaXMuX2ZhZGVPdXRBbmltYXRlICYmIHRoaXMuX2ZhZGVPdXRBbmltYXRlLnBsYXlTdGF0ZSA9PT0gXCJydW5uaW5nXCIgfHwgdS50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHJkLFxuICAgICAgdFxuICAgICkuZGVmYXVsdFByZXZlbnRlZCB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKGkpID0+IHUub2ZmKGksIFwibW91c2VvdmVyXCIsIHZzKSksIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgJiYgKHRoaXMuX2ZhZGVPdXRBbmltYXRlID0gdGhpcy5fbWVudS5hbmltYXRlKFxuICAgICAgd2QsXG4gICAgICAkaVxuICAgICkpLCBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgdGhpcy5fbWVudS5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtQdH1gKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtQdH1gKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIiksIHAucmVtb3ZlRGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiKSwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGFkLCB0KTtcbiAgICAgIH0sXG4gICAgICB0aGlzLl9hbmltYXRpb25DYW5QbGF5ID8gJGkuZHVyYXRpb24gOiAwXG4gICAgKSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgaWYgKHQgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5wLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIE4oS3MsIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0eXBlb2YgdC5yZWZlcmVuY2UgPT0gXCJvYmplY3RcIiAmJiAhTmUodC5yZWZlcmVuY2UpICYmIHR5cGVvZiB0LnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYCR7S3MudG9VcHBlckNhc2UoKX06IE9wdGlvbiBcInJlZmVyZW5jZVwiIHByb3ZpZGVkIHR5cGUgXCJvYmplY3RcIiB3aXRob3V0IGEgcmVxdWlyZWQgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIiBtZXRob2QuYFxuICAgICAgKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBfY3JlYXRlUG9wcGVyKHQpIHtcbiAgICBpZiAodHlwZW9mIGlsID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkJvb3RzdHJhcCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKVwiXG4gICAgICApO1xuICAgIGxldCBlID0gdGhpcy5fZWxlbWVudDtcbiAgICB0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSBcInBhcmVudFwiID8gZSA9IHQgOiBOZSh0aGlzLl9jb25maWcucmVmZXJlbmNlKSA/IGUgPSBHdCh0aGlzLl9jb25maWcucmVmZXJlbmNlKSA6IHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlID09IFwib2JqZWN0XCIgJiYgKGUgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlKTtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCksIG4gPSBpLm1vZGlmaWVycy5maW5kKFxuICAgICAgKG8pID0+IG8ubmFtZSA9PT0gXCJhcHBseVN0eWxlc1wiICYmIG8uZW5hYmxlZCA9PT0gITFcbiAgICApO1xuICAgIHRoaXMuX3BvcHBlciA9IGplKFxuICAgICAgZSxcbiAgICAgIHRoaXMuX21lbnUsXG4gICAgICBpXG4gICAgKSwgbiAmJiBwLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgXCJwb3BwZXJcIiwgXCJzdGF0aWNcIik7XG4gIH1cbiAgX2lzU2hvd24odCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gdC5kYXRhc2V0W2B0ZURyb3Bkb3duJHtQdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIFB0LnNsaWNlKDEpfWBdID09PSBcIlwiO1xuICB9XG4gIF9nZXRNZW51RWxlbWVudCgpIHtcbiAgICByZXR1cm4gaC5uZXh0KHRoaXMuX2VsZW1lbnQsIFVzKVswXTtcbiAgfVxuICBfZ2V0UGxhY2VtZW50KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHQuZGF0YXNldC50ZURyb3Bkb3duUG9zaXRpb24gPT09IHBkKVxuICAgICAgcmV0dXJuIENkO1xuICAgIGlmICh0LmRhdGFzZXQudGVEcm9wZG93blBvc2l0aW9uID09PSBmZClcbiAgICAgIHJldHVybiBBZDtcbiAgICBjb25zdCBlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS10ZS1wb3NpdGlvblwiKS50cmltKCkgPT09IFwiZW5kXCI7XG4gICAgcmV0dXJuIHQuZGF0YXNldC50ZURyb3Bkb3duUG9zaXRpb24gPT09IHVkID8gZSA/IHZkIDogYmQgOiBlID8gVGQgOiBFZDtcbiAgfVxuICBfZGV0ZWN0TmF2YmFyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoX2QpICE9PSBudWxsO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgeyBvZmZzZXQ6IHQgfSA9IHRoaXMuX2NvbmZpZztcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gTnVtYmVyLnBhcnNlSW50KGUsIDEwKSkgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAoZSkgPT4gdChlLCB0aGlzLl9lbGVtZW50KSA6IHQ7XG4gIH1cbiAgX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJwcmV2ZW50T3ZlcmZsb3dcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRpc3BsYXkgPT09IFwic3RhdGljXCIgJiYgKHQubW9kaWZpZXJzID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcImFwcGx5U3R5bGVzXCIsXG4gICAgICAgIGVuYWJsZWQ6ICExXG4gICAgICB9XG4gICAgXSksIHtcbiAgICAgIC4uLnQsXG4gICAgICAuLi50eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKHQpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xuICAgIH07XG4gIH1cbiAgX3NlbGVjdE1lbnVJdGVtKHsga2V5OiB0LCB0YXJnZXQ6IGUgfSkge1xuICAgIGNvbnN0IGkgPSBoLmZpbmQoXG4gICAgICBnZCxcbiAgICAgIHRoaXMuX21lbnVcbiAgICApLmZpbHRlcihTdCk7XG4gICAgaS5sZW5ndGggJiYgd2EoXG4gICAgICBpLFxuICAgICAgZSxcbiAgICAgIHQgPT09IG9zLFxuICAgICAgIWkuaW5jbHVkZXMoZSlcbiAgICApLmZvY3VzKCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gd3QuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNsZWFyTWVudXModCkge1xuICAgIGlmICh0ICYmICh0LmJ1dHRvbiA9PT0gbmQgfHwgdC50eXBlID09PSBcImtleXVwXCIgJiYgdC5rZXkgIT09IExvKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gaC5maW5kKElpKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGUubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCBvID0gd3QuZ2V0SW5zdGFuY2UoZVtpXSk7XG4gICAgICBpZiAoIW8gfHwgby5fY29uZmlnLmF1dG9DbG9zZSA9PT0gITEgfHwgIW8uX2lzU2hvd24oKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCByID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBvLl9lbGVtZW50XG4gICAgICB9O1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY29uc3QgYSA9IHQuY29tcG9zZWRQYXRoKCksIGwgPSBhLmluY2x1ZGVzKG8uX21lbnUpO1xuICAgICAgICBpZiAoYS5pbmNsdWRlcyhvLl9lbGVtZW50KSB8fCBvLl9jb25maWcuYXV0b0Nsb3NlID09PSBcImluc2lkZVwiICYmICFsIHx8IG8uX2NvbmZpZy5hdXRvQ2xvc2UgPT09IFwib3V0c2lkZVwiICYmIGwgfHwgby5fbWVudS5jb250YWlucyh0LnRhcmdldCkgJiYgKHQudHlwZSA9PT0gXCJrZXl1cFwiICYmIHQua2V5ID09PSBMbyB8fCAvaW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxmb3JtL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHQudHlwZSA9PT0gXCJjbGlja1wiICYmIChyLmNsaWNrRXZlbnQgPSB0KTtcbiAgICAgIH1cbiAgICAgIG8uX2NvbXBsZXRlSGlkZShyKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldFBhcmVudEZyb21FbGVtZW50KHQpIHtcbiAgICByZXR1cm4gWHQodCkgfHwgdC5wYXJlbnROb2RlO1xuICB9XG4gIHN0YXRpYyBkYXRhQXBpS2V5ZG93bkhhbmRsZXIodCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpID8gdC5rZXkgPT09ICRvIHx8IHQua2V5ICE9PSBucyAmJiAodC5rZXkgIT09IG9zICYmIHQua2V5ICE9PSBObiB8fCB0LnRhcmdldC5jbG9zZXN0KFVzKSkgOiAhb2QudGVzdCh0LmtleSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuZGF0YXNldFtgdGVEcm9wZG93biR7UHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBQdC5zbGljZSgxKX1gXSA9PT0gXCJcIjtcbiAgICBpZiAoIWUgJiYgdC5rZXkgPT09IG5zIHx8ICh0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCksIHVlKHRoaXMpKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gdGhpcy5tYXRjaGVzKElpKSA/IHRoaXMgOiBoLnByZXYodGhpcywgSWkpWzBdLCBuID0gd3QuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKTtcbiAgICBpZiAodC5rZXkgPT09IG5zKSB7XG4gICAgICBuLmhpZGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHQua2V5ID09PSBObiB8fCB0LmtleSA9PT0gb3MpIHtcbiAgICAgIGUgfHwgbi5zaG93KCksIG4uX3NlbGVjdE1lbnVJdGVtKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoIWUgfHwgdC5rZXkgPT09ICRvKSAmJiB3dC5jbGVhck1lbnVzKCk7XG4gIH1cbn1cbmNvbnN0IHpzID0gXCJjb2xsYXBzZVwiLCBzbCA9IFwidGUuY29sbGFwc2VcIiwgT3MgPSBgLiR7c2x9YCwgTm8gPSB7XG4gIHRvZ2dsZTogITAsXG4gIHBhcmVudDogbnVsbFxufSwgeGQgPSB7XG4gIHRvZ2dsZTogXCJib29sZWFuXCIsXG4gIHBhcmVudDogXCIobnVsbHxlbGVtZW50KVwiXG59LCBTZCA9IGBzaG93JHtPc31gLCBEZCA9IGBzaG93biR7T3N9YCwgSWQgPSBgaGlkZSR7T3N9YCwgJGQgPSBgaGlkZGVuJHtPc31gLCBYcyA9IFwiZGF0YS10ZS1jb2xsYXBzZS1zaG93XCIsIFJvID0gXCJkYXRhLXRlLWNvbGxhcHNlLWNvbGxhcHNlZFwiLCBMaSA9IFwiZGF0YS10ZS1jb2xsYXBzZS1jb2xsYXBzaW5nXCIsIExkID0gXCJkYXRhLXRlLWNvbGxhcHNlLWhvcml6b250YWxcIiwgT2UgPSBcImRhdGEtdGUtY29sbGFwc2UtaXRlbVwiLCBQbyA9IGA6c2NvcGUgWyR7T2V9XSBbJHtPZX1dYCwgTWQgPSBcIndpZHRoXCIsIE5kID0gXCJoZWlnaHRcIiwgUmQgPSBcIltkYXRhLXRlLWNvbGxhcHNlLWl0ZW1dW2RhdGEtdGUtY29sbGFwc2Utc2hvd10sIFtkYXRhLXRlLWNvbGxhcHNlLWl0ZW1dW2RhdGEtdGUtY29sbGFwc2UtY29sbGFwc2luZ11cIiwgSG8gPSBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsIFBkID0ge1xuICB2aXNpYmxlOiBcIiF2aXNpYmxlXCIsXG4gIGhpZGRlbjogXCJoaWRkZW5cIixcbiAgYmFzZVRyYW5zaXRpb246IFwib3ZlcmZsb3ctaGlkZGVuIGR1cmF0aW9uLVszNTBtc10gZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMS4wKV0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgY29sbGFwc2luZzogXCJoLTAgdHJhbnNpdGlvbi1baGVpZ2h0XSBvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBjb2xsYXBzaW5nSG9yaXpvbnRhbDogXCJ3LTAgaC1hdXRvIHRyYW5zaXRpb24tW3dpZHRoXSBvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiXG59LCBIZCA9IHtcbiAgdmlzaWJsZTogXCJzdHJpbmdcIixcbiAgaGlkZGVuOiBcInN0cmluZ1wiLFxuICBiYXNlVHJhbnNpdGlvbjogXCJzdHJpbmdcIixcbiAgY29sbGFwc2luZzogXCJzdHJpbmdcIixcbiAgY29sbGFwc2luZ0hvcml6b250YWw6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBVdCBleHRlbmRzIHZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fdHJpZ2dlckFycmF5ID0gW107XG4gICAgY29uc3QgbiA9IGguZmluZChIbyk7XG4gICAgZm9yIChsZXQgbyA9IDAsIHIgPSBuLmxlbmd0aDsgbyA8IHI7IG8rKykge1xuICAgICAgY29uc3QgYSA9IG5bb10sIGwgPSBYbihhKSwgYyA9IGguZmluZChsKS5maWx0ZXIoXG4gICAgICAgIChkKSA9PiBkID09PSB0aGlzLl9lbGVtZW50XG4gICAgICApO1xuICAgICAgbCAhPT0gbnVsbCAmJiBjLmxlbmd0aCAmJiAodGhpcy5fc2VsZWN0b3IgPSBsLCB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChhKSk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemVDaGlsZHJlbigpLCB0aGlzLl9jb25maWcucGFyZW50IHx8IHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksIHRoaXMuX2lzU2hvd24oKSksIHRoaXMuX2NvbmZpZy50b2dnbGUgJiYgdGhpcy50b2dnbGUoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gTm87XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiB6cztcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2lzU2hvd24oKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdCA9IFtdLCBlO1xuICAgIGlmICh0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICBjb25zdCBkID0gaC5maW5kKFxuICAgICAgICBQbyxcbiAgICAgICAgdGhpcy5fY29uZmlnLnBhcmVudFxuICAgICAgKTtcbiAgICAgIHQgPSBoLmZpbmQoXG4gICAgICAgIFJkLFxuICAgICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICApLmZpbHRlcigoXykgPT4gIWQuaW5jbHVkZXMoXykpO1xuICAgIH1cbiAgICBjb25zdCBpID0gaC5maW5kT25lKHRoaXMuX3NlbGVjdG9yKTtcbiAgICBpZiAodC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGQgPSB0LmZpbmQoKF8pID0+IGkgIT09IF8pO1xuICAgICAgaWYgKGUgPSBkID8gVXQuZ2V0SW5zdGFuY2UoZCkgOiBudWxsLCBlICYmIGUuX2lzVHJhbnNpdGlvbmluZylcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFNkKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHQuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgaSAhPT0gZCAmJiBVdC5nZXRPckNyZWF0ZUluc3RhbmNlKGQsIHsgdG9nZ2xlOiAhMSB9KS5oaWRlKCksIGUgfHwgSS5zZXREYXRhKGQsIHNsLCBudWxsKTtcbiAgICB9KTtcbiAgICBjb25zdCBvID0gdGhpcy5fZ2V0RGltZW5zaW9uKCksIHIgPSBvID09PSBcImhlaWdodFwiID8gdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nIDogdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nSG9yaXpvbnRhbDtcbiAgICBwLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMudmlzaWJsZSksIHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5oaWRkZW4pLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShPZSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKExpLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zdHlsZVtvXSA9IDAsIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksICEwKSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITA7XG4gICAgY29uc3QgYSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCBwLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgcC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCByKSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShMaSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKE9lLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoWHMsIFwiXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlW29dID0gXCJcIiwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIERkKTtcbiAgICB9LCBjID0gYHNjcm9sbCR7b1swXS50b1VwcGVyQ2FzZSgpICsgby5zbGljZSgxKX1gO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soYSwgdGhpcy5fZWxlbWVudCwgITApLCB0aGlzLl9lbGVtZW50LnN0eWxlW29dID0gYCR7dGhpcy5fZWxlbWVudFtjXX1weGA7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkgfHwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIElkKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXREaW1lbnNpb24oKSwgaSA9IGUgPT09IFwiaGVpZ2h0XCIgPyB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmcgOiB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmdIb3Jpem9udGFsO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZV0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2VdfXB4YCwgRmUodGhpcy5fZWxlbWVudCksIHAuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgaSksIHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgcC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKExpLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoT2UpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShYcyk7XG4gICAgY29uc3QgbiA9IHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGg7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBuOyByKyspIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLl90cmlnZ2VyQXJyYXlbcl0sIGwgPSBYdChhKTtcbiAgICAgIGwgJiYgIXRoaXMuX2lzU2hvd24obCkgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFthXSwgITEpO1xuICAgIH1cbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMDtcbiAgICBjb25zdCBvID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgaSksIHAuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKExpKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoT2UsIFwiXCIpLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgJGQpO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtlXSA9IFwiXCIsIHRoaXMuX3F1ZXVlQ2FsbGJhY2sobywgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIF9pc1Nob3duKHQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgcmV0dXJuIHQuaGFzQXR0cmlidXRlKFhzKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uTm8sXG4gICAgICAuLi5wLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIHQudG9nZ2xlID0gISF0LnRvZ2dsZSwgdC5wYXJlbnQgPSBHdCh0LnBhcmVudCksIE4oenMsIHQsIHhkKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlBkLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKHpzLCB0LCBIZCksIHQ7XG4gIH1cbiAgX2dldERpbWVuc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoTGQpID8gTWQgOiBOZDtcbiAgfVxuICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gaC5maW5kKFxuICAgICAgUG8sXG4gICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgKTtcbiAgICBoLmZpbmQoSG8sIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcigoZSkgPT4gIXQuaW5jbHVkZXMoZSkpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBYdChlKTtcbiAgICAgIGkgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFtlXSwgdGhpcy5faXNTaG93bihpKSk7XG4gICAgfSk7XG4gIH1cbiAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0LCBlKSB7XG4gICAgdC5sZW5ndGggJiYgdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBlID8gaS5yZW1vdmVBdHRyaWJ1dGUoUm8pIDogaS5zZXRBdHRyaWJ1dGUoYCR7Um99YCwgXCJcIiksIGkuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBlKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSB7fTtcbiAgICAgIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgL3Nob3d8aGlkZS8udGVzdCh0KSAmJiAoZS50b2dnbGUgPSAhMSk7XG4gICAgICBjb25zdCBpID0gVXQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBlKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEJvID0gXCIuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wXCIsIFZvID0gXCIuc3RpY2t5LXRvcFwiO1xuY2xhc3MgcGkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgfVxuICBnZXRXaWR0aCgpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cuaW5uZXJXaWR0aCAtIHQpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICB0aGlzLl9kaXNhYmxlT3ZlckZsb3coKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJwYWRkaW5nUmlnaHRcIixcbiAgICAgIChlKSA9PiBlICsgdFxuICAgICksIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFxuICAgICAgQm8sXG4gICAgICBcInBhZGRpbmdSaWdodFwiLFxuICAgICAgKGUpID0+IGUgKyB0XG4gICAgKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICBWbyxcbiAgICAgIFwibWFyZ2luUmlnaHRcIixcbiAgICAgIChlKSA9PiBlIC0gdFxuICAgICk7XG4gIH1cbiAgX2Rpc2FibGVPdmVyRmxvdygpIHtcbiAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50LCBcIm92ZXJmbG93XCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgfVxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldFdpZHRoKCksIG8gPSAocikgPT4ge1xuICAgICAgaWYgKHIgIT09IHRoaXMuX2VsZW1lbnQgJiYgd2luZG93LmlubmVyV2lkdGggPiByLmNsaWVudFdpZHRoICsgbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUociwgZSk7XG4gICAgICBjb25zdCBhID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocilbZV07XG4gICAgICByLnN0eWxlW2VdID0gYCR7aShcbiAgICAgICAgTnVtYmVyLnBhcnNlRmxvYXQoYSlcbiAgICAgICl9cHhgO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBvKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFwib3ZlcmZsb3dcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgXCJwYWRkaW5nUmlnaHRcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoQm8sIFwicGFkZGluZ1JpZ2h0XCIpLCB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFZvLCBcIm1hcmdpblJpZ2h0XCIpO1xuICB9XG4gIF9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IHQuc3R5bGVbZV07XG4gICAgaSAmJiBwLnNldERhdGFBdHRyaWJ1dGUodCwgZSwgaSk7XG4gIH1cbiAgX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSkge1xuICAgIGNvbnN0IGkgPSAobikgPT4ge1xuICAgICAgY29uc3QgbyA9IHAuZ2V0RGF0YUF0dHJpYnV0ZShuLCBlKTtcbiAgICAgIHR5cGVvZiBvID4gXCJ1XCIgPyBuLnN0eWxlLnJlbW92ZVByb3BlcnR5KGUpIDogKHAucmVtb3ZlRGF0YUF0dHJpYnV0ZShuLCBlKSwgbi5zdHlsZVtlXSA9IG8pO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBpKTtcbiAgfVxuICBfYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBlKSB7XG4gICAgTmUodCkgPyBlKHQpIDogaC5maW5kKHQsIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goZSk7XG4gIH1cbiAgaXNPdmVyZmxvd2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpID4gMDtcbiAgfVxufVxuY29uc3QgQmQgPSB7XG4gIGlzVmlzaWJsZTogITAsXG4gIC8vIGlmIGZhbHNlLCB3ZSB1c2UgdGhlIGJhY2tkcm9wIGhlbHBlciB3aXRob3V0IGFkZGluZyBhbnkgZWxlbWVudCB0byB0aGUgZG9tXG4gIGlzQW5pbWF0ZWQ6ICExLFxuICByb290RWxlbWVudDogXCJib2R5XCIsXG4gIC8vIGdpdmUgdGhlIGNob2ljZSB0byBwbGFjZSBiYWNrZHJvcCB1bmRlciBkaWZmZXJlbnQgZWxlbWVudHNcbiAgY2xpY2tDYWxsYmFjazogbnVsbCxcbiAgYmFja2Ryb3BDbGFzc2VzOiBudWxsXG59LCBWZCA9IHtcbiAgaXNWaXNpYmxlOiBcImJvb2xlYW5cIixcbiAgaXNBbmltYXRlZDogXCJib29sZWFuXCIsXG4gIHJvb3RFbGVtZW50OiBcIihlbGVtZW50fHN0cmluZylcIixcbiAgY2xpY2tDYWxsYmFjazogXCIoZnVuY3Rpb258bnVsbClcIixcbiAgYmFja2Ryb3BDbGFzc2VzOiBcIihhcnJheXxudWxsKVwiXG59LCBubCA9IFwiYmFja2Ryb3BcIiwgV28gPSBgbW91c2Vkb3duLnRlLiR7bmx9YDtcbmNsYXNzIGxvIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyh0KSwgdGhpcy5faXNBcHBlbmRlZCA9ICExLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBzaG93KHQpIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcbiAgICAgIGhlKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hcHBlbmQoKSwgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQgJiYgRmUodGhpcy5fZ2V0RWxlbWVudCgpKTtcbiAgICBjb25zdCBlID0gdGhpcy5fY29uZmlnLmJhY2tkcm9wQ2xhc3NlcyB8fCBbXG4gICAgICBcIm9wYWNpdHktNTBcIixcbiAgICAgIFwidHJhbnNpdGlvbi1hbGxcIixcbiAgICAgIFwiZHVyYXRpb24tMzAwXCIsXG4gICAgICBcImVhc2UtaW4tb3V0XCIsXG4gICAgICBcImZpeGVkXCIsXG4gICAgICBcInRvcC0wXCIsXG4gICAgICBcImxlZnQtMFwiLFxuICAgICAgXCJ6LVsxMDQwXVwiLFxuICAgICAgXCJiZy1ibGFja1wiLFxuICAgICAgXCJ3LXNjcmVlblwiLFxuICAgICAgXCJoLXNjcmVlblwiXG4gICAgXTtcbiAgICBwLnJlbW92ZUNsYXNzKHRoaXMuX2dldEVsZW1lbnQoKSwgXCJvcGFjaXR5LTBcIiksIHAuYWRkQ2xhc3ModGhpcy5fZ2V0RWxlbWVudCgpLCBlKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWJhY2tkcm9wLXNob3dcIiwgXCJcIiksIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgaGUodCk7XG4gICAgfSk7XG4gIH1cbiAgaGlkZSh0KSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICBoZSh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWJhY2tkcm9wLXNob3dcIiksIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0wXCIpLCB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktNTBcIiksIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy5kaXNwb3NlKCksIGhlKHQpO1xuICAgIH0pO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldEVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50KSB7XG4gICAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHQuY2xhc3NOYW1lID0gdGhpcy5fY29uZmlnLmNsYXNzTmFtZSwgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQgJiYgdC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS01MFwiKSwgdGhpcy5fZWxlbWVudCA9IHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uQmQsXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgdC5yb290RWxlbWVudCA9IEd0KHQucm9vdEVsZW1lbnQpLCBOKG5sLCB0LCBWZCksIHQ7XG4gIH1cbiAgX2FwcGVuZCgpIHtcbiAgICB0aGlzLl9pc0FwcGVuZGVkIHx8ICh0aGlzLl9jb25maWcucm9vdEVsZW1lbnQuYXBwZW5kKHRoaXMuX2dldEVsZW1lbnQoKSksIHUub24odGhpcy5fZ2V0RWxlbWVudCgpLCBXbywgKCkgPT4ge1xuICAgICAgaGUodGhpcy5fY29uZmlnLmNsaWNrQ2FsbGJhY2spO1xuICAgIH0pLCB0aGlzLl9pc0FwcGVuZGVkID0gITApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5faXNBcHBlbmRlZCAmJiAodS5vZmYodGhpcy5fZWxlbWVudCwgV28pLCB0aGlzLl9lbGVtZW50LnJlbW92ZSgpLCB0aGlzLl9pc0FwcGVuZGVkID0gITEpO1xuICB9XG4gIF9lbXVsYXRlQW5pbWF0aW9uKHQpIHtcbiAgICB5YShcbiAgICAgIHQsXG4gICAgICB0aGlzLl9nZXRFbGVtZW50KCksXG4gICAgICB0aGlzLl9jb25maWcuaXNBbmltYXRlZFxuICAgICk7XG4gIH1cbn1cbmNsYXNzIGJpIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX3RvZ2dsZXIgPSBpLCB0aGlzLl9ldmVudCA9IGUuZXZlbnQgfHwgXCJibHVyXCIsIHRoaXMuX2NvbmRpdGlvbiA9IGUuY29uZGl0aW9uIHx8ICgoKSA9PiAhMCksIHRoaXMuX3NlbGVjdG9yID0gZS5zZWxlY3RvciB8fCAnYnV0dG9uLCBhLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJywgdGhpcy5fb25seVZpc2libGUgPSBlLm9ubHlWaXNpYmxlIHx8ICExLCB0aGlzLl9mb2N1c2FibGVFbGVtZW50cyA9IFtdLCB0aGlzLl9maXJzdEVsZW1lbnQgPSBudWxsLCB0aGlzLl9sYXN0RWxlbWVudCA9IG51bGwsIHRoaXMuaGFuZGxlciA9IChuKSA9PiB7XG4gICAgICB0aGlzLl9jb25kaXRpb24obikgJiYgIW4uc2hpZnRLZXkgJiYgbi50YXJnZXQgPT09IHRoaXMuX2xhc3RFbGVtZW50ID8gKG4ucHJldmVudERlZmF1bHQoKSwgdGhpcy5fZmlyc3RFbGVtZW50LmZvY3VzKCkpIDogdGhpcy5fY29uZGl0aW9uKG4pICYmIG4uc2hpZnRLZXkgJiYgbi50YXJnZXQgPT09IHRoaXMuX2ZpcnN0RWxlbWVudCAmJiAobi5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9sYXN0RWxlbWVudC5mb2N1cygpKTtcbiAgICB9O1xuICB9XG4gIHRyYXAoKSB7XG4gICAgdGhpcy5fc2V0RWxlbWVudHMoKSwgdGhpcy5faW5pdCgpLCB0aGlzLl9zZXRGb2N1c1RyYXAoKTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9ldmVudCwgdGhpcy5oYW5kbGVyKTtcbiAgICB9KSwgdGhpcy5fdG9nZ2xlciAmJiB0aGlzLl90b2dnbGVyLmZvY3VzKCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX3NldEVsZW1lbnRzKCksIHRoaXMuX3NldEZvY3VzVHJhcCgpO1xuICB9XG4gIF9pbml0KCkge1xuICAgIGNvbnN0IHQgPSAoZSkgPT4ge1xuICAgICAgIXRoaXMuX2ZpcnN0RWxlbWVudCB8fCBlLmtleSAhPT0gXCJUYWJcIiB8fCB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5pbmNsdWRlcyhlLnRhcmdldCkgfHwgKGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5fZmlyc3RFbGVtZW50LmZvY3VzKCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0KSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdCk7XG4gIH1cbiAgX2ZpbHRlclZpc2libGUodCkge1xuICAgIHJldHVybiB0LmZpbHRlcigoZSkgPT4ge1xuICAgICAgaWYgKCFTdChlKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgaSA9IGgucGFyZW50cyhlLCBcIipcIik7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGkubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgY29uc3QgbyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGlbbl0pO1xuICAgICAgICBpZiAobyAmJiAoby5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBvLnZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9KTtcbiAgfVxuICBfc2V0RWxlbWVudHMoKSB7XG4gICAgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMgPSBoLmZvY3VzYWJsZUNoaWxkcmVuKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9vbmx5VmlzaWJsZSAmJiAodGhpcy5fZm9jdXNhYmxlRWxlbWVudHMgPSB0aGlzLl9maWx0ZXJWaXNpYmxlKHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzKSksIHRoaXMuX2ZpcnN0RWxlbWVudCA9IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzWzBdLCB0aGlzLl9sYXN0RWxlbWVudCA9IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzW3RoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIF9zZXRGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgZSA9PT0gdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMSB8fCBlID09PSAwID8gdC5hZGRFdmVudExpc3RlbmVyKHRoaXMuX2V2ZW50LCB0aGlzLmhhbmRsZXIpIDogdC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX2V2ZW50LCB0aGlzLmhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCB4cyA9IChzLCB0ID0gXCJoaWRlXCIpID0+IHtcbiAgY29uc3QgZSA9IGBjbGljay5kaXNtaXNzJHtzLkVWRU5UX0tFWX1gLCBpID0gcy5OQU1FO1xuICB1Lm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGUsXG4gICAgYFtkYXRhLXRlLSR7aX0tZGlzbWlzc11gLFxuICAgIGZ1bmN0aW9uKG4pIHtcbiAgICAgIGlmIChbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIG4ucHJldmVudERlZmF1bHQoKSwgdWUodGhpcykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG8gPSBYdCh0aGlzKSB8fCB0aGlzLmNsb3Nlc3QoYC4ke2l9YCkgfHwgdGhpcy5jbG9zZXN0KGBbZGF0YS10ZS0ke2l9LWluaXRdYCk7XG4gICAgICBpZiAoIW8pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShvKVt0XSgpO1xuICAgIH1cbiAgKTtcbn0sIEZvID0gXCJvZmZjYW52YXNcIiwgV2QgPSBcInRlLm9mZmNhbnZhc1wiLCBLZSA9IGAuJHtXZH1gLCBGZCA9IFwiLmRhdGEtYXBpXCIsIFlkID0gYGxvYWQke0tlfSR7RmR9YCwgamQgPSBcIkVzY2FwZVwiLCBZbyA9IHtcbiAgYmFja2Ryb3A6ICEwLFxuICBrZXlib2FyZDogITAsXG4gIHNjcm9sbDogITFcbn0sIEtkID0ge1xuICBiYWNrZHJvcDogXCJib29sZWFuXCIsXG4gIGtleWJvYXJkOiBcImJvb2xlYW5cIixcbiAgc2Nyb2xsOiBcImJvb2xlYW5cIlxufSwgam8gPSBcInNob3dcIiwgVWQgPSBcIltkYXRhLXRlLW9mZmNhbnZhcy1pbml0XVtkYXRhLXRlLW9mZmNhbnZhcy1zaG93XVwiLCB6ZCA9IGBzaG93JHtLZX1gLCBYZCA9IGBzaG93biR7S2V9YCwgR2QgPSBgaGlkZSR7S2V9YCwgcWQgPSBgaGlkZGVuJHtLZX1gLCBRZCA9IGBrZXlkb3duLmRpc21pc3Mke0tlfWA7XG5jbGFzcyBycyBleHRlbmRzIHZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2lzU2hvd24gPSAhMSwgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKSwgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpLCB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gRm87XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBZbztcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHQpO1xuICB9XG4gIHNob3codCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB6ZCwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faXNTaG93biA9ICEwLCB0aGlzLl9lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIiwgdGhpcy5fYmFja2Ryb3Auc2hvdygpLCB0aGlzLl9jb25maWcuc2Nyb2xsIHx8IG5ldyBwaSgpLmhpZGUoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIsICEwKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZGlhbG9nXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS10ZS1vZmZjYW52YXMtJHtqb31gLCBcIlwiKTtcbiAgICBjb25zdCBpID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29uZmlnLnNjcm9sbCB8fCB0aGlzLl9mb2N1c3RyYXAudHJhcCgpLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWGQsIHsgcmVsYXRlZFRhcmdldDogdCB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soaSwgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBHZCkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCB0aGlzLl9lbGVtZW50LmJsdXIoKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1vZmZjYW52YXMtJHtqb31gKSwgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xuICAgIGNvbnN0IGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIiksIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCIsIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgbmV3IHBpKCkucmVzZXQoKSwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHFkKTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZSwgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8ICh1Lm9uKFxuICAgICAgd2luZG93LFxuICAgICAgWWQsXG4gICAgICAoKSA9PiBoLmZpbmQoVWQpLmZvckVhY2goXG4gICAgICAgICh0KSA9PiBycy5nZXRPckNyZWF0ZUluc3RhbmNlKHQpLnNob3coKVxuICAgICAgKVxuICAgICksIHhzKHJzKSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLllvLFxuICAgICAgLi4ucC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCBOKEZvLCB0LCBLZCksIHQ7XG4gIH1cbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICByZXR1cm4gbmV3IGxvKHtcbiAgICAgIGlzVmlzaWJsZTogdGhpcy5fY29uZmlnLmJhY2tkcm9wLFxuICAgICAgaXNBbmltYXRlZDogITAsXG4gICAgICByb290RWxlbWVudDogdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgY2xpY2tDYWxsYmFjazogKCkgPT4gdGhpcy5oaWRlKClcbiAgICB9KTtcbiAgfVxuICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcbiAgICByZXR1cm4gbmV3IGJpKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIGV2ZW50OiBcImtleWRvd25cIixcbiAgICAgIGNvbmRpdGlvbjogKHQpID0+IHQua2V5ID09PSBcIlRhYlwiXG4gICAgfSk7XG4gIH1cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHUub24odGhpcy5fZWxlbWVudCwgUWQsICh0KSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdC5rZXkgPT09IGpkICYmIHRoaXMuaGlkZSgpO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IHJzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZVt0XSA9PT0gdm9pZCAwIHx8IHQuc3RhcnRzV2l0aChcIl9cIikgfHwgdCA9PT0gXCJjb25zdHJ1Y3RvclwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBHcyA9IFwiYWxlcnRcIiwgWmQgPSBcInRlLmFsZXJ0XCIsIG9sID0gYC4ke1pkfWAsIEpkID0gYGNsb3NlJHtvbH1gLCB0aCA9IGBjbG9zZWQke29sfWAsIEdlID0gXCJkYXRhLXRlLWFsZXJ0LXNob3dcIiwgZWggPSB7XG4gIGFuaW1hdGlvbjogXCJib29sZWFuXCIsXG4gIGF1dG9oaWRlOiBcImJvb2xlYW5cIixcbiAgZGVsYXk6IFwibnVtYmVyXCJcbn0sIEtvID0ge1xuICBhbmltYXRpb246ICEwLFxuICBhdXRvaGlkZTogITAsXG4gIGRlbGF5OiAxZTNcbn0sIGloID0ge1xuICBmYWRlSW46IFwiYW5pbWF0ZS1bZmFkZS1pbl8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsXG4gIGZhZGVPdXQ6IFwiYW5pbWF0ZS1bZmFkZS1vdXRfMC4zc19ib3RoXSBwLVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiXG59LCBzaCA9IHtcbiAgZmFkZUluOiBcInN0cmluZ1wiLFxuICBmYWRlT3V0OiBcInN0cmluZ1wiXG59O1xuY2xhc3MgUm4gZXh0ZW5kcyB2dCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gZWg7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBLbztcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEdzO1xuICB9XG4gIC8vIFB1YmxpY1xuICBjbG9zZSgpIHtcbiAgICBpZiAodS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEpkKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBlID0gMDtcbiAgICB0aGlzLl9jb25maWcuYW5pbWF0aW9uICYmIChlID0gMzAwLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCkpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShHZSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhcbiAgICAgICAgKCkgPT4gdGhpcy5fZGVzdHJveUVsZW1lbnQoKSxcbiAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgdGhpcy5fY29uZmlnLmFuaW1hdGlvblxuICAgICAgKTtcbiAgICB9LCBlKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmF1dG9oaWRlICYmIHRoaXMuX3NldHVwQXV0b2hpZGUoKSwgIXRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKEdlKSAmJiAocC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCBTdCh0aGlzLl9lbGVtZW50KSkpIHtcbiAgICAgICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAgICAgcC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCB1Lm9mZihlLnRhcmdldCwgXCJhbmltYXRpb25lbmRcIiwgdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKEdlLCBcIlwiKSwgdS5vbih0aGlzLl9lbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbikpO1xuICAgIH1cbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50ICYmIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKEdlKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoR2UpO1xuICAgICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAgIHAuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJoaWRkZW5cIiksIHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJibG9ja1wiKSwgdGhpcy5fdGltZW91dCAhPT0gbnVsbCAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLCB0aGlzLl90aW1lb3V0ID0gbnVsbCksIHUub2ZmKGUudGFyZ2V0LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgIH07XG4gICAgICB1Lm9uKHRoaXMuX2VsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsIHQpLCBwLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpO1xuICAgIH1cbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKHhzKFJuLCBcImNsb3NlXCIpLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uS28sXG4gICAgICAuLi5wLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgTihHcywgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5paCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTihHcywgdCwgc2gpLCB0O1xuICB9XG4gIF9zZXR1cEF1dG9oaWRlKCkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSk7XG4gIH1cbiAgX2Rlc3Ryb3lFbGVtZW50KCkge1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aCksIHRoaXMuZGlzcG9zZSgpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IFJuLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZVt0XSA9PT0gdm9pZCAwIHx8IHQuc3RhcnRzV2l0aChcIl9cIikgfHwgdCA9PT0gXCJjb25zdHJ1Y3RvclwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBxcyA9IFwiY2Fyb3VzZWxcIiwgbmggPSBcInRlLmNhcm91c2VsXCIsIHB0ID0gYC4ke25ofWAsIHJsID0gXCIuZGF0YS1hcGlcIiwgb2ggPSBcIkFycm93TGVmdFwiLCByaCA9IFwiQXJyb3dSaWdodFwiLCBhaCA9IDUwMCwgbGggPSA0MCwgVW8gPSB7XG4gIGludGVydmFsOiA1ZTMsXG4gIGtleWJvYXJkOiAhMCxcbiAgc2xpZGU6ICExLFxuICBwYXVzZTogXCJob3ZlclwiLFxuICB3cmFwOiAhMCxcbiAgdG91Y2g6ICEwXG59LCBjaCA9IHtcbiAgaW50ZXJ2YWw6IFwiKG51bWJlcnxib29sZWFuKVwiLFxuICBrZXlib2FyZDogXCJib29sZWFuXCIsXG4gIHNsaWRlOiBcIihib29sZWFufHN0cmluZylcIixcbiAgcGF1c2U6IFwiKHN0cmluZ3xib29sZWFuKVwiLFxuICB3cmFwOiBcImJvb2xlYW5cIixcbiAgdG91Y2g6IFwiYm9vbGVhblwiXG59LCBkaCA9IHtcbiAgcG9pbnRlcjogXCJ0b3VjaC1wYW4teVwiLFxuICBibG9jazogXCIhYmxvY2tcIixcbiAgdmlzaWJsZTogXCJkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTpvcGFjaXR5LTEwMCBkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTp6LVsxXVwiLFxuICBpbnZpc2libGU6IFwiZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06ei0wIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOm9wYWNpdHktMCBkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTpkdXJhdGlvbi0wIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOmRlbGF5LTYwMFwiLFxuICBzbGlkZVJpZ2h0OiBcInRyYW5zbGF0ZS14LWZ1bGxcIixcbiAgc2xpZGVMZWZ0OiBcIi10cmFuc2xhdGUteC1mdWxsXCJcbn0sIGhoID0ge1xuICBwb2ludGVyOiBcInN0cmluZ1wiLFxuICBibG9jazogXCJzdHJpbmdcIixcbiAgdmlzaWJsZTogXCJzdHJpbmdcIixcbiAgaW52aXNpYmxlOiBcInN0cmluZ1wiLFxuICBzbGlkZVJpZ2h0OiBcInN0cmluZ1wiLFxuICBzbGlkZUxlZnQ6IFwic3RyaW5nXCJcbn0sIHNlID0gXCJuZXh0XCIsIG5lID0gXCJwcmV2XCIsIGNlID0gXCJsZWZ0XCIsIHNpID0gXCJyaWdodFwiLCB1aCA9IHtcbiAgW29oXTogc2ksXG4gIFtyaF06IGNlXG59LCBwaCA9IGBzbGlkZSR7cHR9YCwgem8gPSBgc2xpZCR7cHR9YCwgZmggPSBga2V5ZG93biR7cHR9YCwgX2ggPSBgbW91c2VlbnRlciR7cHR9YCwgbWggPSBgbW91c2VsZWF2ZSR7cHR9YCwgZ2ggPSBgdG91Y2hzdGFydCR7cHR9YCwgYmggPSBgdG91Y2htb3ZlJHtwdH1gLCB2aCA9IGB0b3VjaGVuZCR7cHR9YCwgRWggPSBgcG9pbnRlcmRvd24ke3B0fWAsIFRoID0gYHBvaW50ZXJ1cCR7cHR9YCwgQ2ggPSBgZHJhZ3N0YXJ0JHtwdH1gLCBBaCA9IGBsb2FkJHtwdH0ke3JsfWAsIHloID0gYGNsaWNrJHtwdH0ke3JsfWAsIHdoID0gXCJkYXRhLXRlLWNhcm91c2VsLWluaXRcIiwgb2UgPSBcImRhdGEtdGUtY2Fyb3VzZWwtYWN0aXZlXCIsIGtoID0gXCJkYXRhLXRlLWNhcm91c2VsLXNsaWRlXCIsIE9oID0gXCJkYXRhLXRlLWNhcm91c2VsLWl0ZW0tZW5kXCIsIFFzID0gXCJkYXRhLXRlLWNhcm91c2VsLWl0ZW0tc3RhcnRcIiwgeGggPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1uZXh0XCIsIFNoID0gXCJkYXRhLXRlLWNhcm91c2VsLWl0ZW0tcHJldlwiLCBEaCA9IFwiZGF0YS10ZS1jYXJvdXNlbC1wb2ludGVyLWV2ZW50XCIsIEloID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1pbml0XVwiLCBhbCA9IFwiW2RhdGEtdGUtY2Fyb3VzZWwtYWN0aXZlXVwiLCBjbyA9IFwiW2RhdGEtdGUtY2Fyb3VzZWwtaXRlbV1cIiwgdmUgPSBgJHthbH0ke2NvfWAsICRoID0gYCR7Y299IGltZ2AsIExoID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1pdGVtLW5leHRdLCBbZGF0YS10ZS1jYXJvdXNlbC1pdGVtLXByZXZdXCIsIE1oID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1pbmRpY2F0b3JzXVwiLCBOaCA9IFwiW2RhdGEtdGUtdGFyZ2V0XVwiLCBSaCA9IFwiW2RhdGEtdGUtc2xpZGVdLCBbZGF0YS10ZS1zbGlkZS10b11cIiwgUGggPSBcInRvdWNoXCIsIEhoID0gXCJwZW5cIjtcbmNsYXNzIFl0IGV4dGVuZHMgdnQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2l0ZW1zID0gbnVsbCwgdGhpcy5faW50ZXJ2YWwgPSBudWxsLCB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbCwgdGhpcy5faXNQYXVzZWQgPSAhMSwgdGhpcy5faXNTbGlkaW5nID0gITEsIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbCwgdGhpcy50b3VjaFN0YXJ0WCA9IDAsIHRoaXMudG91Y2hEZWx0YVggPSAwLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IGguZmluZE9uZShcbiAgICAgIE1oLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX3RvdWNoU3VwcG9ydGVkID0gXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCwgdGhpcy5fcG9pbnRlckV2ZW50ID0gISF3aW5kb3cuUG9pbnRlckV2ZW50LCB0aGlzLl9zZXRBY3RpdmVFbGVtZW50Q2xhc3MoKSwgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFVvO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gcXM7XG4gIH1cbiAgLy8gUHVibGljXG4gIG5leHQoKSB7XG4gICAgdGhpcy5fc2xpZGUoc2UpO1xuICB9XG4gIG5leHRXaGVuVmlzaWJsZSgpIHtcbiAgICAhZG9jdW1lbnQuaGlkZGVuICYmIFN0KHRoaXMuX2VsZW1lbnQpICYmIHRoaXMubmV4dCgpO1xuICB9XG4gIHByZXYoKSB7XG4gICAgdGhpcy5fc2xpZGUobmUpO1xuICB9XG4gIHBhdXNlKHQpIHtcbiAgICB0IHx8ICh0aGlzLl9pc1BhdXNlZCA9ICEwKSwgaC5maW5kT25lKExoLCB0aGlzLl9lbGVtZW50KSAmJiAoRWEodGhpcy5fZWxlbWVudCksIHRoaXMuY3ljbGUoITApKSwgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgfVxuICBjeWNsZSh0KSB7XG4gICAgdCB8fCAodGhpcy5faXNQYXVzZWQgPSAhMSksIHRoaXMuX2ludGVydmFsICYmIChjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgdGhpcy5faW50ZXJ2YWwgPSBudWxsKSwgdGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCAmJiAhdGhpcy5faXNQYXVzZWQgJiYgKHRoaXMuX3VwZGF0ZUludGVydmFsKCksIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoXG4gICAgICAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID8gdGhpcy5uZXh0V2hlblZpc2libGUgOiB0aGlzLm5leHQpLmJpbmQoXG4gICAgICAgIHRoaXNcbiAgICAgICksXG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICApKTtcbiAgfVxuICB0byh0KSB7XG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IGguZmluZE9uZShcbiAgICAgIHZlLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtcbiAgICBpZiAodCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgfHwgdCA8IDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgdS5vbmUodGhpcy5fZWxlbWVudCwgem8sICgpID0+IHRoaXMudG8odCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZSA9PT0gdCkge1xuICAgICAgdGhpcy5wYXVzZSgpLCB0aGlzLmN5Y2xlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0ID4gZSA/IHNlIDogbmU7XG4gICAgdGhpcy5fc2xpZGUoaSwgdGhpcy5faXRlbXNbdF0pO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAodS5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgeWgsXG4gICAgICBSaCxcbiAgICAgIFl0LmRhdGFBcGlDbGlja0hhbmRsZXJcbiAgICApLCB1Lm9uKHdpbmRvdywgQWgsICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBoLmZpbmQoSWgpO1xuICAgICAgZm9yIChsZXQgZSA9IDAsIGkgPSB0Lmxlbmd0aDsgZSA8IGk7IGUrKylcbiAgICAgICAgWXQuY2Fyb3VzZWxJbnRlcmZhY2UoXG4gICAgICAgICAgdFtlXSxcbiAgICAgICAgICBZdC5nZXRJbnN0YW5jZSh0W2VdKVxuICAgICAgICApO1xuICAgIH0pLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uVW8sXG4gICAgICAuLi5wLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIE4ocXMsIHQsIGNoKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmRoLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKHFzLCB0LCBoaCksIHQ7XG4gIH1cbiAgX2FwcGx5SW5pdGlhbENsYXNzZXMoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZE9uZShcbiAgICAgIHZlLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgdC5jbGFzc0xpc3QuYWRkKFxuICAgICAgdGhpcy5fY2xhc3Nlcy5ibG9jayxcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMudmlzaWJsZS5zcGxpdChcIiBcIilcbiAgICApLCB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KHQpO1xuICB9XG4gIF9oYW5kbGVTd2lwZSgpIHtcbiAgICBjb25zdCB0ID0gTWF0aC5hYnModGhpcy50b3VjaERlbHRhWCk7XG4gICAgaWYgKHQgPD0gbGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHQgLyB0aGlzLnRvdWNoRGVsdGFYO1xuICAgIHRoaXMudG91Y2hEZWx0YVggPSAwLCBlICYmIHRoaXMuX3NsaWRlKGUgPiAwID8gc2kgOiBjZSk7XG4gIH1cbiAgX3NldEFjdGl2ZUVsZW1lbnRDbGFzcygpIHtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gaC5maW5kT25lKFxuICAgICAgdmUsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgcC5hZGRDbGFzcyh0aGlzLl9hY3RpdmVFbGVtZW50LCBcImhpZGRlblwiKTtcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgZmgsXG4gICAgICAodCkgPT4gdGhpcy5fa2V5ZG93bih0KVxuICAgICksIHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gXCJob3ZlclwiICYmICh1Lm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIF9oLFxuICAgICAgKHQpID0+IHRoaXMucGF1c2UodClcbiAgICApLCB1Lm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIG1oLFxuICAgICAgKHQpID0+IHRoaXMuY3ljbGUodClcbiAgICApKSwgdGhpcy5fY29uZmlnLnRvdWNoICYmIHRoaXMuX3RvdWNoU3VwcG9ydGVkICYmIHRoaXMuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3NlcygpO1xuICB9XG4gIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHQgPSAobykgPT4gdGhpcy5fcG9pbnRlckV2ZW50ICYmIChvLnBvaW50ZXJUeXBlID09PSBIaCB8fCBvLnBvaW50ZXJUeXBlID09PSBQaCksIGUgPSAobykgPT4ge1xuICAgICAgdChvKSA/IHRoaXMudG91Y2hTdGFydFggPSBvLmNsaWVudFggOiB0aGlzLl9wb2ludGVyRXZlbnQgfHwgKHRoaXMudG91Y2hTdGFydFggPSBvLnRvdWNoZXNbMF0uY2xpZW50WCk7XG4gICAgfSwgaSA9IChvKSA9PiB7XG4gICAgICB0aGlzLnRvdWNoRGVsdGFYID0gby50b3VjaGVzICYmIG8udG91Y2hlcy5sZW5ndGggPiAxID8gMCA6IG8udG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WDtcbiAgICB9LCBuID0gKG8pID0+IHtcbiAgICAgIHQobykgJiYgKHRoaXMudG91Y2hEZWx0YVggPSBvLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYKSwgdGhpcy5faGFuZGxlU3dpcGUoKSwgdGhpcy5fY29uZmlnLnBhdXNlID09PSBcImhvdmVyXCIgJiYgKHRoaXMucGF1c2UoKSwgdGhpcy50b3VjaFRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMudG91Y2hUaW1lb3V0KSwgdGhpcy50b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAocikgPT4gdGhpcy5jeWNsZShyKSxcbiAgICAgICAgYWggKyB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgICkpO1xuICAgIH07XG4gICAgaC5maW5kKCRoLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKFxuICAgICAgKG8pID0+IHtcbiAgICAgICAgdS5vbihcbiAgICAgICAgICBvLFxuICAgICAgICAgIENoLFxuICAgICAgICAgIChyKSA9PiByLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApLCB0aGlzLl9wb2ludGVyRXZlbnQgPyAodS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBFaCxcbiAgICAgIChvKSA9PiBlKG8pXG4gICAgKSwgdS5vbih0aGlzLl9lbGVtZW50LCBUaCwgKG8pID0+IG4obykpLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5wb2ludGVyKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYCR7RGh9YCwgXCJcIikpIDogKHUub24odGhpcy5fZWxlbWVudCwgZ2gsIChvKSA9PiBlKG8pKSwgdS5vbih0aGlzLl9lbGVtZW50LCBiaCwgKG8pID0+IGkobykpLCB1Lm9uKHRoaXMuX2VsZW1lbnQsIHZoLCAobykgPT4gbihvKSkpO1xuICB9XG4gIF9rZXlkb3duKHQpIHtcbiAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdWhbdC5rZXldO1xuICAgIGUgJiYgKHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fc2xpZGUoZSkpO1xuICB9XG4gIF9nZXRJdGVtSW5kZXgodCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcyA9IHQgJiYgdC5wYXJlbnROb2RlID8gaC5maW5kKGNvLCB0LnBhcmVudE5vZGUpIDogW10sIHRoaXMuX2l0ZW1zLmluZGV4T2YodCk7XG4gIH1cbiAgX2dldEl0ZW1CeU9yZGVyKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdCA9PT0gc2U7XG4gICAgcmV0dXJuIHdhKFxuICAgICAgdGhpcy5faXRlbXMsXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIHRoaXMuX2NvbmZpZy53cmFwXG4gICAgKTtcbiAgfVxuICBfdHJpZ2dlclNsaWRlRXZlbnQodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRJdGVtSW5kZXgodCksIG4gPSB0aGlzLl9nZXRJdGVtSW5kZXgoXG4gICAgICBoLmZpbmRPbmUodmUsIHRoaXMuX2VsZW1lbnQpXG4gICAgKTtcbiAgICByZXR1cm4gdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHBoLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0LFxuICAgICAgZGlyZWN0aW9uOiBlLFxuICAgICAgZnJvbTogbixcbiAgICAgIHRvOiBpXG4gICAgfSk7XG4gIH1cbiAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQodCkge1xuICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgY29uc3QgZSA9IGguZmluZE9uZShcbiAgICAgICAgYWwsXG4gICAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50XG4gICAgICApO1xuICAgICAgZS5yZW1vdmVBdHRyaWJ1dGUob2UpLCBlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtY3VycmVudFwiKSwgZS5jbGFzc0xpc3QucmVtb3ZlKFwiIW9wYWNpdHktMTAwXCIpO1xuICAgICAgY29uc3QgaSA9IGguZmluZChcbiAgICAgICAgTmgsXG4gICAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50XG4gICAgICApO1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBpLmxlbmd0aDsgbisrKVxuICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KFxuICAgICAgICAgIGlbbl0uZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zbGlkZS10b1wiKSxcbiAgICAgICAgICAxMFxuICAgICAgICApID09PSB0aGlzLl9nZXRJdGVtSW5kZXgodCkpIHtcbiAgICAgICAgICBpW25dLnNldEF0dHJpYnV0ZShgJHtvZX1gLCBcIlwiKSwgaVtuXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiwgXCJ0cnVlXCIpLCBpW25dLmNsYXNzTGlzdC5hZGQoXCIhb3BhY2l0eS0xMDBcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUludGVydmFsKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IGguZmluZE9uZSh2ZSwgdGhpcy5fZWxlbWVudCk7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSBOdW1iZXIucGFyc2VJbnQoXG4gICAgICB0LmdldEF0dHJpYnV0ZShcImRhdGEtdGUtaW50ZXJ2YWxcIiksXG4gICAgICAxMFxuICAgICk7XG4gICAgZSA/ICh0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWwsIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IGUpIDogdGhpcy5fY29uZmlnLmludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWw7XG4gIH1cbiAgX3NsaWRlKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZGlyZWN0aW9uVG9PcmRlcih0KSwgbiA9IGguZmluZE9uZShcbiAgICAgIHZlLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIG8gPSB0aGlzLl9nZXRJdGVtSW5kZXgobiksIHIgPSBlIHx8IHRoaXMuX2dldEl0ZW1CeU9yZGVyKGksIG4pLCBhID0gdGhpcy5fZ2V0SXRlbUluZGV4KHIpLCBsID0gISF0aGlzLl9pbnRlcnZhbCwgYyA9IGkgPT09IHNlLCBkID0gYyA/IFFzIDogT2gsIF8gPSBjID8geGggOiBTaCwgZiA9IHRoaXMuX29yZGVyVG9EaXJlY3Rpb24oaSksIG0gPSBkID09PSBRcyA/IHRoaXMuX2NsYXNzZXMuc2xpZGVMZWZ0IDogdGhpcy5fY2xhc3Nlcy5zbGlkZVJpZ2h0LCBnID0gZCAhPT0gUXMgPyB0aGlzLl9jbGFzc2VzLnNsaWRlTGVmdCA6IHRoaXMuX2NsYXNzZXMuc2xpZGVSaWdodDtcbiAgICBpZiAociAmJiByLmhhc0F0dHJpYnV0ZShvZSkpIHtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9ICExO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNTbGlkaW5nIHx8IHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KHIsIGYpLmRlZmF1bHRQcmV2ZW50ZWQgfHwgIW4gfHwgIXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faXNTbGlkaW5nID0gITAsIGwgJiYgdGhpcy5wYXVzZSgpLCB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KHIpLCB0aGlzLl9hY3RpdmVFbGVtZW50ID0gcjtcbiAgICBjb25zdCBUID0gKCkgPT4ge1xuICAgICAgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHpvLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHIsXG4gICAgICAgIGRpcmVjdGlvbjogZixcbiAgICAgICAgZnJvbTogbyxcbiAgICAgICAgdG86IGFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKGtoKSkge1xuICAgICAgci5zZXRBdHRyaWJ1dGUoYCR7X31gLCBcIlwiKSwgci5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMuYmxvY2ssIGcpLCBGZShyKSwgbi5zZXRBdHRyaWJ1dGUoYCR7ZH1gLCBcIlwiKSwgbi5jbGFzc0xpc3QuYWRkKFxuICAgICAgICBtLFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmludmlzaWJsZS5zcGxpdChcIiBcIilcbiAgICAgICksIG4uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLnZpc2libGUuc3BsaXQoXCIgXCIpKSwgci5zZXRBdHRyaWJ1dGUoYCR7ZH1gLCBcIlwiKSwgci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMudmlzaWJsZS5zcGxpdChcIiBcIikpLCByLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgIHRoaXMuX2NsYXNzZXMuc2xpZGVSaWdodCxcbiAgICAgICAgdGhpcy5fY2xhc3Nlcy5zbGlkZUxlZnRcbiAgICAgICk7XG4gICAgICBjb25zdCBDID0gKCkgPT4ge1xuICAgICAgICByLnJlbW92ZUF0dHJpYnV0ZShkKSwgci5yZW1vdmVBdHRyaWJ1dGUoXyksIHIuc2V0QXR0cmlidXRlKGAke29lfWAsIFwiXCIpLCBuLnJlbW92ZUF0dHJpYnV0ZShvZSksIG4uY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgICBtLFxuICAgICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW52aXNpYmxlLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgICB0aGlzLl9jbGFzc2VzLmJsb2NrXG4gICAgICAgICksIG4ucmVtb3ZlQXR0cmlidXRlKF8pLCBuLnJlbW92ZUF0dHJpYnV0ZShkKSwgdGhpcy5faXNTbGlkaW5nID0gITEsIHNldFRpbWVvdXQoVCwgMCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhDLCBuLCAhMCk7XG4gICAgfSBlbHNlXG4gICAgICBuLnJlbW92ZUF0dHJpYnV0ZShvZSksIG4uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc2VzLmJsb2NrKSwgci5zZXRBdHRyaWJ1dGUoYCR7b2V9YCwgXCJcIiksIHIuY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLmJsb2NrKSwgdGhpcy5faXNTbGlkaW5nID0gITEsIFQoKTtcbiAgICBsICYmIHRoaXMuY3ljbGUoKTtcbiAgfVxuICBfZGlyZWN0aW9uVG9PcmRlcih0KSB7XG4gICAgcmV0dXJuIFtzaSwgY2VdLmluY2x1ZGVzKHQpID8gRigpID8gdCA9PT0gY2UgPyBuZSA6IHNlIDogdCA9PT0gY2UgPyBzZSA6IG5lIDogdDtcbiAgfVxuICBfb3JkZXJUb0RpcmVjdGlvbih0KSB7XG4gICAgcmV0dXJuIFtzZSwgbmVdLmluY2x1ZGVzKHQpID8gRigpID8gdCA9PT0gbmUgPyBjZSA6IHNpIDogdCA9PT0gbmUgPyBzaSA6IGNlIDogdDtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGNhcm91c2VsSW50ZXJmYWNlKHQsIGUpIHtcbiAgICBjb25zdCBpID0gWXQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlKTtcbiAgICBsZXQgeyBfY29uZmlnOiBuIH0gPSBpO1xuICAgIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgKG4gPSB7XG4gICAgICAuLi5uLFxuICAgICAgLi4uZVxuICAgIH0pO1xuICAgIGNvbnN0IG8gPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IG4uc2xpZGU7XG4gICAgaWYgKHR5cGVvZiBlID09IFwibnVtYmVyXCIpXG4gICAgICBpLnRvKGUpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBvID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgaVtvXSA+IFwidVwiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke299XCJgKTtcbiAgICAgIGlbb10oKTtcbiAgICB9IGVsc2VcbiAgICAgIG4uaW50ZXJ2YWwgJiYgbi5jYXJvdXNlbEluaXQgPT09IG51bGwgJiYgKGkucGF1c2UoKSwgaS5jeWNsZSgpKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgWXQuY2Fyb3VzZWxJbnRlcmZhY2UodGhpcywgdCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGRhdGFBcGlDbGlja0hhbmRsZXIodCkge1xuICAgIGNvbnN0IGUgPSBYdCh0aGlzKTtcbiAgICBpZiAoIWUgfHwgIWUuaGFzQXR0cmlidXRlKHdoKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0ge1xuICAgICAgLi4ucC5nZXREYXRhQXR0cmlidXRlcyhlKSxcbiAgICAgIC4uLnAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcylcbiAgICB9LCBuID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNsaWRlLXRvXCIpO1xuICAgIG4gJiYgKGkuaW50ZXJ2YWwgPSAhMSksIFl0LmNhcm91c2VsSW50ZXJmYWNlKGUsIGkpLCBuICYmIFl0LmdldEluc3RhbmNlKGUpLnRvKG4pLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cbmNvbnN0IFpzID0gXCJtb2RhbFwiLCBCaCA9IFwidGUubW9kYWxcIiwgRXQgPSBgLiR7Qmh9YCwgWG8gPSBcIkVzY2FwZVwiLCBHbyA9IHtcbiAgYmFja2Ryb3A6ICEwLFxuICBrZXlib2FyZDogITAsXG4gIGZvY3VzOiAhMFxufSwgVmggPSB7XG4gIGJhY2tkcm9wOiBcIihib29sZWFufHN0cmluZylcIixcbiAga2V5Ym9hcmQ6IFwiYm9vbGVhblwiLFxuICBmb2N1czogXCJib29sZWFuXCJcbn0sIFdoID0ge1xuICBzaG93OiBcInRyYW5zZm9ybS1ub25lXCIsXG4gIHN0YXRpYzogXCJzY2FsZS1bMS4wMl1cIixcbiAgc3RhdGljUHJvcGVydGllczogXCJ0cmFuc2l0aW9uLXNjYWxlIGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dFwiXG59LCBGaCA9IHtcbiAgc2hvdzogXCJzdHJpbmdcIixcbiAgc3RhdGljOiBcInN0cmluZ1wiLFxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInN0cmluZ1wiXG59LCBZaCA9IGBoaWRlJHtFdH1gLCBqaCA9IGBoaWRlUHJldmVudGVkJHtFdH1gLCBLaCA9IGBoaWRkZW4ke0V0fWAsIFVoID0gYHNob3cke0V0fWAsIHpoID0gYHNob3duJHtFdH1gLCBxbyA9IGByZXNpemUke0V0fWAsIFFvID0gYGNsaWNrLmRpc21pc3Mke0V0fWAsIFpvID0gYGtleWRvd24uZGlzbWlzcyR7RXR9YCwgWGggPSBgbW91c2V1cC5kaXNtaXNzJHtFdH1gLCBKbyA9IGBtb3VzZWRvd24uZGlzbWlzcyR7RXR9YCwgdHIgPSBcImRhdGEtdGUtbW9kYWwtb3BlblwiLCBlciA9IFwiZGF0YS10ZS1vcGVuXCIsIHFlID0gXCJbZGF0YS10ZS1tb2RhbC1kaWFsb2ctcmVmXVwiLCBHaCA9IFwiW2RhdGEtdGUtbW9kYWwtYm9keS1yZWZdXCI7XG5jbGFzcyBQbiBleHRlbmRzIHZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9kaWFsb2cgPSBoLmZpbmRPbmUocWUsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCksIHRoaXMuX2lzU2hvd24gPSAhMSwgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9ICExLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IHBpKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBHbztcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFpzO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUodCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3codCk7XG4gIH1cbiAgc2hvdyh0KSB7XG4gICAgdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFVoLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5faXNTaG93biA9ICEwLCB0aGlzLl9pc0FuaW1hdGVkKCkgJiYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICEwKSwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSwgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUodHIsIFwidHJ1ZVwiKSwgdGhpcy5fYWRqdXN0RGlhbG9nKCksIHRoaXMuX3NldEVzY2FwZUV2ZW50KCksIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCksIHUub24odGhpcy5fZGlhbG9nLCBKbywgKCkgPT4ge1xuICAgICAgdS5vbmUodGhpcy5fZWxlbWVudCwgWGgsIChpKSA9PiB7XG4gICAgICAgIGkudGFyZ2V0ID09PSB0aGlzLl9lbGVtZW50ICYmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gITApO1xuICAgICAgfSk7XG4gICAgfSksIHRoaXMuX3Nob3dFbGVtZW50KHQpLCB0aGlzLl9zaG93QmFja2Ryb3AoKSk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBZaCkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc1Nob3duID0gITE7XG4gICAgY29uc3QgZSA9IHRoaXMuX2lzQW5pbWF0ZWQoKTtcbiAgICBlICYmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMCksIHRoaXMuX3NldEVzY2FwZUV2ZW50KCksIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIGguZmluZE9uZShxZSwgdGhpcy5fZWxlbWVudCkuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc2VzLnNob3cpLCB1Lm9mZih0aGlzLl9lbGVtZW50LCBRbyksIHUub2ZmKHRoaXMuX2RpYWxvZywgSm8pLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2hpZGVNb2RhbCgpLCB0aGlzLl9lbGVtZW50LCBlKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoZXIpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgW3dpbmRvdywgdGhpcy5fZGlhbG9nXS5mb3JFYWNoKFxuICAgICAgKHQpID0+IHUub2ZmKHQsIEV0KVxuICAgICksIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKSwgdGhpcy5fZm9jdXN0cmFwLmRpc2FibGUoKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIGhhbmRsZVVwZGF0ZSgpIHtcbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKHhzKFBuKSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgbG8oe1xuICAgICAgaXNWaXNpYmxlOiAhIXRoaXMuX2NvbmZpZy5iYWNrZHJvcCxcbiAgICAgIC8vICdzdGF0aWMnIG9wdGlvbiB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdHJ1ZSwgYW5kIGJvb2xlYW5zIHdpbGwga2VlcCB0aGVpciB2YWx1ZVxuICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpXG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBiaSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICBjb25kaXRpb246ICh0KSA9PiB0LmtleSA9PT0gXCJUYWJcIlxuICAgIH0pO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uR28sXG4gICAgICAuLi5wLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIE4oWnMsIHQsIFZoKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLldoLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKFpzLCB0LCBGaCksIHQ7XG4gIH1cbiAgX3Nob3dFbGVtZW50KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5faXNBbmltYXRlZCgpLCBpID0gaC5maW5kT25lKEdoLCB0aGlzLl9kaWFsb2cpO1xuICAgICghdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlIHx8IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpICYmIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIsICEwKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZGlhbG9nXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShgJHtlcn1gLCBcInRydWVcIiksIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICBjb25zdCBuID0gaC5maW5kT25lKHFlLCB0aGlzLl9lbGVtZW50KTtcbiAgICBuLmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5zaG93KSwgbi5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0wXCIpLCBuLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTEwMFwiKSwgaSAmJiAoaS5zY3JvbGxUb3AgPSAwKSwgZSAmJiBGZSh0aGlzLl9lbGVtZW50KTtcbiAgICBjb25zdCBvID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29uZmlnLmZvY3VzICYmIHRoaXMuX2ZvY3VzdHJhcC50cmFwKCksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgemgsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKG8sIHRoaXMuX2RpYWxvZywgZSk7XG4gIH1cbiAgX3NldEVzY2FwZUV2ZW50KCkge1xuICAgIHRoaXMuX2lzU2hvd24gPyB1Lm9uKGRvY3VtZW50LCBabywgKHQpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gWG8gPyAodC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmhpZGUoKSkgOiAhdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIHQua2V5ID09PSBYbyAmJiB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XG4gICAgfSkgOiB1Lm9mZih0aGlzLl9lbGVtZW50LCBabyk7XG4gIH1cbiAgX3NldFJlc2l6ZUV2ZW50KCkge1xuICAgIHRoaXMuX2lzU2hvd24gPyB1Lm9uKHdpbmRvdywgcW8sICgpID0+IHRoaXMuX2FkanVzdERpYWxvZygpKSA6IHUub2ZmKHdpbmRvdywgcW8pO1xuICB9XG4gIF9oaWRlTW9kYWwoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZE9uZShxZSwgdGhpcy5fZWxlbWVudCk7XG4gICAgdC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc2hvdyksIHQuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMTAwXCIpLCB0LmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTBcIiksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfSwgMzAwKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCAhMCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJyb2xlXCIpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZSh0ciksIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBLaCk7XG4gICAgfSk7XG4gIH1cbiAgX3Nob3dCYWNrZHJvcCh0KSB7XG4gICAgdS5vbih0aGlzLl9lbGVtZW50LCBRbywgKGUpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCAmJiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAhMCA/IHRoaXMuaGlkZSgpIDogdGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSBcInN0YXRpY1wiICYmIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSk7XG4gICAgfSksIHRoaXMuX2JhY2tkcm9wLnNob3codCk7XG4gIH1cbiAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuICEhaC5maW5kT25lKHFlLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICBpZiAodS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGpoKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY2xhc3NMaXN0OiBlLCBzY3JvbGxIZWlnaHQ6IGksIHN0eWxlOiBuIH0gPSB0aGlzLl9lbGVtZW50LCBvID0gaSA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgIW8gJiYgbi5vdmVyZmxvd1kgPT09IFwiaGlkZGVuXCIgfHwgZS5jb250YWlucyh0aGlzLl9jbGFzc2VzLnN0YXRpYykgfHwgKG8gfHwgKG4ub3ZlcmZsb3dZID0gXCJoaWRkZW5cIiksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljLnNwbGl0KFwiIFwiKSksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGUucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc3RhdGljKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGUucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpO1xuICAgICAgfSwgMzAwKSwgbyB8fCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgbi5vdmVyZmxvd1kgPSBcIlwiO1xuICAgICAgfSwgdGhpcy5fZGlhbG9nKTtcbiAgICB9LCB0aGlzLl9kaWFsb2cpLCB0aGlzLl9lbGVtZW50LmZvY3VzKCkpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gdGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBfYWRqdXN0RGlhbG9nKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIGUgPSB0aGlzLl9zY3JvbGxCYXIuZ2V0V2lkdGgoKSwgaSA9IGUgPiAwO1xuICAgICghaSAmJiB0ICYmICFGKCkgfHwgaSAmJiAhdCAmJiBGKCkpICYmICh0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7ZX1weGApLCAoaSAmJiAhdCAmJiAhRigpIHx8ICFpICYmIHQgJiYgRigpKSAmJiAodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtlfXB4YCk7XG4gIH1cbiAgX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiXCIsIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCJcIjtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGkgPSBQbi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IHFoID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImJhY2tncm91bmRcIixcbiAgXCJjaXRlXCIsXG4gIFwiaHJlZlwiLFxuICBcIml0ZW10eXBlXCIsXG4gIFwibG9uZ2Rlc2NcIixcbiAgXCJwb3N0ZXJcIixcbiAgXCJzcmNcIixcbiAgXCJ4bGluazpocmVmXCJcbl0pLCBRaCA9IC9eYXJpYS1bXFx3LV0qJC9pLCBaaCA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGV8c21zKTp8W14jJi86P10qKD86WyMvP118JCkpL2ksIEpoID0gL15kYXRhOig/OmltYWdlXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW1xcZCsvYS16XSs9KiQvaSwgdHUgPSAocywgdCkgPT4ge1xuICBjb25zdCBlID0gcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAodC5pbmNsdWRlcyhlKSlcbiAgICByZXR1cm4gcWguaGFzKGUpID8gISEoWmgudGVzdChzLm5vZGVWYWx1ZSkgfHwgSmgudGVzdChzLm5vZGVWYWx1ZSkpIDogITA7XG4gIGNvbnN0IGkgPSB0LmZpbHRlcihcbiAgICAobikgPT4gbiBpbnN0YW5jZW9mIFJlZ0V4cFxuICApO1xuICBmb3IgKGxldCBuID0gMCwgbyA9IGkubGVuZ3RoOyBuIDwgbzsgbisrKVxuICAgIGlmIChpW25dLnRlc3QoZSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn0sIGV1ID0ge1xuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICBcIipcIjogW1wiY2xhc3NcIiwgXCJkaXJcIiwgXCJpZFwiLCBcImxhbmdcIiwgXCJyb2xlXCIsIFFoXSxcbiAgYTogW1widGFyZ2V0XCIsIFwiaHJlZlwiLCBcInRpdGxlXCIsIFwicmVsXCJdLFxuICBhcmVhOiBbXSxcbiAgYjogW10sXG4gIGJyOiBbXSxcbiAgY29sOiBbXSxcbiAgY29kZTogW10sXG4gIGRpdjogW10sXG4gIGVtOiBbXSxcbiAgaHI6IFtdLFxuICBoMTogW10sXG4gIGgyOiBbXSxcbiAgaDM6IFtdLFxuICBoNDogW10sXG4gIGg1OiBbXSxcbiAgaDY6IFtdLFxuICBpOiBbXSxcbiAgaW1nOiBbXCJzcmNcIiwgXCJzcmNzZXRcIiwgXCJhbHRcIiwgXCJ0aXRsZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLFxuICBsaTogW10sXG4gIG9sOiBbXSxcbiAgcDogW10sXG4gIHByZTogW10sXG4gIHM6IFtdLFxuICBzbWFsbDogW10sXG4gIHNwYW46IFtdLFxuICBzdWI6IFtdLFxuICBzdXA6IFtdLFxuICBzdHJvbmc6IFtdLFxuICB1OiBbXSxcbiAgdWw6IFtdXG59O1xuZnVuY3Rpb24gaXIocywgdCwgZSkge1xuICBpZiAoIXMubGVuZ3RoKVxuICAgIHJldHVybiBzO1xuICBpZiAoZSAmJiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIGUocyk7XG4gIGNvbnN0IG4gPSBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzLCBcInRleHQvaHRtbFwiKSwgbyA9IFtdLmNvbmNhdCguLi5uLmJvZHkucXVlcnlTZWxlY3RvckFsbChcIipcIikpO1xuICBmb3IgKGxldCByID0gMCwgYSA9IG8ubGVuZ3RoOyByIDwgYTsgcisrKSB7XG4gICAgY29uc3QgbCA9IG9bcl0sIGMgPSBsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0KS5pbmNsdWRlcyhjKSkge1xuICAgICAgbC5yZW1vdmUoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBkID0gW10uY29uY2F0KC4uLmwuYXR0cmlidXRlcyksIF8gPSBbXS5jb25jYXQoXG4gICAgICB0W1wiKlwiXSB8fCBbXSxcbiAgICAgIHRbY10gfHwgW11cbiAgICApO1xuICAgIGQuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgdHUoZiwgXykgfHwgbC5yZW1vdmVBdHRyaWJ1dGUoZi5ub2RlTmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG4uYm9keS5pbm5lckhUTUw7XG59XG5jb25zdCBzciA9IFwidG9vbHRpcFwiLCBpdSA9IFwidGUudG9vbHRpcFwiLCBDdCA9IGAuJHtpdX1gLCBzdSA9IFwidGUtdG9vbHRpcFwiLCBudSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInNhbml0aXplXCIsIFwiYWxsb3dMaXN0XCIsIFwic2FuaXRpemVGblwiXSksIG91ID0ge1xuICBhbmltYXRpb246IFwiYm9vbGVhblwiLFxuICB0ZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgdGl0bGU6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiLFxuICB0cmlnZ2VyOiBcInN0cmluZ1wiLFxuICBkZWxheTogXCIobnVtYmVyfG9iamVjdClcIixcbiAgaHRtbDogXCJib29sZWFuXCIsXG4gIHNlbGVjdG9yOiBcIihzdHJpbmd8Ym9vbGVhbilcIixcbiAgcGxhY2VtZW50OiBcIihzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBjb250YWluZXI6IFwiKHN0cmluZ3xlbGVtZW50fGJvb2xlYW4pXCIsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogXCJhcnJheVwiLFxuICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gIGN1c3RvbUNsYXNzOiBcIihzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIHNhbml0aXplOiBcImJvb2xlYW5cIixcbiAgc2FuaXRpemVGbjogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgYWxsb3dMaXN0OiBcIm9iamVjdFwiLFxuICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiXG59LCBydSA9IHtcbiAgQVVUTzogXCJhdXRvXCIsXG4gIFRPUDogXCJ0b3BcIixcbiAgUklHSFQ6IEYoKSA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICBCT1RUT006IFwiYm90dG9tXCIsXG4gIExFRlQ6IEYoKSA/IFwicmlnaHRcIiA6IFwibGVmdFwiXG59LCBhdSA9IHtcbiAgYW5pbWF0aW9uOiAhMCxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwib3BhY2l0eS0wIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0zMDAgZWFzZS1pbi1vdXQgYWJzb2x1dGUgei1bMTA4MF0gYmxvY2sgbS0wIHRleHQtc20gbm90LWl0YWxpYyBmb250LW5vcm1hbCB0ZXh0LWxlZnQgbm8tdW5kZXJsaW5lIHVuZGVybGluZS1vZmZzZXQtYXV0byBub3JtYWwtY2FzZSBsZWFkaW5nLTYgdHJhY2tpbmctbm9ybWFsIGJyZWFrLW5vcm1hbCB3aGl0ZXNwYWNlLW5vcm1hbFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBkYXRhLXRlLXRvb2x0aXAtaW5uZXItcmVmIGNsYXNzPVwidG9vbHRpcC1pbm5lciBtYXgtdy1bMjAwcHhdIHRleHQtc20gcHktMS41IHB4LTQgdGV4dC13aGl0ZSB0ZXh0LWNlbnRlciBiZy1bIzZkNmQ2ZF0gcm91bmRlZFwiPjwvZGl2PjwvZGl2PicsXG4gIHRyaWdnZXI6IFwiaG92ZXIgZm9jdXNcIixcbiAgdGl0bGU6IFwiXCIsXG4gIGRlbGF5OiAwLFxuICBodG1sOiAhMSxcbiAgc2VsZWN0b3I6ICExLFxuICBwbGFjZW1lbnQ6IFwidG9wXCIsXG4gIG9mZnNldDogWzAsIDBdLFxuICBjb250YWluZXI6ICExLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXSxcbiAgYm91bmRhcnk6IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gIGN1c3RvbUNsYXNzOiBcIlwiLFxuICBzYW5pdGl6ZTogITAsXG4gIHNhbml0aXplRm46IG51bGwsXG4gIGFsbG93TGlzdDogZXUsXG4gIHBvcHBlckNvbmZpZzogeyBoaWRlOiAhMCB9XG59LCBsdSA9IHtcbiAgSElERTogYGhpZGUke0N0fWAsXG4gIEhJRERFTjogYGhpZGRlbiR7Q3R9YCxcbiAgU0hPVzogYHNob3cke0N0fWAsXG4gIFNIT1dOOiBgc2hvd24ke0N0fWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke0N0fWAsXG4gIENMSUNLOiBgY2xpY2ske0N0fWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtDdH1gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHtDdH1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7Q3R9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke0N0fWBcbn0sIGN1ID0gXCJmYWRlXCIsIGR1ID0gXCJtb2RhbFwiLCBKcyA9IFwic2hvd1wiLCBRZSA9IFwic2hvd1wiLCB0biA9IFwib3V0XCIsIG5yID0gXCIudG9vbHRpcC1pbm5lclwiLCBvciA9IGAuJHtkdX1gLCByciA9IFwiaGlkZS50ZS5tb2RhbFwiLCBaZSA9IFwiaG92ZXJcIiwgZW4gPSBcImZvY3VzXCIsIGh1ID0gXCJjbGlja1wiLCB1dSA9IFwibWFudWFsXCI7XG5jbGFzcyB2aSBleHRlbmRzIHZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIGlmICh0eXBlb2YgaWwgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiQm9vdHN0cmFwJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZylcIlxuICAgICAgKTtcbiAgICBzdXBlcih0KSwgdGhpcy5faXNFbmFibGVkID0gITAsIHRoaXMuX3RpbWVvdXQgPSAwLCB0aGlzLl9ob3ZlclN0YXRlID0gXCJcIiwgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IHt9LCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMudGlwID0gbnVsbCwgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIGF1O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gc3I7XG4gIH1cbiAgc3RhdGljIGdldCBFdmVudCgpIHtcbiAgICByZXR1cm4gbHU7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gb3U7XG4gIH1cbiAgLy8gUHVibGljXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhMDtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICExO1xuICB9XG4gIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgfVxuICB0b2dnbGUodCkge1xuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpXG4gICAgICBpZiAodCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQpO1xuICAgICAgICBlLl9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIWUuX2FjdGl2ZVRyaWdnZXIuY2xpY2ssIGUuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSA/IGUuX2VudGVyKG51bGwsIGUpIDogZS5fbGVhdmUobnVsbCwgZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKEpzKSkge1xuICAgICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbnRlcihudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgdS5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LmNsb3Nlc3Qob3IpLFxuICAgICAgcnIsXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyXG4gICAgKSwgdGhpcy50aXAgJiYgdGhpcy50aXAucmVtb3ZlKCksIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50c1wiKTtcbiAgICBpZiAoISh0aGlzLmlzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB1LnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XXG4gICAgKSwgZSA9IFRhKHRoaXMuX2VsZW1lbnQpLCBpID0gZSA9PT0gbnVsbCA/IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy5fZWxlbWVudCkgOiBlLmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICh0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5OQU1FID09PSBcInRvb2x0aXBcIiAmJiB0aGlzLnRpcCAmJiB0aGlzLmdldFRpdGxlKCkgIT09IHRoaXMudGlwLnF1ZXJ5U2VsZWN0b3IobnIpLmlubmVySFRNTCAmJiAodGhpcy5fZGlzcG9zZVBvcHBlcigpLCB0aGlzLnRpcC5yZW1vdmUoKSwgdGhpcy50aXAgPSBudWxsKTtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIG8gPSBPdCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpO1xuICAgIG4uc2V0QXR0cmlidXRlKFwiaWRcIiwgbyksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCBvKSwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudGlwLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTEwMFwiKSwgdGhpcy50aXAuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMFwiKTtcbiAgICB9LCAxMDApO1xuICAgIGNvbnN0IHIgPSB0eXBlb2YgdGhpcy5fY29uZmlnLnBsYWNlbWVudCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgbiwgdGhpcy5fZWxlbWVudCkgOiB0aGlzLl9jb25maWcucGxhY2VtZW50LCBhID0gdGhpcy5fZ2V0QXR0YWNobWVudChyKTtcbiAgICB0aGlzLl9hZGRBdHRhY2htZW50Q2xhc3MoYSk7XG4gICAgY29uc3QgeyBjb250YWluZXI6IGwgfSA9IHRoaXMuX2NvbmZpZztcbiAgICBpZiAoSS5zZXREYXRhKG4sIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpLCB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSB8fCAobC5hcHBlbmQobiksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKSksIHRoaXMuX3BvcHBlciA/IHRoaXMuX3BvcHBlci51cGRhdGUoKSA6IHRoaXMuX3BvcHBlciA9IGplKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9nZXRQb3BwZXJDb25maWcoYSlcbiAgICApLCBuLmdldEF0dHJpYnV0ZShcImlkXCIpLmluY2x1ZGVzKFwidG9vbHRpcFwiKSlcbiAgICAgIHN3aXRjaCAocikge1xuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHktWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHgtWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB4LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB5LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNvbnN0IGQgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MpO1xuICAgIGQgJiYgbi5jbGFzc0xpc3QuYWRkKC4uLmQuc3BsaXQoXCIgXCIpKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKG0pID0+IHtcbiAgICAgIHUub24obSwgXCJtb3VzZW92ZXJcIiwgdnMpO1xuICAgIH0pO1xuICAgIGNvbnN0IF8gPSAoKSA9PiB7XG4gICAgICBjb25zdCBtID0gdGhpcy5faG92ZXJTdGF0ZTtcbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSBudWxsLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTiksIG0gPT09IHRuICYmIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuICAgIH0sIGYgPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0cmFuc2l0aW9uLW9wYWNpdHlcIik7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhfLCB0aGlzLnRpcCwgZik7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX3BvcHBlcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkgfHwgKHRoaXMuX2hvdmVyU3RhdGUgIT09IFFlICYmIHQucmVtb3ZlKCksIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pLCB0aGlzLl9kaXNwb3NlUG9wcGVyKCkpO1xuICAgIH07XG4gICAgaWYgKHUudHJpZ2dlcihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREVcbiAgICApLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0wXCIpLCB0LmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTEwMFwiKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKG8pID0+IHUub2ZmKG8sIFwibW91c2VvdmVyXCIsIHZzKSksIHRoaXMuX2FjdGl2ZVRyaWdnZXJbaHVdID0gITEsIHRoaXMuX2FjdGl2ZVRyaWdnZXJbZW5dID0gITEsIHRoaXMuX2FjdGl2ZVRyaWdnZXJbWmVdID0gITE7XG4gICAgY29uc3QgbiA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhcIm9wYWNpdHktMFwiKTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMudGlwLCBuKSwgdGhpcy5faG92ZXJTdGF0ZSA9IFwiXCI7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX3BvcHBlciAhPT0gbnVsbCAmJiB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gIH1cbiAgLy8gUHJvdGVjdGVkXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRUaXRsZSgpO1xuICB9XG4gIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMudGlwKVxuICAgICAgcmV0dXJuIHRoaXMudGlwO1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHQuaW5uZXJIVE1MID0gdGhpcy5fY29uZmlnLnRlbXBsYXRlO1xuICAgIGNvbnN0IGUgPSB0LmNoaWxkcmVuWzBdO1xuICAgIHJldHVybiB0aGlzLnNldENvbnRlbnQoZSksIGUuY2xhc3NMaXN0LnJlbW92ZShjdSwgSnMpLCB0aGlzLnRpcCA9IGUsIHRoaXMudGlwO1xuICB9XG4gIHNldENvbnRlbnQodCkge1xuICAgIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLmdldFRpdGxlKCksIG5yKTtcbiAgfVxuICBfc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gaC5maW5kT25lKGksIHQpO1xuICAgIGlmICghZSAmJiBuKSB7XG4gICAgICBuLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KG4sIGUpO1xuICB9XG4gIHNldEVsZW1lbnRDb250ZW50KHQsIGUpIHtcbiAgICBpZiAodCAhPT0gbnVsbCkge1xuICAgICAgaWYgKE5lKGUpKSB7XG4gICAgICAgIGUgPSBHdChlKSwgdGhpcy5fY29uZmlnLmh0bWwgPyBlLnBhcmVudE5vZGUgIT09IHQgJiYgKHQuaW5uZXJIVE1MID0gXCJcIiwgdC5hcHBlbmQoZSkpIDogdC50ZXh0Q29udGVudCA9IGUudGV4dENvbnRlbnQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbmZpZy5odG1sID8gKHRoaXMuX2NvbmZpZy5zYW5pdGl6ZSAmJiAoZSA9IGlyKFxuICAgICAgICBlLFxuICAgICAgICB0aGlzLl9jb25maWcuYWxsb3dMaXN0LFxuICAgICAgICB0aGlzLl9jb25maWcuc2FuaXRpemVGblxuICAgICAgKSksIHQuaW5uZXJIVE1MID0gZSkgOiB0LnRleHRDb250ZW50ID0gZTtcbiAgICB9XG4gIH1cbiAgZ2V0VGl0bGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1vcmlnaW5hbC10aXRsZVwiKSB8fCB0aGlzLl9jb25maWcudGl0bGU7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHQpO1xuICB9XG4gIHVwZGF0ZUF0dGFjaG1lbnQodCkge1xuICAgIHJldHVybiB0ID09PSBcInJpZ2h0XCIgPyBcImVuZFwiIDogdCA9PT0gXCJsZWZ0XCIgPyBcInN0YXJ0XCIgOiB0O1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSB7XG4gICAgcmV0dXJuIGUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5nZXRPckNyZWF0ZUluc3RhbmNlKFxuICAgICAgdC5kZWxlZ2F0ZVRhcmdldCxcbiAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICApO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgeyBvZmZzZXQ6IHQgfSA9IHRoaXMuX2NvbmZpZztcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gTnVtYmVyLnBhcnNlSW50KGUsIDEwKSkgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAoZSkgPT4gdChlLCB0aGlzLl9lbGVtZW50KSA6IHQ7XG4gIH1cbiAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdC5jYWxsKHRoaXMuX2VsZW1lbnQpIDogdDtcbiAgfVxuICBfZ2V0UG9wcGVyQ29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgcGxhY2VtZW50OiB0LFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImZsaXBcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuX2NvbmZpZy5mYWxsYmFja1BsYWNlbWVudHNcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImFycm93XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZWxlbWVudDogYC4ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXJyb3dgXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvbkNoYW5nZVwiLFxuICAgICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICAgIHBoYXNlOiBcImFmdGVyV3JpdGVcIixcbiAgICAgICAgICBmbjogKGkpID0+IHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShpKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb25GaXJzdFVwZGF0ZTogKGkpID0+IHtcbiAgICAgICAgaS5vcHRpb25zLnBsYWNlbWVudCAhPT0gaS5wbGFjZW1lbnQgJiYgdGhpcy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGkpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmUsXG4gICAgICAuLi50eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGUpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xuICAgIH07XG4gIH1cbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyh0KSB7XG4gICAgdGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChcbiAgICAgIGAke3RoaXMuX2dldEJhc2ljQ2xhc3NQcmVmaXgoKX0tJHt0aGlzLnVwZGF0ZUF0dGFjaG1lbnQodCl9YFxuICAgICk7XG4gIH1cbiAgX2dldEF0dGFjaG1lbnQodCkge1xuICAgIHJldHVybiBydVt0LnRvVXBwZXJDYXNlKCldO1xuICB9XG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29uZmlnLnRyaWdnZXIuc3BsaXQoXCIgXCIpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGlmIChlID09PSBcImNsaWNrXCIpXG4gICAgICAgIHUub24oXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLFxuICAgICAgICAgIHRoaXMuX2NvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAoaSkgPT4gdGhpcy50b2dnbGUoaSlcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgaWYgKGUgIT09IHV1KSB7XG4gICAgICAgIGNvbnN0IGkgPSBlID09PSBaZSA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTiwgbiA9IGUgPT09IFplID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVDtcbiAgICAgICAgdS5vbihcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgIGksXG4gICAgICAgICAgdGhpcy5fY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIChvKSA9PiB0aGlzLl9lbnRlcihvKVxuICAgICAgICApLCB1Lm9uKFxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgbixcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXG4gICAgICAgICAgKG8pID0+IHRoaXMuX2xlYXZlKG8pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSksIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50ICYmIHRoaXMuaGlkZSgpO1xuICAgIH0sIHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LmNsb3Nlc3Qob3IpLFxuICAgICAgcnIsXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyXG4gICAgKSwgdGhpcy5fY29uZmlnLnNlbGVjdG9yID8gdGhpcy5fY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5fY29uZmlnLFxuICAgICAgdHJpZ2dlcjogXCJtYW51YWxcIixcbiAgICAgIHNlbGVjdG9yOiBcIlwiXG4gICAgfSA6IHRoaXMuX2ZpeFRpdGxlKCk7XG4gIH1cbiAgX2ZpeFRpdGxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcInRpdGxlXCIpLCBlID0gdHlwZW9mIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFxuICAgICAgXCJkYXRhLXRlLW9yaWdpbmFsLXRpdGxlXCJcbiAgICApO1xuICAgICh0IHx8IGUgIT09IFwic3RyaW5nXCIpICYmICh0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtb3JpZ2luYWwtdGl0bGVcIiwgdCB8fCBcIlwiKSwgdCAmJiAhdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50ICYmIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBcIlwiKSk7XG4gIH1cbiAgX2VudGVyKHQsIGUpIHtcbiAgICBpZiAoZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSwgdCAmJiAoZS5fYWN0aXZlVHJpZ2dlclt0LnR5cGUgPT09IFwiZm9jdXNpblwiID8gZW4gOiBaZV0gPSAhMCksIGUuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhKcykgfHwgZS5faG92ZXJTdGF0ZSA9PT0gUWUpIHtcbiAgICAgIGUuX2hvdmVyU3RhdGUgPSBRZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNsZWFyVGltZW91dChlLl90aW1lb3V0KSwgZS5faG92ZXJTdGF0ZSA9IFFlLCAhZS5fY29uZmlnLmRlbGF5IHx8ICFlLl9jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgZS5zaG93KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGUuX2hvdmVyU3RhdGUgPT09IFFlICYmIGUuc2hvdygpO1xuICAgIH0sIGUuX2NvbmZpZy5kZWxheS5zaG93KTtcbiAgfVxuICBfbGVhdmUodCwgZSkge1xuICAgIGlmIChlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQsIGUpLCB0ICYmIChlLl9hY3RpdmVUcmlnZ2VyW3QudHlwZSA9PT0gXCJmb2N1c291dFwiID8gZW4gOiBaZV0gPSBlLl9lbGVtZW50LmNvbnRhaW5zKHQucmVsYXRlZFRhcmdldCkpLCAhZS5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICBpZiAoY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLCBlLl9ob3ZlclN0YXRlID0gdG4sICFlLl9jb25maWcuZGVsYXkgfHwgIWUuX2NvbmZpZy5kZWxheS5oaWRlKSB7XG4gICAgICAgIGUuaGlkZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGUuX2hvdmVyU3RhdGUgPT09IHRuICYmIGUuaGlkZSgpO1xuICAgICAgfSwgZS5fY29uZmlnLmRlbGF5LmhpZGUpO1xuICAgIH1cbiAgfVxuICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdGhpcy5fYWN0aXZlVHJpZ2dlcilcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RdKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBudS5oYXMoaSkgJiYgZGVsZXRlIGVbaV07XG4gICAgfSksIHQgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5lLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgdC5jb250YWluZXIgPSB0LmNvbnRhaW5lciA9PT0gITEgPyBkb2N1bWVudC5ib2R5IDogR3QodC5jb250YWluZXIpLCB0eXBlb2YgdC5kZWxheSA9PSBcIm51bWJlclwiICYmICh0LmRlbGF5ID0ge1xuICAgICAgc2hvdzogdC5kZWxheSxcbiAgICAgIGhpZGU6IHQuZGVsYXlcbiAgICB9KSwgdHlwZW9mIHQudGl0bGUgPT0gXCJudW1iZXJcIiAmJiAodC50aXRsZSA9IHQudGl0bGUudG9TdHJpbmcoKSksIHR5cGVvZiB0LmNvbnRlbnQgPT0gXCJudW1iZXJcIiAmJiAodC5jb250ZW50ID0gdC5jb250ZW50LnRvU3RyaW5nKCkpLCBOKHNyLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdC5zYW5pdGl6ZSAmJiAodC50ZW1wbGF0ZSA9IGlyKFxuICAgICAgdC50ZW1wbGF0ZSxcbiAgICAgIHQuYWxsb3dMaXN0LFxuICAgICAgdC5zYW5pdGl6ZUZuXG4gICAgKSksIHQ7XG4gIH1cbiAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5fY29uZmlnKVxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VdICE9PSB0aGlzLl9jb25maWdbZV0gJiYgKHRbZV0gPSB0aGlzLl9jb25maWdbZV0pO1xuICAgIHJldHVybiB0O1xuICB9XG4gIF9jbGVhblRpcENsYXNzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFRpcEVsZW1lbnQoKSwgZSA9IG5ldyBSZWdFeHAoXG4gICAgICBgKF58XFxcXHMpJHt0aGlzLl9nZXRCYXNpY0NsYXNzUHJlZml4KCl9XFxcXFMrYCxcbiAgICAgIFwiZ1wiXG4gICAgKSwgaSA9IHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikubWF0Y2goZSk7XG4gICAgaSAhPT0gbnVsbCAmJiBpLmxlbmd0aCA+IDAgJiYgaS5tYXAoKG4pID0+IG4udHJpbSgpKS5mb3JFYWNoKChuKSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUobikpO1xuICB9XG4gIF9nZXRCYXNpY0NsYXNzUHJlZml4KCkge1xuICAgIHJldHVybiBzdTtcbiAgfVxuICBfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHQpIHtcbiAgICBjb25zdCB7IHN0YXRlOiBlIH0gPSB0O1xuICAgIGUgJiYgKHRoaXMudGlwID0gZS5lbGVtZW50cy5wb3BwZXIsIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSwgdGhpcy5fYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQoZS5wbGFjZW1lbnQpKSk7XG4gIH1cbiAgX2Rpc3Bvc2VQb3BwZXIoKSB7XG4gICAgdGhpcy5fcG9wcGVyICYmICh0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9wb3BwZXIgPSBudWxsKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSB2aS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgcHUgPSBcInBvcG92ZXJcIiwgZnUgPSBcInRlLnBvcG92ZXJcIiwgQXQgPSBgLiR7ZnV9YCwgX3UgPSBcInRlLXBvcG92ZXJcIiwgbXUgPSB7XG4gIC4uLnZpLkRlZmF1bHQsXG4gIHBsYWNlbWVudDogXCJyaWdodFwiLFxuICBvZmZzZXQ6IFswLCA4XSxcbiAgdHJpZ2dlcjogXCJjbGlja1wiLFxuICBjb250ZW50OiBcIlwiLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJvcGFjaXR5LTAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgei1bMTA3MF0gYmxvY2sgbWF4LXctWzI2N3B4XSBicmVhay13b3JkcyBiZy13aGl0ZSBiZy1jbGlwLXBhZGRpbmcgYm9yZGVyIGJvcmRlci1uZXV0cmFsLTEwMCByb3VuZGVkLWxnIHNoYWRvdy1bMF8wcHhfM3B4XzBfcmdiYSgwLDAsMCwwLjA3KSwwXzJweF8ycHhfMF9yZ2JhKDAsMCwwLDAuMDQpXSB0ZXh0LXNtIG5vdC1pdGFsaWMgZm9udC1ub3JtYWwgdGV4dC1sZWZ0IG5vLXVuZGVybGluZSB1bmRlcmxpbmUtb2Zmc2V0LWF1dG8gbm9ybWFsLWNhc2UgbGVhZGluZy02IHRyYWNraW5nLW5vcm1hbCBicmVhay1ub3JtYWwgd2hpdGVzcGFjZS1ub3JtYWwgZGFyazpiZy1uZXV0cmFsLTcwMCBkYXJrOmJvcmRlci0wIGRhcms6dGV4dC13aGl0ZSBkYXRhLVtwb3BwZXItcmVmZXJlbmNlLWhpZGRlbl06aGlkZGVuXCIgcm9sZT1cInRvb2x0aXBcIj48aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlciBweS0yIHB4LTQgbWItMCBib3JkZXItYi0yIGJvcmRlci1uZXV0cmFsLTEwMCByb3VuZGVkLXQtbGcgZm9udC1tZWRpdW0gZW1wdHk6aGlkZGVuIGRhcms6Ym9yZGVyLW5ldXRyYWwtNTAwXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5IHAtNCB0ZXh0LVsjMjEyNTI5XSBkYXJrOnRleHQtd2hpdGVcIj48L2Rpdj48L2Rpdj4nXG59LCBndSA9IHtcbiAgLi4udmkuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQ6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiXG59LCBidSA9IHtcbiAgSElERTogYGhpZGUke0F0fWAsXG4gIEhJRERFTjogYGhpZGRlbiR7QXR9YCxcbiAgU0hPVzogYHNob3cke0F0fWAsXG4gIFNIT1dOOiBgc2hvd24ke0F0fWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke0F0fWAsXG4gIENMSUNLOiBgY2xpY2ske0F0fWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtBdH1gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHtBdH1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7QXR9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke0F0fWBcbn0sIHZ1ID0gXCIucG9wb3Zlci1oZWFkZXJcIiwgRXUgPSBcIi5wb3BvdmVyLWJvZHlcIjtcbmNsYXNzIGxsIGV4dGVuZHMgdmkge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gbXU7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBwdTtcbiAgfVxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBidTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBndTtcbiAgfVxuICAvLyBPdmVycmlkZXNcbiAgaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcbiAgfVxuICBzZXRDb250ZW50KHQpIHtcbiAgICB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5nZXRUaXRsZSgpLCB2dSksIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLl9nZXRDb250ZW50KCksIEV1KTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY29udGVudCk7XG4gIH1cbiAgX2dldEJhc2ljQ2xhc3NQcmVmaXgoKSB7XG4gICAgcmV0dXJuIF91O1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IGxsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBzbiA9IFwic2Nyb2xsc3B5XCIsIFR1ID0gXCJ0ZS5zY3JvbGxzcHlcIiwgU3MgPSBgLiR7VHV9YCwgQ3UgPSBcIi5kYXRhLWFwaVwiLCBhciA9IHtcbiAgb2Zmc2V0OiAxMCxcbiAgbWV0aG9kOiBcImF1dG9cIixcbiAgdGFyZ2V0OiBcIlwiXG59LCBBdSA9IHtcbiAgb2Zmc2V0OiBcIm51bWJlclwiLFxuICBtZXRob2Q6IFwic3RyaW5nXCIsXG4gIHRhcmdldDogXCIoc3RyaW5nfGVsZW1lbnQpXCJcbn0sIHl1ID0ge1xuICBhY3RpdmU6IFwiIXRleHQtcHJpbWFyeSBkYXJrOiF0ZXh0LXByaW1hcnktNDAwIGZvbnQtc2VtaWJvbGQgYm9yZGVyLWwtWzAuMTI1cmVtXSBib3JkZXItc29saWQgYm9yZGVyLXByaW1hcnkgZGFyazpib3JkZXItcHJpbWFyeS00MDBcIlxufSwgd3UgPSB7XG4gIGFjdGl2ZTogXCJzdHJpbmdcIlxufSwga3UgPSBgYWN0aXZhdGUke1NzfWAsIE91ID0gYHNjcm9sbCR7U3N9YCwgeHUgPSBgbG9hZCR7U3N9JHtDdX1gLCBubiA9IFwiZGF0YS10ZS1uYXYtbGluay1hY3RpdmVcIiwgY2wgPSBcIltkYXRhLXRlLWRyb3Bkb3duLWl0ZW0tcmVmXVwiLCBTdSA9ICdbZGF0YS10ZS1zcHk9XCJzY3JvbGxcIl0nLCBEdSA9IFwiW2RhdGEtdGUtbmF2LWxpc3QtcmVmXVwiLCBIbiA9IFwiW2RhdGEtdGUtbmF2LWxpbmstcmVmXVwiLCBJdSA9IFwiW2RhdGEtdGUtbmF2LWl0ZW0tcmVmXVwiLCBkbCA9IFwiW2RhdGEtdGUtbGlzdC1ncm91cC1pdGVtLXJlZl1cIiwgb24gPSBgJHtIbn0sICR7ZGx9LCAke2NsfWAsICR1ID0gXCJbZGF0YS10ZS1kcm9wZG93bi1yZWZdXCIsIEx1ID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBNdSA9IFwib2Zmc2V0XCIsIGxyID0gXCJwb3NpdGlvblwiO1xuY2xhc3MgQm4gZXh0ZW5kcyB2dCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQudGFnTmFtZSA9PT0gXCJCT0RZXCIgPyB3aW5kb3cgOiB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9vZmZzZXRzID0gW10sIHRoaXMuX3RhcmdldHMgPSBbXSwgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbCwgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gMCwgdS5vbih0aGlzLl9zY3JvbGxFbGVtZW50LCBPdSwgKCkgPT4gdGhpcy5fcHJvY2VzcygpKSwgdGhpcy5yZWZyZXNoKCksIHRoaXMuX3Byb2Nlc3MoKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIGFyO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gc247XG4gIH1cbiAgLy8gUHVibGljXG4gIHJlZnJlc2goKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHRoaXMuX3Njcm9sbEVsZW1lbnQud2luZG93ID8gTXUgOiBsciwgZSA9IHRoaXMuX2NvbmZpZy5tZXRob2QgPT09IFwiYXV0b1wiID8gdCA6IHRoaXMuX2NvbmZpZy5tZXRob2QsIGkgPSBlID09PSBsciA/IHRoaXMuX2dldFNjcm9sbFRvcCgpIDogMDtcbiAgICB0aGlzLl9vZmZzZXRzID0gW10sIHRoaXMuX3RhcmdldHMgPSBbXSwgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCksIGguZmluZChcbiAgICAgIG9uLFxuICAgICAgdGhpcy5fY29uZmlnLnRhcmdldFxuICAgICkubWFwKChvKSA9PiB7XG4gICAgICBjb25zdCByID0gWG4obyksIGEgPSByID8gaC5maW5kT25lKHIpIDogbnVsbDtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIGNvbnN0IGwgPSBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobC53aWR0aCB8fCBsLmhlaWdodClcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcFtlXShhKS50b3AgKyBpLFxuICAgICAgICAgICAgclxuICAgICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KS5maWx0ZXIoKG8pID0+IG8pLnNvcnQoKG8sIHIpID0+IG9bMF0gLSByWzBdKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICB0aGlzLl9vZmZzZXRzLnB1c2gob1swXSksIHRoaXMuX3RhcmdldHMucHVzaChvWzFdKTtcbiAgICB9KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHUub2ZmKHRoaXMuX3Njcm9sbEVsZW1lbnQsIFNzKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAodS5vbih3aW5kb3csIHh1LCAoKSA9PiB7XG4gICAgICBoLmZpbmQoU3UpLmZvckVhY2goXG4gICAgICAgICh0KSA9PiBuZXcgQm4odClcbiAgICAgICk7XG4gICAgfSksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5hcixcbiAgICAgIC4uLnAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgPyB0IDoge31cbiAgICB9LCB0LnRhcmdldCA9IEd0KHQudGFyZ2V0KSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIE4oc24sIHQsIEF1KSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnl1LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKHNuLCB0LCB3dSksIHQ7XG4gIH1cbiAgX2dldFNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gdGhpcy5fc2Nyb2xsRWxlbWVudC5wYWdlWU9mZnNldCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG4gIF9nZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IHx8IE1hdGgubWF4KFxuICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0XG4gICAgKTtcbiAgfVxuICBfZ2V0T2Zmc2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgfVxuICBfcHJvY2VzcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0U2Nyb2xsVG9wKCkgKyB0aGlzLl9jb25maWcub2Zmc2V0LCBlID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCksIGkgPSB0aGlzLl9jb25maWcub2Zmc2V0ICsgZSAtIHRoaXMuX2dldE9mZnNldEhlaWdodCgpO1xuICAgIGlmICh0aGlzLl9zY3JvbGxIZWlnaHQgIT09IGUgJiYgdGhpcy5yZWZyZXNoKCksIHQgPj0gaSkge1xuICAgICAgY29uc3QgbiA9IHRoaXMuX3RhcmdldHNbdGhpcy5fdGFyZ2V0cy5sZW5ndGggLSAxXTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCAhPT0gbiAmJiB0aGlzLl9hY3RpdmF0ZShuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCAmJiB0IDwgdGhpcy5fb2Zmc2V0c1swXSAmJiB0aGlzLl9vZmZzZXRzWzBdID4gMCkge1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbCwgdGhpcy5fY2xlYXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgbiA9IHRoaXMuX29mZnNldHMubGVuZ3RoOyBuLS07IClcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCAhPT0gdGhpcy5fdGFyZ2V0c1tuXSAmJiB0ID49IHRoaXMuX29mZnNldHNbbl0gJiYgKHR5cGVvZiB0aGlzLl9vZmZzZXRzW24gKyAxXSA+IFwidVwiIHx8IHQgPCB0aGlzLl9vZmZzZXRzW24gKyAxXSkgJiYgdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tuXSk7XG4gIH1cbiAgX2FjdGl2YXRlKHQpIHtcbiAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSB0LCB0aGlzLl9jbGVhcigpO1xuICAgIGNvbnN0IGUgPSBvbi5zcGxpdChcIixcIikubWFwKFxuICAgICAgKG4pID0+IGAke259W2RhdGEtdGUtdGFyZ2V0PVwiJHt0fVwiXSwke259W2hyZWY9XCIke3R9XCJdYFxuICAgICksIGkgPSBoLmZpbmRPbmUoZS5qb2luKFwiLFwiKSwgdGhpcy5fY29uZmlnLnRhcmdldCk7XG4gICAgaS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSksIGkuc2V0QXR0cmlidXRlKG5uLCBcIlwiKSwgaS5nZXRBdHRyaWJ1dGUoY2wpID8gaC5maW5kT25lKFxuICAgICAgTHUsXG4gICAgICBpLmNsb3Nlc3QoJHUpXG4gICAgKS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSkgOiBoLnBhcmVudHMoaSwgRHUpLmZvckVhY2goXG4gICAgICAobikgPT4ge1xuICAgICAgICBoLnByZXYoXG4gICAgICAgICAgbixcbiAgICAgICAgICBgJHtIbn0sICR7ZGx9YFxuICAgICAgICApLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgICBvLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKSwgby5zZXRBdHRyaWJ1dGUobm4sIFwiXCIpO1xuICAgICAgICB9KSwgaC5wcmV2KG4sIEl1KS5mb3JFYWNoKFxuICAgICAgICAgIChvKSA9PiB7XG4gICAgICAgICAgICBoLmNoaWxkcmVuKG8sIEhuKS5mb3JFYWNoKFxuICAgICAgICAgICAgICAocikgPT4gci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICksIHUudHJpZ2dlcih0aGlzLl9zY3JvbGxFbGVtZW50LCBrdSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgIH0pO1xuICB9XG4gIF9jbGVhcigpIHtcbiAgICBoLmZpbmQob24sIHRoaXMuX2NvbmZpZy50YXJnZXQpLmZpbHRlcihcbiAgICAgICh0KSA9PiB0LmNsYXNzTGlzdC5jb250YWlucyguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpXG4gICAgKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKSwgdC5yZW1vdmVBdHRyaWJ1dGUobm4pO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IEJuLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBjciA9IFwidGFiXCIsIE51ID0gXCJ0ZS50YWJcIiwgRHMgPSBgLiR7TnV9YCwgUnUgPSBgaGlkZSR7RHN9YCwgUHUgPSBgaGlkZGVuJHtEc31gLCBIdSA9IGBzaG93JHtEc31gLCBCdSA9IGBzaG93biR7RHN9YCwgVnUgPSBcImRhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZcIiwgd2UgPSBcImRhdGEtdGUtdGFiLWFjdGl2ZVwiLCBhcyA9IFwiZGF0YS10ZS1uYXYtYWN0aXZlXCIsIFd1ID0gXCJbZGF0YS10ZS1kcm9wZG93bi1yZWZdXCIsIEZ1ID0gXCJbZGF0YS10ZS1uYXYtcmVmXVwiLCBkciA9IGBbJHt3ZX1dYCwgWXUgPSBgWyR7YXN9XWAsIGhyID0gXCI6c2NvcGUgPiBsaSA+IC5hY3RpdmVcIiwganUgPSBcIltkYXRhLXRlLWRyb3Bkb3duLXRvZ2dsZS1yZWZdXCIsIEt1ID0gXCI6c2NvcGUgPiBbZGF0YS10ZS1kcm9wZG93bi1tZW51LXJlZl0gW2RhdGEtdGUtZHJvcGRvd24tc2hvd11cIiwgVXUgPSB7XG4gIHNob3c6IFwib3BhY2l0eS0xMDBcIixcbiAgaGlkZTogXCJvcGFjaXR5LTBcIlxufSwgenUgPSB7XG4gIHNob3c6IFwic3RyaW5nXCIsXG4gIGhpZGU6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBobCBleHRlbmRzIHZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhlKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gY3I7XG4gIH1cbiAgLy8gUHVibGljXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKGFzKSA9PT0gXCJcIilcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdDtcbiAgICBjb25zdCBlID0gWHQodGhpcy5fZWxlbWVudCksIGkgPSB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoRnUpLCBuID0gaC5maW5kT25lKFxuICAgICAgWXUsXG4gICAgICBpXG4gICAgKTtcbiAgICBpZiAoaSkge1xuICAgICAgY29uc3QgbCA9IGkubm9kZU5hbWUgPT09IFwiVUxcIiB8fCBpLm5vZGVOYW1lID09PSBcIk9MXCIgPyBociA6IGRyO1xuICAgICAgdCA9IGguZmluZChsLCBpKSwgdCA9IHRbdC5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgY29uc3QgbyA9IHQgPyB1LnRyaWdnZXIodCwgUnUsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9KSA6IG51bGw7XG4gICAgaWYgKHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBIdSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQgfHwgbyAhPT0gbnVsbCAmJiBvLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fYWN0aXZhdGUoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgaSxcbiAgICAgIG51bGwsXG4gICAgICBuLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgY29uc3QgYSA9ICgpID0+IHtcbiAgICAgIHUudHJpZ2dlcih0LCBQdSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9KSwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEJ1LCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZSA/IHRoaXMuX2FjdGl2YXRlKFxuICAgICAgZSxcbiAgICAgIGUucGFyZW50Tm9kZSxcbiAgICAgIGEsXG4gICAgICBuLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkgOiBhKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlV1LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKGNyLCB0LCB6dSksIHQ7XG4gIH1cbiAgX2FjdGl2YXRlKHQsIGUsIGksIG4sIG8pIHtcbiAgICBjb25zdCBhID0gKGUgJiYgKGUubm9kZU5hbWUgPT09IFwiVUxcIiB8fCBlLm5vZGVOYW1lID09PSBcIk9MXCIpID8gaC5maW5kKGhyLCBlKSA6IGguY2hpbGRyZW4oZSwgZHIpKVswXSwgbCA9IGkgJiYgYSAmJiBhLmhhc0F0dHJpYnV0ZSh3ZSksIGMgPSAoKSA9PiB0aGlzLl90cmFuc2l0aW9uQ29tcGxldGUoXG4gICAgICB0LFxuICAgICAgYSxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgb1xuICAgICk7XG4gICAgYSAmJiBsID8gKHAucmVtb3ZlQ2xhc3MoYSwgdGhpcy5fY2xhc3Nlcy5zaG93KSwgcC5hZGRDbGFzcyhhLCB0aGlzLl9jbGFzc2VzLmhpZGUpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKGMsIHQsICEwKSkgOiBjKCk7XG4gIH1cbiAgX3RyYW5zaXRpb25Db21wbGV0ZSh0LCBlLCBpLCBuLCBvKSB7XG4gICAgaWYgKGUgJiYgbikge1xuICAgICAgZS5yZW1vdmVBdHRyaWJ1dGUod2UpLCBuLnJlbW92ZUF0dHJpYnV0ZShhcyk7XG4gICAgICBjb25zdCBhID0gaC5maW5kT25lKFxuICAgICAgICBLdSxcbiAgICAgICAgZS5wYXJlbnROb2RlXG4gICAgICApO1xuICAgICAgYSAmJiBhLnJlbW92ZUF0dHJpYnV0ZSh3ZSksIGUuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJ0YWJcIiAmJiBlLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITEpO1xuICAgIH1cbiAgICB0LnNldEF0dHJpYnV0ZSh3ZSwgXCJcIiksIG8uc2V0QXR0cmlidXRlKGFzLCBcIlwiKSwgdC5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpID09PSBcInRhYlwiICYmIHQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMCksIEZlKHQpLCB0LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLl9jbGFzc2VzLmhpZGUpICYmIChwLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMuaGlkZSksIHAuYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5zaG93KSk7XG4gICAgbGV0IHIgPSB0LnBhcmVudE5vZGU7XG4gICAgaWYgKHIgJiYgci5ub2RlTmFtZSA9PT0gXCJMSVwiICYmIChyID0gci5wYXJlbnROb2RlKSwgciAmJiByLmhhc0F0dHJpYnV0ZShWdSkpIHtcbiAgICAgIGNvbnN0IGEgPSB0LmNsb3Nlc3QoV3UpO1xuICAgICAgYSAmJiBoLmZpbmQoanUsIGEpLmZvckVhY2goXG4gICAgICAgIChsKSA9PiBsLnNldEF0dHJpYnV0ZSh3ZSwgXCJcIilcbiAgICAgICksIHQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCAhMCk7XG4gICAgfVxuICAgIGkgJiYgaSgpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IGhsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBybiA9IFwidG9hc3RcIiwgWHUgPSBcInRlLnRvYXN0XCIsIFF0ID0gYC4ke1h1fWAsIEd1ID0gYG1vdXNlb3ZlciR7UXR9YCwgcXUgPSBgbW91c2VvdXQke1F0fWAsIFF1ID0gYGZvY3VzaW4ke1F0fWAsIFp1ID0gYGZvY3Vzb3V0JHtRdH1gLCBKdSA9IGBoaWRlJHtRdH1gLCB0cCA9IGBoaWRkZW4ke1F0fWAsIGVwID0gYHNob3cke1F0fWAsIGlwID0gYHNob3duJHtRdH1gLCB1ciA9IFwiZGF0YS10ZS10b2FzdC1oaWRlXCIsIGFuID0gXCJkYXRhLXRlLXRvYXN0LXNob3dcIiwgTWkgPSBcImRhdGEtdGUtdG9hc3Qtc2hvd2luZ1wiLCBzcCA9IHtcbiAgYW5pbWF0aW9uOiBcImJvb2xlYW5cIixcbiAgYXV0b2hpZGU6IFwiYm9vbGVhblwiLFxuICBkZWxheTogXCJudW1iZXJcIlxufSwgcHIgPSB7XG4gIGFuaW1hdGlvbjogITAsXG4gIGF1dG9oaWRlOiAhMCxcbiAgZGVsYXk6IDVlM1xufSwgbnAgPSB7XG4gIGZhZGVJbjogXCJhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF0gcC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIixcbiAgZmFkZU91dDogXCJhbmltYXRlLVtmYWRlLW91dF8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCJcbn0sIG9wID0ge1xuICBmYWRlSW46IFwic3RyaW5nXCIsXG4gIGZhZGVPdXQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBWbiBleHRlbmRzIHZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl90aW1lb3V0ID0gbnVsbCwgdGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiA9ICExLCB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gITEsIHRoaXMuX3NldExpc3RlbmVycygpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIHNwO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gcHI7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBybjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgc2hvdygpIHtcbiAgICBpZiAodS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGVwKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9jb25maWcuYW5pbWF0aW9uICYmIChwLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCksIHAuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pKTtcbiAgICBjb25zdCBlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoTWkpLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgaXApLCB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodXIpLCBGZSh0aGlzLl9lbGVtZW50KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYW4sIFwiXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShNaSwgXCJcIiksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQgfHwgdGhpcy5fZWxlbWVudC5kYXRhc2V0LnRlVG9hc3RTaG93ID09PSB2b2lkIDAgfHwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEp1KS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSAoKSA9PiB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB0aGlzLl9jb25maWcuYW5pbWF0aW9uICYmIChpID0gMzAwLCBwLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKHVyLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoTWkpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhbiksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0cCk7XG4gICAgICB9LCBpKTtcbiAgICB9O1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKE1pLCBcIlwiKSwgdGhpcy5fcXVldWVDYWxsYmFjayhlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9lbGVtZW50LmRhdGFzZXQudGVUb2FzdFNob3cgIT09IHZvaWQgMCAmJiB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhbiksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKHhzKFZuKSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnByLFxuICAgICAgLi4ucC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCA/IHQgOiB7fVxuICAgIH0sIE4ocm4sIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ubnAsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4ocm4sIHQsIG9wKSwgdDtcbiAgfVxuICBfbWF5YmVTY2hlZHVsZUhpZGUoKSB7XG4gICAgdGhpcy5fY29uZmlnLmF1dG9oaWRlICYmICh0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uIHx8IHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gfHwgKHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSkpKTtcbiAgfVxuICBfb25JbnRlcmFjdGlvbih0LCBlKSB7XG4gICAgc3dpdGNoICh0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJtb3VzZW92ZXJcIjpcbiAgICAgIGNhc2UgXCJtb3VzZW91dFwiOlxuICAgICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZm9jdXNpblwiOlxuICAgICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGUpIHtcbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpID0gdC5yZWxhdGVkVGFyZ2V0O1xuICAgIHRoaXMuX2VsZW1lbnQgPT09IGkgfHwgdGhpcy5fZWxlbWVudC5jb250YWlucyhpKSB8fCB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xuICB9XG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgdS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBHdSxcbiAgICAgICh0KSA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICEwKVxuICAgICksIHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgcXUsXG4gICAgICAodCkgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMSlcbiAgICApLCB1Lm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFF1LFxuICAgICAgKHQpID0+IHRoaXMuX29uSW50ZXJhY3Rpb24odCwgITApXG4gICAgKSwgdS5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBadSxcbiAgICAgICh0KSA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICExKVxuICAgICk7XG4gIH1cbiAgX2NsZWFyVGltZW91dCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IFZuLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuKCgpID0+IHtcbiAgdmFyIHMgPSB7IDQ1NDogKGksIG4sIG8pID0+IHtcbiAgICBvLmQobiwgeyBaOiAoKSA9PiBsIH0pO1xuICAgIHZhciByID0gbyg2NDUpLCBhID0gby5uKHIpKCkoZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGNbMV07XG4gICAgfSk7XG4gICAgYS5wdXNoKFtpLmlkLCBcIklOUFVUOi13ZWJraXQtYXV0b2ZpbGwsU0VMRUNUOi13ZWJraXQtYXV0b2ZpbGwsVEVYVEFSRUE6LXdlYmtpdC1hdXRvZmlsbHthbmltYXRpb24tbmFtZTpvbmF1dG9maWxsc3RhcnR9SU5QVVQ6bm90KDotd2Via2l0LWF1dG9maWxsKSxTRUxFQ1Q6bm90KDotd2Via2l0LWF1dG9maWxsKSxURVhUQVJFQTpub3QoOi13ZWJraXQtYXV0b2ZpbGwpe2FuaW1hdGlvbi1uYW1lOm9uYXV0b2ZpbGxjYW5jZWx9QGtleWZyYW1lcyBvbmF1dG9maWxsc3RhcnR7fUBrZXlmcmFtZXMgb25hdXRvZmlsbGNhbmNlbHt9XCIsIFwiXCJdKTtcbiAgICBjb25zdCBsID0gYTtcbiAgfSwgNjQ1OiAoaSkgPT4ge1xuICAgIGkuZXhwb3J0cyA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHZhciBvID0gW107XG4gICAgICByZXR1cm4gby50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocikge1xuICAgICAgICAgIHZhciBhID0gbihyKTtcbiAgICAgICAgICByZXR1cm4gclsyXSA/IFwiQG1lZGlhIFwiLmNvbmNhdChyWzJdLCBcIiB7XCIpLmNvbmNhdChhLCBcIn1cIikgOiBhO1xuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgfSwgby5pID0gZnVuY3Rpb24ociwgYSwgbCkge1xuICAgICAgICB0eXBlb2YgciA9PSBcInN0cmluZ1wiICYmIChyID0gW1tudWxsLCByLCBcIlwiXV0pO1xuICAgICAgICB2YXIgYyA9IHt9O1xuICAgICAgICBpZiAobClcbiAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IHRoaXMubGVuZ3RoOyBkKyspIHtcbiAgICAgICAgICAgIHZhciBfID0gdGhpc1tkXVswXTtcbiAgICAgICAgICAgIF8gIT0gbnVsbCAmJiAoY1tfXSA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGYgPSAwOyBmIDwgci5sZW5ndGg7IGYrKykge1xuICAgICAgICAgIHZhciBtID0gW10uY29uY2F0KHJbZl0pO1xuICAgICAgICAgIGwgJiYgY1ttWzBdXSB8fCAoYSAmJiAobVsyXSA/IG1bMl0gPSBcIlwiLmNvbmNhdChhLCBcIiBhbmQgXCIpLmNvbmNhdChtWzJdKSA6IG1bMl0gPSBhKSwgby5wdXNoKG0pKTtcbiAgICAgICAgfVxuICAgICAgfSwgbztcbiAgICB9O1xuICB9LCA4MTA6ICgpID0+IHtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA8IFwidVwiKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudChcInRlc3RcIiwgeyBjYW5jZWxhYmxlOiAhMCB9KTtcbiAgICAgICAgICBpZiAoaS5wcmV2ZW50RGVmYXVsdCgpLCBpLmRlZmF1bHRQcmV2ZW50ZWQgIT09ICEwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHByZXZlbnQgZGVmYXVsdFwiKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdmFyIG4gPSBmdW5jdGlvbihyLCBhKSB7XG4gICAgICAgICAgICB2YXIgbCwgYztcbiAgICAgICAgICAgIHJldHVybiAoYSA9IGEgfHwge30pLmJ1YmJsZXMgPSAhIWEuYnViYmxlcywgYS5jYW5jZWxhYmxlID0gISFhLmNhbmNlbGFibGUsIChsID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKSkuaW5pdEN1c3RvbUV2ZW50KHIsIGEuYnViYmxlcywgYS5jYW5jZWxhYmxlLCBhLmRldGFpbCksIGMgPSBsLnByZXZlbnREZWZhdWx0LCBsLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGMuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0UHJldmVudGVkXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSAhMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG4ucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZSwgd2luZG93LkN1c3RvbUV2ZW50ID0gbjtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gIH0sIDM3OTogKGksIG4sIG8pID0+IHtcbiAgICB2YXIgciwgYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB7fTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihFKSB7XG4gICAgICAgIGlmICh2W0VdID09PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgQSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoRSk7XG4gICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBBIGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgQSA9IEEuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgQSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgdltFXSA9IEE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZbRV07XG4gICAgICB9O1xuICAgIH0oKSwgbCA9IFtdO1xuICAgIGZ1bmN0aW9uIGModikge1xuICAgICAgZm9yICh2YXIgRSA9IC0xLCBBID0gMDsgQSA8IGwubGVuZ3RoOyBBKyspXG4gICAgICAgIGlmIChsW0FdLmlkZW50aWZpZXIgPT09IHYpIHtcbiAgICAgICAgICBFID0gQTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIEU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQodiwgRSkge1xuICAgICAgZm9yICh2YXIgQSA9IHt9LCB5ID0gW10sIFMgPSAwOyBTIDwgdi5sZW5ndGg7IFMrKykge1xuICAgICAgICB2YXIgTyA9IHZbU10sIGsgPSBFLmJhc2UgPyBPWzBdICsgRS5iYXNlIDogT1swXSwgRCA9IEFba10gfHwgMCwgeCA9IFwiXCIuY29uY2F0KGssIFwiIFwiKS5jb25jYXQoRCk7XG4gICAgICAgIEFba10gPSBEICsgMTtcbiAgICAgICAgdmFyICQgPSBjKHgpLCBQID0geyBjc3M6IE9bMV0sIG1lZGlhOiBPWzJdLCBzb3VyY2VNYXA6IE9bM10gfTtcbiAgICAgICAgJCAhPT0gLTEgPyAobFskXS5yZWZlcmVuY2VzKyssIGxbJF0udXBkYXRlcihQKSkgOiBsLnB1c2goeyBpZGVudGlmaWVyOiB4LCB1cGRhdGVyOiB3KFAsIEUpLCByZWZlcmVuY2VzOiAxIH0pLCB5LnB1c2goeCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gXyh2KSB7XG4gICAgICB2YXIgRSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSwgQSA9IHYuYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgIGlmIChBLm5vbmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgdmFyIHkgPSBvLm5jO1xuICAgICAgICB5ICYmIChBLm5vbmNlID0geSk7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMoQSkuZm9yRWFjaChmdW5jdGlvbihPKSB7XG4gICAgICAgIEUuc2V0QXR0cmlidXRlKE8sIEFbT10pO1xuICAgICAgfSksIHR5cGVvZiB2Lmluc2VydCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHYuaW5zZXJ0KEUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBTID0gYSh2Lmluc2VydCB8fCBcImhlYWRcIik7XG4gICAgICAgIGlmICghUylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgICAgICBTLmFwcGVuZENoaWxkKEUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEU7XG4gICAgfVxuICAgIHZhciBmLCBtID0gKGYgPSBbXSwgZnVuY3Rpb24odiwgRSkge1xuICAgICAgcmV0dXJuIGZbdl0gPSBFLCBmLmZpbHRlcihCb29sZWFuKS5qb2luKGBcbmApO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGcodiwgRSwgQSwgeSkge1xuICAgICAgdmFyIFMgPSBBID8gXCJcIiA6IHkubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQoeS5tZWRpYSwgXCIge1wiKS5jb25jYXQoeS5jc3MsIFwifVwiKSA6IHkuY3NzO1xuICAgICAgaWYgKHYuc3R5bGVTaGVldClcbiAgICAgICAgdi5zdHlsZVNoZWV0LmNzc1RleHQgPSBtKEUsIFMpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBPID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoUyksIGsgPSB2LmNoaWxkTm9kZXM7XG4gICAgICAgIGtbRV0gJiYgdi5yZW1vdmVDaGlsZChrW0VdKSwgay5sZW5ndGggPyB2Lmluc2VydEJlZm9yZShPLCBrW0VdKSA6IHYuYXBwZW5kQ2hpbGQoTyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGIodiwgRSwgQSkge1xuICAgICAgdmFyIHkgPSBBLmNzcywgUyA9IEEubWVkaWEsIE8gPSBBLnNvdXJjZU1hcDtcbiAgICAgIGlmIChTID8gdi5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBTKSA6IHYucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIiksIE8gJiYgdHlwZW9mIGJ0b2EgPCBcInVcIiAmJiAoeSArPSBgXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGAuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KE8pKSkpLCBcIiAqL1wiKSksIHYuc3R5bGVTaGVldClcbiAgICAgICAgdi5zdHlsZVNoZWV0LmNzc1RleHQgPSB5O1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoOyB2LmZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICB2LnJlbW92ZUNoaWxkKHYuZmlyc3RDaGlsZCk7XG4gICAgICAgIHYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoeSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgVCA9IG51bGwsIEMgPSAwO1xuICAgIGZ1bmN0aW9uIHcodiwgRSkge1xuICAgICAgdmFyIEEsIHksIFM7XG4gICAgICBpZiAoRS5zaW5nbGV0b24pIHtcbiAgICAgICAgdmFyIE8gPSBDKys7XG4gICAgICAgIEEgPSBUIHx8IChUID0gXyhFKSksIHkgPSBnLmJpbmQobnVsbCwgQSwgTywgITEpLCBTID0gZy5iaW5kKG51bGwsIEEsIE8sICEwKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBBID0gXyhFKSwgeSA9IGIuYmluZChudWxsLCBBLCBFKSwgUyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICBpZiAoay5wYXJlbnROb2RlID09PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICBrLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoayk7XG4gICAgICAgICAgfSkoQSk7XG4gICAgICAgIH07XG4gICAgICByZXR1cm4geSh2KSwgZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoaykge1xuICAgICAgICAgIGlmIChrLmNzcyA9PT0gdi5jc3MgJiYgay5tZWRpYSA9PT0gdi5tZWRpYSAmJiBrLnNvdXJjZU1hcCA9PT0gdi5zb3VyY2VNYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgeSh2ID0gayk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIFMoKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGkuZXhwb3J0cyA9IGZ1bmN0aW9uKHYsIEUpIHtcbiAgICAgIChFID0gRSB8fCB7fSkuc2luZ2xldG9uIHx8IHR5cGVvZiBFLnNpbmdsZXRvbiA9PSBcImJvb2xlYW5cIiB8fCAoRS5zaW5nbGV0b24gPSAociA9PT0gdm9pZCAwICYmIChyID0gISEod2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpKSwgcikpO1xuICAgICAgdmFyIEEgPSBkKHYgPSB2IHx8IFtdLCBFKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICAgIGlmICh5ID0geSB8fCBbXSwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHkpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBTID0gMDsgUyA8IEEubGVuZ3RoOyBTKyspIHtcbiAgICAgICAgICAgIHZhciBPID0gYyhBW1NdKTtcbiAgICAgICAgICAgIGxbT10ucmVmZXJlbmNlcy0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBrID0gZCh5LCBFKSwgRCA9IDA7IEQgPCBBLmxlbmd0aDsgRCsrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGMoQVtEXSk7XG4gICAgICAgICAgICBsW3hdLnJlZmVyZW5jZXMgPT09IDAgJiYgKGxbeF0udXBkYXRlcigpLCBsLnNwbGljZSh4LCAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEEgPSBrO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH0gfSwgdCA9IHt9O1xuICBmdW5jdGlvbiBlKGkpIHtcbiAgICB2YXIgbiA9IHRbaV07XG4gICAgaWYgKG4gIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBuLmV4cG9ydHM7XG4gICAgdmFyIG8gPSB0W2ldID0geyBpZDogaSwgZXhwb3J0czoge30gfTtcbiAgICByZXR1cm4gc1tpXShvLCBvLmV4cG9ydHMsIGUpLCBvLmV4cG9ydHM7XG4gIH1cbiAgZS5uID0gKGkpID0+IHtcbiAgICB2YXIgbiA9IGkgJiYgaS5fX2VzTW9kdWxlID8gKCkgPT4gaS5kZWZhdWx0IDogKCkgPT4gaTtcbiAgICByZXR1cm4gZS5kKG4sIHsgYTogbiB9KSwgbjtcbiAgfSwgZS5kID0gKGksIG4pID0+IHtcbiAgICBmb3IgKHZhciBvIGluIG4pXG4gICAgICBlLm8obiwgbykgJiYgIWUubyhpLCBvKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgbywgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBuW29dIH0pO1xuICB9LCBlLm8gPSAoaSwgbikgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksIG4pLCAoKCkgPT4ge1xuICAgIHZhciBpID0gZSgzNzkpLCBuID0gZS5uKGkpLCBvID0gZSg0NTQpO1xuICAgIGZ1bmN0aW9uIHIobCkge1xuICAgICAgaWYgKCFsLmhhc0F0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIikpIHtcbiAgICAgICAgbC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIsIFwiXCIpO1xuICAgICAgICB2YXIgYyA9IG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoXCJvbmF1dG9jb21wbGV0ZVwiLCB7IGJ1YmJsZXM6ICEwLCBjYW5jZWxhYmxlOiAhMCwgZGV0YWlsOiBudWxsIH0pO1xuICAgICAgICBsLmRpc3BhdGNoRXZlbnQoYykgfHwgKGwudmFsdWUgPSBcIlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYShsKSB7XG4gICAgICBsLmhhc0F0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIikgJiYgKGwucmVtb3ZlQXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiKSwgbC5kaXNwYXRjaEV2ZW50KG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoXCJvbmF1dG9jb21wbGV0ZVwiLCB7IGJ1YmJsZXM6ICEwLCBjYW5jZWxhYmxlOiAhMSwgZGV0YWlsOiBudWxsIH0pKSk7XG4gICAgfVxuICAgIG4oKShvLlosIHsgaW5zZXJ0OiBcImhlYWRcIiwgc2luZ2xldG9uOiAhMSB9KSwgby5aLmxvY2FscywgZSg4MTApLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uc3RhcnRcIiwgZnVuY3Rpb24obCkge1xuICAgICAgbC5hbmltYXRpb25OYW1lID09PSBcIm9uYXV0b2ZpbGxzdGFydFwiID8gcihsLnRhcmdldCkgOiBhKGwudGFyZ2V0KTtcbiAgICB9LCAhMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbihsKSB7XG4gICAgICBsLmlucHV0VHlwZSAhPT0gXCJpbnNlcnRSZXBsYWNlbWVudFRleHRcIiAmJiBcImRhdGFcIiBpbiBsID8gYShsLnRhcmdldCkgOiByKGwudGFyZ2V0KTtcbiAgICB9LCAhMCk7XG4gIH0pKCk7XG59KSgpO1xuY29uc3QgbG4gPSBcImlucHV0XCIsIE5pID0gXCJ0ZS5pbnB1dFwiLCB1bCA9IFwiZGF0YS10ZS1pbnB1dC13cmFwcGVyLWluaXRcIiwgcGwgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtcmVmXCIsIGZsID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLWxlYWRpbmctcmVmXCIsIF9sID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLW1pZGRsZS1yZWZcIiwgcnAgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtdHJhaWxpbmctcmVmXCIsIGFwID0gXCJkYXRhLXRlLWlucHV0LWhlbHBlci1yZWZcIiwgbHAgPSBcImRhdGEtdGUtaW5wdXQtcGxhY2Vob2xkZXItYWN0aXZlXCIsIEh0ID0gXCJkYXRhLXRlLWlucHV0LXN0YXRlLWFjdGl2ZVwiLCBmciA9IFwiZGF0YS10ZS1pbnB1dC1mb2N1c2VkXCIsIF9yID0gXCJkYXRhLXRlLWlucHV0LWZvcm0tY291bnRlclwiLCByZSA9IGBbJHt1bH1dIGlucHV0YCwgYWUgPSBgWyR7dWx9XSB0ZXh0YXJlYWAsIEVlID0gYFske3BsfV1gLCBtciA9IGBbJHtmbH1dYCwgZ3IgPSBgWyR7X2x9XWAsIGNwID0gYFske2FwfV1gLCBkcCA9IHtcbiAgaW5wdXRGb3JtV2hpdGU6ICExXG59LCBocCA9IHtcbiAgaW5wdXRGb3JtV2hpdGU6IFwiKGJvb2xlYW4pXCJcbn0sIHVwID0ge1xuICBub3RjaDogXCJncm91cCBmbGV4IGFic29sdXRlIGxlZnQtMCB0b3AtMCB3LWZ1bGwgbWF4LXctZnVsbCBoLWZ1bGwgdGV4dC1sZWZ0IHBvaW50ZXItZXZlbnRzLW5vbmVcIixcbiAgbm90Y2hMZWFkaW5nOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBsZWZ0LTAgdG9wLTAgaC1mdWxsIHctMiBib3JkZXItci0wIHJvdW5kZWQtbC1bMC4yNXJlbV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXItMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci1yLTBcIixcbiAgbm90Y2hMZWFkaW5nTm9ybWFsOiBcImJvcmRlci1uZXV0cmFsLTMwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWy0xcHhfMF8wXyMzYjcxY2EsXzBfMXB4XzBfMF8jM2I3MWNhLF8wXy0xcHhfMF8wXyMzYjcxY2FdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCIsXG4gIG5vdGNoTGVhZGluZ1doaXRlOiBcImJvcmRlci1uZXV0cmFsLTIwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWy0xcHhfMF8wXyNmZmZmZmYsXzBfMXB4XzBfMF8jZmZmZmZmLF8wXy0xcHhfMF8wXyNmZmZmZmZdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci13aGl0ZVwiLFxuICBub3RjaE1pZGRsZTogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZ3Jvdy0wIHNocmluay0wIGJhc2lzLWF1dG8gdy1hdXRvIG1heC13LVtjYWxjKDEwMCUtMXJlbSldIGgtZnVsbCBib3JkZXItci0wIGJvcmRlci1sLTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXgtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci14LTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItdCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItc29saWQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItc29saWQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXQtdHJhbnNwYXJlbnQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItdC10cmFuc3BhcmVudFwiLFxuICBub3RjaE1pZGRsZU5vcm1hbDogXCJib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVswXzFweF8wXzBfIzNiNzFjYV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXByaW1hcnlcIixcbiAgbm90Y2hNaWRkbGVXaGl0ZTogXCJib3JkZXItbmV1dHJhbC0yMDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVswXzFweF8wXzBfI2ZmZmZmZl0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXdoaXRlXCIsXG4gIG5vdGNoVHJhaWxpbmc6IFwicG9pbnRlci1ldmVudHMtbm9uZSBib3JkZXIgYm9yZGVyLXNvbGlkIGJveC1ib3JkZXIgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGdyb3cgaC1mdWxsIGJvcmRlci1sLTAgcm91bmRlZC1yLVswLjI1cmVtXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItbC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLWwtMFwiLFxuICBub3RjaFRyYWlsaW5nTm9ybWFsOiBcImJvcmRlci1uZXV0cmFsLTMwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzFweF8wXzBfIzNiNzFjYSxfMF8tMXB4XzBfMF8jM2I3MWNhLF8wXzFweF8wXzBfIzNiNzFjYV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXByaW1hcnlcIixcbiAgbm90Y2hUcmFpbGluZ1doaXRlOiBcImJvcmRlci1uZXV0cmFsLTIwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzFweF8wXzBfI2ZmZmZmZixfMF8tMXB4XzBfMF8jZmZmZmZmLF8wXzFweF8wXzBfI2ZmZmZmZl0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXdoaXRlXCIsXG4gIGNvdW50ZXI6IFwidGV4dC1yaWdodCBsZWFkaW5nLVsxLjZdXCJcbn0sIHBwID0ge1xuICBub3RjaDogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nOiBcInN0cmluZ1wiLFxuICBub3RjaExlYWRpbmdOb3JtYWw6IFwic3RyaW5nXCIsXG4gIG5vdGNoTGVhZGluZ1doaXRlOiBcInN0cmluZ1wiLFxuICBub3RjaE1pZGRsZTogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGVOb3JtYWw6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlV2hpdGU6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmc6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmdOb3JtYWw6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmdXaGl0ZTogXCJzdHJpbmdcIixcbiAgY291bnRlcjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFYge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUsIHQpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2xhYmVsID0gbnVsbCwgdGhpcy5fbGFiZWxXaWR0aCA9IDAsIHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IDAsIHRoaXMuX25vdGNoTGVhZGluZyA9IG51bGwsIHRoaXMuX25vdGNoTWlkZGxlID0gbnVsbCwgdGhpcy5fbm90Y2hUcmFpbGluZyA9IG51bGwsIHRoaXMuX2luaXRpYXRlZCA9ICExLCB0aGlzLl9oZWxwZXIgPSBudWxsLCB0aGlzLl9jb3VudGVyID0gITEsIHRoaXMuX2NvdW50ZXJFbGVtZW50ID0gbnVsbCwgdGhpcy5fbWF4TGVuZ3RoID0gMCwgdGhpcy5fbGVhZGluZ0ljb24gPSBudWxsLCB0aGlzLl9lbGVtZW50ICYmIChJLnNldERhdGEodCwgTmksIHRoaXMpLCB0aGlzLmluaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGxuO1xuICB9XG4gIGdldCBpbnB1dCgpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCkgfHwgaC5maW5kT25lKFwidGV4dGFyZWFcIiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgdGhpcy5faW5pdGlhdGVkIHx8ICh0aGlzLl9nZXRMYWJlbERhdGEoKSwgdGhpcy5fYXBwbHlEaXZzKCksIHRoaXMuX2FwcGx5Tm90Y2goKSwgdGhpcy5fYWN0aXZhdGUoKSwgdGhpcy5fZ2V0SGVscGVyKCksIHRoaXMuX2dldENvdW50ZXIoKSwgdGhpcy5fZ2V0RXZlbnRzKCksIHRoaXMuX2luaXRpYXRlZCA9ICEwKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fZ2V0TGFiZWxEYXRhKCksIHRoaXMuX2dldE5vdGNoRGF0YSgpLCB0aGlzLl9hcHBseU5vdGNoKCksIHRoaXMuX2FjdGl2YXRlKCksIHRoaXMuX2dldEhlbHBlcigpLCB0aGlzLl9nZXRDb3VudGVyKCk7XG4gIH1cbiAgZm9yY2VBY3RpdmUoKSB7XG4gICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoSHQsIFwiXCIpLCBoLmZpbmRPbmUoRWUsIHRoaXMuaW5wdXQucGFyZW50Tm9kZSkuc2V0QXR0cmlidXRlKFxuICAgICAgSHQsXG4gICAgICBcIlwiXG4gICAgKTtcbiAgfVxuICBmb3JjZUluYWN0aXZlKCkge1xuICAgIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKEh0KSwgaC5maW5kT25lKFxuICAgICAgRWUsXG4gICAgICB0aGlzLmlucHV0LnBhcmVudE5vZGVcbiAgICApLnJlbW92ZUF0dHJpYnV0ZShIdCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9yZW1vdmVCb3JkZXIoKSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIE5pKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q29uZmlnKHQsIGUpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmRwLFxuICAgICAgLi4ucC5nZXREYXRhQXR0cmlidXRlcyhlKSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCBOKGxuLCB0LCBocCksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi51cCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTihsbiwgdCwgcHApLCB0O1xuICB9XG4gIF9nZXRMYWJlbERhdGEoKSB7XG4gICAgdGhpcy5fbGFiZWwgPSBoLmZpbmRPbmUoXCJsYWJlbFwiLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fbGFiZWwgPT09IG51bGwgPyB0aGlzLl9zaG93UGxhY2Vob2xkZXIoKSA6ICh0aGlzLl9nZXRMYWJlbFdpZHRoKCksIHRoaXMuX2dldExhYmVsUG9zaXRpb25JbklucHV0R3JvdXAoKSwgdGhpcy5fdG9nZ2xlRGVmYXVsdERhdGVQbGFjZWhvbGRlcigpKTtcbiAgfVxuICBfZ2V0SGVscGVyKCkge1xuICAgIHRoaXMuX2hlbHBlciA9IGguZmluZE9uZShjcCwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX2dldENvdW50ZXIoKSB7XG4gICAgdGhpcy5fY291bnRlciA9IHAuZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgIHRoaXMuaW5wdXQsXG4gICAgICBcImlucHV0U2hvd2NvdW50ZXJcIlxuICAgICksIHRoaXMuX2NvdW50ZXIgJiYgKHRoaXMuX21heExlbmd0aCA9IHRoaXMuaW5wdXQubWF4TGVuZ3RoLCB0aGlzLl9zaG93Q291bnRlcigpKTtcbiAgfVxuICBfZ2V0RXZlbnRzKCkge1xuICAgIHUub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgIHJlLFxuICAgICAgVi5hY3RpdmF0ZShuZXcgVigpKVxuICAgICksIHUub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIHJlLFxuICAgICAgVi5hY3RpdmF0ZShuZXcgVigpKVxuICAgICksIHUub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiYmx1clwiLFxuICAgICAgcmUsXG4gICAgICBWLmRlYWN0aXZhdGUobmV3IFYoKSlcbiAgICApLCB1Lm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImZvY3VzXCIsXG4gICAgICBhZSxcbiAgICAgIFYuYWN0aXZhdGUobmV3IFYoKSlcbiAgICApLCB1Lm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImlucHV0XCIsXG4gICAgICBhZSxcbiAgICAgIFYuYWN0aXZhdGUobmV3IFYoKSlcbiAgICApLCB1Lm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImJsdXJcIixcbiAgICAgIGFlLFxuICAgICAgVi5kZWFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgdS5vbih3aW5kb3csIFwic2hvd24udGUubW9kYWxcIiwgKHQpID0+IHtcbiAgICAgIGguZmluZChyZSwgdC50YXJnZXQpLmZvckVhY2goXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IFYuZ2V0SW5zdGFuY2UoZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBpICYmIGkudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICksIGguZmluZChhZSwgdC50YXJnZXQpLmZvckVhY2goXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IFYuZ2V0SW5zdGFuY2UoZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBpICYmIGkudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSksIHUub24od2luZG93LCBcInNob3duLnRlLmRyb3Bkb3duXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC50YXJnZXQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBcIltkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXVwiXG4gICAgICApO1xuICAgICAgZSAmJiAoaC5maW5kKHJlLCBlKS5mb3JFYWNoKFxuICAgICAgICAoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG4gPSBWLmdldEluc3RhbmNlKGkucGFyZW50Tm9kZSk7XG4gICAgICAgICAgbiAmJiBuLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApLCBoLmZpbmQoYWUsIGUpLmZvckVhY2goXG4gICAgICAgIChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbiA9IFYuZ2V0SW5zdGFuY2UoaS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBuICYmIG4udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgIH0pLCB1Lm9uKHdpbmRvdywgXCJzaG93bi50ZS50YWJcIiwgKHQpID0+IHtcbiAgICAgIGxldCBlO1xuICAgICAgdC50YXJnZXQuaHJlZiA/IGUgPSB0LnRhcmdldC5ocmVmLnNwbGl0KFwiI1wiKVsxXSA6IGUgPSBwLmdldERhdGFBdHRyaWJ1dGUodC50YXJnZXQsIFwidGFyZ2V0XCIpLnNwbGl0KFxuICAgICAgICBcIiNcIlxuICAgICAgKVsxXTtcbiAgICAgIGNvbnN0IGkgPSBoLmZpbmRPbmUoYCMke2V9YCk7XG4gICAgICBoLmZpbmQocmUsIGkpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgY29uc3QgbyA9IFYuZ2V0SW5zdGFuY2Uobi5wYXJlbnROb2RlKTtcbiAgICAgICAgbyAmJiBvLnVwZGF0ZSgpO1xuICAgICAgfSksIGguZmluZChhZSwgaSkuZm9yRWFjaChcbiAgICAgICAgKG4pID0+IHtcbiAgICAgICAgICBjb25zdCBvID0gVi5nZXRJbnN0YW5jZShuLnBhcmVudE5vZGUpO1xuICAgICAgICAgIG8gJiYgby51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KSwgdS5vbih3aW5kb3csIFwicmVzZXRcIiwgKHQpID0+IHtcbiAgICAgIGguZmluZChyZSwgdC50YXJnZXQpLmZvckVhY2goXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IFYuZ2V0SW5zdGFuY2UoZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBpICYmIGkuZm9yY2VJbmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICApLCBoLmZpbmQoYWUsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBWLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaSAmJiBpLmZvcmNlSW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KSwgdS5vbih3aW5kb3csIFwib25hdXRvY29tcGxldGVcIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBWLmdldEluc3RhbmNlKHQudGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgIWUgfHwgIXQuY2FuY2VsYWJsZSB8fCBlLmZvcmNlQWN0aXZlKCk7XG4gICAgfSk7XG4gIH1cbiAgX3Nob3dDb3VudGVyKCkge1xuICAgIGlmIChoLmZpbmQoXG4gICAgICBgWyR7X3J9XWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKS5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NvdW50ZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgcC5hZGRDbGFzcyh0aGlzLl9jb3VudGVyRWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5jb3VudGVyKSwgdGhpcy5fY291bnRlckVsZW1lbnQuc2V0QXR0cmlidXRlKF9yLCBcIlwiKTtcbiAgICBjb25zdCBlID0gdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGg7XG4gICAgdGhpcy5fY291bnRlckVsZW1lbnQuaW5uZXJIVE1MID0gYCR7ZX0gLyAke3RoaXMuX21heExlbmd0aH1gLCB0aGlzLl9oZWxwZXIuYXBwZW5kQ2hpbGQodGhpcy5fY291bnRlckVsZW1lbnQpLCB0aGlzLl9iaW5kQ291bnRlcigpO1xuICB9XG4gIF9iaW5kQ291bnRlcigpIHtcbiAgICB1Lm9uKHRoaXMuaW5wdXQsIFwiaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoO1xuICAgICAgdGhpcy5fY291bnRlckVsZW1lbnQuaW5uZXJIVE1MID0gYCR7dH0gLyAke3RoaXMuX21heExlbmd0aH1gO1xuICAgIH0pO1xuICB9XG4gIF90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKHQgPSB0aGlzLmlucHV0KSB7XG4gICAgaWYgKCEodC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09PSBcImRhdGVcIikpXG4gICAgICByZXR1cm47XG4gICAgIShkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0KSAmJiAhdC52YWx1ZSA/IHQuc3R5bGUub3BhY2l0eSA9IDAgOiB0LnN0eWxlLm9wYWNpdHkgPSAxO1xuICB9XG4gIF9zaG93UGxhY2Vob2xkZXIoKSB7XG4gICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUobHAsIFwiXCIpO1xuICB9XG4gIF9nZXROb3RjaERhdGEoKSB7XG4gICAgdGhpcy5fbm90Y2hNaWRkbGUgPSBoLmZpbmRPbmUoXG4gICAgICBncixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBoLmZpbmRPbmUoXG4gICAgICBtcixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICB9XG4gIF9nZXRMYWJlbFdpZHRoKCkge1xuICAgIHRoaXMuX2xhYmVsV2lkdGggPSB0aGlzLl9sYWJlbC5jbGllbnRXaWR0aCAqIDAuOCArIDg7XG4gIH1cbiAgX2dldExhYmVsUG9zaXRpb25JbklucHV0R3JvdXAoKSB7XG4gICAgaWYgKHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IDAsICF0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtdGUtaW5wdXQtZ3JvdXAtcmVmXCIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB0aGlzLmlucHV0LCBlID0gaC5wcmV2KFxuICAgICAgdCxcbiAgICAgIFwiW2RhdGEtdGUtaW5wdXQtZ3JvdXAtdGV4dC1yZWZdXCJcbiAgICApWzBdO1xuICAgIGUgPT09IHZvaWQgMCA/IHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IDAgOiB0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSBlLm9mZnNldFdpZHRoIC0gMTtcbiAgfVxuICBfYXBwbHlEaXZzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuaW5wdXRGb3JtV2hpdGUgPyB0aGlzLl9jbGFzc2VzLm5vdGNoTGVhZGluZ1doaXRlIDogdGhpcy5fY2xhc3Nlcy5ub3RjaExlYWRpbmdOb3JtYWwsIGUgPSB0aGlzLl9jb25maWcuaW5wdXRGb3JtV2hpdGUgPyB0aGlzLl9jbGFzc2VzLm5vdGNoTWlkZGxlV2hpdGUgOiB0aGlzLl9jbGFzc2VzLm5vdGNoTWlkZGxlTm9ybWFsLCBpID0gdGhpcy5fY29uZmlnLmlucHV0Rm9ybVdoaXRlID8gdGhpcy5fY2xhc3Nlcy5ub3RjaFRyYWlsaW5nV2hpdGUgOiB0aGlzLl9jbGFzc2VzLm5vdGNoVHJhaWxpbmdOb3JtYWwsIG4gPSBoLmZpbmQoRWUsIHRoaXMuX2VsZW1lbnQpLCBvID0gTShcImRpdlwiKTtcbiAgICBwLmFkZENsYXNzKG8sIHRoaXMuX2NsYXNzZXMubm90Y2gpLCBvLnNldEF0dHJpYnV0ZShwbCwgXCJcIiksIHRoaXMuX25vdGNoTGVhZGluZyA9IE0oXCJkaXZcIiksIHAuYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9ub3RjaExlYWRpbmcsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLm5vdGNoTGVhZGluZ30gJHt0fWBcbiAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcuc2V0QXR0cmlidXRlKGZsLCBcIlwiKSwgdGhpcy5fbm90Y2hNaWRkbGUgPSBNKFwiZGl2XCIpLCBwLmFkZENsYXNzKFxuICAgICAgdGhpcy5fbm90Y2hNaWRkbGUsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLm5vdGNoTWlkZGxlfSAke2V9YFxuICAgICksIHRoaXMuX25vdGNoTWlkZGxlLnNldEF0dHJpYnV0ZShfbCwgXCJcIiksIHRoaXMuX25vdGNoVHJhaWxpbmcgPSBNKFwiZGl2XCIpLCBwLmFkZENsYXNzKFxuICAgICAgdGhpcy5fbm90Y2hUcmFpbGluZyxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubm90Y2hUcmFpbGluZ30gJHtpfWBcbiAgICApLCB0aGlzLl9ub3RjaFRyYWlsaW5nLnNldEF0dHJpYnV0ZShycCwgXCJcIiksICEobi5sZW5ndGggPj0gMSkgJiYgKG8uYXBwZW5kKHRoaXMuX25vdGNoTGVhZGluZyksIG8uYXBwZW5kKHRoaXMuX25vdGNoTWlkZGxlKSwgby5hcHBlbmQodGhpcy5fbm90Y2hUcmFpbGluZyksIHRoaXMuX2VsZW1lbnQuYXBwZW5kKG8pKTtcbiAgfVxuICBfYXBwbHlOb3RjaCgpIHtcbiAgICB0aGlzLl9ub3RjaE1pZGRsZS5zdHlsZS53aWR0aCA9IGAke3RoaXMuX2xhYmVsV2lkdGh9cHhgLCB0aGlzLl9ub3RjaExlYWRpbmcuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9sYWJlbE1hcmdpbkxlZnQgKyA5fXB4YCwgdGhpcy5fbGFiZWwgIT09IG51bGwgJiYgKHRoaXMuX2xhYmVsLnN0eWxlLm1hcmdpbkxlZnQgPSBgJHt0aGlzLl9sYWJlbE1hcmdpbkxlZnR9cHhgKTtcbiAgfVxuICBfcmVtb3ZlQm9yZGVyKCkge1xuICAgIGNvbnN0IHQgPSBoLmZpbmRPbmUoRWUsIHRoaXMuX2VsZW1lbnQpO1xuICAgIHQgJiYgdC5yZW1vdmUoKTtcbiAgfVxuICBfYWN0aXZhdGUodCkge1xuICAgIEFhKCgpID0+IHtcbiAgICAgIHRoaXMuX2dldEVsZW1lbnRzKHQpO1xuICAgICAgY29uc3QgZSA9IHQgPyB0LnRhcmdldCA6IHRoaXMuaW5wdXQsIGkgPSBoLmZpbmRPbmUoXG4gICAgICAgIEVlLFxuICAgICAgICB0aGlzLl9lbGVtZW50XG4gICAgICApO1xuICAgICAgdCAmJiB0LnR5cGUgPT09IFwiZm9jdXNcIiAmJiBpLnNldEF0dHJpYnV0ZShmciwgXCJcIiksIGUudmFsdWUgIT09IFwiXCIgJiYgKGUuc2V0QXR0cmlidXRlKEh0LCBcIlwiKSwgaS5zZXRBdHRyaWJ1dGUoSHQsIFwiXCIpKSwgdGhpcy5fdG9nZ2xlRGVmYXVsdERhdGVQbGFjZWhvbGRlcihlKTtcbiAgICB9KTtcbiAgfVxuICBfZ2V0RWxlbWVudHModCkge1xuICAgIGlmICh0ICYmICh0aGlzLl9lbGVtZW50ID0gdC50YXJnZXQucGFyZW50Tm9kZSwgdGhpcy5fbGFiZWwgPSBoLmZpbmRPbmUoXCJsYWJlbFwiLCB0aGlzLl9lbGVtZW50KSksIHQgJiYgdGhpcy5fbGFiZWwpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9sYWJlbFdpZHRoO1xuICAgICAgdGhpcy5fZ2V0TGFiZWxEYXRhKCksIGUgIT09IHRoaXMuX2xhYmVsV2lkdGggJiYgKHRoaXMuX25vdGNoTWlkZGxlID0gaC5maW5kT25lKFxuICAgICAgICBncixcbiAgICAgICAgdC50YXJnZXQucGFyZW50Tm9kZVxuICAgICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gaC5maW5kT25lKFxuICAgICAgICBtcixcbiAgICAgICAgdC50YXJnZXQucGFyZW50Tm9kZVxuICAgICAgKSwgdGhpcy5fYXBwbHlOb3RjaCgpKTtcbiAgICB9XG4gIH1cbiAgX2RlYWN0aXZhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0ID8gdC50YXJnZXQgOiB0aGlzLmlucHV0LCBpID0gaC5maW5kT25lKFxuICAgICAgRWUsXG4gICAgICBlLnBhcmVudE5vZGVcbiAgICApO1xuICAgIGkucmVtb3ZlQXR0cmlidXRlKGZyKSwgZS52YWx1ZSA9PT0gXCJcIiAmJiAoZS5yZW1vdmVBdHRyaWJ1dGUoSHQpLCBpLnJlbW92ZUF0dHJpYnV0ZShIdCkpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKGUpO1xuICB9XG4gIHN0YXRpYyBhY3RpdmF0ZSh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHQuX2FjdGl2YXRlKGUpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlYWN0aXZhdGUodCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB0Ll9kZWFjdGl2YXRlKGUpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gSS5nZXREYXRhKHRoaXMsIE5pKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgVih0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YSh0LCBOaSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgYnIgPSBcImFuaW1hdGlvblwiLCBjbiA9IFwidGUuYW5pbWF0aW9uXCIsIGZwID0ge1xuICBhbmltYXRpb246IFwic3RyaW5nXCIsXG4gIGFuaW1hdGlvblN0YXJ0OiBcInN0cmluZ1wiLFxuICBhbmltYXRpb25TaG93T25Mb2FkOiBcImJvb2xlYW5cIixcbiAgb25TdGFydDogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgb25FbmQ6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIG9uSGlkZTogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgb25TaG93OiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBhbmltYXRpb25PblNjcm9sbDogXCIoc3RyaW5nKVwiLFxuICBhbmltYXRpb25XaW5kb3dIZWlnaHQ6IFwibnVtYmVyXCIsXG4gIGFuaW1hdGlvbk9mZnNldDogXCIobnVtYmVyfHN0cmluZylcIixcbiAgYW5pbWF0aW9uRGVsYXk6IFwiKG51bWJlcnxzdHJpbmcpXCIsXG4gIGFuaW1hdGlvblJldmVyc2U6IFwiYm9vbGVhblwiLFxuICBhbmltYXRpb25JbnRlcnZhbDogXCIobnVtYmVyfHN0cmluZylcIixcbiAgYW5pbWF0aW9uUmVwZWF0OiBcIihudW1iZXJ8Ym9vbGVhbilcIixcbiAgYW5pbWF0aW9uUmVzZXQ6IFwiYm9vbGVhblwiXG59LCBfcCA9IHtcbiAgYW5pbWF0aW9uOiBcImZhZGVcIixcbiAgYW5pbWF0aW9uU3RhcnQ6IFwib25DbGlja1wiLFxuICBhbmltYXRpb25TaG93T25Mb2FkOiAhMCxcbiAgb25TdGFydDogbnVsbCxcbiAgb25FbmQ6IG51bGwsXG4gIG9uSGlkZTogbnVsbCxcbiAgb25TaG93OiBudWxsLFxuICBhbmltYXRpb25PblNjcm9sbDogXCJvbmNlXCIsXG4gIGFuaW1hdGlvbldpbmRvd0hlaWdodDogMCxcbiAgYW5pbWF0aW9uT2Zmc2V0OiAwLFxuICBhbmltYXRpb25EZWxheTogMCxcbiAgYW5pbWF0aW9uUmV2ZXJzZTogITEsXG4gIGFuaW1hdGlvbkludGVydmFsOiAwLFxuICBhbmltYXRpb25SZXBlYXQ6ICExLFxuICBhbmltYXRpb25SZXNldDogITFcbn07XG5jbGFzcyBtbCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fYW5pbWF0ZUVsZW1lbnQgPSB0aGlzLl9nZXRBbmltYXRlRWxlbWVudCgpLCB0aGlzLl9pc0ZpcnN0U2Nyb2xsID0gITAsIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCA9ICEwLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9lbGVtZW50ICYmIChJLnNldERhdGEodCwgY24sIHRoaXMpLCB0aGlzLl9pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBicjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cbiAgc3RhcnRBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgfVxuICBzdG9wQW5pbWF0aW9uKCkge1xuICAgIHRoaXMuX2NsZWFyQW5pbWF0aW9uQ2xhc3MoKTtcbiAgfVxuICBjaGFuZ2VBbmltYXRpb25UeXBlKHQpIHtcbiAgICB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbiA9IHQ7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB1Lm9mZih0aGlzLl9lbGVtZW50LCBcIm1vdXNlZG93blwiKSwgdS5vZmYodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIpLCB1Lm9mZih3aW5kb3csIFwic2Nyb2xsXCIpLCB1Lm9mZih0aGlzLl9lbGVtZW50LCBcIm1vdXNlb3ZlclwiKSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGNuKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX2FuaW1hdGVFbGVtZW50ID0gbnVsbCwgdGhpcy5faXNGaXJzdFNjcm9sbCA9IG51bGwsIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLmFuaW1hdGlvblN0YXJ0KSB7XG4gICAgICBjYXNlIFwib25Ib3ZlclwiOlxuICAgICAgICB0aGlzLl9iaW5kSG92ZXJFdmVudHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib25Mb2FkXCI6XG4gICAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm9uU2Nyb2xsXCI6XG4gICAgICAgIHRoaXMuX2JpbmRTY3JvbGxFdmVudHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib25DbGlja1wiOlxuICAgICAgICB0aGlzLl9iaW5kQ2xpY2tFdmVudHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX2JpbmRUcmlnZ2VyT25FbmRDYWxsYmFjaygpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJlc2V0ICYmIHRoaXMuX2JpbmRSZXNldEFuaW1hdGlvbkFmdGVyRmluaXNoKCk7XG4gIH1cbiAgX2dldEFuaW1hdGVFbGVtZW50KCkge1xuICAgIGNvbnN0IHQgPSBwLmdldERhdGFBdHRyaWJ1dGUoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJhbmltYXRpb24tdGFyZ2V0XCJcbiAgICApO1xuICAgIHJldHVybiB0ID8gaC5maW5kKHQpWzBdIDogdGhpcy5fZWxlbWVudDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9hbmltYXRlRWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5fcCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTihiciwgdCwgZnApLCB0O1xuICB9XG4gIF9hbmltYXRlT25TY3JvbGwoKSB7XG4gICAgY29uc3QgdCA9IHAub2Zmc2V0KHRoaXMuX2FuaW1hdGVFbGVtZW50KS50b3AsIGUgPSB0aGlzLl9hbmltYXRlRWxlbWVudC5vZmZzZXRIZWlnaHQsIGkgPSB3aW5kb3cuaW5uZXJIZWlnaHQsIG4gPSB0ICsgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25PZmZzZXQgPD0gaSAmJiB0ICsgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25PZmZzZXQgKyBlID49IDAsIG8gPSB0aGlzLl9hbmltYXRlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID09PSBcInZpc2libGVcIjtcbiAgICBzd2l0Y2ggKCEwKSB7XG4gICAgICBjYXNlIChuICYmIHRoaXMuX2lzRmlyc3RTY3JvbGwpOlxuICAgICAgICB0aGlzLl9pc0ZpcnN0U2Nyb2xsID0gITEsIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAoIW4gJiYgdGhpcy5faXNGaXJzdFNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMSwgdGhpcy5faGlkZUFuaW1hdGVFbGVtZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAobiAmJiAhbyAmJiB0aGlzLl9yZXBlYXRBbmltYXRlT25TY3JvbGwpOlxuICAgICAgICB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9uU2Nyb2xsICE9PSBcInJlcGVhdFwiICYmICh0aGlzLl9yZXBlYXRBbmltYXRlT25TY3JvbGwgPSAhMSksIHRoaXMuX2NhbGxiYWNrKHRoaXMuX29wdGlvbnMub25TaG93KSwgdGhpcy5fc2hvd0FuaW1hdGVFbGVtZW50KCksIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAoIW4gJiYgbyAmJiB0aGlzLl9yZXBlYXRBbmltYXRlT25TY3JvbGwpOlxuICAgICAgICB0aGlzLl9oaWRlQW5pbWF0ZUVsZW1lbnQoKSwgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpLCB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uSGlkZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfYWRkQW5pbWF0ZWRDbGFzcygpIHtcbiAgICBwLmFkZENsYXNzKFxuICAgICAgdGhpcy5fYW5pbWF0ZUVsZW1lbnQsXG4gICAgICBgYW5pbWF0ZS0ke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9ufWBcbiAgICApO1xuICB9XG4gIF9jbGVhckFuaW1hdGlvbkNsYXNzKCkge1xuICAgIHRoaXMuX2FuaW1hdGVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoYGFuaW1hdGUtJHt0aGlzLl9vcHRpb25zLmFuaW1hdGlvbn1gKTtcbiAgfVxuICBfc3RhcnRBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sodGhpcy5fb3B0aW9ucy5vblN0YXJ0KSwgdGhpcy5fYWRkQW5pbWF0ZWRDbGFzcygpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJlcGVhdCAmJiAhdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCAmJiB0aGlzLl9zZXRBbmltYXRpb25SZXBlYXQoKSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXZlcnNlICYmIHRoaXMuX3NldEFuaW1hdGlvblJldmVyc2UoKSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25EZWxheSAmJiB0aGlzLl9zZXRBbmltYXRpb25EZWxheSgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uICYmIHRoaXMuX3NldEFuaW1hdGlvbkR1cmF0aW9uKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uSW50ZXJ2YWwgJiYgdGhpcy5fc2V0QW5pbWF0aW9uSW50ZXJ2YWwoKTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uUmV2ZXJzZSgpIHtcbiAgICBwLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXQgPT09ICEwID8gXCJpbmZpbml0ZVwiIDogXCIyXCIsXG4gICAgICBhbmltYXRpb25EaXJlY3Rpb246IFwiYWx0ZXJuYXRlXCJcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uRHVyYXRpb24oKSB7XG4gICAgcC5zdHlsZSh0aGlzLl9hbmltYXRlRWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uRHVyYXRpb246IGAke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb259bXNgXG4gICAgfSk7XG4gIH1cbiAgX3NldEFuaW1hdGlvbkRlbGF5KCkge1xuICAgIHAuc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHtcbiAgICAgIGFuaW1hdGlvbkRlbGF5OiBgJHt0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkRlbGF5fW1zYFxuICAgIH0pO1xuICB9XG4gIF9zZXRBbmltYXRpb25SZXBlYXQoKSB7XG4gICAgcC5zdHlsZSh0aGlzLl9hbmltYXRlRWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVwZWF0ID09PSAhMCA/IFwiaW5maW5pdGVcIiA6IHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVwZWF0XG4gICAgfSk7XG4gIH1cbiAgX3NldEFuaW1hdGlvbkludGVydmFsKCkge1xuICAgIHUub24odGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkQW5pbWF0ZWRDbGFzcygpO1xuICAgICAgfSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCk7XG4gICAgfSk7XG4gIH1cbiAgX2hpZGVBbmltYXRlRWxlbWVudCgpIHtcbiAgICBwLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfSk7XG4gIH1cbiAgX3Nob3dBbmltYXRlRWxlbWVudCgpIHtcbiAgICBwLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7IHZpc2liaWxpdHk6IFwidmlzaWJsZVwiIH0pO1xuICB9XG4gIF9iaW5kUmVzZXRBbmltYXRpb25BZnRlckZpbmlzaCgpIHtcbiAgICB1Lm9uKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRUcmlnZ2VyT25FbmRDYWxsYmFjaygpIHtcbiAgICB1Lm9uKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uRW5kKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZFNjcm9sbEV2ZW50cygpIHtcbiAgICB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblNob3dPbkxvYWQgfHwgdGhpcy5fYW5pbWF0ZU9uU2Nyb2xsKCksIHUub24od2luZG93LCBcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRlT25TY3JvbGwoKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZENsaWNrRXZlbnRzKCkge1xuICAgIHUub24odGhpcy5fZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZEhvdmVyRXZlbnRzKCkge1xuICAgIHUub25lKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdmVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgfSksIHUub25lKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYmluZEhvdmVyRXZlbnRzKCk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG4gIF9jYWxsYmFjayh0KSB7XG4gICAgdCBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIHQoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGF1dG9Jbml0KHQpIHtcbiAgICB0Ll9pbml0KCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgbmV3IG1sKHRoaXNbMF0sIHQpLmluaXQoKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgY24pO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IGRuID0gXCJyaXBwbGVcIiwgUmkgPSBcInRlLnJpcHBsZVwiLCBtcCA9IFwicmdiYSh7e2NvbG9yfX0sIDAuMikgMCwgcmdiYSh7e2NvbG9yfX0sIDAuMykgNDAlLCByZ2JhKHt7Y29sb3J9fSwgMC40KSA1MCUsIHJnYmEoe3tjb2xvcn19LCAwLjUpIDYwJSwgcmdiYSh7e2NvbG9yfX0sIDApIDcwJVwiLCBncCA9IFtcIltkYXRhLXRlLXJpcHBsZS1pbml0XVwiXSwgUGkgPSBbMCwgMCwgMF0sIGJwID0gW1xuICB7IG5hbWU6IFwicHJpbWFyeVwiLCBncmFkaWVudENvbG9yOiBcIiMzQjcxQ0FcIiB9LFxuICB7IG5hbWU6IFwic2Vjb25kYXJ5XCIsIGdyYWRpZW50Q29sb3I6IFwiIzlGQTZCMlwiIH0sXG4gIHsgbmFtZTogXCJzdWNjZXNzXCIsIGdyYWRpZW50Q29sb3I6IFwiIzE0QTQ0RFwiIH0sXG4gIHsgbmFtZTogXCJkYW5nZXJcIiwgZ3JhZGllbnRDb2xvcjogXCIjREM0QzY0XCIgfSxcbiAgeyBuYW1lOiBcIndhcm5pbmdcIiwgZ3JhZGllbnRDb2xvcjogXCIjRTRBMTFCXCIgfSxcbiAgeyBuYW1lOiBcImluZm9cIiwgZ3JhZGllbnRDb2xvcjogXCIjNTRCNEQzXCIgfSxcbiAgeyBuYW1lOiBcImxpZ2h0XCIsIGdyYWRpZW50Q29sb3I6IFwiI2ZiZmJmYlwiIH0sXG4gIHsgbmFtZTogXCJkYXJrXCIsIGdyYWRpZW50Q29sb3I6IFwiIzI2MjYyNlwiIH1cbl0sIHZyID0gMC41LCB2cCA9IHtcbiAgcmlwcGxlQ2VudGVyZWQ6ICExLFxuICByaXBwbGVDb2xvcjogXCJcIixcbiAgcmlwcGxlQ29sb3JEYXJrOiBcIlwiLFxuICByaXBwbGVEdXJhdGlvbjogXCI1MDBtc1wiLFxuICByaXBwbGVSYWRpdXM6IDAsXG4gIHJpcHBsZVVuYm91bmQ6ICExXG59LCBFcCA9IHtcbiAgcmlwcGxlQ2VudGVyZWQ6IFwiYm9vbGVhblwiLFxuICByaXBwbGVDb2xvcjogXCJzdHJpbmdcIixcbiAgcmlwcGxlQ29sb3JEYXJrOiBcInN0cmluZ1wiLFxuICByaXBwbGVEdXJhdGlvbjogXCJzdHJpbmdcIixcbiAgcmlwcGxlUmFkaXVzOiBcIm51bWJlclwiLFxuICByaXBwbGVVbmJvdW5kOiBcImJvb2xlYW5cIlxufSwgVHAgPSB7XG4gIHJpcHBsZTogXCJyZWxhdGl2ZSBvdmVyZmxvdy1oaWRkZW4gaW5saW5lLWJsb2NrIGFsaWduLWJvdHRvbVwiLFxuICByaXBwbGVXYXZlOiBcInJvdW5kZWQtWzUwJV0gb3BhY2l0eS01MCBwb2ludGVyLWV2ZW50cy1ub25lIGFic29sdXRlIHRvdWNoLW5vbmUgc2NhbGUtMCB0cmFuc2l0aW9uLVt0cmFuc2Zvcm0sX29wYWNpdHldIGVhc2UtW2N1YmljLWJlemllcigwLDAsMC4xNSwxKSxfY3ViaWMtYmV6aWVyKDAsMCwwLjE1LDEpXSB6LVs5OTldXCIsXG4gIHVuYm91bmQ6IFwib3ZlcmZsb3ctdmlzaWJsZVwiXG59LCBDcCA9IHtcbiAgcmlwcGxlOiBcInN0cmluZ1wiLFxuICByaXBwbGVXYXZlOiBcInN0cmluZ1wiLFxuICB1bmJvdW5kOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgQ3Mge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9lbGVtZW50ICYmIChJLnNldERhdGEodCwgUmksIHRoaXMpLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKSksIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2NyZWF0ZVJpcHBsZS5iaW5kKHRoaXMpLCB0aGlzLl9yaXBwbGVUaW1lciA9IG51bGwsIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMSwgdGhpcy5faW5pdGlhbENsYXNzZXMgPSBudWxsLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gZG47XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fYWRkQ2xpY2tFdmVudCh0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBSaSksIHUub2ZmKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2F1dG9Jbml0KHQpIHtcbiAgICBncC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBoLmNsb3Nlc3QodC50YXJnZXQsIGUpICYmICh0aGlzLl9lbGVtZW50ID0gaC5jbG9zZXN0KHQudGFyZ2V0LCBlKSk7XG4gICAgfSksIHRoaXMuX2VsZW1lbnQuc3R5bGUubWluV2lkdGggfHwgKHAuc3R5bGUodGhpcy5fZWxlbWVudCwge1xuICAgICAgXCJtaW4td2lkdGhcIjogZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS53aWR0aFxuICAgIH0pLCB0aGlzLl9pc01pbldpZHRoU2V0ID0gITApLCB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IFsuLi50aGlzLl9lbGVtZW50LmNsYXNzTGlzdF0sIHAuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKCksIHRoaXMuX2NyZWF0ZVJpcHBsZSh0KTtcbiAgfVxuICBfYWRkQ2xpY2tFdmVudCh0KSB7XG4gICAgdS5vbih0LCBcIm1vdXNlZG93blwiLCB0aGlzLl9jbGlja0hhbmRsZXIpO1xuICB9XG4gIF9jcmVhdGVSaXBwbGUodCkge1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodGhpcy5fY2xhc3Nlcy5yaXBwbGUpIDwgMCAmJiBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKTtcbiAgICBjb25zdCB7IGxheWVyWDogZSwgbGF5ZXJZOiBpIH0gPSB0LCBuID0gZSwgbyA9IGksIHIgPSB0aGlzLl9lbGVtZW50Lm9mZnNldEhlaWdodCwgYSA9IHRoaXMuX2VsZW1lbnQub2Zmc2V0V2lkdGgsIGwgPSB0aGlzLl9kdXJhdGlvblRvTXNOdW1iZXIodGhpcy5fb3B0aW9ucy5yaXBwbGVEdXJhdGlvbiksIGMgPSB7XG4gICAgICBvZmZzZXRYOiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gciAvIDIgOiBuLFxuICAgICAgb2Zmc2V0WTogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IGEgLyAyIDogbyxcbiAgICAgIGhlaWdodDogcixcbiAgICAgIHdpZHRoOiBhXG4gICAgfSwgZCA9IHRoaXMuX2dldERpYW1ldGVyKGMpLCBfID0gdGhpcy5fb3B0aW9ucy5yaXBwbGVSYWRpdXMgfHwgZCAvIDIsIGYgPSB7XG4gICAgICBkZWxheTogbCAqIHZyLFxuICAgICAgZHVyYXRpb246IGwgLSBsICogdnJcbiAgICB9LCBtID0ge1xuICAgICAgbGVmdDogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IGAke2EgLyAyIC0gX31weGAgOiBgJHtuIC0gX31weGAsXG4gICAgICB0b3A6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBgJHtyIC8gMiAtIF99cHhgIDogYCR7byAtIF99cHhgLFxuICAgICAgaGVpZ2h0OiBgJHt0aGlzLl9vcHRpb25zLnJpcHBsZVJhZGl1cyAqIDIgfHwgZH1weGAsXG4gICAgICB3aWR0aDogYCR7dGhpcy5fb3B0aW9ucy5yaXBwbGVSYWRpdXMgKiAyIHx8IGR9cHhgLFxuICAgICAgdHJhbnNpdGlvbkRlbGF5OiBgMHMsICR7Zi5kZWxheX1tc2AsXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2x9bXMsICR7Zi5kdXJhdGlvbn1tc2BcbiAgICB9LCBnID0gTShcImRpdlwiKTtcbiAgICB0aGlzLl9jcmVhdGVIVE1MUmlwcGxlKHtcbiAgICAgIHdyYXBwZXI6IHRoaXMuX2VsZW1lbnQsXG4gICAgICByaXBwbGU6IGcsXG4gICAgICBzdHlsZXM6IG1cbiAgICB9KSwgdGhpcy5fcmVtb3ZlSFRNTFJpcHBsZSh7IHJpcHBsZTogZywgZHVyYXRpb246IGwgfSk7XG4gIH1cbiAgX2NyZWF0ZUhUTUxSaXBwbGUoeyB3cmFwcGVyOiB0LCByaXBwbGU6IGUsIHN0eWxlczogaSB9KSB7XG4gICAgT2JqZWN0LmtleXMoaSkuZm9yRWFjaChcbiAgICAgIChuKSA9PiBlLnN0eWxlW25dID0gaVtuXVxuICAgICksIHAuYWRkQ2xhc3MoZSwgdGhpcy5fY2xhc3Nlcy5yaXBwbGVXYXZlKSwgZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXJpcHBsZS1yZWZcIiwgXCJcIiksIHRoaXMuX2FkZENvbG9yKGUsIHQpLCB0aGlzLl90b2dnbGVVbmJvdW5kKHQpLCB0aGlzLl9hcHBlbmRSaXBwbGUoZSwgdCk7XG4gIH1cbiAgX3JlbW92ZUhUTUxSaXBwbGUoeyByaXBwbGU6IHQsIGR1cmF0aW9uOiBlIH0pIHtcbiAgICB0aGlzLl9yaXBwbGVUaW1lciAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX3JpcHBsZVRpbWVyKSwgdGhpcy5fcmlwcGxlVGltZXIgPSBudWxsKSwgdCAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHQuY2xhc3NMaXN0LmFkZChcIiFvcGFjaXR5LTBcIik7XG4gICAgfSwgMTApLCB0aGlzLl9yaXBwbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHQgJiYgKHQucmVtb3ZlKCksIHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICAgIGguZmluZChcIltkYXRhLXRlLXJpcHBsZS1yZWZdXCIsIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goXG4gICAgICAgICAgKG4pID0+IHtcbiAgICAgICAgICAgIG4ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICApLCB0aGlzLl9pc01pbldpZHRoU2V0ICYmIChwLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHsgXCJtaW4td2lkdGhcIjogXCJcIiB9KSwgdGhpcy5faXNNaW5XaWR0aFNldCA9ICExKTtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuX2luaXRpYWxDbGFzc2VzID8gdGhpcy5fYWRkZWROZXdSaXBwbGVDbGFzc2VzKFxuICAgICAgICAgIHRoaXMuX2NsYXNzZXMucmlwcGxlLFxuICAgICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzXG4gICAgICAgICkgOiB0aGlzLl9jbGFzc2VzLnJpcHBsZS5zcGxpdChcIiBcIik7XG4gICAgICAgIHAucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgaSk7XG4gICAgICB9XG4gICAgfSwgZSk7XG4gIH1cbiAgX2FkZGVkTmV3UmlwcGxlQ2xhc3Nlcyh0LCBlKSB7XG4gICAgcmV0dXJuIHQuc3BsaXQoXCIgXCIpLmZpbHRlcihcbiAgICAgIChpKSA9PiBlLmZpbmRJbmRleCgobikgPT4gaSA9PT0gbikgPT09IC0xXG4gICAgKTtcbiAgfVxuICBfZHVyYXRpb25Ub01zTnVtYmVyKHQpIHtcbiAgICByZXR1cm4gTnVtYmVyKHQucmVwbGFjZShcIm1zXCIsIFwiXCIpLnJlcGxhY2UoXCJzXCIsIFwiMDAwXCIpKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQgPSB7fSkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4udnAsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4oZG4sIHQsIEVwKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlRwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKGRuLCB0LCBDcCksIHQ7XG4gIH1cbiAgX2dldERpYW1ldGVyKHsgb2Zmc2V0WDogdCwgb2Zmc2V0WTogZSwgaGVpZ2h0OiBpLCB3aWR0aDogbiB9KSB7XG4gICAgY29uc3QgbyA9IGUgPD0gaSAvIDIsIHIgPSB0IDw9IG4gLyAyLCBhID0gKGYsIG0pID0+IE1hdGguc3FydChmICoqIDIgKyBtICoqIDIpLCBsID0gZSA9PT0gaSAvIDIgJiYgdCA9PT0gbiAvIDIsIGMgPSB7XG4gICAgICBmaXJzdDogbyA9PT0gITAgJiYgciA9PT0gITEsXG4gICAgICBzZWNvbmQ6IG8gPT09ICEwICYmIHIgPT09ICEwLFxuICAgICAgdGhpcmQ6IG8gPT09ICExICYmIHIgPT09ICEwLFxuICAgICAgZm91cnRoOiBvID09PSAhMSAmJiByID09PSAhMVxuICAgIH0sIGQgPSB7XG4gICAgICB0b3BMZWZ0OiBhKHQsIGUpLFxuICAgICAgdG9wUmlnaHQ6IGEobiAtIHQsIGUpLFxuICAgICAgYm90dG9tTGVmdDogYSh0LCBpIC0gZSksXG4gICAgICBib3R0b21SaWdodDogYShuIC0gdCwgaSAtIGUpXG4gICAgfTtcbiAgICBsZXQgXyA9IDA7XG4gICAgcmV0dXJuIGwgfHwgYy5mb3VydGggPyBfID0gZC50b3BMZWZ0IDogYy50aGlyZCA/IF8gPSBkLnRvcFJpZ2h0IDogYy5zZWNvbmQgPyBfID0gZC5ib3R0b21SaWdodCA6IGMuZmlyc3QgJiYgKF8gPSBkLmJvdHRvbUxlZnQpLCBfICogMjtcbiAgfVxuICBfYXBwZW5kUmlwcGxlKHQsIGUpIHtcbiAgICBlLmFwcGVuZENoaWxkKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHAuYWRkQ2xhc3ModCwgXCJvcGFjaXR5LTAgc2NhbGUtMTAwXCIpO1xuICAgIH0sIDUwKTtcbiAgfVxuICBfdG9nZ2xlVW5ib3VuZCh0KSB7XG4gICAgdGhpcy5fb3B0aW9ucy5yaXBwbGVVbmJvdW5kID09PSAhMCA/IHAuYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy51bmJvdW5kKSA6IHAucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy51bmJvdW5kKTtcbiAgfVxuICBfYWRkQ29sb3IodCkge1xuICAgIGxldCBlID0gdGhpcy5fb3B0aW9ucy5yaXBwbGVDb2xvciB8fCBcInJnYigwLDAsMClcIjtcbiAgICAobG9jYWxTdG9yYWdlLnRoZW1lID09PSBcImRhcmtcIiB8fCAhKFwidGhlbWVcIiBpbiBsb2NhbFN0b3JhZ2UpICYmIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzKSAmJiAoZSA9IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3JEYXJrIHx8IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3IpO1xuICAgIGNvbnN0IGkgPSBicC5maW5kKFxuICAgICAgKHIpID0+IHIubmFtZSA9PT0gZS50b0xvd2VyQ2FzZSgpXG4gICAgKSwgbiA9IGkgPyB0aGlzLl9jb2xvclRvUkdCKGkuZ3JhZGllbnRDb2xvcikuam9pbihcIixcIikgOiB0aGlzLl9jb2xvclRvUkdCKGUpLmpvaW4oXCIsXCIpLCBvID0gbXAuc3BsaXQoXCJ7e2NvbG9yfX1cIikuam9pbihgJHtufWApO1xuICAgIHQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHJhZGlhbC1ncmFkaWVudChjaXJjbGUsICR7b30pYDtcbiAgfVxuICBfY29sb3JUb1JHQih0KSB7XG4gICAgZnVuY3Rpb24gZShvKSB7XG4gICAgICByZXR1cm4gby5sZW5ndGggPCA3ICYmIChvID0gYCMke29bMV19JHtvWzFdfSR7b1syXX0ke29bMl19JHtvWzNdfSR7b1szXX1gKSwgW1xuICAgICAgICBwYXJzZUludChvLnN1YnN0cigxLCAyKSwgMTYpLFxuICAgICAgICBwYXJzZUludChvLnN1YnN0cigzLCAyKSwgMTYpLFxuICAgICAgICBwYXJzZUludChvLnN1YnN0cig1LCAyKSwgMTYpXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpKG8pIHtcbiAgICAgIGNvbnN0IHIgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKFxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmljdHVtXCIpXG4gICAgICApLCBhID0gXCJyZ2IoMSwgMiwgMylcIjtcbiAgICAgIHJldHVybiByLnN0eWxlLmNvbG9yID0gYSwgci5zdHlsZS5jb2xvciAhPT0gYSB8fCAoci5zdHlsZS5jb2xvciA9IG8sIHIuc3R5bGUuY29sb3IgPT09IGEgfHwgci5zdHlsZS5jb2xvciA9PT0gXCJcIikgPyBQaSA6IChvID0gZ2V0Q29tcHV0ZWRTdHlsZShyKS5jb2xvciwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyKSwgbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG4obykge1xuICAgICAgcmV0dXJuIG8gPSBvLm1hdGNoKC9bLlxcZF0rL2cpLm1hcCgocikgPT4gK051bWJlcihyKSksIG8ubGVuZ3RoID0gMywgbztcbiAgICB9XG4gICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cmFuc3BhcmVudFwiID8gUGkgOiB0WzBdID09PSBcIiNcIiA/IGUodCkgOiAodC5pbmRleE9mKFwicmdiXCIpID09PSAtMSAmJiAodCA9IGkodCkpLCB0LmluZGV4T2YoXCJyZ2JcIikgPT09IDAgPyBuKHQpIDogUGkpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgYXV0b0luaXRpYWwodCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB0Ll9hdXRvSW5pdChlKTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSS5nZXREYXRhKHRoaXMsIFJpKSA/IG51bGwgOiBuZXcgQ3ModGhpcywgdCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIFJpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5mdW5jdGlvbiBRKHMpIHtcbiAgcmV0dXJuIHMuZ2V0RGF0ZSgpO1xufVxuZnVuY3Rpb24gbHMocykge1xuICByZXR1cm4gcy5nZXREYXkoKTtcbn1cbmZ1bmN0aW9uIFkocykge1xuICByZXR1cm4gcy5nZXRNb250aCgpO1xufVxuZnVuY3Rpb24gSChzKSB7XG4gIHJldHVybiBzLmdldEZ1bGxZZWFyKCk7XG59XG5mdW5jdGlvbiBBcChzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBlLnN0YXJ0RGF5LCBuID0gaSA+IDAgPyA3IC0gaSA6IDAsIHIgPSBuZXcgRGF0ZShzLCB0KS5nZXREYXkoKSArIG47XG4gIHJldHVybiByID49IDcgPyByIC0gNyA6IHI7XG59XG5mdW5jdGlvbiBXbihzKSB7XG4gIHJldHVybiB5cChzKS5nZXREYXRlKCk7XG59XG5mdW5jdGlvbiB5cChzKSB7XG4gIHJldHVybiBEdChzLmdldEZ1bGxZZWFyKCksIHMuZ2V0TW9udGgoKSArIDEsIDApO1xufVxuZnVuY3Rpb24gRGUoKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbn1cbmZ1bmN0aW9uIGl0KHMsIHQpIHtcbiAgcmV0dXJuIG50KHMsIHQgKiAxMik7XG59XG5mdW5jdGlvbiBudChzLCB0KSB7XG4gIGNvbnN0IGUgPSBEdChcbiAgICBzLmdldEZ1bGxZZWFyKCksXG4gICAgcy5nZXRNb250aCgpICsgdCxcbiAgICBzLmdldERhdGUoKVxuICApLCBpID0gUShzKSwgbiA9IFEoZSk7XG4gIHJldHVybiBpICE9PSBuICYmIGUuc2V0RGF0ZSgwKSwgZTtcbn1cbmZ1bmN0aW9uIFRlKHMsIHQpIHtcbiAgcmV0dXJuIER0KHMuZ2V0RnVsbFllYXIoKSwgcy5nZXRNb250aCgpLCBzLmdldERhdGUoKSArIHQpO1xufVxuZnVuY3Rpb24gRHQocywgdCwgZSkge1xuICBjb25zdCBpID0gbmV3IERhdGUocywgdCwgZSk7XG4gIHJldHVybiBzID49IDAgJiYgcyA8IDEwMCAmJiBpLnNldEZ1bGxZZWFyKGkuZ2V0RnVsbFllYXIoKSAtIDE5MDApLCBpO1xufVxuZnVuY3Rpb24gRXIocykge1xuICBjb25zdCB0ID0gcy5zcGxpdChcIi1cIiksIGUgPSB0WzBdLCBpID0gdFsxXSwgbiA9IHRbMl07XG4gIHJldHVybiBEdChlLCBpLCBuKTtcbn1cbmZ1bmN0aW9uIHdwKHMpIHtcbiAgcmV0dXJuICFOdW1iZXIuaXNOYU4ocy5nZXRUaW1lKCkpO1xufVxuZnVuY3Rpb24geGUocywgdCkge1xuICByZXR1cm4gSChzKSAtIEgodCkgfHwgWShzKSAtIFkodCkgfHwgUShzKSAtIFEodCk7XG59XG5mdW5jdGlvbiBkZShzLCB0KSB7XG4gIHJldHVybiBzLnNldEhvdXJzKDAsIDAsIDAsIDApLCB0LnNldEhvdXJzKDAsIDAsIDAsIDApLCBzLmdldFRpbWUoKSA9PT0gdC5nZXRUaW1lKCk7XG59XG5mdW5jdGlvbiBjcyhzLCB0KSB7XG4gIGNvbnN0IGkgPSBIKHMpIC0gT3AoKTtcbiAgcmV0dXJuIGtwKGksIHQpO1xufVxuZnVuY3Rpb24ga3AocywgdCkge1xuICByZXR1cm4gKHMgJSB0ICsgdCkgJSB0O1xufVxuZnVuY3Rpb24gT3AocywgdCwgZSkge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiBlID8gaSA9IEgoZSkgLSBzICsgMSA6IHQgJiYgKGkgPSBIKHQpKSwgaTtcbn1cbmZ1bmN0aW9uIEFzKHMsIHQsIGUsIGksIG4sIG8pIHtcbiAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICByLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBhID0gdCAmJiB4ZShzLCB0KSA8PSAtMSwgbCA9IGUgJiYgeGUocywgZSkgPj0gMSwgYyA9IG4gJiYgeGUocywgcikgPD0gLTEsIGQgPSBvICYmIHhlKHMsIHIpID49IDEsIF8gPSBpICYmIGkocykgPT09ICExO1xuICByZXR1cm4gYSB8fCBsIHx8IF8gfHwgYyB8fCBkO1xufVxuZnVuY3Rpb24gZ2wocywgdCwgZSwgaSwgbiwgbykge1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGEgPSBpICYmIEgoaSksIGwgPSBpICYmIFkoaSksIGMgPSBlICYmIEgoZSksIGQgPSBlICYmIFkoZSksIF8gPSBIKHIpLCBmID0gWShyKSwgbSA9IGwgJiYgYSAmJiAodCA+IGEgfHwgdCA9PT0gYSAmJiBzID4gbCksIGcgPSBkICYmIGMgJiYgKHQgPCBjIHx8IHQgPT09IGMgJiYgcyA8IGQpLCBiID0gbiAmJiAodCA8IF8gfHwgdCA9PT0gXyAmJiBzIDwgZiksIFQgPSBvICYmICh0ID4gXyB8fCB0ID09PSBfICYmIHMgPiBmKTtcbiAgcmV0dXJuIG0gfHwgZyB8fCBiIHx8IFQ7XG59XG5mdW5jdGlvbiBGbihzLCB0LCBlLCBpLCBuKSB7XG4gIGNvbnN0IG8gPSB0ICYmIEgodCksIHIgPSBlICYmIEgoZSksIGEgPSBIKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKSwgbCA9IHIgJiYgcyA+IHIsIGMgPSBvICYmIHMgPCBvLCBkID0gaSAmJiBzIDwgYSwgXyA9IG4gJiYgcyA+IGE7XG4gIHJldHVybiBsIHx8IGMgfHwgZCB8fCBfO1xufVxuZnVuY3Rpb24geHAocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICBjb25zdCBsID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIHJldHVybiBsLnNldEhvdXJzKDAsIDAsIDAsIDApLCAocyAmJiBvICYmIHhlKG8sIGwpIDwgMCB8fCBzKSAmJiAobyA9IGwpLCBvICYmIGRpKFxuICAgIHQsXG4gICAgbyxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYVxuICApO1xufVxuZnVuY3Rpb24gU3AocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICBjb25zdCBsID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIHJldHVybiBsLnNldEhvdXJzKDAsIDAsIDAsIDApLCAocyAmJiBuICYmIHhlKG4sIGwpIDwgMCB8fCBzKSAmJiAobiA9IGwpLCBuICYmIGRpKFxuICAgIHQsXG4gICAgbixcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYVxuICApO1xufVxuZnVuY3Rpb24gZGkocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICByZXR1cm4gZSA9PT0gXCJkYXlzXCIgPyBIKHMpID09PSBIKHQpICYmIFkocykgPT09IFkodCkgOiBlID09PSBcIm1vbnRoc1wiID8gSChzKSA9PT0gSCh0KSA6IGUgPT09IFwieWVhcnNcIiA/IEgodCkgPj0gYSAmJiBIKHQpIDw9IHIgOiAhMTtcbn1cbmNvbnN0IERwID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItbW9kYWwtY29udGFpbmVyLXJlZlwiLCBJcCA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWRyb3Bkb3duLWNvbnRhaW5lci1yZWZcIiwgJHAgPSBcImRhdGEtdGUtZHJvcGRvd24tYmFja2Ryb3AtcmVmXCIsIExwID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItZGF0ZS10ZXh0LXJlZlwiLCBUciA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctcmVmXCIsIE1wID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItcHJldmlvdXMtYnV0dG9uLXJlZlwiLCBOcCA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLW5leHQtYnV0dG9uLXJlZlwiLCBScCA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLW9rLWJ1dHRvbi1yZWZcIiwgUHAgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1jYW5jZWwtYnV0dG9uLXJlZlwiLCBIcCA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNsZWFyLWJ1dHRvbi1yZWZcIiwgQnAgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci12aWV3LWNoYW5nZS1idXR0b24tcmVmXCI7XG5mdW5jdGlvbiBWcChzLCB0LCBlLCBpLCBuLCBvLCByLCBhLCBsLCBjKSB7XG4gIGNvbnN0IGQgPSBZKHMpLCBfID0gSChzKSwgZiA9IFEocyksIG0gPSBscyhzKSwgZyA9IE0oXCJkaXZcIiksIGIgPSBgXG4gICAgICAgICR7Q3IoXG4gICAgcyxcbiAgICBkLFxuICAgIF8sXG4gICAgdCxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBjXG4gICl9XG4gICAgYCwgVCA9IGBcbiAgICAgICR7RnAoZiwgbSwgZCwgbiwgYyl9XG4gICAgICAke0NyKFxuICAgIHMsXG4gICAgZCxcbiAgICBfLFxuICAgIHQsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgY1xuICApfVxuICAgIGA7XG4gIHJldHVybiBuLmlubGluZSA/IChwLmFkZENsYXNzKGcsIGMuZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyKSwgZy5zZXRBdHRyaWJ1dGUoSXAsIGwpLCBnLmlubmVySFRNTCA9IGIpIDogKHAuYWRkQ2xhc3MoZywgYy5tb2RhbENvbnRhaW5lciksIGcuc2V0QXR0cmlidXRlKERwLCBsKSwgZy5pbm5lckhUTUwgPSBUKSwgZztcbn1cbmZ1bmN0aW9uIFdwKHMpIHtcbiAgY29uc3QgdCA9IE0oXCJkaXZcIik7XG4gIHJldHVybiBwLmFkZENsYXNzKHQsIHMpLCB0LnNldEF0dHJpYnV0ZSgkcCwgXCJcIiksIHQ7XG59XG5mdW5jdGlvbiBGcChzLCB0LCBlLCBpLCBuKSB7XG4gIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwiJHtuLmRhdGVwaWNrZXJIZWFkZXJ9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke24uZGF0ZXBpY2tlclRpdGxlfVwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtuLmRhdGVwaWNrZXJUaXRsZVRleHR9XCI+JHtpLnRpdGxlfTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke24uZGF0ZXBpY2tlckRhdGV9XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCIke24uZGF0ZXBpY2tlckRhdGVUZXh0fVwiICR7THB9ID4ke2kud2Vla2RheXNTaG9ydFt0XX0sICR7aS5tb250aHNTaG9ydFtlXX0gJHtzfTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xufVxuZnVuY3Rpb24gQ3IocywgdCwgZSwgaSwgbiwgbywgciwgYSwgbCwgYywgZCkge1xuICBsZXQgXztcbiAgcmV0dXJuIHIuaW5saW5lID8gXyA9IGBcbiAgICA8ZGl2IGNsYXNzPVwiJHtkLmRhdGVwaWNrZXJNYWlufVwiPlxuICAgICAgJHt5cih0LCBlLCByLCBkKX1cbiAgICAgIDxkaXYgY2xhc3M9XCIke2QuZGF0ZXBpY2tlclZpZXd9XCIgJHtUcn0gdGFiaW5kZXg9XCIwXCI+XG4gICAgICAgICR7QXIoXG4gICAgcyxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBsLFxuICAgIGMsXG4gICAgZFxuICApfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGAgOiBfID0gYFxuICAgIDxkaXYgY2xhc3M9XCIke2QuZGF0ZXBpY2tlck1haW59XCI+XG4gICAgICAke3lyKHQsIGUsIHIsIGQpfVxuICAgICAgPGRpdiBjbGFzcz1cIiR7ZC5kYXRlcGlja2VyVmlld31cIiAke1RyfSB0YWJpbmRleD1cIjBcIj5cbiAgICAgICAgJHtBcihcbiAgICBzLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIGwsXG4gICAgYyxcbiAgICBkXG4gICl9XG4gICAgICA8L2Rpdj5cbiAgICAgICR7WXAociwgZCl9XG4gICAgPC9kaXY+XG4gIGAsIF87XG59XG5mdW5jdGlvbiBBcihzLCB0LCBlLCBpLCBuLCBvLCByLCBhLCBsLCBjKSB7XG4gIGxldCBkO1xuICByZXR1cm4gby52aWV3ID09PSBcImRheXNcIiA/IGQgPSBkcyhzLCBlLCBvLCBjKSA6IG8udmlldyA9PT0gXCJtb250aHNcIiA/IGQgPSBocyhcbiAgICB0LFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgY1xuICApIDogZCA9IHVzKFxuICAgIHMsXG4gICAgaSxcbiAgICBvLFxuICAgIGEsXG4gICAgbCxcbiAgICBjXG4gICksIGQ7XG59XG5mdW5jdGlvbiB5cihzLCB0LCBlLCBpKSB7XG4gIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cIiR7aS5kYXRlcGlja2VyRGF0ZUNvbnRyb2xzfVwiPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7aS5kYXRlcGlja2VyVmlld0NoYW5nZUJ1dHRvbn1cIiBhcmlhLWxhYmVsPVwiJHtlLnN3aXRjaFRvTXVsdGlZZWFyVmlld0xhYmVsfVwiICR7QnB9PlxuICAgICAgICAke2UubW9udGhzRnVsbFtzXX0gJHt0fSAke2t0KFxuICAgIGUsXG4gICAgaVxuICApfVxuICAgICAgPC9idXR0b24+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJBcnJvd0NvbnRyb2xzfVwiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJQcmV2aW91c0J1dHRvbn1cIiBhcmlhLWxhYmVsPVwiJHtlLnByZXZNb250aExhYmVsfVwiICR7TXB9PiR7ZS5jaGFuZ2VNb250aEljb25UZW1wbGF0ZX08L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7aS5kYXRlcGlja2VyTmV4dEJ1dHRvbn1cIiBhcmlhLWxhYmVsPVwiJHtlLm5leHRNb250aExhYmVsfVwiICR7TnB9PiR7ZS5jaGFuZ2VNb250aEljb25UZW1wbGF0ZX08L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIGA7XG59XG5mdW5jdGlvbiBrdChzLCB0KSB7XG4gIHJldHVybiBgXG4gIDxzcGFuIGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJWaWV3Q2hhbmdlSWNvbn1cIj5cbiAgJHtzLnZpZXdDaGFuZ2VJY29uVGVtcGxhdGV9XG4gIDwvc3Bhbj5cbiAgYDtcbn1cbmZ1bmN0aW9uIFlwKHMsIHQpIHtcbiAgY29uc3QgZSA9IGA8YnV0dG9uIGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJGb290ZXJCdG59XCIgYXJpYS1sYWJlbD1cIiR7cy5va0J0bkxhYmVsfVwiICR7UnB9PiR7cy5va0J0blRleHR9PC9idXR0b24+YCwgaSA9IGA8YnV0dG9uIGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJGb290ZXJCdG59XCIgYXJpYS1sYWJlbD1cIiR7cy5jYW5jZWxCdG5MYWJlbH1cIiAke1BwfT4ke3MuY2FuY2VsQnRuVGV4dH08L2J1dHRvbj5gLCBuID0gYDxidXR0b24gY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3RlckJ0bn0gJHt0LmRhdGVwaWNrZXJDbGVhckJ0bn1cIiBhcmlhLWxhYmVsPVwiJHtzLmNsZWFyQnRuTGFiZWx9XCIgJHtIcH0+JHtzLmNsZWFyQnRuVGV4dH08L2J1dHRvbj5gO1xuICByZXR1cm4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJGb290ZXJ9XCI+XG4gICAgICAgICAgXG4gICAgICAgICR7cy5yZW1vdmVDbGVhckJ0biA/IFwiXCIgOiBufVxuICAgICAgICAke3MucmVtb3ZlQ2FuY2VsQnRuID8gXCJcIiA6IGl9XG4gICAgICAgICR7cy5yZW1vdmVPa0J0biA/IFwiXCIgOiBlfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIGA7XG59XG5mdW5jdGlvbiBkcyhzLCB0LCBlLCBpKSB7XG4gIGNvbnN0IG4gPSBqcChzLCB0LCBlKSwgciA9IGBcbiAgICAgIDx0cj5cbiAgICAgICAgJHtlLndlZWtkYXlzTmFycm93Lm1hcCgobCwgYykgPT4gYDx0aCBjbGFzcz1cIiR7aS5kYXRlcGlja2VyRGF5SGVhZGluZ31cIiBzY29wZT1cImNvbFwiIGFyaWEtbGFiZWw9XCIke2Uud2Vla2RheXNGdWxsW2NdfVwiPiR7bH08L3RoPmApLmpvaW4oXCJcIil9XG4gICAgICA8L3RyPlxuICAgIGAsIGEgPSBuLm1hcCgobCkgPT4gYFxuICAgICAgICA8dHI+XG4gICAgICAgICAgJHtsLm1hcCgoYykgPT4gYFxuICAgICAgICAgICAgICA8dGRcbiAgICAgICAgICAgICAgY2xhc3M9XCIke2kuZGF0ZXBpY2tlckNlbGx9ICR7aS5kYXRlcGlja2VyQ2VsbFNtYWxsfVwiXG4gICAgICAgICAgICAgIGRhdGEtdGUtZGF0ZT1cIiR7SChjLmRhdGUpfS0ke1koXG4gICAgYy5kYXRlXG4gICl9LSR7UShjLmRhdGUpfVwiXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCIke2MuZGF0ZX1cIlxuICAgICAgICAgICAgICBhcmlhLXNlbGVjdGVkPVwiJHtjLmlzU2VsZWN0ZWR9XCJcbiAgICAgICAgICAgICAgJHtjLmlzU2VsZWN0ZWQgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAkeyFjLmN1cnJlbnRNb250aCB8fCBjLmRpc2FibGVkID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgJHtjLmlzVG9kYXkgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICBjbGFzcz1cIiR7aS5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7aS5kYXRlcGlja2VyQ2VsbENvbnRlbnRTbWFsbH1cIlxuICAgICAgICAgICAgICAgICAgc3R5bGU9XCIke2MuY3VycmVudE1vbnRoID8gXCJkaXNwbGF5OiBibG9ja1wiIDogXCJkaXNwbGF5OiBub25lXCJ9XCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICR7Yy5kYXlOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIGApLmpvaW4oXCJcIil9XG4gICAgICAgIDwvdHI+XG4gICAgICBgKS5qb2luKFwiXCIpO1xuICByZXR1cm4gYFxuICAgICAgPHRhYmxlIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJUYWJsZX1cIj5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICR7cn1cbiAgICAgICAgPC90aGVhZD5cbiAgICAgICAgPHRib2R5PlxuICAgICAgICAgJHthfVxuICAgICAgICA8L3Rib2R5PlxuICAgICAgPC90YWJsZT5cbiAgICBgO1xufVxuZnVuY3Rpb24ganAocywgdCwgZSkge1xuICBjb25zdCBpID0gW10sIG4gPSBZKHMpLCBvID0gWShudChzLCAtMSkpLCByID0gWShudChzLCAxKSksIGEgPSBIKHMpLCBsID0gQXAoYSwgbiwgZSksIGMgPSBXbihzKSwgZCA9IFduKG50KHMsIC0xKSksIF8gPSA3O1xuICBsZXQgZiA9IDEsIG0gPSAhMTtcbiAgZm9yIChsZXQgZyA9IDE7IGcgPCBfOyBnKyspIHtcbiAgICBjb25zdCBiID0gW107XG4gICAgaWYgKGcgPT09IDEpIHtcbiAgICAgIGNvbnN0IFQgPSBkIC0gbCArIDE7XG4gICAgICBmb3IgKGxldCB3ID0gVDsgdyA8PSBkOyB3KyspIHtcbiAgICAgICAgY29uc3QgdiA9IER0KGEsIG8sIHcpO1xuICAgICAgICBiLnB1c2goe1xuICAgICAgICAgIGRhdGU6IHYsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBtLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHQgJiYgZGUodiwgdCksXG4gICAgICAgICAgaXNUb2RheTogZGUodiwgRGUoKSksXG4gICAgICAgICAgZGF5TnVtYmVyOiBRKHYpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbSA9ICEwO1xuICAgICAgY29uc3QgQyA9IF8gLSBiLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgQzsgdysrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBEdChhLCBuLCBmKTtcbiAgICAgICAgYi5wdXNoKHtcbiAgICAgICAgICBkYXRlOiB2LFxuICAgICAgICAgIGN1cnJlbnRNb250aDogbSxcbiAgICAgICAgICBpc1NlbGVjdGVkOiB0ICYmIGRlKHYsIHQpLFxuICAgICAgICAgIGlzVG9kYXk6IGRlKHYsIERlKCkpLFxuICAgICAgICAgIGRheU51bWJlcjogUSh2KSxcbiAgICAgICAgICBkaXNhYmxlZDogQXMoXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgZS5taW4sXG4gICAgICAgICAgICBlLm1heCxcbiAgICAgICAgICAgIGUuZmlsdGVyLFxuICAgICAgICAgICAgZS5kaXNhYmxlUGFzdCxcbiAgICAgICAgICAgIGUuZGlzYWJsZUZ1dHVyZVxuICAgICAgICAgIClcbiAgICAgICAgfSksIGYrKztcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGZvciAobGV0IFQgPSAxOyBUIDwgODsgVCsrKSB7XG4gICAgICAgIGYgPiBjICYmIChmID0gMSwgbSA9ICExKTtcbiAgICAgICAgY29uc3QgQyA9IER0KFxuICAgICAgICAgIGEsXG4gICAgICAgICAgbSA/IG4gOiByLFxuICAgICAgICAgIGZcbiAgICAgICAgKTtcbiAgICAgICAgYi5wdXNoKHtcbiAgICAgICAgICBkYXRlOiBDLFxuICAgICAgICAgIGN1cnJlbnRNb250aDogbSxcbiAgICAgICAgICBpc1NlbGVjdGVkOiB0ICYmIGRlKEMsIHQpLFxuICAgICAgICAgIGlzVG9kYXk6IGRlKEMsIERlKCkpLFxuICAgICAgICAgIGRheU51bWJlcjogUShDKSxcbiAgICAgICAgICBkaXNhYmxlZDogQXMoXG4gICAgICAgICAgICBDLFxuICAgICAgICAgICAgZS5taW4sXG4gICAgICAgICAgICBlLm1heCxcbiAgICAgICAgICAgIGUuZmlsdGVyLFxuICAgICAgICAgICAgZS5kaXNhYmxlUGFzdCxcbiAgICAgICAgICAgIGUuZGlzYWJsZUZ1dHVyZVxuICAgICAgICAgIClcbiAgICAgICAgfSksIGYrKztcbiAgICAgIH1cbiAgICBpLnB1c2goYik7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBocyhzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSBLcChpLCBuKSwgYSA9IFkoRGUoKSksIGwgPSBIKERlKCkpLCBjID0gYFxuICAgICAgJHtyLm1hcCgoZCkgPT4gYFxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICR7ZC5tYXAoKF8pID0+IHtcbiAgICBjb25zdCBmID0gaS5tb250aHNTaG9ydC5pbmRleE9mKF8pO1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiJHtvLmRhdGVwaWNrZXJDZWxsfSAke28uZGF0ZXBpY2tlckNlbGxMYXJnZX1cIlxuICAgICAgICAgICAgICAgICR7Z2woXG4gICAgICBmLFxuICAgICAgcyxcbiAgICAgIGkubWluLFxuICAgICAgaS5tYXgsXG4gICAgICBpLmRpc2FibGVQYXN0LFxuICAgICAgaS5kaXNhYmxlRnV0dXJlXG4gICAgKSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YS10ZS1tb250aD1cIiR7Zn1cIiBkYXRhLXRlLXllYXI9XCIke3N9XCIgYXJpYS1sYWJlbD1cIiR7X30sICR7c31cIlxuICAgICAgICAgICAgICAgICR7ZiA9PT0gZSAmJiBzID09PSB0ID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgICAke2YgPT09IGEgJiYgcyA9PT0gbCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cIiBkYXRhLXRlLW1vbnRoPVwiJHtmfVwiIGRhdGEtdGUteWVhcj1cIiR7c31cIiBhcmlhLWxhYmVsPVwiJHtffSwgJHtzfVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZX1cIj4ke199PC9kaXY+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgYDtcbiAgfSkuam9pbihcIlwiKX1cbiAgICAgICAgICA8L3RyPlxuICAgICAgICBgKS5qb2luKFwiXCIpfVxuICAgIGA7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke28uZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAke2N9XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgIGA7XG59XG5mdW5jdGlvbiBLcChzLCB0KSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgbGV0IGkgPSBbXTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLm1vbnRoc1Nob3J0Lmxlbmd0aDsgbisrKVxuICAgIGlmIChpLnB1c2gocy5tb250aHNTaG9ydFtuXSksIGkubGVuZ3RoID09PSB0KSB7XG4gICAgICBjb25zdCBvID0gaTtcbiAgICAgIGUucHVzaChvKSwgaSA9IFtdO1xuICAgIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB1cyhzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSBVcChzLCBpLCBuKSwgYSA9IEgoRGUoKSksIGwgPSBgXG4gICAgJHtyLm1hcCgoYykgPT4gYFxuICAgICAgICA8dHI+XG4gICAgICAgICAgJHtjLm1hcCgoZCkgPT4gYFxuICAgICAgICAgICAgICA8dGQgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGx9ICR7by5kYXRlcGlja2VyQ2VsbExhcmdlfVwiICBhcmlhLWxhYmVsPVwiJHtkfVwiIGRhdGEtdGUteWVhcj1cIiR7ZH1cIlxuICAgICAgICAgICAgICAke0ZuKFxuICAgIGQsXG4gICAgZS5taW4sXG4gICAgZS5tYXgsXG4gICAgZS5kaXNhYmxlUGFzdCxcbiAgICBlLmRpc2FibGVGdXR1cmVcbiAgKSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7ZCA9PT0gdCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7ZCA9PT0gYSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGxDb250ZW50fSAke28uZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2V9XCI+JHtkfTwvZGl2PlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgYCkuam9pbihcIlwiKX1cbiAgICAgICAgPC90cj5cbiAgICAgIGApLmpvaW4oXCJcIil9XG4gIGA7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke28uZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICR7bH1cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgYDtcbn1cbmZ1bmN0aW9uIFVwKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IFtdLCBuID0gSChzKSwgbyA9IGNzKHMsIHQpLCByID0gbiAtIG87XG4gIGxldCBhID0gW107XG4gIGZvciAobGV0IGwgPSAwOyBsIDwgdDsgbCsrKVxuICAgIGlmIChhLnB1c2gociArIGwpLCBhLmxlbmd0aCA9PT0gZSkge1xuICAgICAgY29uc3QgYyA9IGE7XG4gICAgICBpLnB1c2goYyksIGEgPSBbXTtcbiAgICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24genAocywgdCkge1xuICByZXR1cm4gYFxuICAgIDxidXR0b24gaWQ9XCIke3N9XCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHt0fVwiIGRhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZiBkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLXJlZj5cbiAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk02Ljc1IDIuMjVBLjc1Ljc1IDAgMDE3LjUgM3YxLjVoOVYzQS43NS43NSAwIDAxMTggM3YxLjVoLjc1YTMgMyAwIDAxMyAzdjExLjI1YTMgMyAwIDAxLTMgM0g1LjI1YTMgMyAwIDAxLTMtM1Y3LjVhMyAzIDAgMDEzLTNINlYzYS43NS43NSAwIDAxLjc1LS43NXptMTMuNSA5YTEuNSAxLjUgMCAwMC0xLjUtMS41SDUuMjVhMS41IDEuNSAwIDAwLTEuNSAxLjV2Ny41YTEuNSAxLjUgMCAwMDEuNSAxLjVoMTMuNWExLjUgMS41IDAgMDAxLjUtMS41di03LjV6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICA8L3N2Zz4gIFxuICAgIDwvYnV0dG9uPlxuICBgO1xufVxuY29uc3QgSWUgPSAzNywgcnQgPSAzOCwgJGUgPSAzOSwgVSA9IDQwLCBMZSA9IDM2LCBNZSA9IDM1LCBobiA9IDMzLCB1biA9IDM0LCBsdCA9IDEzLCBwcyA9IDMyLCBJcyA9IDI3LCBmaSA9IDksIFhwID0gOCwgR3AgPSA0NiwgbXQgPSAyNCwgSGkgPSA0LCBCaSA9IDQsIHBuID0gXCJkYXRlcGlja2VyXCIsIGZzID0gXCJ0ZS5kYXRlcGlja2VyXCIsICRzID0gYC4ke2ZzfWAsIHFwID0gXCIuZGF0YS1hcGlcIiwgUXAgPSBgY2xvc2UkeyRzfWAsIFpwID0gYG9wZW4keyRzfWAsIEpwID0gYGRhdGVDaGFuZ2UkeyRzfWAsIFZpID0gYGNsaWNrJHskc30ke3FwfWAsIGJsID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItbW9kYWwtY29udGFpbmVyLXJlZlwiLCB2bCA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWRyb3Bkb3duLWNvbnRhaW5lci1yZWZcIiwgV2kgPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLXJlZl1cIiwgdGYgPSBgWyR7Ymx9XWAsIGVmID0gYFske3ZsfV1gLCBzZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci12aWV3LWNoYW5nZS1idXR0b24tcmVmXVwiLCBuZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1wcmV2aW91cy1idXR0b24tcmVmXVwiLCBvZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1uZXh0LWJ1dHRvbi1yZWZdXCIsIHJmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLW9rLWJ1dHRvbi1yZWZdXCIsIGFmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLWNhbmNlbC1idXR0b24tcmVmXVwiLCBsZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1jbGVhci1idXR0b24tcmVmXVwiLCBjZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci12aWV3LXJlZl1cIiwgZGYgPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLWJ1dHRvbi1yZWZdXCIsIGhmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLWRhdGUtdGV4dC1yZWZdXCIsIHVmID0gXCJbZGF0YS10ZS1kcm9wZG93bi1iYWNrZHJvcC1yZWZdXCIsIHBmID0gXCJhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIGZmID0gXCJhbmltYXRlLVtmYWRlLW91dF8wLjNzX2JvdGhdIHB4LVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLCBfZiA9IFwiYW5pbWF0ZS1bZmFkZS1pbl8wLjE1c19ib3RoXSBweC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIiwgbWYgPSBcImFuaW1hdGUtW2ZhZGUtb3V0XzAuMTVzX2JvdGhdIHB4LVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLCBnZiA9IFwiZmxleCBmbGV4LWNvbCBmaXhlZCB0b3AtMS8yIGxlZnQtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiB3LVszMjhweF0gaC1bNTEycHhdIGJnLXdoaXRlIHJvdW5kZWQtWzAuNnJlbV0gc2hhZG93LWxnIHotWzEwNjZdIHhzOm1heC1tZDpsYW5kc2NhcGU6dy1bNDc1cHhdIHhzOm1heC1tZDpsYW5kc2NhcGU6aC1bMzYwcHhdIHhzOm1heC1tZDpsYW5kc2NhcGU6ZmxleC1yb3cgZGFyazpiZy16aW5jLTcwMFwiLCBiZiA9IFwidy1mdWxsIGgtZnVsbCBmaXhlZCB0b3AtMCByaWdodC0wIGxlZnQtMCBib3R0b20tMCBiZy1ibGFjay80MCB6LVsxMDY1XVwiLCB2ZiA9IFwicmVsYXRpdmUgaC1mdWxsXCIsIEVmID0gXCJ4czptYXgtbWQ6bGFuZHNjYXBlOmgtZnVsbCBoLVsxMjBweF0gcHgtNiBiZy1wcmltYXJ5IGZsZXggZmxleC1jb2wgcm91bmRlZC10LWxnIGRhcms6YmctemluYy04MDBcIiwgVGYgPSBcImgtOCBmbGV4IGZsZXgtY29sIGp1c3RpZnktZW5kXCIsIENmID0gXCJ0ZXh0LVsxMHB4XSBmb250LW5vcm1hbCB1cHBlcmNhc2UgdHJhY2tpbmctWzEuN3B4XSB0ZXh0LXdoaXRlXCIsIEFmID0gXCJ4czptYXgtbWQ6bGFuZHNjYXBlOm10LTI0IGgtWzcycHhdIGZsZXggZmxleC1jb2wganVzdGlmeS1lbmRcIiwgeWYgPSBcInRleHQtWzM0cHhdIGZvbnQtbm9ybWFsIHRleHQtd2hpdGVcIiwgd2YgPSBcIm91dGxpbmUtbm9uZSBweC0zXCIsIGtmID0gXCJweC0zIHB0LTIuNSBwYi0wIGZsZXgganVzdGlmeS1iZXR3ZWVuIHRleHQtYmxhY2svWzY0XVwiLCBPZiA9IFwiZmxleCBpdGVtcy1jZW50ZXIgb3V0bGluZS1ub25lIHAtMi41IHRleHQtbmV1dHJhbC01MDAgZm9udC1tZWRpdW0gdGV4dC1bMC45cmVtXSByb3VuZGVkLXhsIHNoYWRvdy1ub25lIGJnLXRyYW5zcGFyZW50IG0tMCBib3JkZXItbm9uZSBob3ZlcjpiZy1uZXV0cmFsLTIwMCBmb2N1czpiZy1uZXV0cmFsLTIwMCAgZGFyazp0ZXh0LXdoaXRlIGRhcms6aG92ZXI6Ymctd2hpdGUvMTAgZGFyazpmb2N1czpiZy13aGl0ZS8xMFwiLCB4ZiA9IFwibXQtMi41XCIsIFNmID0gXCJwLTAgdy0xMCBoLTEwIGxlYWRpbmctMTAgYm9yZGVyLW5vbmUgb3V0bGluZS1ub25lIG0tMCB0ZXh0LWdyYXktNjAwIGJnLXRyYW5zcGFyZW50IG1yLTYgaG92ZXI6YmctbmV1dHJhbC0yMDAgaG92ZXI6cm91bmRlZC1bNTAlXSBmb2N1czpiZy1uZXV0cmFsLTIwMCBmb2N1czpyb3VuZGVkLVs1MCVdIGRhcms6dGV4dC13aGl0ZSBkYXJrOmhvdmVyOmJnLXdoaXRlLzEwIGRhcms6Zm9jdXM6Ymctd2hpdGUvMTAgWyY+c3ZnXTp3LTQgWyY+c3ZnXTpoLTQgWyY+c3ZnXTpteC1hdXRvXCIsIERmID0gXCJwLTAgdy0xMCBoLTEwIGxlYWRpbmctMTAgYm9yZGVyLW5vbmUgb3V0bGluZS1ub25lIG0tMCB0ZXh0LWdyYXktNjAwIGJnLXRyYW5zcGFyZW50IGhvdmVyOmJnLW5ldXRyYWwtMjAwIGhvdmVyOnJvdW5kZWQtWzUwJV0gZm9jdXM6YmctbmV1dHJhbC0yMDAgZm9jdXM6cm91bmRlZC1bNTAlXSBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwIFsmPnN2Z106dy00IFsmPnN2Z106aC00IFsmPnN2Z106cm90YXRlLTE4MCBbJj5zdmddOm14LWF1dG9cIiwgSWYgPSBcImgtMTQgZmxleCBhYnNvbHV0ZSB3LWZ1bGwgYm90dG9tLTAganVzdGlmeS1lbmQgaXRlbXMtY2VudGVyIHB4LTNcIiwgJGYgPSBcIm91dGxpbmUtbm9uZSBiZy13aGl0ZSB0ZXh0LXByaW1hcnkgYm9yZGVyLW5vbmUgY3Vyc29yLXBvaW50ZXIgcHktMCBweC0yLjUgdXBwZXJjYXNlIHRleHQtWzAuOHJlbV0gbGVhZGluZy0xMCBmb250LW1lZGl1bSBoLTEwIHRyYWNraW5nLVsuMXJlbV0gcm91bmRlZC1bMTBweF0gbWItMi41IGhvdmVyOmJnLW5ldXRyYWwtMjAwIGZvY3VzOmJnLW5ldXRyYWwtMjAwIGRhcms6YmctdHJhbnNwYXJlbnQgZGFyazp0ZXh0LXdoaXRlIGRhcms6aG92ZXI6Ymctd2hpdGUvMTAgZGFyazpmb2N1czpiZy13aGl0ZS8xMFwiLCBMZiA9IFwibXItYXV0b1wiLCBNZiA9IFwidy0xMCBoLTEwIHRleHQtY2VudGVyIHRleHQtWzEycHhdIGZvbnQtbm9ybWFsIGRhcms6dGV4dC13aGl0ZVwiLCBOZiA9IFwidGV4dC1jZW50ZXIgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTp0ZXh0LW5ldXRyYWwtMzAwIGRhdGEtW3RlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTpwb2ludGVyLWV2ZW50cy1ub25lIGRhdGEtW3RlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZF06aG92ZXI6Y3Vyc29yLWRlZmF1bHQgaG92ZXI6Y3Vyc29yLXBvaW50ZXIgZ3JvdXBcIiwgUmYgPSBcInctMTAgaC0xMCB4czptYXgtbWQ6bGFuZHNjYXBlOnctOCB4czptYXgtbWQ6bGFuZHNjYXBlOmgtOFwiLCBQZiA9IFwidy1bNzZweF0gaC1bNDJweF1cIiwgSGYgPSBcIm14LWF1dG8gZ3JvdXAtWzpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXSk6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pOmhvdmVyXTpiZy1uZXV0cmFsLTMwMCBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXV06YmctcHJpbWFyeSBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXV06dGV4dC13aGl0ZSBncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdKVtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXV06YmctbmV1dHJhbC0xMDAgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXV06ZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXTpiZy1wcmltYXJ5IGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudF1dOmJvcmRlci1zb2xpZCBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRdXTpib3JkZXItYmxhY2sgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyIGRhcms6Z3JvdXAtWzpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXSk6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pOmhvdmVyXTpiZy13aGl0ZS8xMCBkYXJrOmdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudF1dOmJvcmRlci13aGl0ZSBkYXJrOnRleHQtd2hpdGUgZGFyazpncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdKVtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXV06Ymctd2hpdGUvMTAgZGFyazpncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXV06dGV4dC1uZXV0cmFsLTUwMFwiLCBCZiA9IFwidy05IGgtOSBsZWFkaW5nLTkgcm91bmRlZC1bNTAlXSB0ZXh0LVsxM3B4XVwiLCBWZiA9IFwidy1bNzJweF0gaC0xMCBsZWFkaW5nLTEwIHB5LVsxcHhdIHB4LTAuNSByb3VuZGVkLVs5OTlweF1cIiwgV2YgPSBcIm14LWF1dG8gdy1bMzA0cHhdXCIsIEZmID0gXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyIFsmPnN2Z106dy01IFsmPnN2Z106aC01IGFic29sdXRlIG91dGxpbmUtbm9uZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCByaWdodC0wLjUgdG9wLTEvMiAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgaG92ZXI6dGV4dC1wcmltYXJ5IGZvY3VzOnRleHQtcHJpbWFyeSBkYXJrOmhvdmVyOnRleHQtcHJpbWFyeS00MDAgZGFyazpmb2N1czp0ZXh0LXByaW1hcnktNDAwIGRhcms6dGV4dC1uZXV0cmFsLTIwMFwiLCBZZiA9IFwiaW5saW5lLWJsb2NrIHBvaW50ZXItZXZlbnRzLW5vbmUgbWwtWzNweF0gWyY+c3ZnXTp3LTQgWyY+c3ZnXTpoLTQgWyY+c3ZnXTpmaWxsLW5ldXRyYWwtNTAwIGRhcms6WyY+c3ZnXTpmaWxsLXdoaXRlXCIsIGpmID0gXCJ3LVszMjhweF0gaC1bMzgwcHhdIGJnLXdoaXRlIHJvdW5kZWQtbGcgc2hhZG93LVswcHhfMnB4XzE1cHhfLTNweF9yZ2JhKDAsMCwwLC4wNyksXzBweF8xMHB4XzIwcHhfLTJweF9yZ2JhKDAsMCwwLC4wNCldIHotWzEwNjZdIGRhcms6YmctemluYy03MDBcIiwgS2YgPSB7XG4gIHRpdGxlOiBcIlNlbGVjdCBkYXRlXCIsXG4gIGNvbnRhaW5lcjogXCJib2R5XCIsXG4gIGRpc2FibGVQYXN0OiAhMSxcbiAgZGlzYWJsZUZ1dHVyZTogITEsXG4gIG1vbnRoc0Z1bGw6IFtcbiAgICBcIkphbnVhcnlcIixcbiAgICBcIkZlYnJ1YXJ5XCIsXG4gICAgXCJNYXJjaFwiLFxuICAgIFwiQXByaWxcIixcbiAgICBcIk1heVwiLFxuICAgIFwiSnVuZVwiLFxuICAgIFwiSnVseVwiLFxuICAgIFwiQXVndXN0XCIsXG4gICAgXCJTZXB0ZW1iZXJcIixcbiAgICBcIk9jdG9iZXJcIixcbiAgICBcIk5vdmVtYmVyXCIsXG4gICAgXCJEZWNlbWJlclwiXG4gIF0sXG4gIG1vbnRoc1Nob3J0OiBbXG4gICAgXCJKYW5cIixcbiAgICBcIkZlYlwiLFxuICAgIFwiTWFyXCIsXG4gICAgXCJBcHJcIixcbiAgICBcIk1heVwiLFxuICAgIFwiSnVuXCIsXG4gICAgXCJKdWxcIixcbiAgICBcIkF1Z1wiLFxuICAgIFwiU2VwXCIsXG4gICAgXCJPY3RcIixcbiAgICBcIk5vdlwiLFxuICAgIFwiRGVjXCJcbiAgXSxcbiAgd2Vla2RheXNGdWxsOiBbXG4gICAgXCJTdW5kYXlcIixcbiAgICBcIk1vbmRheVwiLFxuICAgIFwiVHVlc2RheVwiLFxuICAgIFwiV2VkbmVzZGF5XCIsXG4gICAgXCJUaHVyc2RheVwiLFxuICAgIFwiRnJpZGF5XCIsXG4gICAgXCJTYXR1cmRheVwiXG4gIF0sXG4gIHdlZWtkYXlzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgd2Vla2RheXNOYXJyb3c6IFtcIlNcIiwgXCJNXCIsIFwiVFwiLCBcIldcIiwgXCJUXCIsIFwiRlwiLCBcIlNcIl0sXG4gIG9rQnRuVGV4dDogXCJPa1wiLFxuICBjbGVhckJ0blRleHQ6IFwiQ2xlYXJcIixcbiAgY2FuY2VsQnRuVGV4dDogXCJDYW5jZWxcIixcbiAgb2tCdG5MYWJlbDogXCJDb25maXJtIHNlbGVjdGlvblwiLFxuICBjbGVhckJ0bkxhYmVsOiBcIkNsZWFyIHNlbGVjdGlvblwiLFxuICBjYW5jZWxCdG5MYWJlbDogXCJDYW5jZWwgc2VsZWN0aW9uXCIsXG4gIG5leHRNb250aExhYmVsOiBcIk5leHQgbW9udGhcIixcbiAgcHJldk1vbnRoTGFiZWw6IFwiUHJldmlvdXMgbW9udGhcIixcbiAgbmV4dFllYXJMYWJlbDogXCJOZXh0IHllYXJcIixcbiAgcHJldlllYXJMYWJlbDogXCJQcmV2aW91cyB5ZWFyXCIsXG4gIGNoYW5nZU1vbnRoSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy02IGgtNlwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE1Ljc1IDE5LjVMOC4yNSAxMmw3LjUtNy41XCIgLz5cbiAgPC9zdmc+XG4gIGAsXG4gIG5leHRNdWx0aVllYXJMYWJlbDogXCJOZXh0IDI0IHllYXJzXCIsXG4gIHByZXZNdWx0aVllYXJMYWJlbDogXCJQcmV2aW91cyAyNCB5ZWFyc1wiLFxuICBzd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbDogXCJDaG9vc2UgeWVhciBhbmQgbW9udGhcIixcbiAgc3dpdGNoVG9Nb250aFZpZXdMYWJlbDogXCJDaG9vc2UgZGF0ZVwiLFxuICBzd2l0Y2hUb0RheVZpZXdMYWJlbDogXCJDaG9vc2UgZGF0ZVwiLFxuICBzdGFydERhdGU6IG51bGwsXG4gIHN0YXJ0RGF5OiAwLFxuICBmb3JtYXQ6IFwiZGQvbW0veXl5eVwiLFxuICB2aWV3OiBcImRheXNcIixcbiAgdmlld0NoYW5nZUljb25UZW1wbGF0ZTogYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjBcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNiBoLTZcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xOS41IDguMjVsLTcuNSA3LjUtNy41LTcuNVwiIC8+XG4gIDwvc3ZnPlxuICBgLFxuICBtaW46IG51bGwsXG4gIG1heDogbnVsbCxcbiAgZmlsdGVyOiBudWxsLFxuICBpbmxpbmU6ICExLFxuICB0b2dnbGVCdXR0b246ICEwLFxuICBkaXNhYmxlVG9nZ2xlQnV0dG9uOiAhMSxcbiAgZGlzYWJsZUlucHV0OiAhMSxcbiAgYW5pbWF0aW9uczogITAsXG4gIGNvbmZpcm1EYXRlT25TZWxlY3Q6ICExLFxuICByZW1vdmVPa0J0bjogITEsXG4gIHJlbW92ZUNhbmNlbEJ0bjogITEsXG4gIHJlbW92ZUNsZWFyQnRuOiAhMVxufSwgVWYgPSB7XG4gIHRpdGxlOiBcInN0cmluZ1wiLFxuICBjb250YWluZXI6IFwic3RyaW5nXCIsXG4gIGRpc2FibGVQYXN0OiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZUZ1dHVyZTogXCJib29sZWFuXCIsXG4gIG1vbnRoc0Z1bGw6IFwiYXJyYXlcIixcbiAgbW9udGhzU2hvcnQ6IFwiYXJyYXlcIixcbiAgd2Vla2RheXNGdWxsOiBcImFycmF5XCIsXG4gIHdlZWtkYXlzU2hvcnQ6IFwiYXJyYXlcIixcbiAgd2Vla2RheXNOYXJyb3c6IFwiYXJyYXlcIixcbiAgb2tCdG5UZXh0OiBcInN0cmluZ1wiLFxuICBjbGVhckJ0blRleHQ6IFwic3RyaW5nXCIsXG4gIGNhbmNlbEJ0blRleHQ6IFwic3RyaW5nXCIsXG4gIG9rQnRuTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNsZWFyQnRuTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNhbmNlbEJ0bkxhYmVsOiBcInN0cmluZ1wiLFxuICBuZXh0TW9udGhMYWJlbDogXCJzdHJpbmdcIixcbiAgcHJldk1vbnRoTGFiZWw6IFwic3RyaW5nXCIsXG4gIG5leHRZZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIHByZXZZZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIG5leHRNdWx0aVllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgcHJldk11bHRpWWVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBjaGFuZ2VNb250aEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgc3dpdGNoVG9NdWx0aVllYXJWaWV3TGFiZWw6IFwic3RyaW5nXCIsXG4gIHN3aXRjaFRvTW9udGhWaWV3TGFiZWw6IFwic3RyaW5nXCIsXG4gIHN3aXRjaFRvRGF5Vmlld0xhYmVsOiBcInN0cmluZ1wiLFxuICBzdGFydERhdGU6IFwiKG51bGx8c3RyaW5nfGRhdGUpXCIsXG4gIHN0YXJ0RGF5OiBcIm51bWJlclwiLFxuICBmb3JtYXQ6IFwic3RyaW5nXCIsXG4gIHZpZXc6IFwic3RyaW5nXCIsXG4gIHZpZXdDaGFuZ2VJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIG1pbjogXCIobnVsbHxzdHJpbmd8ZGF0ZSlcIixcbiAgbWF4OiBcIihudWxsfHN0cmluZ3xkYXRlKVwiLFxuICBmaWx0ZXI6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGlubGluZTogXCJib29sZWFuXCIsXG4gIHRvZ2dsZUJ1dHRvbjogXCJib29sZWFuXCIsXG4gIGRpc2FibGVUb2dnbGVCdXR0b246IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlSW5wdXQ6IFwiYm9vbGVhblwiLFxuICBhbmltYXRpb25zOiBcImJvb2xlYW5cIixcbiAgY29uZmlybURhdGVPblNlbGVjdDogXCJib29sZWFuXCIsXG4gIHJlbW92ZU9rQnRuOiBcImJvb2xlYW5cIixcbiAgcmVtb3ZlQ2FuY2VsQnRuOiBcImJvb2xlYW5cIixcbiAgcmVtb3ZlQ2xlYXJCdG46IFwiYm9vbGVhblwiXG59LCB6ZiA9IHtcbiAgZmFkZUluOiBwZixcbiAgZmFkZU91dDogZmYsXG4gIGZhZGVJblNob3J0OiBfZixcbiAgZmFkZU91dFNob3J0OiBtZixcbiAgbW9kYWxDb250YWluZXI6IGdmLFxuICBkYXRlcGlja2VyQmFja2Ryb3A6IGJmLFxuICBkYXRlcGlja2VyTWFpbjogdmYsXG4gIGRhdGVwaWNrZXJIZWFkZXI6IEVmLFxuICBkYXRlcGlja2VyVGl0bGU6IFRmLFxuICBkYXRlcGlja2VyVGl0bGVUZXh0OiBDZixcbiAgZGF0ZXBpY2tlckRhdGU6IEFmLFxuICBkYXRlcGlja2VyRGF0ZVRleHQ6IHlmLFxuICBkYXRlcGlja2VyVmlldzogd2YsXG4gIGRhdGVwaWNrZXJEYXRlQ29udHJvbHM6IGtmLFxuICBkYXRlcGlja2VyVmlld0NoYW5nZUJ1dHRvbjogT2YsXG4gIGRhdGVwaWNrZXJWaWV3Q2hhbmdlSWNvbjogWWYsXG4gIGRhdGVwaWNrZXJBcnJvd0NvbnRyb2xzOiB4ZixcbiAgZGF0ZXBpY2tlclByZXZpb3VzQnV0dG9uOiBTZixcbiAgZGF0ZXBpY2tlck5leHRCdXR0b246IERmLFxuICBkYXRlcGlja2VyRm9vdGVyOiBJZixcbiAgZGF0ZXBpY2tlckZvb3RlckJ0bjogJGYsXG4gIGRhdGVwaWNrZXJDbGVhckJ0bjogTGYsXG4gIGRhdGVwaWNrZXJEYXlIZWFkaW5nOiBNZixcbiAgZGF0ZXBpY2tlckNlbGw6IE5mLFxuICBkYXRlcGlja2VyQ2VsbFNtYWxsOiBSZixcbiAgZGF0ZXBpY2tlckNlbGxMYXJnZTogUGYsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudDogSGYsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudFNtYWxsOiBCZixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2U6IFZmLFxuICBkYXRlcGlja2VyVGFibGU6IFdmLFxuICBkYXRlcGlja2VyVG9nZ2xlQnV0dG9uOiBGZixcbiAgZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyOiBqZlxufSwgWGYgPSB7XG4gIGZhZGVJbjogXCJzdHJpbmdcIixcbiAgZmFkZU91dDogXCJzdHJpbmdcIixcbiAgZmFkZUluU2hvcnQ6IFwic3RyaW5nXCIsXG4gIGZhZGVPdXRTaG9ydDogXCJzdHJpbmdcIixcbiAgbW9kYWxDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJCYWNrZHJvcDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlck1haW46IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJIZWFkZXI6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUaXRsZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRpdGxlVGV4dDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRhdGU6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEYXRlVGV4dDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclZpZXc6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEYXRlQ29udHJvbHM6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJWaWV3Q2hhbmdlQnV0dG9uOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQXJyb3dDb250cm9sczogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclByZXZpb3VzQnV0dG9uOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyTmV4dEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckZvb3RlcjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckZvb3RlckJ0bjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNsZWFyQnRuOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRGF5SGVhZGluZzogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGw6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsU21hbGw6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsTGFyZ2U6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50U21hbGw6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudExhcmdlOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVGFibGU6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUb2dnbGVCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEcm9wZG93bkNvbnRhaW5lcjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIEdnIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9pbnB1dCA9IGguZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fYWN0aXZlRGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX3ZpZXcgPSB0aGlzLl9vcHRpb25zLnZpZXcsIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGwsIHRoaXMuX2lzT3BlbiA9ICExLCB0aGlzLl90b2dnbGVCdXR0b25JZCA9IE90KFwiZGF0ZXBpY2tlci10b2dnbGUtXCIpLCB0aGlzLl9hbmltYXRpb25zID0gIXdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIikubWF0Y2hlcyAmJiB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbnMsIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBwaSgpLCB0aGlzLl9lbGVtZW50ICYmIEkuc2V0RGF0YSh0LCBmcywgdGhpcyksIHRoaXMuX2luaXQoKSwgdGhpcy50b2dnbGVCdXR0b24gJiYgdGhpcy5fb3B0aW9ucy5kaXNhYmxlVG9nZ2xlICYmICh0aGlzLnRvZ2dsZUJ1dHRvbi5kaXNhYmxlZCA9IFwidHJ1ZVwiKSwgdGhpcy5fb3B0aW9ucy5kaXNhYmxlSW5wdXQgJiYgKHRoaXMuX2lucHV0LmRpc2FibGVkID0gXCJ0cnVlXCIpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBwbjtcbiAgfVxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUoXG4gICAgICBgWyR7Ymx9PScke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfSddYFxuICAgICkgfHwgaC5maW5kT25lKFxuICAgICAgYFske3ZsfT0nJHt0aGlzLl90b2dnbGVCdXR0b25JZH0nXWBcbiAgICApO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIGdldCBhY3RpdmVDZWxsKCkge1xuICAgIGxldCB0O1xuICAgIHJldHVybiB0aGlzLl92aWV3ID09PSBcImRheXNcIiAmJiAodCA9IHRoaXMuX2dldEFjdGl2ZURheUNlbGwoKSksIHRoaXMuX3ZpZXcgPT09IFwibW9udGhzXCIgJiYgKHQgPSB0aGlzLl9nZXRBY3RpdmVNb250aENlbGwoKSksIHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiAmJiAodCA9IHRoaXMuX2dldEFjdGl2ZVllYXJDZWxsKCkpLCB0O1xuICB9XG4gIGdldCBhY3RpdmVEYXkoKSB7XG4gICAgcmV0dXJuIFEodGhpcy5fYWN0aXZlRGF0ZSk7XG4gIH1cbiAgZ2V0IGFjdGl2ZU1vbnRoKCkge1xuICAgIHJldHVybiBZKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG4gIGdldCBhY3RpdmVZZWFyKCkge1xuICAgIHJldHVybiBIKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG4gIGdldCBmaXJzdFllYXJJblZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlWWVhciAtIGNzKHRoaXMuX2FjdGl2ZURhdGUsIG10KTtcbiAgfVxuICBnZXQgbGFzdFllYXJJblZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RZZWFySW5WaWV3ICsgbXQgLSAxO1xuICB9XG4gIGdldCB2aWV3Q2hhbmdlQnV0dG9uKCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUoc2YsIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgcHJldmlvdXNCdXR0b24oKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShuZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBuZXh0QnV0dG9uKCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUob2YsIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgb2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShyZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBjYW5jZWxCdXR0b24oKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShhZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBjbGVhckJ1dHRvbigpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKGxmLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IGRhdGVzQ29udGFpbmVyKCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUoY2YsIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgdG9nZ2xlQnV0dG9uKCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUoZGYsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIHVwZGF0ZSh0ID0ge30pIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fb3B0aW9ucywgLi4udCB9KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodCA9IHtcbiAgICAgIC4uLktmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKHBuLCB0LCBVZiksIHQubWF4ICYmIHR5cGVvZiB0Lm1heCA9PSBcInN0cmluZ1wiICYmICh0Lm1heCA9IG5ldyBEYXRlKHQubWF4KSksIHQubWluICYmIHR5cGVvZiB0Lm1pbiA9PSBcInN0cmluZ1wiICYmICh0Lm1pbiA9IG5ldyBEYXRlKHQubWluKSksIHQuc3RhcnREYXkgJiYgdC5zdGFydERheSAhPT0gMCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dldE5ld0RheXNPcmRlckFycmF5KHQpO1xuICAgICAgdC53ZWVrZGF5c05hcnJvdyA9IGk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uemYsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4ocG4sIHQsIFhmKSwgdDtcbiAgfVxuICBfZ2V0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUodGhpcy5fb3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9nZXROZXdEYXlzT3JkZXJBcnJheSh0KSB7XG4gICAgY29uc3QgZSA9IHQuc3RhcnREYXksIGkgPSB0LndlZWtkYXlzTmFycm93O1xuICAgIHJldHVybiBpLnNsaWNlKGUpLmNvbmNhdChpLnNsaWNlKDAsIGUpKTtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICAhdGhpcy50b2dnbGVCdXR0b24gJiYgdGhpcy5fb3B0aW9ucy50b2dnbGVCdXR0b24gJiYgKHRoaXMuX2FwcGVuZFRvZ2dsZUJ1dHRvbigpLCAodGhpcy5faW5wdXQucmVhZE9ubHkgfHwgdGhpcy5faW5wdXQuZGlzYWJsZWQpICYmICh0aGlzLnRvZ2dsZUJ1dHRvbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIpKSwgdGhpcy5fbGlzdGVuVG9Vc2VySW5wdXQoKSwgdGhpcy5fbGlzdGVuVG9Ub2dnbGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKTtcbiAgfVxuICBfYXBwZW5kVG9nZ2xlQnV0dG9uKCkge1xuICAgIGNvbnN0IHQgPSB6cChcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlcy5kYXRlcGlja2VyVG9nZ2xlQnV0dG9uXG4gICAgKTtcbiAgICB0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCB0KTtcbiAgfVxuICBvcGVuKCkge1xuICAgIGlmICh0aGlzLl9pbnB1dC5yZWFkT25seSB8fCB0aGlzLl9pbnB1dC5kaXNhYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFpwKTtcbiAgICBpZiAodGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9zZXRJbml0aWFsRGF0ZSgpO1xuICAgIGNvbnN0IGUgPSBXcCh0aGlzLl9jbGFzc2VzLmRhdGVwaWNrZXJCYWNrZHJvcCksIGkgPSBWcChcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZERhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIEJpLFxuICAgICAgbXQsXG4gICAgICBIaSxcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5fb3B0aW9ucy5pbmxpbmUgPyB0aGlzLl9vcGVuRHJvcGRvd24oaSkgOiAodGhpcy5fb3Blbk1vZGFsKGUsIGkpLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpKSwgdGhpcy5fYW5pbWF0aW9ucyAmJiAocC5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pLCBwLmFkZENsYXNzKGUsIHRoaXMuX2NsYXNzZXMuZmFkZUluU2hvcnQpKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKHRoaXMuY29udGFpbmVyKSwgdGhpcy5fbGlzdGVuVG9EYXRlU2VsZWN0aW9uKCksIHRoaXMuX2FkZENvbnRyb2xzTGlzdGVuZXJzKCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpLCB0aGlzLl9saXN0ZW5Ub0VzY2FwZUNsaWNrKCksIHRoaXMuX2xpc3RlblRvS2V5Ym9hcmROYXZpZ2F0aW9uKCksIHRoaXMuX2xpc3RlblRvRGF0ZXNDb250YWluZXJGb2N1cygpLCB0aGlzLl9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyQmx1cigpLCB0aGlzLl9hc3luY0ZvY3VzRGF0ZXNDb250YWluZXIoKSwgdGhpcy5fdXBkYXRlVmlld0NvbnRyb2xzQW5kQXR0cmlidXRlcyh0aGlzLl92aWV3KSwgdGhpcy5faXNPcGVuID0gITAsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fbGlzdGVuVG9PdXRzaWRlQ2xpY2soKTtcbiAgICB9LCAwKTtcbiAgfVxuICBfb3BlbkRyb3Bkb3duKHQpIHtcbiAgICB0aGlzLl9wb3BwZXIgPSBqZSh0aGlzLl9pbnB1dCwgdCwge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiXG4gICAgfSksIHRoaXMuX2dldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKHQpO1xuICB9XG4gIF9vcGVuTW9kYWwodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICBpLmFwcGVuZENoaWxkKHQpLCBpLmFwcGVuZENoaWxkKGUpO1xuICB9XG4gIF9zZXRGb2N1c1RyYXAodCkge1xuICAgIHRoaXMuX2ZvY3VzVHJhcCA9IG5ldyBiaSh0LCB7XG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICBjb25kaXRpb246IChlKSA9PiBlLmtleSA9PT0gXCJUYWJcIlxuICAgIH0pLCB0aGlzLl9mb2N1c1RyYXAudHJhcCgpO1xuICB9XG4gIF9saXN0ZW5Ub1VzZXJJbnB1dCgpIHtcbiAgICB1Lm9uKHRoaXMuX2lucHV0LCBcImlucHV0XCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVVc2VySW5wdXQodC50YXJnZXQudmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUNsaWNrKCkge1xuICAgIHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgVmksXG4gICAgICBXaSxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9Ub2dnbGVLZXlkb3duKCkge1xuICAgIHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBXaSxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQua2V5Q29kZSA9PT0gbHQgJiYgIXRoaXMuX2lzT3BlbiAmJiB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub0RhdGVTZWxlY3Rpb24oKSB7XG4gICAgdS5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpIHtcbiAgICBjb25zdCBlID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldC5wYXJlbnROb2RlLmRhdGFzZXQgOiB0LnRhcmdldC5kYXRhc2V0LCBpID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldC5wYXJlbnROb2RlIDogdC50YXJnZXQ7XG4gICAgaWYgKGUudGVEYXRlICYmIHRoaXMuX3BpY2tEYXkoZS50ZURhdGUsIGkpLCBlLnRlTW9udGggJiYgZS50ZVllYXIpIHtcbiAgICAgIGNvbnN0IG4gPSBwYXJzZUludChlLnRlTW9udGgsIDEwKSwgbyA9IHBhcnNlSW50KGUudGVZZWFyLCAxMCk7XG4gICAgICB0aGlzLl9waWNrTW9udGgobiwgbyk7XG4gICAgfVxuICAgIGlmIChlLnRlWWVhciAmJiAhZS50ZU1vbnRoKSB7XG4gICAgICBjb25zdCBuID0gcGFyc2VJbnQoZS50ZVllYXIsIDEwKTtcbiAgICAgIHRoaXMuX3BpY2tZZWFyKG4pO1xuICAgIH1cbiAgICB0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl91cGRhdGVIZWFkZXJEYXRlKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnQsXG4gICAgICB0aGlzLl9vcHRpb25zLndlZWtkYXlzU2hvcnRcbiAgICApO1xuICB9XG4gIF91cGRhdGVIZWFkZXJEYXRlKHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gaC5maW5kT25lKFxuICAgICAgaGYsXG4gICAgICB0aGlzLmNvbnRhaW5lclxuICAgICksIG8gPSBZKHQpLCByID0gUSh0KSwgYSA9IGxzKHQpO1xuICAgIG4uaW5uZXJIVE1MID0gYCR7aVthXX0sICR7ZVtvXX0gJHtyfWA7XG4gIH1cbiAgX2FkZENvbnRyb2xzTGlzdGVuZXJzKCkge1xuICAgIHUub24odGhpcy5uZXh0QnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiID8gdGhpcy5uZXh0TW9udGgoKSA6IHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiA/IHRoaXMubmV4dFllYXJzKCkgOiB0aGlzLm5leHRZZWFyKCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpO1xuICAgIH0pLCB1Lm9uKHRoaXMucHJldmlvdXNCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdmlldyA9PT0gXCJkYXlzXCIgPyB0aGlzLnByZXZpb3VzTW9udGgoKSA6IHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiA/IHRoaXMucHJldmlvdXNZZWFycygpIDogdGhpcy5wcmV2aW91c1llYXIoKSwgdGhpcy5fdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCk7XG4gICAgfSksIHUub24odGhpcy52aWV3Q2hhbmdlQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiID8gdGhpcy5fY2hhbmdlVmlldyhcInllYXJzXCIpIDogKHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiB8fCB0aGlzLl92aWV3ID09PSBcIm1vbnRoc1wiKSAmJiB0aGlzLl9jaGFuZ2VWaWV3KFwiZGF5c1wiKTtcbiAgICB9KSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5fbGlzdGVuVG9Gb290ZXJCdXR0b25zQ2xpY2soKTtcbiAgfVxuICBfbGlzdGVuVG9Gb290ZXJCdXR0b25zQ2xpY2soKSB7XG4gICAgdS5vbih0aGlzLm9rQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHRoaXMuaGFuZGxlT2soKSksIHUub24odGhpcy5jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5oYW5kbGVDYW5jZWwoKSksIHUub24odGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLmhhbmRsZUNsZWFyKCkpO1xuICB9XG4gIF9saXN0ZW5Ub091dHNpZGVDbGljaygpIHtcbiAgICB1Lm9uKGRvY3VtZW50LCBWaSwgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnRhcmdldCA9PT0gdGhpcy5jb250YWluZXIsIGkgPSB0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5jb250YWlucyh0LnRhcmdldCk7XG4gICAgICAhZSAmJiAhaSAmJiB0aGlzLmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvRXNjYXBlQ2xpY2soKSB7XG4gICAgdS5vbihkb2N1bWVudCwgXCJrZXlkb3duXCIsICh0KSA9PiB7XG4gICAgICB0LmtleUNvZGUgPT09IElzICYmIHRoaXMuX2lzT3BlbiAmJiB0aGlzLmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvS2V5Ym9hcmROYXZpZ2F0aW9uKCkge1xuICAgIHUub24odGhpcy5kYXRlc0NvbnRhaW5lciwgXCJrZXlkb3duXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVLZXlkb3duKHQpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyRm9jdXMoKSB7XG4gICAgdS5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImZvY3VzXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyQmx1cigpIHtcbiAgICB1Lm9uKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlS2V5ZG93bih0KSB7XG4gICAgdGhpcy5fdmlldyA9PT0gXCJkYXlzXCIgJiYgdGhpcy5faGFuZGxlRGF5c1ZpZXdLZXlkb3duKHQpLCB0aGlzLl92aWV3ID09PSBcIm1vbnRoc1wiICYmIHRoaXMuX2hhbmRsZU1vbnRoc1ZpZXdLZXlkb3duKHQpLCB0aGlzLl92aWV3ID09PSBcInllYXJzXCIgJiYgdGhpcy5faGFuZGxlWWVhcnNWaWV3S2V5ZG93bih0KTtcbiAgfVxuICBfaGFuZGxlRGF5c1ZpZXdLZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fYWN0aXZlRGF0ZSwgaSA9IHRoaXMuYWN0aXZlQ2VsbDtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSBJZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IFRlKHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IDEgOiAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAkZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IFRlKHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IC0xIDogMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBydDpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IFRlKHRoaXMuX2FjdGl2ZURhdGUsIC03KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBUZSh0aGlzLl9hY3RpdmVEYXRlLCA3KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gVGUoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICAxIC0gUSh0aGlzLl9hY3RpdmVEYXRlKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTWU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBUZShcbiAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgICAgIFduKHRoaXMuX2FjdGl2ZURhdGUpIC0gUSh0aGlzLl9hY3RpdmVEYXRlKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaG46XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB1bjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbHQ6XG4gICAgICBjYXNlIHBzOlxuICAgICAgICB0aGlzLl9zZWxlY3REYXRlKHRoaXMuX2FjdGl2ZURhdGUpLCB0aGlzLl9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGkoXG4gICAgICBlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICBtdCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXhcbiAgICApIHx8IHRoaXMuX2NoYW5nZVZpZXcoXCJkYXlzXCIpLCB0aGlzLl9yZW1vdmVIaWdobGlnaHRGcm9tQ2VsbChpKSwgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKHRoaXMuYWN0aXZlQ2VsbCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfYXN5bmNGb2N1c0RhdGVzQ29udGFpbmVyKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kYXRlc0NvbnRhaW5lci5mb2N1cygpO1xuICAgIH0sIDApO1xuICB9XG4gIF9mb2N1c0FjdGl2ZUNlbGwodCkge1xuICAgIHQgJiYgdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXCIsIFwiXCIpO1xuICB9XG4gIF9yZW1vdmVIaWdobGlnaHRGcm9tQ2VsbCh0KSB7XG4gICAgdCAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRcIik7XG4gIH1cbiAgX2dldEFjdGl2ZURheUNlbGwoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZChcInRkXCIsIHRoaXMuZGF0ZXNDb250YWluZXIpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHQpLmZpbmQoKGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBFcihpLmRhdGFzZXQudGVEYXRlKTtcbiAgICAgIHJldHVybiBkZShuLCB0aGlzLl9hY3RpdmVEYXRlKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlTW9udGhzVmlld0tleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hY3RpdmVEYXRlLCBpID0gdGhpcy5hY3RpdmVDZWxsO1xuICAgIHN3aXRjaCAodC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEllOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gMSA6IC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICRlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gLTEgOiAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHJ0OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgLTQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIDQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAtdGhpcy5hY3RpdmVNb250aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIDExIC0gdGhpcy5hY3RpdmVNb250aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBobjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHVuOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBsdDpcbiAgICAgIGNhc2UgcHM6XG4gICAgICAgIHRoaXMuX3NlbGVjdE1vbnRoKHRoaXMuYWN0aXZlTW9udGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpKFxuICAgICAgZSxcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl92aWV3LFxuICAgICAgbXQsXG4gICAgICB0aGlzLl9vcHRpb25zLm1pbixcbiAgICAgIHRoaXMuX29wdGlvbnMubWF4XG4gICAgKSB8fCB0aGlzLl9jaGFuZ2VWaWV3KFwibW9udGhzXCIpLCB0aGlzLl9yZW1vdmVIaWdobGlnaHRGcm9tQ2VsbChpKSwgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKHRoaXMuYWN0aXZlQ2VsbCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfZ2V0QWN0aXZlTW9udGhDZWxsKCkge1xuICAgIGNvbnN0IHQgPSBoLmZpbmQoXCJ0ZFwiLCB0aGlzLmRhdGVzQ29udGFpbmVyKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0KS5maW5kKChpKSA9PiB7XG4gICAgICBjb25zdCBuID0gcGFyc2VJbnQoaS5kYXRhc2V0LnRlWWVhciwgMTApLCBvID0gcGFyc2VJbnQoaS5kYXRhc2V0LnRlTW9udGgsIDEwKTtcbiAgICAgIHJldHVybiBuID09PSB0aGlzLmFjdGl2ZVllYXIgJiYgbyA9PT0gdGhpcy5hY3RpdmVNb250aDtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlWWVhcnNWaWV3S2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZURhdGUsIGkgPSB0aGlzLmFjdGl2ZUNlbGwsIG4gPSA0LCBvID0gMjQ7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgSWU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAxIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJGU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcnQ6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAtbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBVOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgLWNzKHRoaXMuX2FjdGl2ZURhdGUsIG8pXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgbyAtIGNzKHRoaXMuX2FjdGl2ZURhdGUsIG8pIC0gMVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaG46XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAtbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB1bjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbHQ6XG4gICAgICBjYXNlIHBzOlxuICAgICAgICB0aGlzLl9zZWxlY3RZZWFyKHRoaXMuYWN0aXZlWWVhcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGkoXG4gICAgICBlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICBtdCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXhcbiAgICApIHx8IHRoaXMuX2NoYW5nZVZpZXcoXCJ5ZWFyc1wiKSwgdGhpcy5fcmVtb3ZlSGlnaGxpZ2h0RnJvbUNlbGwoaSksIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2dldEFjdGl2ZVllYXJDZWxsKCkge1xuICAgIGNvbnN0IHQgPSBoLmZpbmQoXCJ0ZFwiLCB0aGlzLmRhdGVzQ29udGFpbmVyKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0KS5maW5kKChpKSA9PiBwYXJzZUludChpLmRhdGFzZXQudGVZZWFyLCAxMCkgPT09IHRoaXMuYWN0aXZlWWVhcik7XG4gIH1cbiAgX3NldEluaXRpYWxEYXRlKCkge1xuICAgIHRoaXMuX2lucHV0LnZhbHVlID8gdGhpcy5faGFuZGxlVXNlcklucHV0KHRoaXMuX2lucHV0LnZhbHVlKSA6IHRoaXMuX29wdGlvbnMuc3RhcnREYXRlID8gdGhpcy5fYWN0aXZlRGF0ZSA9IG5ldyBEYXRlKHRoaXMuX29wdGlvbnMuc3RhcnREYXRlKSA6IHRoaXMuX2FjdGl2ZURhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCB0ID0gdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFFwKTtcbiAgICAhdGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fcmVtb3ZlRGF0ZXBpY2tlckxpc3RlbmVycygpLCB0aGlzLl9hbmltYXRpb25zICYmIHAuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCksIHRoaXMuX29wdGlvbnMuaW5saW5lID8gdGhpcy5fY2xvc2VEcm9wZG93bigpIDogdGhpcy5fY2xvc2VNb2RhbCgpLCB0aGlzLl9pc09wZW4gPSAhMSwgdGhpcy5fdmlldyA9IHRoaXMuX29wdGlvbnMudmlldywgdGhpcy50b2dnbGVCdXR0b24gPyB0aGlzLnRvZ2dsZUJ1dHRvbi5mb2N1cygpIDogdGhpcy5faW5wdXQuZm9jdXMoKSk7XG4gIH1cbiAgX2Nsb3NlRHJvcGRvd24oKSB7XG4gICAgY29uc3QgdCA9IGguZmluZE9uZShlZik7XG4gICAgd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKS5tYXRjaGVzICYmICh0ICYmIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodCksIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpKSwgdC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHQgJiYgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgfSksIHRoaXMuX3JlbW92ZUZvY3VzVHJhcCgpO1xuICB9XG4gIF9jbG9zZU1vZGFsKCkge1xuICAgIGNvbnN0IHQgPSBoLmZpbmRPbmUodWYpLCBlID0gaC5maW5kT25lKHRmKTtcbiAgICAhZSB8fCAhdCB8fCAodGhpcy5fYW5pbWF0aW9ucyA/IChwLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dFNob3J0KSwgdC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZVBpY2tlcih0LCBlKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgfSkpIDogKHRoaXMuX3JlbW92ZVBpY2tlcih0LCBlKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCkpKTtcbiAgfVxuICBfcmVtb3ZlUGlja2VyKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgaS5yZW1vdmVDaGlsZCh0KSwgaS5yZW1vdmVDaGlsZChlKTtcbiAgfVxuICBfcmVtb3ZlRm9jdXNUcmFwKCkge1xuICAgIHRoaXMuX2ZvY3VzVHJhcCAmJiAodGhpcy5fZm9jdXNUcmFwLmRpc2FibGUoKSwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCk7XG4gIH1cbiAgX3JlbW92ZURhdGVwaWNrZXJMaXN0ZW5lcnMoKSB7XG4gICAgdS5vZmYodGhpcy5uZXh0QnV0dG9uLCBcImNsaWNrXCIpLCB1Lm9mZih0aGlzLnByZXZpb3VzQnV0dG9uLCBcImNsaWNrXCIpLCB1Lm9mZih0aGlzLnZpZXdDaGFuZ2VCdXR0b24sIFwiY2xpY2tcIiksIHUub2ZmKHRoaXMub2tCdXR0b24sIFwiY2xpY2tcIiksIHUub2ZmKHRoaXMuY2FuY2VsQnV0dG9uLCBcImNsaWNrXCIpLCB1Lm9mZih0aGlzLmNsZWFyQnV0dG9uLCBcImNsaWNrXCIpLCB1Lm9mZih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImNsaWNrXCIpLCB1Lm9mZih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImtleWRvd25cIiksIHUub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiZm9jdXNcIiksIHUub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiYmx1clwiKSwgdS5vZmYoZG9jdW1lbnQsIFZpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2lzT3BlbiAmJiB0aGlzLmNsb3NlKCksIHRoaXMuX3JlbW92ZUlucHV0QW5kVG9nZ2xlTGlzdGVuZXJzKCk7XG4gICAgY29uc3QgdCA9IGguZmluZE9uZShcbiAgICAgIGAjJHt0aGlzLl90b2dnbGVCdXR0b25JZH1gXG4gICAgKTtcbiAgICB0ICYmIHRoaXMuX2VsZW1lbnQucmVtb3ZlQ2hpbGQodCksIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBmcyksIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9pbnB1dCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsLCB0aGlzLl9hY3RpdmVEYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuX2hlYWRlckRhdGUgPSBudWxsLCB0aGlzLl9oZWFkZXJZZWFyID0gbnVsbCwgdGhpcy5faGVhZGVyTW9udGggPSBudWxsLCB0aGlzLl92aWV3ID0gbnVsbCwgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbDtcbiAgfVxuICBfcmVtb3ZlSW5wdXRBbmRUb2dnbGVMaXN0ZW5lcnMoKSB7XG4gICAgdS5vZmYodGhpcy5faW5wdXQsIFwiaW5wdXRcIiksIHUub2ZmKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFZpLFxuICAgICAgV2lcbiAgICApLCB1Lm9mZih0aGlzLl9lbGVtZW50LCBcImtleWRvd25cIiwgV2kpO1xuICB9XG4gIGhhbmRsZU9rKCkge1xuICAgIHRoaXMuX2NvbmZpcm1TZWxlY3Rpb24odGhpcy5faGVhZGVyRGF0ZSksIHRoaXMuY2xvc2UoKTtcbiAgfVxuICBfc2VsZWN0RGF0ZSh0LCBlID0gdGhpcy5hY3RpdmVDZWxsKSB7XG4gICAgY29uc3QgeyBtaW46IGksIG1heDogbiwgZmlsdGVyOiBvLCBkaXNhYmxlUGFzdDogciwgZGlzYWJsZUZ1dHVyZTogYSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBBcyh0LCBpLCBuLCBvLCByLCBhKSB8fCAodGhpcy5fcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpLCB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKSwgdGhpcy5fYWRkU2VsZWN0ZWRTdHlsZXMoZSksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IHQsIHRoaXMuX3NlbGVjdGVkWWVhciA9IEgodCksIHRoaXMuX3NlbGVjdGVkTW9udGggPSBZKHQpLCB0aGlzLl9oZWFkZXJEYXRlID0gdCwgKHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMub3B0aW9ucy5jb25maXJtRGF0ZU9uU2VsZWN0KSAmJiAodGhpcy5fY29uZmlybVNlbGVjdGlvbih0KSwgdGhpcy5jbG9zZSgpKSk7XG4gIH1cbiAgX3NlbGVjdFllYXIodCwgZSA9IHRoaXMuYWN0aXZlQ2VsbCkge1xuICAgIHRoaXMuX3JlbW92ZUN1cnJlbnRTZWxlY3Rpb25TdHlsZXMoKSwgdGhpcy5fcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCksIHRoaXMuX2FkZFNlbGVjdGVkU3R5bGVzKGUpLCB0aGlzLl9oZWFkZXJZZWFyID0gdCwgdGhpcy5fYXN5bmNDaGFuZ2VWaWV3KFwibW9udGhzXCIpO1xuICB9XG4gIF9zZWxlY3RNb250aCh0LCBlID0gdGhpcy5hY3RpdmVDZWxsKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpLCB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKSwgdGhpcy5fYWRkU2VsZWN0ZWRTdHlsZXMoZSksIHRoaXMuX2hlYWRlck1vbnRoID0gdCwgdGhpcy5fYXN5bmNDaGFuZ2VWaWV3KFwiZGF5c1wiKTtcbiAgfVxuICBfcmVtb3ZlU2VsZWN0ZWRTdHlsZXModCkge1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiKTtcbiAgfVxuICBfYWRkU2VsZWN0ZWRTdHlsZXModCkge1xuICAgIHQgJiYgdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiLCBcIlwiKTtcbiAgfVxuICBfY29uZmlybVNlbGVjdGlvbih0KSB7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLmZvcm1hdERhdGUodCk7XG4gICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IGUsIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBKcCwgeyBkYXRlOiB0IH0pLCB1LnRyaWdnZXIodGhpcy5faW5wdXQsIFwiaW5wdXRcIik7XG4gICAgfVxuICB9XG4gIGhhbmRsZUNhbmNlbCgpIHtcbiAgICB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5jbG9zZSgpO1xuICB9XG4gIGhhbmRsZUNsZWFyKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5faGVhZGVyTW9udGggPSBudWxsLCB0aGlzLl9oZWFkZXJZZWFyID0gbnVsbCwgdGhpcy5fcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpLCB0aGlzLl9pbnB1dC52YWx1ZSA9IFwiXCIsIHRoaXMuX3NldEluaXRpYWxEYXRlKCksIHRoaXMuX2NoYW5nZVZpZXcoXCJkYXlzXCIpLCB0aGlzLl91cGRhdGVIZWFkZXJEYXRlKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnQsXG4gICAgICB0aGlzLl9vcHRpb25zLndlZWtkYXlzU2hvcnRcbiAgICApO1xuICB9XG4gIF9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCkge1xuICAgIGNvbnN0IHQgPSBoLmZpbmRPbmUoXG4gICAgICBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF1cIixcbiAgICAgIHRoaXMuY29udGFpbmVyXG4gICAgKTtcbiAgICB0ICYmIHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIik7XG4gIH1cbiAgX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpIHtcbiAgICBjb25zdCB0ID0gaC5maW5kT25lKFxuICAgICAgXCJbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZF1cIixcbiAgICAgIHRoaXMuY29udGFpbmVyXG4gICAgKTtcbiAgICB0ICYmIHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZFwiKTtcbiAgfVxuICBmb3JtYXREYXRlKHQpIHtcbiAgICBjb25zdCBlID0gUSh0KSwgaSA9IHRoaXMuX2FkZExlYWRpbmdaZXJvKFEodCkpLCBuID0gdGhpcy5fb3B0aW9ucy53ZWVrZGF5c1Nob3J0W2xzKHQpXSwgbyA9IHRoaXMuX29wdGlvbnMud2Vla2RheXNGdWxsW2xzKHQpXSwgciA9IFkodCkgKyAxLCBhID0gdGhpcy5fYWRkTGVhZGluZ1plcm8oWSh0KSArIDEpLCBsID0gdGhpcy5fb3B0aW9ucy5tb250aHNTaG9ydFtZKHQpXSwgYyA9IHRoaXMuX29wdGlvbnMubW9udGhzRnVsbFtZKHQpXSwgZCA9IEgodCkudG9TdHJpbmcoKS5sZW5ndGggPT09IDIgPyBIKHQpIDogSCh0KS50b1N0cmluZygpLnNsaWNlKDIsIDQpLCBfID0gSCh0KSwgZiA9IHRoaXMuX29wdGlvbnMuZm9ybWF0LnNwbGl0KFxuICAgICAgLyhkezEsNH18bXsxLDR9fHl7NH18eXl8IS4pL2dcbiAgICApO1xuICAgIGxldCBtID0gXCJcIjtcbiAgICByZXR1cm4gZi5mb3JFYWNoKChnKSA9PiB7XG4gICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgY2FzZSBcImRkZGRcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIG8pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGRkXCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCBuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCBpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW1tbVwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtbW1cIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICBnID0gZy5yZXBsYWNlKGcsIGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIGcgPSBnLnJlcGxhY2UoZywgcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCBfKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgICAgZyA9IGcucmVwbGFjZShnLCBkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG0gKz0gZztcbiAgICB9KSwgbTtcbiAgfVxuICBfYWRkTGVhZGluZ1plcm8odCkge1xuICAgIHJldHVybiBwYXJzZUludCh0LCAxMCkgPCAxMCA/IGAwJHt0fWAgOiB0O1xuICB9XG4gIF9waWNrRGF5KHQsIGUpIHtcbiAgICBjb25zdCBpID0gRXIodCksIHsgbWluOiBuLCBtYXg6IG8sIGZpbHRlcjogciwgZGlzYWJsZVBhc3Q6IGEsIGRpc2FibGVGdXR1cmU6IGwgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgQXMoaSwgbiwgbywgciwgYSwgbCkgfHwgKHRoaXMuX2FjdGl2ZURhdGUgPSBpLCB0aGlzLl9zZWxlY3REYXRlKGksIGUpKTtcbiAgfVxuICBfcGlja1llYXIodCkge1xuICAgIGNvbnN0IHsgbWluOiBlLCBtYXg6IGksIGRpc2FibGVQYXN0OiBuLCBkaXNhYmxlRnV0dXJlOiBvIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGlmIChGbih0LCBlLCBpLCBuLCBvKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gRHQodCwgdGhpcy5hY3RpdmVNb250aCwgdGhpcy5hY3RpdmVEYXkpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSByLCB0aGlzLl9zZWxlY3RlZERhdGUgPSByLCB0aGlzLl9zZWxlY3RZZWFyKHQpO1xuICB9XG4gIF9waWNrTW9udGgodCwgZSkge1xuICAgIGNvbnN0IHsgbWluOiBpLCBtYXg6IG4sIGRpc2FibGVQYXN0OiBvLCBkaXNhYmxlRnV0dXJlOiByIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGlmIChnbCh0LCBlLCBpLCBuLCBvLCByKSB8fCBGbihlLCBpLCBuLCBvLCByKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0gRHQoZSwgdCwgdGhpcy5hY3RpdmVEYXkpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBhLCB0aGlzLl9zZWxlY3RNb250aCh0KTtcbiAgfVxuICBuZXh0TW9udGgoKSB7XG4gICAgY29uc3QgdCA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIDEpLCBlID0gZHMoXG4gICAgICB0LFxuICAgICAgdGhpcy5faGVhZGVyRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5fb3B0aW9ucy5tb250aHNGdWxsW3RoaXMuYWN0aXZlTW9udGhdfSAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IGt0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgcHJldmlvdXNNb250aCgpIHtcbiAgICBjb25zdCB0ID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgLTEpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0O1xuICAgIGNvbnN0IGUgPSBkcyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9oZWFkZXJEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuX29wdGlvbnMubW9udGhzRnVsbFt0aGlzLmFjdGl2ZU1vbnRoXX0gJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBrdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIG5leHRZZWFyKCkge1xuICAgIGNvbnN0IHQgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAxKTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0ga3QoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgY29uc3QgZSA9IGhzKFxuICAgICAgdGhpcy5hY3RpdmVZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRNb250aCxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBCaSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBwcmV2aW91c1llYXIoKSB7XG4gICAgY29uc3QgdCA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0ga3QoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgY29uc3QgZSA9IGhzKFxuICAgICAgdGhpcy5hY3RpdmVZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRNb250aCxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBCaSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBuZXh0WWVhcnMoKSB7XG4gICAgY29uc3QgdCA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIDI0KTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdDtcbiAgICBjb25zdCBlID0gdXMoXG4gICAgICB0LFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIG10LFxuICAgICAgSGksXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmZpcnN0WWVhckluVmlld30gLSAke3RoaXMubGFzdFllYXJJblZpZXd9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBrdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIHByZXZpb3VzWWVhcnMoKSB7XG4gICAgY29uc3QgdCA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIC0yNCk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQ7XG4gICAgY29uc3QgZSA9IHVzKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBtdCxcbiAgICAgIEhpLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5maXJzdFllYXJJblZpZXd9IC0gJHt0aGlzLmxhc3RZZWFySW5WaWV3fWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0ga3QoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBfYXN5bmNDaGFuZ2VWaWV3KHQpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2NoYW5nZVZpZXcodCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX2NoYW5nZVZpZXcodCkge1xuICAgIHRoaXMuX3ZpZXcgPSB0LCB0aGlzLmRhdGVzQ29udGFpbmVyLmJsdXIoKSwgdCA9PT0gXCJkYXlzXCIgJiYgKHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZHMoXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5faGVhZGVyRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSksIHQgPT09IFwibW9udGhzXCIgJiYgKHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gaHMoXG4gICAgICB0aGlzLmFjdGl2ZVllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIEJpLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICkpLCB0ID09PSBcInllYXJzXCIgJiYgKHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gdXMoXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIG10LFxuICAgICAgSGksXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSksIHRoaXMuZGF0ZXNDb250YWluZXIuZm9jdXMoKSwgdGhpcy5fdXBkYXRlVmlld0NvbnRyb2xzQW5kQXR0cmlidXRlcyh0KSwgdGhpcy5fdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCk7XG4gIH1cbiAgX3VwZGF0ZVZpZXdDb250cm9sc0FuZEF0dHJpYnV0ZXModCkge1xuICAgIHQgPT09IFwiZGF5c1wiICYmICh0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGxbdGhpcy5hY3RpdmVNb250aF19ICR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0ga3QoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3dpdGNoVG9NdWx0aVllYXJWaWV3TGFiZWxcbiAgICApLCB0aGlzLnByZXZpb3VzQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5wcmV2TW9udGhMYWJlbFxuICAgICksIHRoaXMubmV4dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMuX29wdGlvbnMubmV4dE1vbnRoTGFiZWwpKSwgdCA9PT0gXCJtb250aHNcIiAmJiAodGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0ga3QoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3dpdGNoVG9EYXlWaWV3TGFiZWxcbiAgICApLCB0aGlzLnByZXZpb3VzQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5wcmV2WWVhckxhYmVsXG4gICAgKSwgdGhpcy5uZXh0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5fb3B0aW9ucy5uZXh0WWVhckxhYmVsKSksIHQgPT09IFwieWVhcnNcIiAmJiAodGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5maXJzdFllYXJJblZpZXd9IC0gJHt0aGlzLmxhc3RZZWFySW5WaWV3fWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0ga3QoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3dpdGNoVG9Nb250aFZpZXdMYWJlbFxuICAgICksIHRoaXMucHJldmlvdXNCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnByZXZNdWx0aVllYXJMYWJlbFxuICAgICksIHRoaXMubmV4dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMubmV4dE11bHRpWWVhckxhYmVsXG4gICAgKSk7XG4gIH1cbiAgX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpIHtcbiAgICB4cChcbiAgICAgIHRoaXMuX29wdGlvbnMuZGlzYWJsZUZ1dHVyZSxcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl92aWV3LFxuICAgICAgbXQsXG4gICAgICB0aGlzLl9vcHRpb25zLm1pbixcbiAgICAgIHRoaXMuX29wdGlvbnMubWF4LFxuICAgICAgdGhpcy5sYXN0WWVhckluVmlldyxcbiAgICAgIHRoaXMuZmlyc3RZZWFySW5WaWV3XG4gICAgKSA/IHRoaXMubmV4dEJ1dHRvbi5kaXNhYmxlZCA9ICEwIDogdGhpcy5uZXh0QnV0dG9uLmRpc2FibGVkID0gITEsIFNwKFxuICAgICAgdGhpcy5fb3B0aW9ucy5kaXNhYmxlUGFzdCxcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl92aWV3LFxuICAgICAgbXQsXG4gICAgICB0aGlzLl9vcHRpb25zLm1pbixcbiAgICAgIHRoaXMuX29wdGlvbnMubWF4LFxuICAgICAgdGhpcy5sYXN0WWVhckluVmlldyxcbiAgICAgIHRoaXMuZmlyc3RZZWFySW5WaWV3XG4gICAgKSA/IHRoaXMucHJldmlvdXNCdXR0b24uZGlzYWJsZWQgPSAhMCA6IHRoaXMucHJldmlvdXNCdXR0b24uZGlzYWJsZWQgPSAhMTtcbiAgfVxuICBfaGFuZGxlVXNlcklucHV0KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0RGVsaW1ldGVycyh0aGlzLl9vcHRpb25zLmZvcm1hdCksIGkgPSB0aGlzLl9wYXJzZURhdGUodCwgdGhpcy5fb3B0aW9ucy5mb3JtYXQsIGUpO1xuICAgIHdwKGkpID8gKHRoaXMuX2FjdGl2ZURhdGUgPSBpLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBpLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBIKGkpLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gWShpKSwgdGhpcy5faGVhZGVyRGF0ZSA9IGkpIDogKHRoaXMuX2FjdGl2ZURhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgdGhpcy5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlckRhdGUgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsKTtcbiAgfVxuICBfZ2V0RGVsaW1ldGVycyh0KSB7XG4gICAgcmV0dXJuIHQubWF0Y2goL1teKGRteSldezEsfS9nKTtcbiAgfVxuICBfcGFyc2VEYXRlKHQsIGUsIGkpIHtcbiAgICBsZXQgbjtcbiAgICBpWzBdICE9PSBpWzFdID8gbiA9IGlbMF0gKyBpWzFdIDogbiA9IGlbMF07XG4gICAgY29uc3QgbyA9IG5ldyBSZWdFeHAoYFske259XWApLCByID0gdC5zcGxpdChvKSwgYSA9IGUuc3BsaXQobyksIGwgPSBlLmluZGV4T2YoXCJtbW1cIikgIT09IC0xLCBjID0gW107XG4gICAgZm9yIChsZXQgYiA9IDA7IGIgPCBhLmxlbmd0aDsgYisrKVxuICAgICAgYVtiXS5pbmRleE9mKFwieXlcIikgIT09IC0xICYmIChjWzBdID0geyB2YWx1ZTogcltiXSwgZm9ybWF0OiBhW2JdIH0pLCBhW2JdLmluZGV4T2YoXCJtXCIpICE9PSAtMSAmJiAoY1sxXSA9IHsgdmFsdWU6IHJbYl0sIGZvcm1hdDogYVtiXSB9KSwgYVtiXS5pbmRleE9mKFwiZFwiKSAhPT0gLTEgJiYgYVtiXS5sZW5ndGggPD0gMiAmJiAoY1syXSA9IHsgdmFsdWU6IHJbYl0sIGZvcm1hdDogYVtiXSB9KTtcbiAgICBsZXQgZDtcbiAgICBlLmluZGV4T2YoXCJtbW1tXCIpICE9PSAtMSA/IGQgPSB0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGwgOiBkID0gdGhpcy5fb3B0aW9ucy5tb250aHNTaG9ydDtcbiAgICBjb25zdCBfID0gTnVtYmVyKGNbMF0udmFsdWUpLCBmID0gbCA/IHRoaXMuZ2V0TW9udGhOdW1iZXJCeU1vbnRoTmFtZShjWzFdLnZhbHVlLCBkKSA6IE51bWJlcihjWzFdLnZhbHVlKSAtIDEsIG0gPSBOdW1iZXIoY1syXS52YWx1ZSk7XG4gICAgcmV0dXJuIER0KF8sIGYsIG0pO1xuICB9XG4gIGdldE1vbnRoTnVtYmVyQnlNb250aE5hbWUodCwgZSkge1xuICAgIHJldHVybiBlLmZpbmRJbmRleCgoaSkgPT4gaSA9PT0gdCk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIGZzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBHZiA9ICh7XG4gIGZvcm1hdDI0OiBzLFxuICBva0xhYmVsOiB0LFxuICBjYW5jZWxMYWJlbDogZSxcbiAgaGVhZElEOiBpLFxuICBmb290ZXJJRDogbixcbiAgYm9keUlEOiBvLFxuICBwaWNrZXJJRDogcixcbiAgY2xlYXJMYWJlbDogYSxcbiAgaW5saW5lOiBsLFxuICBzaG93Q2xlYXJCdG46IGMsXG4gIGFtTGFiZWw6IGQsXG4gIHBtTGFiZWw6IF9cbn0sIGYpID0+IHtcbiAgY29uc3QgbSA9IGA8ZGl2IGlkPScke3J9JyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJXcmFwcGVyfScgZGF0YS10ZS10aW1lcGlja2VyLXdyYXBwZXI+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDb250YWluZXJ9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlckVsZW1lbnRzfVwiPlxuICAgICAgICA8ZGl2IGlkPScke2l9JyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJIZWFkfScgc3R5bGU9J3BhZGRpbmctcmlnaHQ6JHtzID8gNTAgOiAxMH1weCc+XG4gICAgICAgIDxkaXYgY2xhc3M9JyR7Zi50aW1lcGlja2VySGVhZENvbnRlbnR9Jz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlckN1cnJlbnRXcmFwcGVyfVwiPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ3VycmVudEJ1dHRvbldyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlckN1cnJlbnRCdXR0b259JyB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXRpbWVwaWNrZXItYWN0aXZlIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50IGRhdGEtdGUtdGltZXBpY2tlci1ob3VyIGRhdGEtdGUtcmlwcGxlLWluaXQ+MjE8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VyRG90fScgZGlzYWJsZWQ+OjwvYnV0dG9uPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlckN1cnJlbnRCdXR0b25XcmFwcGVyfVwiPlxuICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VyQ3VycmVudEJ1dHRvbn0nIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50IGRhdGEtdGUtdGltZXBpY2tlci1taW51dGUgZGF0YS10ZS1yaXBwbGUtaW5pdD4yMTwvYnV0dG9uPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAke3MgPyBcIlwiIDogYDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlck1vZGVXcmFwcGVyfVwiPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJNb2RlQW19XCIgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS10aW1lcGlja2VyLWFtIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyLW1vZGUgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke2R9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJNb2RlUG19XCIgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS10aW1lcGlja2VyLXBtIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyLW1vZGUgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke199PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+YH1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgICR7bCA/IFwiXCIgOiBgPGRpdiBpZD0nJHtvfScgY2xhc3M9JyR7Zi50aW1lcGlja2VyQ2xvY2tXcmFwcGVyfScgZGF0YS10ZS10aW1lcGlja2VyLWNsb2NrLXdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPScke2YudGltZXBpY2tlckNsb2NrfScgZGF0YS10ZS10aW1lcGlja2VyLWNsb2NrPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJNaWRkbGVEb3R9JyBkYXRhLXRlLXRpbWVwaWNrZXItbWlkZGxlLWRvdD48L3NwYW4+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9JyR7Zi50aW1lcGlja2VySGFuZFBvaW50ZXJ9JyBkYXRhLXRlLXRpbWVwaWNrZXItaGFuZC1wb2ludGVyPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9JyR7Zi50aW1lcGlja2VyUG9pbnRlckNpcmNsZX0nIGRhdGEtdGUtdGltZXBpY2tlci1jaXJjbGU+PC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAke3MgPyAnPGRpdiBjbGFzcz1cIicgKyBmLnRpbWVwaWNrZXJDbG9ja0lubmVyICsgJ1wiIGRhdGEtdGUtdGltZXBpY2tlci1jbG9jay1pbm5lcj48L2Rpdj4nIDogXCJcIn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PmB9XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD0nJHtufScgY2xhc3M9JyR7Zi50aW1lcGlja2VyRm9vdGVyV3JhcHBlcn0nPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyRm9vdGVyfVwiPlxuICAgICAgICAke2MgPyBgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlckZvb3RlckJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1jbGVhciB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7YX08L2J1dHRvbj5gIDogXCJcIn1cbiAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlckZvb3RlckJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1jYW5jZWwgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke2V9PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJGb290ZXJCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItc3VibWl0IHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt0fTwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+YCwgZyA9IGA8ZGl2IGlkPScke3J9JyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVXcmFwcGVyfScgZGF0YS10ZS10aW1lcGlja2VyLXdyYXBwZXI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUNvbnRhaW5lcn1cIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVFbGVtZW50c31cIj5cbiAgICAgICAgICA8ZGl2IGlkPScke2l9JyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVIZWFkfSdcbiAgICAgICAgICBzdHlsZT0ncGFkZGluZy1yaWdodDoxMHB4Jz5cbiAgICAgICAgICA8ZGl2IGNsYXNzPScke2YudGltZXBpY2tlcklubGluZUhlYWRDb250ZW50fSc+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlckN1cnJlbnRXcmFwcGVyfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVIb3VyV3JhcHBlcn1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaW5saW5lLWhvdXItaWNvbnM+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvblVwfVwiIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLXVwIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWlubGluZS1ob3VyPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvblN2Z31cIj5cbiAgICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNSBoLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTQuNSAxNS43NWw3LjUtNy41IDcuNSA3LjVcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPiAgIFxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lQ3VycmVudEJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50IGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50LWlubGluZSB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PjIxPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvbkRvd259XCIgZGF0YS10ZS10aW1lcGlja2VyLWljb24taW5saW5lLWhvdXIgZGF0YS10ZS10aW1lcGlja2VyLWljb24tZG93bj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Tdmd9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xOS41IDguMjVsLTcuNSA3LjUtNy41LTcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgPC9zdmc+ICBcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lRG90fScgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQtaW5saW5lIGRpc2FibGVkPjo8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlckN1cnJlbnRNaW51dGVXcmFwcGVyfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uVXB9XCIgZGF0YS10ZS10aW1lcGlja2VyLWljb24tdXAgZGF0YS10ZS10aW1lcGlja2VyLWljb24taW5saW5lLW1pbnV0ZT5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnfVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNSBoLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk00LjUgMTUuNzVsNy41LTcuNSA3LjUgNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVDdXJyZW50QnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLW1pbnV0ZSBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudCBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudC1pbmxpbmUgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4yMTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uRG93bn1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1pbmxpbmUtbWludXRlIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWRvd24+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvblN2Z31cIj5cbiAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSA4LjI1bC03LjUgNy41LTcuNS03LjVcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz4gXG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAke3MgPyBcIlwiIDogYDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZU1vZGVXcmFwcGVyfVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lTW9kZUFtfVwiIGRhdGEtdGUtdGltZXBpY2tlci1hbSBkYXRhLXRlLXRpbWVwaWNrZXItaG91ci1tb2RlIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHtkfTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZU1vZGVQbX1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaG91ci1tb2RlIGRhdGEtdGUtdGltZXBpY2tlci1wbSB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7X308L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lU3VibWl0QnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLXN1Ym1pdCB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dH08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+YH1cbiAgICAgICAgICAgICAgJHtzID8gYDxidXR0b24gY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lU3VibWl0QnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLXN1Ym1pdCB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dH08L2J1dHRvbj5gIDogXCJcIn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PmA7XG4gIHJldHVybiBsID8gZyA6IG07XG59LCBxZiA9IChzLCB0LCBlKSA9PiB7XG4gIGNvbnN0IHsgaWNvblNWRzogaSB9ID0gcztcbiAgcmV0dXJuIGBcbiAgPGJ1dHRvbiBpZD1cIiR7dH1cIiB0YWJpbmRleD1cIjBcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke2UudGltZXBpY2tlclRvZ2dsZUJ1dHRvbn1cIiBkYXRhLXRlLXRvZ2dsZT1cInRpbWVwaWNrZXJcIiBkYXRhLXRlLXRpbWVwaWNrZXItdG9nZ2xlLWJ1dHRvbiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbj5cbiAgICAke2l9XG4gIDwvYnV0dG9uPlxuYDtcbn0sIExzID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItZGlzYWJsZWRcIiwgRmkgPSBcImRhdGEtdGUtdGltZXBpY2tlci1hY3RpdmVcIiwgZmUgPSAocykgPT4ge1xuICBpZiAocyA9PT0gXCJcIilcbiAgICByZXR1cm47XG4gIGxldCB0LCBlLCBpLCBuO1xuICByZXR1cm4gRWwocykgPyAodCA9IHMuZ2V0SG91cnMoKSwgbiA9IHQsIGUgPSBzLmdldE1pbnV0ZXMoKSwgdCAlPSAxMiwgbiA9PT0gMCAmJiB0ID09PSAwICYmIChpID0gXCJBTVwiKSwgdCA9IHQgfHwgMTIsIGkgPT09IHZvaWQgMCAmJiAoaSA9IE51bWJlcihuKSA+PSAxMiA/IFwiUE1cIiA6IFwiQU1cIiksIGUgPSBlIDwgMTAgPyBgMCR7ZX1gIDogZSkgOiAoW3QsIGUsIGldID0gUihzLCAhMSksIG4gPSB0LCB0ICU9IDEyLCBuID09PSAwICYmIHQgPT09IDAgJiYgKGkgPSBcIkFNXCIpLCB0ID0gdCB8fCAxMiwgaSA9PT0gdm9pZCAwICYmIChpID0gTnVtYmVyKG4pID49IDEyID8gXCJQTVwiIDogXCJBTVwiKSksIHtcbiAgICBob3VyczogdCxcbiAgICBtaW51dGVzOiBlLFxuICAgIGFtT3JQbTogaVxuICB9O1xufSwgRWwgPSAocykgPT4gcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocykgPT09IFwiW29iamVjdCBEYXRlXVwiICYmICFOdW1iZXIuaXNOYU4ocyksIHdyID0gKHMpID0+IHtcbiAgaWYgKHMgPT09IFwiXCIpXG4gICAgcmV0dXJuO1xuICBsZXQgdCwgZTtcbiAgcmV0dXJuIEVsKHMpID8gKHQgPSBzLmdldEhvdXJzKCksIGUgPSBzLmdldE1pbnV0ZXMoKSkgOiBbdCwgZV0gPSBSKHMsICExKSwgZSA9IE51bWJlcihlKSA8IDEwID8gYDAke051bWJlcihlKX1gIDogZSwge1xuICAgIGhvdXJzOiB0LFxuICAgIG1pbnV0ZXM6IGVcbiAgfTtcbn0sIFFmID0gKHMsIHQsIGUpID0+IHUub24oZG9jdW1lbnQsIHMsIHQsICh7IHRhcmdldDogaSB9KSA9PiB7XG4gIGlmIChpLmhhc0F0dHJpYnV0ZShGaSkpXG4gICAgcmV0dXJuO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQpLmZvckVhY2goKG8pID0+IHtcbiAgICBvLmhhc0F0dHJpYnV0ZShGaSkgJiYgKHAucmVtb3ZlQ2xhc3MobywgZS5vcGFjaXR5KSwgby5yZW1vdmVBdHRyaWJ1dGUoRmkpKTtcbiAgfSksIHAuYWRkQ2xhc3MoaSwgZS5vcGFjaXR5KSwgaS5zZXRBdHRyaWJ1dGUoRmksIFwiXCIpO1xufSksIGtyID0gKHsgY2xpZW50WDogcywgY2xpZW50WTogdCwgdG91Y2hlczogZSB9LCBpLCBuID0gITEpID0+IHtcbiAgY29uc3QgeyBsZWZ0OiBvLCB0b3A6IHIgfSA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGxldCBhID0ge307XG4gIHJldHVybiAhbiB8fCAhZSA/IGEgPSB7XG4gICAgeDogcyAtIG8sXG4gICAgeTogdCAtIHJcbiAgfSA6IG4gJiYgT2JqZWN0LmtleXMoZSkubGVuZ3RoID4gMCAmJiAoYSA9IHtcbiAgICB4OiBlWzBdLmNsaWVudFggLSBvLFxuICAgIHk6IGVbMF0uY2xpZW50WSAtIHJcbiAgfSksIGE7XG59LCBZaSA9ICgpID0+IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAyICYmIC9NYWNJbnRlbC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIHx8IC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChcbiAgbmF2aWdhdG9yLnVzZXJBZ2VudFxuKSwgUiA9IChzLCB0ID0gITApID0+IHQgPyBzLnZhbHVlLnJlcGxhY2UoLzovZ2ksIFwiIFwiKS5zcGxpdChcIiBcIikgOiBzLnJlcGxhY2UoLzovZ2ksIFwiIFwiKS5zcGxpdChcIiBcIiksIFRsID0gKHMsIHQpID0+IHtcbiAgY29uc3QgW2UsIGksIG5dID0gUihzLCAhMSksIFtvLCByLCBhXSA9IFIodCwgITEpO1xuICByZXR1cm4gbiA9PT0gXCJQTVwiICYmIGEgPT09IFwiQU1cIiB8fCBuID09PSBhICYmIGUgPiBvIHx8IGkgPiByO1xufSwgQ2wgPSAoKSA9PiB7XG4gIGNvbnN0IHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgdCA9IHMuZ2V0SG91cnMoKSwgZSA9IHMuZ2V0TWludXRlcygpO1xuICByZXR1cm4gYCR7dH06JHtlIDwgMTAgPyBgMCR7ZX1gIDogZX1gO1xufSwganQgPSAocywgdCwgZSkgPT4ge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHM7XG4gIGxldCBpID0gQ2woKTtcbiAgcmV0dXJuIGUgJiYgKGkgPSBgJHtmZShpKS5ob3Vyc306JHtmZShpKS5taW51dGVzfSAke2ZlKGkpLmFtT3JQbX1gKSwgKHMgIT09IFwiXCIgJiYgVGwoaSwgcykgfHwgcyA9PT0gXCJcIikgJiYgKHMgPSBpKSwgcztcbn0sIEt0ID0gKHMsIHQsIGUpID0+IHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBzO1xuICBsZXQgaSA9IENsKCk7XG4gIHJldHVybiBlICYmIChpID0gYCR7ZmUoaSkuaG91cnN9OiR7ZmUoaSkubWludXRlc30gJHtmZShpKS5hbU9yUG19YCksIChzICE9PSBcIlwiICYmICFUbChpLCBzKSB8fCBzID09PSBcIlwiKSAmJiAocyA9IGkpLCBzO1xufSwgWmYgPSAoeyBmb3JtYXQxMjogcywgbWF4VGltZTogdCwgbWluVGltZTogZSwgZGlzYWJsZVBhc3Q6IGksIGRpc2FibGVGdXR1cmU6IG4gfSwgbywgcikgPT4ge1xuICBjb25zdCBhID0gUihvKVsxXTtcbiAgZSA9IGp0KGUsIGksIHMpLCB0ID0gS3QodCwgbiwgcyk7XG4gIGNvbnN0IFtsLCBjLCBkXSA9IFIodCwgITEpLCBbXywgZiwgbV0gPSBSKGUsICExKTtcbiAgaWYgKGQgIT09IHZvaWQgMCB8fCBtICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIFtyLCBhXTtcbiAgaWYgKCEobCAhPT0gXCJcIiAmJiBfID09PSBcIlwiICYmIE51bWJlcihyKSA+IE51bWJlcihsKSkgJiYgIShsID09PSBcIlwiICYmIF8gIT09IFwiXCIgJiYgYyA9PT0gdm9pZCAwICYmIGYgIT09IFwiXCIgJiYgTnVtYmVyKHIpIDwgTnVtYmVyKF8pKSlcbiAgICByZXR1cm4gW3IsIGFdO1xufSwgT3IgPSAocywgdCwgZSwgaSkgPT4ge1xuICBzLmZvckVhY2goKG4pID0+IHtcbiAgICB0ID0gdCA9PT0gXCIxMlwiICYmIGkgPyBcIjBcIiA6IHQsIChuLnRleHRDb250ZW50ID09PSBcIjAwXCIgfHwgTnVtYmVyKG4udGV4dENvbnRlbnQgPT09IFwiMTJcIiAmJiBpID8gXCIwXCIgOiBuLnRleHRDb250ZW50KSA+IHQpICYmIChwLmFkZENsYXNzKG4sIGUudGlwc0Rpc2FibGVkKSwgbi5zZXRBdHRyaWJ1dGUoTHMsIFwiXCIpKTtcbiAgfSk7XG59LCB4ciA9IChzLCB0LCBlLCBpKSA9PiB7XG4gIHMuZm9yRWFjaCgobikgPT4ge1xuICAgIHQgPSB0ID09PSBcIjEyXCIgJiYgaSA/IFwiMFwiIDogdCwgbi50ZXh0Q29udGVudCAhPT0gXCIwMFwiICYmIE51bWJlcihuLnRleHRDb250ZW50ID09PSBcIjEyXCIgJiYgaSA/IFwiMFwiIDogbi50ZXh0Q29udGVudCkgPCBOdW1iZXIodCkgJiYgKHAuYWRkQ2xhc3MobiwgZS50aXBzRGlzYWJsZWQpLCBuLnNldEF0dHJpYnV0ZShMcywgXCJcIikpO1xuICB9KTtcbn0sIEFsID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgaWYgKHQgPT09IFwiMTJcIiB8fCB0ID09PSBcIjI0XCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBuID0gZSA/IDEyIDogMjQ7XG4gIHJldHVybiBpID09PSBcIm1heFwiID8gKE51bWJlcihzKSA9PT0gbiA/IDAgOiBOdW1iZXIocykpID4gTnVtYmVyKHQpIDogKE51bWJlcihzKSA9PT0gbiA/IDAgOiBOdW1iZXIocykpIDwgTnVtYmVyKHQpO1xufSwgSmYgPSAocywgdCwgZSwgaSwgbiwgbykgPT4ge1xuICBzLmZvckVhY2goKHIpID0+IHtcbiAgICAoQWwoaSwgZSwgbywgXCJtYXhcIikgfHwgTnVtYmVyKHIudGV4dENvbnRlbnQpID4gdCAmJiBOdW1iZXIoaSkgPT09IE51bWJlcihlKSkgJiYgKHAuYWRkQ2xhc3Mociwgbi50aXBzRGlzYWJsZWQpLCByLnNldEF0dHJpYnV0ZShMcywgXCJcIikpO1xuICB9KTtcbn0sIHRfID0gKHMsIHQsIGUsIGksIG4sIG8pID0+IHtcbiAgcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgKEFsKGksIGUsIG8sIFwibWluXCIpIHx8IE51bWJlcihyLnRleHRDb250ZW50KSA8IHQgJiYgTnVtYmVyKGkpID09PSBOdW1iZXIoZSkpICYmIChwLmFkZENsYXNzKHIsIG4udGlwc0Rpc2FibGVkKSwgci5zZXRBdHRyaWJ1dGUoTHMsIFwiXCIpKTtcbiAgfSk7XG59LCBlXyA9IChzKSA9PiBzLnN0YXJ0c1dpdGgoXCIwXCIpID8gTnVtYmVyKHMuc2xpY2UoMSkpIDogTnVtYmVyKHMpLCBoaSA9IFwidGltZXBpY2tlclwiLCBMID0gYGRhdGEtdGUtJHtoaX1gLCBTciA9IFwiW2RhdGEtdGUtdG9nZ2xlXVwiLCBfcyA9IGB0ZS4ke2hpfWAsICR0ID0gYC4ke19zfWAsIEx0ID0gXCIuZGF0YS1hcGlcIiwgRHIgPSBgY2xpY2skeyR0fSR7THR9YCwgamkgPSBga2V5ZG93biR7JHR9JHtMdH1gLCBJciA9IGBtb3VzZWRvd24keyR0fSR7THR9YCwgJHIgPSBgbW91c2V1cCR7JHR9JHtMdH1gLCBMciA9IGBtb3VzZW1vdmUkeyR0fSR7THR9YCwgTXIgPSBgbW91c2VsZWF2ZSR7JHR9JHtMdH1gLCBOciA9IGBtb3VzZW92ZXIkeyR0fSR7THR9YCwgUnIgPSBgdG91Y2htb3ZlJHskdH0ke0x0fWAsIFByID0gYHRvdWNoZW5kJHskdH0ke0x0fWAsIEhyID0gYHRvdWNoc3RhcnQkeyR0fSR7THR9YCwgaV8gPSBgWyR7TH0tYW1dYCwgc18gPSBgWyR7TH0tcG1dYCwgbl8gPSBgWyR7TH0tZm9ybWF0MjRdYCwgS2kgPSBgWyR7TH0tY3VycmVudF1gLCBVaSA9IGBbJHtMfS1ob3VyLW1vZGVdYCwgb18gPSBgWyR7TH0tdG9nZ2xlLWJ1dHRvbl1gLCBmbiA9IGAke0x9LWNhbmNlbGAsIEJyID0gYCR7TH0tY2xlYXJgLCBfbiA9IGAke0x9LXN1Ym1pdGAsIHJfID0gYCR7TH0taWNvbmAsIG1uID0gYCR7TH0taWNvbi11cGAsIGduID0gYCR7TH0taWNvbi1kb3duYCwgYV8gPSBgJHtMfS1pY29uLWlubGluZS1ob3VyYCwgbF8gPSBgJHtMfS1pY29uLWlubGluZS1taW51dGVgLCBWciA9IGAke0x9LWlubGluZS1ob3VyLWljb25zYCwgY18gPSBgJHtMfS1jdXJyZW50LWlubGluZWAsIGRfID0gXCJyZWFkb25seVwiLCBXciA9IGAke0x9LWludmFsaWQtZmVlZGJhY2tgLCBibiA9IGAke0x9LWlzLWludmFsaWRgLCBCdCA9IGAke0x9LWRpc2FibGVkYCwgQiA9IGAke0x9LWFjdGl2ZWAsIGhfID0gYCR7TH0taW5wdXRgLCBsZSA9IGAke0x9LWNsb2NrYCwgSmUgPSBgJHtMfS1jbG9jay1pbm5lcmAsIHZuID0gYCR7TH0td3JhcHBlcmAsIEZyID0gYCR7TH0tY2xvY2std3JhcHBlcmAsIHppID0gYCR7TH0taG91cmAsIEVuID0gYCR7TH0tbWludXRlYCwgWGkgPSBgJHtMfS10aXBzLWVsZW1lbnRgLCBLID0gYCR7TH0tdGlwcy1ob3Vyc2AsIFggPSBgJHtMfS10aXBzLW1pbnV0ZXNgLCBhdCA9IGAke0x9LXRpcHMtaW5uZXJgLCBHaSA9IGAke0x9LXRpcHMtaW5uZXItZWxlbWVudGAsIFlyID0gYCR7TH0tbWlkZGxlLWRvdGAsIFRuID0gYCR7TH0taGFuZC1wb2ludGVyYCwgQ24gPSBgJHtMfS1jaXJjbGVgLCBqciA9IGAke0x9LW1vZGFsYCwgdV8gPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTIgNnY2aDQuNW00LjUgMGE5IDkgMCAxMS0xOCAwIDkgOSAwIDAxMTggMHpcIiAvPlxuPC9zdmc+YCwgcF8gPSB7XG4gIGFwcGVuZFZhbGlkYXRpb25JbmZvOiAhMCxcbiAgYm9keUlEOiBcIlwiLFxuICBjYW5jZWxMYWJlbDogXCJDYW5jZWxcIixcbiAgY2xlYXJMYWJlbDogXCJDbGVhclwiLFxuICBjbG9zZU1vZGFsT25CYWNrZHJvcENsaWNrOiAhMCxcbiAgY2xvc2VNb2RhbE9uTWludXRlc0NsaWNrOiAhMSxcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgZGVmYXVsdFRpbWU6IFwiXCIsXG4gIGRpc2FibGVkOiAhMSxcbiAgZGlzYWJsZVBhc3Q6ICExLFxuICBkaXNhYmxlRnV0dXJlOiAhMSxcbiAgZW5hYmxlVmFsaWRhdGlvbjogITAsXG4gIGZvY3VzSW5wdXRBZnRlckFwcHJvdmU6ICExLFxuICBmb290ZXJJRDogXCJcIixcbiAgZm9ybWF0MTI6ICEwLFxuICBmb3JtYXQyNDogITEsXG4gIGhlYWRJRDogXCJcIixcbiAgaW5jcmVtZW50OiAhMSxcbiAgaW5saW5lOiAhMSxcbiAgaW52YWxpZExhYmVsOiBcIkludmFsaWQgVGltZSBGb3JtYXRcIixcbiAgbWF4VGltZTogXCJcIixcbiAgbWluVGltZTogXCJcIixcbiAgbW9kYWxJRDogXCJcIixcbiAgb2tMYWJlbDogXCJPa1wiLFxuICBvdmVyZmxvd0hpZGRlbjogITAsXG4gIHBpY2tlcklEOiBcIlwiLFxuICByZWFkT25seTogITEsXG4gIHNob3dDbGVhckJ0bjogITAsXG4gIHN3aXRjaEhvdXJzVG9NaW51dGVzT25DbGljazogITAsXG4gIGljb25TVkc6IHVfLFxuICB3aXRoSWNvbjogITAsXG4gIHBtTGFiZWw6IFwiUE1cIixcbiAgYW1MYWJlbDogXCJBTVwiLFxuICBhbmltYXRpb25zOiAhMFxufSwgZl8gPSB7XG4gIGFwcGVuZFZhbGlkYXRpb25JbmZvOiBcImJvb2xlYW5cIixcbiAgYm9keUlEOiBcInN0cmluZ1wiLFxuICBjYW5jZWxMYWJlbDogXCJzdHJpbmdcIixcbiAgY2xlYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgY2xvc2VNb2RhbE9uQmFja2Ryb3BDbGljazogXCJib29sZWFuXCIsXG4gIGNsb3NlTW9kYWxPbk1pbnV0ZXNDbGljazogXCJib29sZWFuXCIsXG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZGlzYWJsZWQ6IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlUGFzdDogXCJib29sZWFuXCIsXG4gIGRpc2FibGVGdXR1cmU6IFwiYm9vbGVhblwiLFxuICBlbmFibGVWYWxpZGF0aW9uOiBcImJvb2xlYW5cIixcbiAgZm9vdGVySUQ6IFwic3RyaW5nXCIsXG4gIGZvcm1hdDEyOiBcImJvb2xlYW5cIixcbiAgZm9ybWF0MjQ6IFwiYm9vbGVhblwiLFxuICBoZWFkSUQ6IFwic3RyaW5nXCIsXG4gIGluY3JlbWVudDogXCJib29sZWFuXCIsXG4gIGlubGluZTogXCJib29sZWFuXCIsXG4gIGludmFsaWRMYWJlbDogXCJzdHJpbmdcIixcbiAgbW9kYWxJRDogXCJzdHJpbmdcIixcbiAgb2tMYWJlbDogXCJzdHJpbmdcIixcbiAgb3ZlcmZsb3dIaWRkZW46IFwiYm9vbGVhblwiLFxuICBwaWNrZXJJRDogXCJzdHJpbmdcIixcbiAgcmVhZE9ubHk6IFwiYm9vbGVhblwiLFxuICBzaG93Q2xlYXJCdG46IFwiYm9vbGVhblwiLFxuICBzd2l0Y2hIb3Vyc1RvTWludXRlc09uQ2xpY2s6IFwiYm9vbGVhblwiLFxuICBkZWZhdWx0VGltZTogXCIoc3RyaW5nfGRhdGV8bnVtYmVyKVwiLFxuICBpY29uU1ZHOiBcInN0cmluZ1wiLFxuICB3aXRoSWNvbjogXCJib29sZWFuXCIsXG4gIHBtTGFiZWw6IFwic3RyaW5nXCIsXG4gIGFtTGFiZWw6IFwic3RyaW5nXCIsXG4gIGFuaW1hdGlvbnM6IFwiYm9vbGVhblwiXG59LCBfXyA9IHtcbiAgdGlwczogXCJhYnNvbHV0ZSByb3VuZGVkLVsxMDAlXSB3LVszMnB4XSBoLVszMnB4XSB0ZXh0LWNlbnRlciBjdXJzb3ItcG9pbnRlciB0ZXh0LVsxLjFyZW1dIHJvdW5kZWQtWzEwMCVdIGJnLXRyYW5zcGFyZW50IGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGZvbnQtbGlnaHQgZm9jdXM6b3V0bGluZS1ub25lIHNlbGVjdGlvbjpiZy10cmFuc3BhcmVudFwiLFxuICB0aXBzQWN0aXZlOiBcInRleHQtd2hpdGUgYmctWyMzYjcxY2FdIGZvbnQtbm9ybWFsXCIsXG4gIHRpcHNEaXNhYmxlZDogXCJ0ZXh0LVsjYjNhZmFmXSBwb2ludGVyLWV2ZW50cy1ub25lIGJnLXRyYW5zcGFyZW50XCIsXG4gIHRyYW5zZm9ybTogXCJ0cmFuc2l0aW9uLVt0cmFuc2Zvcm0saGVpZ2h0XSBlYXNlLWluLW91dCBkdXJhdGlvbi1bNDAwbXNdXCIsXG4gIG1vZGFsOiBcInotWzEwNjVdXCIsXG4gIGNsb2NrQW5pbWF0aW9uOiBcImFuaW1hdGUtW3Nob3ctdXAtY2xvY2tfMzUwbXNfbGluZWFyXVwiLFxuICBvcGFjaXR5OiBcIiFvcGFjaXR5LTEwMFwiLFxuICB0aW1lcGlja2VyV3JhcHBlcjogXCJ0b3VjaC1ub25lIG9wYWNpdHktMTAwIHotWzEwNjVdIGluc2V0LTAgYmctWyMwMDAwMDA2Nl0gaC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZsZXgtY29sIGZpeGVkXCIsXG4gIHRpbWVwaWNrZXJDb250YWluZXI6IFwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgbWF4LWgtW2NhbGMoMTAwJS02NHB4KV0gb3ZlcmZsb3cteS1hdXRvIHNoYWRvdy1bMF8xMHB4XzE1cHhfLTNweF9yZ2JhKDAsMCwwLDAuMDcpLDBfNHB4XzZweF8tMnB4X3JnYmEoMCwwLDAsMC4wNSldIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLWxnXCIsXG4gIHRpbWVwaWNrZXJFbGVtZW50czogXCJmbGV4IGZsZXgtY29sIG1pbi13LVszMTBweF0gbWluLWgtWzMyNXB4XSBiZy13aGl0ZSByb3VuZGVkLXQtWzAuNnJlbV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFmbGV4LXJvdyBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLXctW2F1dG9dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4taC1bYXV0b10gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm92ZXJmbG93LXktYXV0byBqdXN0aWZ5LWFyb3VuZFwiLFxuICB0aW1lcGlja2VySGVhZDogXCJiZy1bIzNiNzFjYV0gZGFyazpiZy16aW5jLTcwMCBoLVsxMDBweF0gcm91bmRlZC10LWxnIHByLVsyNHB4XSBwbC1bNTBweF0gcHktWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLXRyLW5vbmUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtYmwtbm9uZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cC1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnByLVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6aC1hdXRvIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4taC1bMzA1cHhdIGZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCIsXG4gIHRpbWVwaWNrZXJIZWFkQ29udGVudDogXCJtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6ZmxleC1jb2wgZmxleCB3LWZ1bGwganVzdGlmeS1ldmVubHlcIixcbiAgdGltZXBpY2tlckN1cnJlbnRXcmFwcGVyOiBcIltkaXJlY3Rpb246bHRyXSBydGw6W2RpcmVjdGlvbjpydGxdXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcjogXCJyZWxhdGl2ZSBoLWZ1bGxcIixcbiAgdGltZXBpY2tlckN1cnJlbnRCdXR0b246IFwidGV4dC1bMy43NXJlbV0gZm9udC1saWdodCBsZWFkaW5nLVsxLjJdIHRyYWNraW5nLVstMC4wMDgzM2VtXSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcC0wIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTp0ZXh0LTV4bCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Zm9udC1ub3JtYWwgY3Vyc29yLXBvaW50ZXIgaG92ZXI6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGZvY3VzOm91dGxpbmUtbm9uZSBcIixcbiAgdGltZXBpY2tlckRvdDogXCJmb250LWxpZ2h0IGxlYWRpbmctWzEuMl0gdHJhY2tpbmctWy0wLjAwODMzZW1dIHRleHQtWzMuNzVyZW1dIG9wYWNpdHktWy41NF0gYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcC0wIHRleHQtd2hpdGUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnRleHQtWzNyZW1dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmb250LW5vcm1hbFwiLFxuICB0aW1lcGlja2VyTW9kZVdyYXBwZXI6IFwiZmxleCBmbGV4LWNvbCBqdXN0aWZ5LWNlbnRlciB0ZXh0LVsxOHB4XSB0ZXh0LVsjZmZmZmZmOGFdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohanVzdGlmeS1hcm91bmQgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFmbGV4LXJvd1wiLFxuICB0aW1lcGlja2VyTW9kZUFtOiBcInAtMCBiZy10cmFuc3BhcmVudCBib3JkZXItbm9uZSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gY3Vyc29yLXBvaW50ZXIgaG92ZXI6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGZvY3VzOm91dGxpbmUtbm9uZVwiLFxuICB0aW1lcGlja2VyTW9kZVBtOiBcInAtMCBiZy10cmFuc3BhcmVudCBib3JkZXItbm9uZSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gY3Vyc29yLXBvaW50ZXIgaG92ZXI6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGZvY3VzOm91dGxpbmUtbm9uZVwiLFxuICB0aW1lcGlja2VyQ2xvY2tXcmFwcGVyOiBcIm1pbi13LVszMTBweF0gbWF4LXctWzMyNXB4XSBtaW4taC1bMzA1cHhdIG92ZXJmbG93LXgtaGlkZGVuIGgtZnVsbCBmbGV4IGp1c3RpZnktY2VudGVyIGZsZXgtY29sIGl0ZW1zLWNlbnRlciBkYXJrOmJnLXppbmMtNTAwXCIsXG4gIHRpbWVwaWNrZXJDbG9jazogXCJyZWxhdGl2ZSByb3VuZGVkLVsxMDAlXSB3LVsyNjBweF0gaC1bMjYwcHhdIGN1cnNvci1kZWZhdWx0IG15LTAgbXgtYXV0byBiZy1bIzAwMDAwMDEyXSBkYXJrOmJnLXppbmMtNjAwLzUwXCIsXG4gIHRpbWVwaWNrZXJNaWRkbGVEb3Q6IFwidG9wLTEvMiBsZWZ0LTEvMiB3LVs2cHhdIGgtWzZweF0gLXRyYW5zbGF0ZS15LTEvMiAtdHJhbnNsYXRlLXgtMS8yIHJvdW5kZWQtWzUwJV0gYmctWyMzYjcxY2FdIGFic29sdXRlXCIsXG4gIHRpbWVwaWNrZXJIYW5kUG9pbnRlcjogXCJiZy1bIzNiNzFjYV0gYm90dG9tLTEvMiBoLTIvNSBsZWZ0LVtjYWxjKDUwJS0xcHgpXSBydGw6IWxlZnQtYXV0byBvcmlnaW4tW2NlbnRlcl9ib3R0b21fMF0gcnRsOiFvcmlnaW4tWzUwJV81MCVfMF0gdy1bMnB4XSBhYnNvbHV0ZVwiLFxuICB0aW1lcGlja2VyUG9pbnRlckNpcmNsZTogXCItdG9wLVsyMXB4XSAtbGVmdC1bMTVweF0gdy1bNHB4XSBib3JkZXItWzE0cHhdIGJvcmRlci1zb2xpZCBib3JkZXItWyMzYjcxY2FdIGgtWzRweF0gYm94LWNvbnRlbnQgcm91bmRlZC1bMTAwJV0gYWJzb2x1dGVcIixcbiAgdGltZXBpY2tlckNsb2NrSW5uZXI6IFwiYWJzb2x1dGUgdG9wLTEvMiBsZWZ0LTEvMiAtdHJhbnNsYXRlLXktMS8yIC10cmFuc2xhdGUteC0xLzIgdy1bMTYwcHhdIGgtWzE2MHB4XSByb3VuZGVkLVsxMDAlXVwiLFxuICB0aW1lcGlja2VyRm9vdGVyV3JhcHBlcjogXCJyb3VuZGVkLWItbGcgZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIHctZnVsbCBoLVs1NnB4XSBweC1bMTJweF0gYmctd2hpdGUgZGFyazpiZy16aW5jLTUwMFwiLFxuICB0aW1lcGlja2VyRm9vdGVyOiBcInctZnVsbCBmbGV4IGp1c3RpZnktYmV0d2VlblwiLFxuICB0aW1lcGlja2VyRm9vdGVyQnV0dG9uOiBcInRleHQtWzAuOHJlbV0gbWluLXctWzY0cHhdIGJveC1ib3JkZXIgZm9udC1tZWRpdW0gbGVhZGluZy1bNDBweF0gcm91bmRlZC1bMTBweF0gdHJhY2tpbmctWzAuMXJlbV0gdXBwZXJjYXNlIHRleHQtWyMzYjcxY2FdIGRhcms6dGV4dC13aGl0ZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLVtiYWNrZ3JvdW5kLWNvbG9yLGJveC1zaGFkb3csYm9yZGVyXSBkdXJhdGlvbi1bMjUwbXNdIGVhc2UtW2N1YmljLWJlemllcigwLjQsMCwwLjIsMSldIGRlbGF5LVswbXNdIG91dGxpbmUtbm9uZSBweS0wIHB4LVsxMHB4XSBoLVs0MHB4XSBtYi1bMTBweF0gaG92ZXI6YmctWyMwMDAwMDAxNF0gZm9jdXM6YmctWyMwMDAwMDAxNF0gZm9jdXM6b3V0bGluZS1ub25lXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVXcmFwcGVyOiBcInRvdWNoLW5vbmUgb3BhY2l0eS0xMDAgei1bMTA2NV0gaW5zZXQtMCBiZy1bIzAwMDAwMDY2XSBoLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgcm91bmRlZC1sZ1wiLFxuICB0aW1lcGlja2VySW5saW5lQ29udGFpbmVyOiBcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZsZXgtY29sIG1heC1oLVtjYWxjKDEwMCUtNjRweCldIG92ZXJmbG93LXktYXV0byBzaGFkb3ctWzBfMTBweF8xNXB4Xy0zcHhfcmdiYSgwLDAsMCwwLjA3KSwwXzRweF82cHhfLTJweF9yZ2JhKDAsMCwwLDAuMDUpXVwiLFxuICB0aW1lcGlja2VySW5saW5lRWxlbWVudHM6IFwiZmxleCBmbGV4LWNvbCBtaW4taC1bYXV0b10gbWluLXctWzMxMHB4XSBiZy13aGl0ZSByb3VuZGVkLVswLjZyZW1dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohZmxleC1yb3cgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtYmwtbGcgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi13LVthdXRvXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Om1pbi1oLVthdXRvXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6b3ZlcmZsb3cteS1hdXRvIGp1c3RpZnktYXJvdW5kXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIZWFkOiBcImJnLVsjM2I3MWNhXSBkYXJrOmJnLXppbmMtNzAwIGgtWzEwMHB4XSByb3VuZGVkLXQtbGcgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtdHItbm9uZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC1ibC1ub25lIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpwLVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cHItWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpoLWF1dG8gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi1oLVszMDVweF0gZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcC0wIHJvdW5kZWQtYi1sZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSGVhZENvbnRlbnQ6IFwibWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZsZXgtY29sIGZsZXggdy1mdWxsIGp1c3RpZnktZXZlbmx5IGl0ZW1zLWNlbnRlclwiLFxuICB0aW1lcGlja2VySW5saW5lSG91cldyYXBwZXI6IFwicmVsYXRpdmUgaC1mdWxsICFvcGFjaXR5LTEwMFwiLFxuICB0aW1lcGlja2VyQ3VycmVudE1pbnV0ZVdyYXBwZXI6IFwicmVsYXRpdmUgaC1mdWxsXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uVXA6IFwiYWJzb2x1dGUgZmlsbC13aGl0ZSAtdG9wLVszNXB4XSBvcGFjaXR5LTAgaG92ZXI6b3BhY2l0eS0xMDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtW2Vhc2VdIGN1cnNvci1wb2ludGVyIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiBsZWZ0LTEvMiB3LVszMHB4XSBoLVszMHB4XSBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlclwiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblN2ZzogXCJoLTQgdy00XCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVDdXJyZW50QnV0dG9uOiBcImZvbnQtbGlnaHQgbGVhZGluZy1bMS4yXSB0cmFja2luZy1bLTAuMDA4MzNlbV0gdGV4dC13aGl0ZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBwLTAgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnRleHQtNXhsIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmb250LW5vcm1hbCAhb3BhY2l0eS0xMDAgY3Vyc29yLXBvaW50ZXIgZm9jdXM6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOm91dGxpbmUtbm9uZSB0ZXh0LVsyLjVyZW1dIGhvdmVyOmJnLVt1bnNldF1cIixcbiAgdGltZXBpY2tlcklubGluZUljb25Eb3duOiBcImFic29sdXRlIGZpbGwtd2hpdGUgLWJvdHRvbS1bNDdweF0gb3BhY2l0eS0wIGhvdmVyOm9wYWNpdHktMTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLVtlYXNlXSBjdXJzb3ItcG9pbnRlciAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgbGVmdC0xLzIgdy1bMzBweF0gaC1bMzBweF0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgdGltZXBpY2tlcklubGluZURvdDogXCJmb250LWxpZ2h0IGxlYWRpbmctWzEuMl0gdHJhY2tpbmctWy0wLjAwODMzZW1dIG9wYWNpdHktWy41NF0gYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcC0wIHRleHQtd2hpdGUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnRleHQtWzNyZW1dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmb250LW5vcm1hbCB0ZXh0LVsyLjVyZW1dXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlV3JhcHBlcjogXCJmbGV4IGp1c3RpZnktY2VudGVyIHRleHQtWzE4cHhdIHRleHQtWyNmZmZmZmY4YV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFqdXN0aWZ5LWFyb3VuZCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWZsZXgtcm93XCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlQW06IFwiaG92ZXI6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGZvY3VzOm91dGxpbmUtbm9uZSBwLTAgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGN1cnNvci1wb2ludGVyIG1yLTIgbWwtNlwiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZVBtOiBcImhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmUgcC0wIGJnLXRyYW5zcGFyZW50IGJvcmRlci1ub25lIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBjdXJzb3ItcG9pbnRlclwiLFxuICB0aW1lcGlja2VySW5saW5lU3VibWl0QnV0dG9uOiBcImhvdmVyOmJnLVsjMDAwMDAwMTRdIGZvY3VzOmJnLVsjMDAwMDAwMTRdIGZvY3VzOm91dGxpbmUtbm9uZSB0ZXh0LVswLjhyZW1dIGJveC1ib3JkZXIgZm9udC1tZWRpdW0gbGVhZGluZy1bNDBweF0gdHJhY2tpbmctWy4xcmVtXSB1cHBlcmNhc2UgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgW3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvcl8yNTBtc19jdWJpYy1iZXppZXIoMC40LDAsMC4yLDEpXzBtcyxib3gtc2hhZG93XzI1MG1zX2N1YmljLWJlemllcigwLjQsMCwwLjIsMSlfMG1zLGJvcmRlcl8yNTBtc19jdWJpYy1iZXppZXIoMC40LDAsMC4yLDEpXzBtc10gb3V0bGluZS1ub25lIHJvdW5kZWQtWzEwMCVdIGgtWzQ4cHhdIG1pbi13LVs0OHB4XSBpbmxpbmUtYmxvY2sgbWwtWzMwcHhdIHRleHQtd2hpdGUgcHktMSBweC0yIG1iLTBcIixcbiAgdGltZXBpY2tlclRvZ2dsZUJ1dHRvbjogXCJoLTQgdy00IG1sLWF1dG8gYWJzb2x1dGUgb3V0bGluZS1ub25lIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHJpZ2h0LTEuNSB0b3AtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMSldIGN1cnNvci1wb2ludGVyIGhvdmVyOnRleHQtWyMzYjcxY2FdIGZvY3VzOnRleHQtWyMzYjcxY2FdIGRhcms6aG92ZXI6dGV4dC1bIzNiNzFjYV0gZGFyazpmb2N1czp0ZXh0LVsjM2I3MWNhXSBkYXJrOnRleHQtd2hpdGVcIlxufSwgbV8gPSB7XG4gIHRpcHM6IFwic3RyaW5nXCIsXG4gIHRpcHNBY3RpdmU6IFwic3RyaW5nXCIsXG4gIHRpcHNEaXNhYmxlZDogXCJzdHJpbmdcIixcbiAgdHJhbnNmb3JtOiBcInN0cmluZ1wiLFxuICBtb2RhbDogXCJzdHJpbmdcIixcbiAgY2xvY2tBbmltYXRpb246IFwic3RyaW5nXCIsXG4gIG9wYWNpdHk6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ29udGFpbmVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyRWxlbWVudHM6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJIZWFkOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySGVhZENvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50V3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRCdXR0b25XcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ3VycmVudEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckRvdDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1vZGVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyTW9kZUFtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyTW9kZVBtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ2xvY2tXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ2xvY2s6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJNaWRkbGVEb3Q6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJIYW5kUG9pbnRlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlclBvaW50ZXJDaXJjbGU6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDbG9ja0lubmVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyRm9vdGVyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckZvb3RlckJ1dHRvbjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZVdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVFbGVtZW50czogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUhlYWQ6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIZWFkQ29udGVudDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUhvdXJXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ3VycmVudE1pbnV0ZVdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uVXA6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lQ3VycmVudEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUljb25Eb3duOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lRG90OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZVdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlQW06IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlUG06IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVTdWJtaXRCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJUb2dnbGVCdXR0b246IFwic3RyaW5nXCJcbn07XG5jbGFzcyBxZyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgaSkge1xuICAgIFR0KHRoaXMsIFwiX3RvZ2dsZUFtUG1cIiwgKHQpID0+IHtcbiAgICAgIHQgPT09IFwiUE1cIiA/ICh0aGlzLl9pc1BtRW5hYmxlZCA9ICEwLCB0aGlzLl9pc0FtRW5hYmxlZCA9ICExKSA6IHQgPT09IFwiQU1cIiAmJiAodGhpcy5faXNQbUVuYWJsZWQgPSAhMSwgdGhpcy5faXNBbUVuYWJsZWQgPSAhMCk7XG4gICAgfSk7XG4gICAgVHQodGhpcywgXCJfdG9nZ2xlQmFja2dyb3VuZENvbG9yQ2lyY2xlXCIsICh0KSA9PiB7XG4gICAgICBpZiAodGhpcy5fbW9kYWwucXVlcnlTZWxlY3RvcihgJHt0fVske0J9XWApICE9PSBudWxsKSB7XG4gICAgICAgIHAuYWRkU3R5bGUodGhpcy5fY2lyY2xlLCB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMxOTc2ZDJcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcC5hZGRTdHlsZSh0aGlzLl9jaXJjbGUsIHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFR0KHRoaXMsIFwiX3RvZ2dsZUNsYXNzQWN0aXZlXCIsICh0LCB7IHRleHRDb250ZW50OiBlIH0sIGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBbLi4udF0uZmluZChcbiAgICAgICAgKG8pID0+IE51bWJlcihvKSA9PT0gTnVtYmVyKGUpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBpZiAoIW8uaGFzQXR0cmlidXRlKEJ0KSkge1xuICAgICAgICAgIGlmIChvLnRleHRDb250ZW50ID09PSBuKSB7XG4gICAgICAgICAgICBwLmFkZENsYXNzKG8sIHRoaXMuX2NsYXNzZXMudGlwc0FjdGl2ZSksIG8uc2V0QXR0cmlidXRlKEIsIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwLnJlbW92ZUNsYXNzKG8sIHRoaXMuX2NsYXNzZXMudGlwc0FjdGl2ZSksIG8ucmVtb3ZlQXR0cmlidXRlKEIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBUdCh0aGlzLCBcIl9tYWtlTWludXRlc0RlZ3JlZXNcIiwgKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5jcmVtZW50OiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgcmV0dXJuIHQgPCAwID8gKGUgPSBNYXRoLnJvdW5kKDM2MCArIHQgLyA2KSAlIDYwLCB0ID0gMzYwICsgTWF0aC5yb3VuZCh0IC8gNikgKiA2KSA6IChlID0gTWF0aC5yb3VuZCh0IC8gNikgJSA2MCwgdCA9IE1hdGgucm91bmQodCAvIDYpICogNiksIGkgJiYgKHQgPSBNYXRoLnJvdW5kKHQgLyAzMCkgKiAzMCwgZSA9IE1hdGgucm91bmQodCAvIDYpICogNiAvIDYsIGUgPT09IDYwICYmIChlID0gXCIwMFwiKSksIHQgPj0gMzYwICYmICh0ID0gMCksIHtcbiAgICAgICAgZGVncmVlczogdCxcbiAgICAgICAgbWludXRlOiBlLFxuICAgICAgICBhZGREZWdyZWVzOiBpID8gMzAgOiA2XG4gICAgICB9O1xuICAgIH0pO1xuICAgIFR0KHRoaXMsIFwiX21ha2VIb3VyRGVncmVlc1wiLCAodCwgZSwgaSkgPT4ge1xuICAgICAgaWYgKHQpXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNUYXJnZXRJbm5lckNsYXNzKHQpID8gZSA8IDAgPyAoaSA9IE1hdGgucm91bmQoMzYwICsgZSAvIDMwKSAlIDI0LCBlID0gMzYwICsgZSkgOiAoaSA9IE1hdGgucm91bmQoZSAvIDMwKSArIDEyLCBpID09PSAxMiAmJiAoaSA9IFwiMDBcIikpIDogZSA8IDAgPyAoaSA9IE1hdGgucm91bmQoMzYwICsgZSAvIDMwKSAlIDEyLCBlID0gMzYwICsgZSkgOiAoaSA9IE1hdGgucm91bmQoZSAvIDMwKSAlIDEyLCAoaSA9PT0gMCB8fCBpID4gMTIpICYmIChpID0gMTIpKSwgZSA+PSAzNjAgJiYgKGUgPSAwKSwge1xuICAgICAgICAgIGRlZ3JlZXM6IGUsXG4gICAgICAgICAgaG91cjogaSxcbiAgICAgICAgICBhZGREZWdyZWVzOiAzMFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIFR0KHRoaXMsIFwiX21ha2VJbm5lckhvdXJzRGVncmVlc1wiLCAodCwgZSkgPT4gKHQgPCAwID8gKGUgPSBNYXRoLnJvdW5kKDM2MCArIHQgLyAzMCkgJSAyNCwgdCA9IDM2MCArIHQpIDogKGUgPSBNYXRoLnJvdW5kKHQgLyAzMCkgKyAxMiwgZSA9PT0gMTIgJiYgKGUgPSBcIjAwXCIpKSwge1xuICAgICAgZGVncmVlczogdCxcbiAgICAgIGhvdXI6IGUsXG4gICAgICBhZGREZWdyZWVzOiAzMFxuICAgIH0pKTtcbiAgICBUdCh0aGlzLCBcIl9nZXRBcHBlbmRDbG9ja1wiLCAodCA9IFtdLCBlID0gYFske2xlfV1gLCBpKSA9PiB7XG4gICAgICBsZXQgeyBtaW5UaW1lOiBuLCBtYXhUaW1lOiBvIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgY29uc3QgeyBpbmxpbmU6IHIsIGZvcm1hdDEyOiBhLCBkaXNhYmxlUGFzdDogbCwgZGlzYWJsZUZ1dHVyZTogYyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIG4gPSBqdChuLCBsLCBhKSwgbyA9IEt0KG8sIGMsIGEpO1xuICAgICAgY29uc3QgW2QsIF8sIGZdID0gUihcbiAgICAgICAgbyxcbiAgICAgICAgITFcbiAgICAgICksIFttLCBnLCBiXSA9IFIoXG4gICAgICAgIG4sXG4gICAgICAgICExXG4gICAgICApO1xuICAgICAgIXIgJiYgYSAmJiB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ICYmICF0aGlzLl9BTS5oYXNBdHRyaWJ1dGUoQikgJiYgKHAuYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShCLCBcIlwiKSk7XG4gICAgICBjb25zdCBUID0gaC5maW5kT25lKGUpLCBDID0gMzYwIC8gdC5sZW5ndGg7XG4gICAgICBmdW5jdGlvbiB3KHkpIHtcbiAgICAgICAgcmV0dXJuIHkgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICB9XG4gICAgICBpZiAoVCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgdiA9IChULm9mZnNldFdpZHRoIC0gMzIpIC8gMiwgRSA9IChULm9mZnNldEhlaWdodCAtIDMyKSAvIDIsIEEgPSB2IC0gNDtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgYSAmJiAoeSA9IGguZmluZE9uZShcbiAgICAgICAgICBgJHtVaX1bJHtCfV1gXG4gICAgICAgICkudGV4dENvbnRlbnQpLCB0aGlzLl9oYW5kbGVEaXNhYmxpbmdUaXBzTWluVGltZShcbiAgICAgICAgICB5LFxuICAgICAgICAgIGIsXG4gICAgICAgICAgZyxcbiAgICAgICAgICBtXG4gICAgICAgICksIHRoaXMuX2hhbmRsZURpc2FibGluZ1RpcHNNYXhUaW1lKFxuICAgICAgICAgIHksXG4gICAgICAgICAgZixcbiAgICAgICAgICBfLFxuICAgICAgICAgIGRcbiAgICAgICAgKTtcbiAgICAgIH0sIDApLCBbLi4udF0uZm9yRWFjaCgoeSwgUykgPT4ge1xuICAgICAgICBjb25zdCBPID0gdyhTICogQyksIGsgPSBNKFwic3BhblwiKSwgRCA9IE0oXCJzcGFuXCIpO1xuICAgICAgICBELmlubmVySFRNTCA9IHksIHAuYWRkQ2xhc3MoaywgdGhpcy5fY2xhc3Nlcy50aXBzKSwgay5zZXRBdHRyaWJ1dGUoaSwgXCJcIik7XG4gICAgICAgIGNvbnN0IHggPSBrLm9mZnNldFdpZHRoLCAkID0gay5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHJldHVybiBwLmFkZFN0eWxlKGssIHtcbiAgICAgICAgICBsZWZ0OiBgJHt2ICsgTWF0aC5zaW4oTykgKiBBIC0geH1weGAsXG4gICAgICAgICAgYm90dG9tOiBgJHtFICsgTWF0aC5jb3MoTykgKiBBIC0gJH1weGBcbiAgICAgICAgfSksIHQuaW5jbHVkZXMoXCIwNVwiKSAmJiBrLnNldEF0dHJpYnV0ZShYLCBcIlwiKSwgdC5pbmNsdWRlcyhcIjEzXCIpID8gRC5zZXRBdHRyaWJ1dGUoR2ksIFwiXCIpIDogRC5zZXRBdHRyaWJ1dGUoWGksIFwiXCIpLCBrLmFwcGVuZENoaWxkKEQpLCBULmFwcGVuZENoaWxkKGspO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2VsZW1lbnQgJiYgSS5zZXREYXRhKHQsIF9zLCB0aGlzKSwgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2N1cnJlbnRUaW1lID0gbnVsbCwgdGhpcy5fdG9nZ2xlQnV0dG9uSWQgPSBPdChcInRpbWVwaWNrZXItdG9nZ2xlLVwiKSwgdGhpcy5ob3Vyc0FycmF5ID0gW1xuICAgICAgXCIxMlwiLFxuICAgICAgXCIxXCIsXG4gICAgICBcIjJcIixcbiAgICAgIFwiM1wiLFxuICAgICAgXCI0XCIsXG4gICAgICBcIjVcIixcbiAgICAgIFwiNlwiLFxuICAgICAgXCI3XCIsXG4gICAgICBcIjhcIixcbiAgICAgIFwiOVwiLFxuICAgICAgXCIxMFwiLFxuICAgICAgXCIxMVwiXG4gICAgXSwgdGhpcy5pbm5lckhvdXJzID0gW1xuICAgICAgXCIwMFwiLFxuICAgICAgXCIxM1wiLFxuICAgICAgXCIxNFwiLFxuICAgICAgXCIxNVwiLFxuICAgICAgXCIxNlwiLFxuICAgICAgXCIxN1wiLFxuICAgICAgXCIxOFwiLFxuICAgICAgXCIxOVwiLFxuICAgICAgXCIyMFwiLFxuICAgICAgXCIyMVwiLFxuICAgICAgXCIyMlwiLFxuICAgICAgXCIyM1wiXG4gICAgXSwgdGhpcy5taW51dGVzQXJyYXkgPSBbXG4gICAgICBcIjAwXCIsXG4gICAgICBcIjA1XCIsXG4gICAgICBcIjEwXCIsXG4gICAgICBcIjE1XCIsXG4gICAgICBcIjIwXCIsXG4gICAgICBcIjI1XCIsXG4gICAgICBcIjMwXCIsXG4gICAgICBcIjM1XCIsXG4gICAgICBcIjQwXCIsXG4gICAgICBcIjQ1XCIsXG4gICAgICBcIjUwXCIsXG4gICAgICBcIjU1XCJcbiAgICBdLCB0aGlzLmlucHV0ID0gaC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuZGF0YVdpdGhJY29uID0gdC5kYXRhc2V0LndpdGhJY29uLCB0aGlzLmRhdGFUb2dnbGUgPSB0LmRhdGFzZXQudG9nZ2xlLCB0aGlzLmN1c3RvbUljb24gPSBoLmZpbmRPbmUoXG4gICAgICBvXyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9jaGVja1RvZ2dsZUJ1dHRvbigpLCB0aGlzLmlucHV0Rm9ybWF0U2hvdyA9IGguZmluZE9uZShcbiAgICAgIG5fLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuaW5wdXRGb3JtYXQgPSB0aGlzLmlucHV0Rm9ybWF0U2hvdyA9PT0gbnVsbCA/IFwiXCIgOiBPYmplY3QudmFsdWVzKHRoaXMuaW5wdXRGb3JtYXRTaG93LmRhdGFzZXQpWzBdLCB0aGlzLmVsZW1lbnRUb2dnbGUgPSBoLmZpbmRPbmUoXG4gICAgICBTcixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLnRvZ2dsZUVsZW1lbnQgPSBPYmplY3QudmFsdWVzKFxuICAgICAgdC5xdWVyeVNlbGVjdG9yKFNyKS5kYXRhc2V0XG4gICAgKVswXSwgdGhpcy5faG91ciA9IG51bGwsIHRoaXMuX21pbnV0ZXMgPSBudWxsLCB0aGlzLl9BTSA9IG51bGwsIHRoaXMuX1BNID0gbnVsbCwgdGhpcy5fd3JhcHBlciA9IG51bGwsIHRoaXMuX21vZGFsID0gbnVsbCwgdGhpcy5faGFuZCA9IG51bGwsIHRoaXMuX2NpcmNsZSA9IG51bGwsIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGwsIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2ludGVydmFsID0gbnVsbCwgdGhpcy5faW5wdXRWYWx1ZSA9IHRoaXMuX29wdGlvbnMuZGVmYXVsdFRpbWUgIT09IFwiXCIgPyB0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lIDogdGhpcy5pbnB1dC52YWx1ZSwgdGhpcy5fb3B0aW9ucy5mb3JtYXQyNCAmJiAodGhpcy5fb3B0aW9ucy5mb3JtYXQxMiA9ICExLCB0aGlzLl9jdXJyZW50VGltZSA9IHdyKHRoaXMuX2lucHV0VmFsdWUpKSwgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMiAmJiAodGhpcy5fb3B0aW9ucy5mb3JtYXQyNCA9ICExLCB0aGlzLl9jdXJyZW50VGltZSA9IGZlKHRoaXMuX2lucHV0VmFsdWUpKSwgdGhpcy5fb3B0aW9ucy5yZWFkT25seSAmJiB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShkXywgITApLCB0aGlzLmlucHV0Rm9ybWF0ID09PSBcInRydWVcIiAmJiB0aGlzLmlucHV0Rm9ybWF0ICE9PSBcIlwiICYmICh0aGlzLl9vcHRpb25zLmZvcm1hdDEyID0gITEsIHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgPSAhMCwgdGhpcy5fY3VycmVudFRpbWUgPSB3cih0aGlzLl9pbnB1dFZhbHVlKSksIHRoaXMuX2FuaW1hdGlvbnMgPSAhd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKS5tYXRjaGVzICYmIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9ucywgdGhpcy5pbml0KCksIHRoaXMuX2lzSG91cnMgPSAhMCwgdGhpcy5faXNNaW51dGVzID0gITEsIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgPSAhMSwgdGhpcy5faXNNb3VzZU1vdmUgPSAhMSwgdGhpcy5faXNJbm5lciA9ICExLCB0aGlzLl9pc0FtRW5hYmxlZCA9ICExLCB0aGlzLl9pc1BtRW5hYmxlZCA9ICExLCB0aGlzLl9vcHRpb25zLmZvcm1hdDEyICYmICF0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lICYmICh0aGlzLl9pc1BtRW5hYmxlZCA9ICEwKSwgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZSA9IHsgZGVncmVlczogbnVsbCB9LCB0aGlzLl9zY3JvbGxCYXIgPSBuZXcgcGkoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gaGk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgY29uc3QgeyBmb3JtYXQxMjogdCwgZm9ybWF0MjQ6IGUsIGVuYWJsZVZhbGlkYXRpb246IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgbGV0IG4sIG8sIHI7XG4gICAgaWYgKHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKGhfLCBcIlwiKSwgdGhpcy5fY3VycmVudFRpbWUgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgeyBob3VyczogYSwgbWludXRlczogbCwgYW1PclBtOiBjIH0gPSB0aGlzLl9jdXJyZW50VGltZTtcbiAgICAgIG4gPSBOdW1iZXIoYSkgPCAxMCA/IDAgOiBcIlwiLCBvID0gYCR7bn0ke051bWJlcihhKX06JHtsfWAsIHIgPSBjLCB0ID8gdGhpcy5pbnB1dC52YWx1ZSA9IGAke299ICR7cn1gIDogZSAmJiAodGhpcy5pbnB1dC52YWx1ZSA9IGAke299YCk7XG4gICAgfSBlbHNlXG4gICAgICBuID0gXCJcIiwgbyA9IFwiXCIsIHIgPSBcIlwiLCB0aGlzLmlucHV0LnZhbHVlID0gXCJcIjtcbiAgICB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aCA+IDAgJiYgdGhpcy5pbnB1dC52YWx1ZSAhPT0gXCJcIiAmJiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoQiwgXCJcIiksIHUudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0XCIpKSwgISh0aGlzLl9vcHRpb25zID09PSBudWxsICYmIHRoaXMuX2VsZW1lbnQgPT09IG51bGwpICYmIChpICYmIHRoaXMuX2dldFZhbGlkYXRlKFwia2V5ZG93biBjaGFuZ2UgYmx1ciBmb2N1c1wiKSwgdGhpcy5faGFuZGxlT3BlbigpLCB0aGlzLl9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9yZW1vdmVNb2RhbCgpLCB0aGlzLl9lbGVtZW50ICE9PSBudWxsICYmIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBfcyksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsLCB0aGlzLmlucHV0ID0gbnVsbCwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbDtcbiAgICB9LCAzNTApLCB1Lm9mZihcbiAgICAgIHRoaXMuX2RvY3VtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgYFtkYXRhLXRlLXRvZ2dsZT0nJHt0aGlzLnRvZ2dsZUVsZW1lbnR9J11gXG4gICAgKSwgdS5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWBcbiAgICApO1xuICB9XG4gIHVwZGF0ZSh0ID0ge30pIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fb3B0aW9ucywgLi4udCB9KTtcbiAgfVxuICAvLyBwcml2YXRlXG4gIF9jaGVja1RvZ2dsZUJ1dHRvbigpIHtcbiAgICB0aGlzLmN1c3RvbUljb24gPT09IG51bGwgJiYgKHRoaXMuZGF0YVdpdGhJY29uICE9PSB2b2lkIDAgJiYgKHRoaXMuX29wdGlvbnMud2l0aEljb24gPSBudWxsLCB0aGlzLmRhdGFXaXRoSWNvbiA9PT0gXCJ0cnVlXCIgJiYgdGhpcy5fYXBwZW5kVG9nZ2xlQnV0dG9uKHRoaXMuX29wdGlvbnMpKSwgdGhpcy5fb3B0aW9ucy53aXRoSWNvbiAmJiB0aGlzLl9hcHBlbmRUb2dnbGVCdXR0b24odGhpcy5fb3B0aW9ucykpO1xuICB9XG4gIF9hcHBlbmRUb2dnbGVCdXR0b24oKSB7XG4gICAgY29uc3QgdCA9IHFmKFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5pbnB1dC5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmVuZFwiLCB0KTtcbiAgfVxuICBfZ2V0RG9tRWxlbWVudHMoKSB7XG4gICAgdGhpcy5faG91ciA9IGguZmluZE9uZShgWyR7eml9XWApLCB0aGlzLl9taW51dGVzID0gaC5maW5kT25lKGBbJHtFbn1dYCksIHRoaXMuX0FNID0gaC5maW5kT25lKGlfKSwgdGhpcy5fUE0gPSBoLmZpbmRPbmUoc18pLCB0aGlzLl93cmFwcGVyID0gaC5maW5kT25lKGBbJHt2bn1dYCksIHRoaXMuX21vZGFsID0gaC5maW5kT25lKGBbJHtqcn1dYCksIHRoaXMuX2hhbmQgPSBoLmZpbmRPbmUoYFske1RufV1gKSwgdGhpcy5fY2lyY2xlID0gaC5maW5kT25lKGBbJHtDbn1dYCksIHRoaXMuX2Nsb2NrID0gaC5maW5kT25lKGBbJHtsZX1dYCksIHRoaXMuX2Nsb2NrSW5uZXIgPSBoLmZpbmRPbmUoXG4gICAgICBgWyR7SmV9XWBcbiAgICApO1xuICB9XG4gIF9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKHQsIGUsIGksIG4sIG8sIHIpIHtcbiAgICBpZiAoIWUgJiYgIWkpXG4gICAgICByZXR1cm4gITA7XG4gICAgY29uc3QgeyBmb3JtYXQyNDogYSwgZm9ybWF0MTI6IGwsIGRpc2FibGVQYXN0OiBjLCBkaXNhYmxlRnV0dXJlOiBkIH0gPSB0aGlzLl9vcHRpb25zLCB7IF9pc0FtRW5hYmxlZDogXywgX2lzUG1FbmFibGVkOiBmIH0gPSB0aGlzLCBtID0gci5rZXlDb2RlLCBnID0gci50YXJnZXQuaGFzQXR0cmlidXRlKEplKSB8fCByLnRhcmdldC5oYXNBdHRyaWJ1dGUoYXQpIHx8IHIudGFyZ2V0Lmhhc0F0dHJpYnV0ZShHaSk7XG4gICAgaSA9IGp0KGksIGMsIGwpLCBlID0gS3QoZSwgZCwgbCksIHR5cGVvZiBlICE9IFwibnVtYmVyXCIgJiYgKGUgPSBSKGUsICExKVswXSk7XG4gICAgY29uc3QgYiA9IGUgIT09IFwiXCIgPyBlICogMzAgOiBcIlwiLCBUID0gaSAhPT0gXCJcIiA/IGkgKiAzMCA6IFwiXCI7XG4gICAgdCA8IDAgJiYgKHQgPSAzNjAgKyB0KSwgdCA9IHQgPT09IDM2MCA/IDAgOiB0O1xuICAgIGNvbnN0IEMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBTID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgYFske1hpfV1gXG4gICAgICApLCBPID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgYFske0dpfV1gXG4gICAgICApLCBrID0gZV8odGhpcy5faG91ci5pbm5lclRleHQpO1xuICAgICAgbGV0IEQsIHgsICQ7XG4gICAgICByZXR1cm4gbSA9PT0gcnQgPyB4ID0gMSA6IG0gPT09IFUgJiYgKHggPSAtMSksIGsgPT09IDEyICYmIG0gPT09IHJ0ID8gJCA9IDEgOiBrID09PSAwICYmIG0gPT09IHJ0ID8gJCA9IDEzIDogayA9PT0gMCAmJiBtID09PSBVID8gJCA9IDIzIDogayA9PT0gMTMgJiYgbSA9PT0gVSA/ICQgPSAwIDogayA9PT0gMSAmJiBtID09PSBVID8gJCA9IDEyIDogJCA9IGsgKyB4LCBTLmZvckVhY2goKFApID0+IHtcbiAgICAgICAgTnVtYmVyKFAudGV4dENvbnRlbnQpID09PSAkICYmIChEID0gUCk7XG4gICAgICB9KSwgTy5mb3JFYWNoKChQKSA9PiB7XG4gICAgICAgIE51bWJlcihQLnRleHRDb250ZW50KSA9PT0gJCAmJiAoRCA9IFApO1xuICAgICAgfSksICFELnBhcmVudEVsZW1lbnQuaGFzQXR0cmlidXRlKEJ0KTtcbiAgICB9LCB3ID0gKCkgPT4ge1xuICAgICAgY29uc3QgUyA9IGkgIT09IFwiXCIgJiYgaSA+IDEyID8gKGkgLSAxMikgKiAzMCA6IFwiXCIsIE8gPSBlICE9PSBcIlwiICYmIGUgPiAxMiA/IChlIC0gMTIpICogMzAgOiBcIlwiO1xuICAgICAgaWYgKCEoUyAmJiB0IDwgUyB8fCBPICYmIHQgPiBPIHx8IGUgJiYgZSA8IDEyKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH07XG4gICAgaWYgKGEgJiYgci50eXBlICE9PSBcImtleWRvd25cIiAmJiBnKVxuICAgICAgcmV0dXJuIHcoKTtcbiAgICBpZiAoci50eXBlID09PSBcImtleWRvd25cIilcbiAgICAgIHJldHVybiBDKCk7XG4gICAgY29uc3QgdiA9ICFvIHx8IG8gPT09IFwiUE1cIiAmJiBmIHx8IGkgIT09IFwiXCIgJiYgbyA9PT0gXCJBTVwiICYmIF8sIEUgPSAhbiB8fCBuID09PSBcIlBNXCIgJiYgZiB8fCBlICE9PSBcIlwiICYmIG4gPT09IFwiQU1cIiAmJiBfLCBBID0gKCkgPT4ge1xuICAgICAgY29uc3QgUyA9IFQgPT09IDM2MCAmJiBsID8gMCA6IFQ7XG4gICAgICBpZiAoaSkge1xuICAgICAgICBpZiAobyA9PT0gXCJQTVwiICYmIF8gfHwgdiAmJiB0IDwgUylcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIHkgPSAoKSA9PiB7XG4gICAgICBjb25zdCBTID0gYiA9PT0gMzYwICYmIGwgPyAwIDogYjtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGlmIChuID09PSBcIkFNXCIgJiYgZiB8fCBFICYmIHQgPiBTKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITA7XG4gICAgfTtcbiAgICByZXR1cm4gQSgpICYmIHkoKTtcbiAgfVxuICBfaGFuZGxlS2V5Ym9hcmQoKSB7XG4gICAgdS5vbih0aGlzLl9kb2N1bWVudCwgamksIFwiXCIsICh0KSA9PiB7XG4gICAgICBsZXQgZSwgaSwgbjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5jcmVtZW50OiBvLFxuICAgICAgICBtYXhUaW1lOiByLFxuICAgICAgICBtaW5UaW1lOiBhLFxuICAgICAgICBmb3JtYXQxMjogbCxcbiAgICAgICAgZGlzYWJsZVBhc3Q6IGMsXG4gICAgICAgIGRpc2FibGVGdXR1cmU6IGRcbiAgICAgIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgbGV0IF8gPSBSKGEsICExKVswXSwgZiA9IFIociwgITEpWzBdO1xuICAgICAgY29uc3QgbSA9IFIoYSwgITEpWzJdLCBnID0gUihyLCAhMSlbMl07XG4gICAgICBfID0ganQoXywgYywgbCksIGYgPSBLdChmLCBkLCBsKSwgdHlwZW9mIGYgIT0gXCJudW1iZXJcIiAmJiAoZiA9IFIoZiwgITEpWzBdKTtcbiAgICAgIGNvbnN0IGIgPSBoLmZpbmRPbmUoYFske1h9XWApID09PSBudWxsLCBUID0gaC5maW5kT25lKGBbJHthdH1dYCkgIT09IG51bGwsIEMgPSBOdW1iZXIodGhpcy5faGFuZC5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgvW15cXGQtXS9nLCBcIlwiKSksIHcgPSBoLmZpbmQoXG4gICAgICAgIGBbJHtYfV1gLFxuICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgKSwgdiA9IGguZmluZChcbiAgICAgICAgYFske0t9XWAsXG4gICAgICAgIHRoaXMuX21vZGFsXG4gICAgICApLCBFID0gaC5maW5kKFxuICAgICAgICBgWyR7YXR9XWAsXG4gICAgICAgIHRoaXMuX21vZGFsXG4gICAgICApO1xuICAgICAgbGV0IEEgPSB0aGlzLl9tYWtlSG91ckRlZ3JlZXModC50YXJnZXQsIEMsIGUpLmhvdXI7XG4gICAgICBjb25zdCB7IGRlZ3JlZXM6IHksIGFkZERlZ3JlZXM6IFMgfSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyhcbiAgICAgICAgdC50YXJnZXQsXG4gICAgICAgIEMsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgICBsZXQgeyBtaW51dGU6IE8sIGRlZ3JlZXM6IGsgfSA9IHRoaXMuX21ha2VNaW51dGVzRGVncmVlcyhDLCBpKTtcbiAgICAgIGNvbnN0IEQgPSB0aGlzLl9tYWtlTWludXRlc0RlZ3JlZXMoXG4gICAgICAgIEMsXG4gICAgICAgIGlcbiAgICAgICkuYWRkRGVncmVlcztcbiAgICAgIGxldCB7IGhvdXI6IHggfSA9IHRoaXMuX21ha2VJbm5lckhvdXJzRGVncmVlcyhcbiAgICAgICAgQyxcbiAgICAgICAgblxuICAgICAgKTtcbiAgICAgIGlmICh0LmtleUNvZGUgPT09IElzKSB7XG4gICAgICAgIGNvbnN0ICQgPSBoLmZpbmRPbmUoXG4gICAgICAgICAgYFske2ZufV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICk7XG4gICAgICAgIHUudHJpZ2dlcigkLCBcImNsaWNrXCIpO1xuICAgICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICAgIGlmIChUICYmICh0LmtleUNvZGUgPT09ICRlICYmICh0aGlzLl9pc0lubmVyID0gITEsIHAuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgICAgICB9KSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICBBID4gMTIgPyAxIDogQVxuICAgICAgICApLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIHYpLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIEUpKSwgdC5rZXlDb2RlID09PSBJZSAmJiAodGhpcy5faXNJbm5lciA9ICEwLCBwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgICB9KSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICB4ID49IDI0IHx8IHggPT09IFwiMDBcIiA/IDAgOiB4XG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgRSksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgICAgICB0aGlzLl9ob3VyIC0gMSxcbiAgICAgICAgICB2XG4gICAgICAgICkpKSwgdC5rZXlDb2RlID09PSBydCkge1xuICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlck1heE1pbkhvdXJzT3B0aW9ucyhcbiAgICAgICAgICAgIHkgKyAzMCxcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBfLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICB0XG4gICAgICAgICAgKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt5ICsgU31kZWcpYFxuICAgICAgICAgIH0pLCB0aGlzLl9pc0lubmVyID8gKHggKz0gMSwgeCA9PT0gMjQgPyB4ID0gMCA6ICh4ID09PSAyNSB8fCB4ID09PSBcIjAwMVwiKSAmJiAoeCA9IDEzKSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZSh4KSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBFKSkgOiAoQSArPSAxLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgICAgQSA+IDEyID8gMSA6IEFcbiAgICAgICAgICApLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIHYpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodC5rZXlDb2RlID09PSBVKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKFxuICAgICAgICAgICAgeSAtIDMwLFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIF8sXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHRcbiAgICAgICAgICApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHAuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3kgLSBTfWRlZylgXG4gICAgICAgICAgfSksIHRoaXMuX2lzSW5uZXIgPyAoeCAtPSAxLCB4ID09PSAxMiA/IHggPSAwIDogeCA9PT0gLTEgJiYgKHggPSAyMyksIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoeCksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgRSkpIDogKEEgLT0gMSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICAgIEEgPT09IDAgPyAxMiA6IEFcbiAgICAgICAgICApLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIHYpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIHQua2V5Q29kZSA9PT0gcnQgJiYgKGsgKz0gRCwgcC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke2t9ZGVnKWBcbiAgICAgICAgfSksIE8gKz0gMSwgbyAmJiAoTyArPSA0LCBPID09PSBcIjAwMTRcIiAmJiAoTyA9IDUpKSwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICBPID4gNTkgPyAwIDogT1xuICAgICAgICApLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZShcbiAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICB0aGlzLl9taW51dGVzLFxuICAgICAgICAgIHdcbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQmFja2dyb3VuZENvbG9yQ2lyY2xlKFxuICAgICAgICAgIGBbJHtYfV1gXG4gICAgICAgICkpLCB0LmtleUNvZGUgPT09IFUgJiYgKGsgLT0gRCwgcC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke2t9ZGVnKWBcbiAgICAgICAgfSksIG8gPyBPIC09IDUgOiBPIC09IDEsIE8gPT09IC0xID8gTyA9IDU5IDogTyA9PT0gLTUgJiYgKE8gPSA1NSksIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoTyksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgIHRoaXMubWludXRlc0FycmF5LFxuICAgICAgICAgIHRoaXMuX21pbnV0ZXMsXG4gICAgICAgICAgd1xuICAgICAgICApLCB0aGlzLl90b2dnbGVCYWNrZ3JvdW5kQ29sb3JDaXJjbGUoXG4gICAgICAgICAgYFske1h9XWBcbiAgICAgICAgKSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldEFjdGl2ZUNsYXNzVG9UaXBzT25PcGVuKHQsIC4uLmUpIHtcbiAgICBpZiAoIXRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQpXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5mb3JtYXQyNCkge1xuICAgICAgICBjb25zdCBpID0gaC5maW5kKFxuICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIG4gPSBoLmZpbmQoXG4gICAgICAgICAgYFske2F0fV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoaSwgdCksIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAobiwgdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbLi4uZV0uZmlsdGVyKChuKSA9PiAobiA9PT0gXCJQTVwiID8gKHAuYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShCLCBcIlwiKSkgOiBuID09PSBcIkFNXCIgPyAocC5hZGRDbGFzcyh0aGlzLl9BTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fQU0uc2V0QXR0cmlidXRlKEIsIFwiXCIpKSA6IChwLnJlbW92ZUNsYXNzKHRoaXMuX0FNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCBwLnJlbW92ZUNsYXNzKHRoaXMuX1BNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9BTS5yZW1vdmVBdHRyaWJ1dGUoQiksIHRoaXMuX1BNLnJlbW92ZUF0dHJpYnV0ZShCKSksIG4pKTtcbiAgICAgICAgY29uc3QgaSA9IGguZmluZChcbiAgICAgICAgICBgWyR7S31dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKGksIHQpO1xuICAgICAgfVxuICB9XG4gIF9zZXRUaXBzQW5kVGltZXNEZXBlbmRPbklucHV0VmFsdWUodCwgZSkge1xuICAgIGNvbnN0IHsgaW5saW5lOiBpLCBmb3JtYXQxMjogbiB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAodGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdClcbiAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSBcIjEyXCIsIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBcIjAwXCIsIGkgfHwgcC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgIHRyYW5zZm9ybTogXCJyb3RhdGVaKDBkZWcpXCJcbiAgICAgIH0pLCBuICYmIChwLmFkZENsYXNzKHRoaXMuX1BNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9QTS5zZXRBdHRyaWJ1dGUoQiwgXCJcIikpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbyA9IHQgPiAxMiA/IHQgKiAzMCAtIDM2MCA6IHQgKiAzMDtcbiAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0LCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gZSwgaSB8fCAocC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHtvfWRlZylgXG4gICAgICB9KSwgcC5hZGRTdHlsZSh0aGlzLl9jaXJjbGUsIHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMxOTc2ZDJcIlxuICAgICAgfSksIChOdW1iZXIodCkgPiAxMiB8fCB0ID09PSBcIjAwXCIpICYmIHAuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuICBfbGlzdGVuVG9Ub2dnbGVLZXlkb3duKCkge1xuICAgIHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWAsXG4gICAgICAodCkgPT4ge1xuICAgICAgICB0LmtleUNvZGUgPT09IGx0ICYmICh0LnByZXZlbnREZWZhdWx0KCksIHUudHJpZ2dlcih0aGlzLmVsZW1lbnRUb2dnbGUsIFwiY2xpY2tcIikpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZU9wZW4oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldENvbnRhaW5lcigpO1xuICAgIGVlLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGBbZGF0YS10ZS10b2dnbGU9JyR7dGhpcy50b2dnbGVFbGVtZW50fSddYCxcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zID09PSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaSA9IHAuZ2V0RGF0YUF0dHJpYnV0ZSh0aGlzLmlucHV0LCBcInRvZ2dsZVwiKSAhPT0gbnVsbCA/IDIwMCA6IDA7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHAuYWRkU3R5bGUodGhpcy5lbGVtZW50VG9nZ2xlLCB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICAgIH0pLCB0aGlzLmVsZW1lbnRUb2dnbGUuYmx1cigpO1xuICAgICAgICAgIGxldCBuO1xuICAgICAgICAgIFIodGhpcy5pbnB1dClbMF0gPT09IFwiXCIgPyBuID0gW1wiMTJcIiwgXCIwMFwiLCBcIlBNXCJdIDogbiA9IFIodGhpcy5pbnB1dCk7XG4gICAgICAgICAgY29uc3QgeyBtb2RhbElEOiBvLCBpbmxpbmU6IHIsIGZvcm1hdDEyOiBhIH0gPSB0aGlzLl9vcHRpb25zLCBbbCwgYywgZF0gPSBuLCBfID0gTShcImRpdlwiKTtcbiAgICAgICAgICBpZiAoKE51bWJlcihsKSA+IDEyIHx8IGwgPT09IFwiMDBcIikgJiYgKHRoaXMuX2lzSW5uZXIgPSAhMCksIHRoaXMuaW5wdXQuYmx1cigpLCBlLnRhcmdldC5ibHVyKCksIF8uaW5uZXJIVE1MID0gR2YodGhpcy5fb3B0aW9ucywgdGhpcy5fY2xhc3NlcyksIHAuYWRkQ2xhc3MoXywgdGhpcy5fY2xhc3Nlcy5tb2RhbCksIF8uc2V0QXR0cmlidXRlKGpyLCBcIlwiKSwgXy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZGlhbG9nXCIpLCBfLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIFwiLTFcIiksIF8uc2V0QXR0cmlidXRlKFwiaWRcIiwgbyksIHIgPyAodGhpcy5fcG9wcGVyID0gamUodGhpcy5pbnB1dCwgXywge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiXG4gICAgICAgICAgfSksIHQuYXBwZW5kQ2hpbGQoXykpIDogKHQuYXBwZW5kQ2hpbGQoXyksIHRoaXMuX3Njcm9sbEJhci5oaWRlKCkpLCB0aGlzLl9nZXREb21FbGVtZW50cygpLCB0aGlzLl9hbmltYXRpb25zID8gdGhpcy5fdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24oKSA6IHAuYWRkQ2xhc3ModGhpcy5fd3JhcHBlciwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fc2V0QWN0aXZlQ2xhc3NUb1RpcHNPbk9wZW4obCwgYywgZCksIHRoaXMuX2FwcGVuZFRpbWVzKCksIHRoaXMuX3NldEFjdGl2ZUNsYXNzVG9UaXBzT25PcGVuKGwsIGMsIGQpLCB0aGlzLl9zZXRUaXBzQW5kVGltZXNEZXBlbmRPbklucHV0VmFsdWUobCwgYyksIHRoaXMuaW5wdXQudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBoLmZpbmQoXG4gICAgICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGEgJiYgKHAuYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShCLCBcIlwiKSksIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSBcIjEyXCIsIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBcIjAwXCIsIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoXG4gICAgICAgICAgICAgIGYsXG4gICAgICAgICAgICAgIE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZVN3aXRjaFRpbWVNb2RlKCksIHRoaXMuX2hhbmRsZU9rQnV0dG9uKCksIHRoaXMuX2hhbmRsZUNsb3NlKCksIHIpXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVIb3ZlcklubGluZUJ0bigpLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrSW5saW5lKCksIHRoaXMuX2hhbmRsZUlubGluZUNsaWNrcygpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlU3dpdGNoSG91ck1pbnV0ZSgpLCB0aGlzLl9oYW5kbGVDbG9ja0NsaWNrKCksIHRoaXMuX2hhbmRsZUtleWJvYXJkKCk7XG4gICAgICAgICAgICBjb25zdCBmID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgYCR7S2l9WyR7Qn1dYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHAuYWRkQ2xhc3MoZiwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgcC5hZGRTdHlsZSh0aGlzLl9ob3VyLCB7XG4gICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgICAgICAgICB9KSwgcC5hZGRTdHlsZSh0aGlzLl9taW51dGVzLCB7XG4gICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9mb2N1c1RyYXAgPSBuZXcgYmkodGhpcy5fd3JhcHBlciwge1xuICAgICAgICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgICAgICAgY29uZGl0aW9uOiAoeyBrZXk6IGYgfSkgPT4gZiA9PT0gXCJUYWJcIlxuICAgICAgICAgIH0pLCB0aGlzLl9mb2N1c1RyYXAudHJhcCgpO1xuICAgICAgICB9LCBpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVJbmxpbmVDbGlja3MoKSB7XG4gICAgbGV0IHQsIGU7XG4gICAgY29uc3QgaSA9IChmKSA9PiB7XG4gICAgICBsZXQgbSA9IGY7XG4gICAgICByZXR1cm4gbSA+IDU5ID8gbSA9IDAgOiBtIDwgMCAmJiAobSA9IDU5KSwgbTtcbiAgICB9LCBuID0gKGYpID0+IHtcbiAgICAgIGxldCBtID0gZjtcbiAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmZvcm1hdDI0ID8gKG0gPiAyNCA/IG0gPSAxIDogbSA8IDAgJiYgKG0gPSAyMyksIG0gPiAyMyAmJiAobSA9IDApKSA6IChtID4gMTIgPyBtID0gMSA6IG0gPCAxICYmIChtID0gMTIpLCBtID4gMTIgJiYgKG0gPSAxKSksIG07XG4gICAgfSwgbyA9IChmKSA9PiB7XG4gICAgICBjb25zdCBtID0gbihmKTtcbiAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUobSk7XG4gICAgfSwgciA9IChmKSA9PiB7XG4gICAgICBjb25zdCBtID0gaShmKTtcbiAgICAgIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUobSk7XG4gICAgfSwgYSA9ICgpID0+IHtcbiAgICAgIHQgKz0gMSwgbyh0KTtcbiAgICB9LCBsID0gKCkgPT4ge1xuICAgICAgZSArPSAxLCByKGUpO1xuICAgIH0sIGMgPSAoKSA9PiB7XG4gICAgICB0IC09IDEsIG8odCk7XG4gICAgfSwgZCA9ICgpID0+IHtcbiAgICAgIGUgLT0gMSwgcihlKTtcbiAgICB9LCBfID0gKGYpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKGYsIDEwMCk7XG4gICAgfTtcbiAgICBlZS5vbihcbiAgICAgIHRoaXMuX21vZGFsLFxuICAgICAgXCJjbGljayBtb3VzZWRvd24gbW91c2V1cCB0b3VjaHN0YXJ0IHRvdWNoZW5kIGNvbnRleHRtZW51XCIsXG4gICAgICBgWyR7bW59XSwgWyR7Z259XWAsXG4gICAgICAoZikgPT4ge1xuICAgICAgICB0ID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBlID0gTnVtYmVyKHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQpO1xuICAgICAgICBjb25zdCB7IHRhcmdldDogbSwgdHlwZTogZyB9ID0gZiwgYiA9IGcgPT09IFwibW91c2Vkb3duXCIgfHwgZyA9PT0gXCJ0b3VjaHN0YXJ0XCI7XG4gICAgICAgIG0uY2xvc2VzdChgWyR7bW59XWApID8gbS5jbG9zZXN0KGBbJHttbn1dYCkucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoVnIpID8gYiA/IF8oYSkgOiBnID09PSBcIm1vdXNldXBcIiB8fCBnID09PSBcInRvdWNoZW5kXCIgfHwgZyA9PT0gXCJjb250ZXh0bWVudVwiID8gY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCkgOiBhKCkgOiBiID8gXyhsKSA6IGcgPT09IFwibW91c2V1cFwiIHx8IGcgPT09IFwidG91Y2hlbmRcIiB8fCBnID09PSBcImNvbnRleHRtZW51XCIgPyBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSA6IGwoKSA6IG0uY2xvc2VzdChgWyR7Z259XWApICYmIChtLmNsb3Nlc3QoYFske2dufV1gKS5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShWcikgPyBiID8gXyhjKSA6IGcgPT09IFwibW91c2V1cFwiIHx8IGcgPT09IFwidG91Y2hlbmRcIiA/IGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpIDogYygpIDogYiA/IF8oZCkgOiBnID09PSBcIm1vdXNldXBcIiB8fCBnID09PSBcInRvdWNoZW5kXCIgPyBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSA6IGQoKSk7XG4gICAgICB9XG4gICAgKSwgdS5vbih3aW5kb3csIGppLCAoZikgPT4ge1xuICAgICAgY29uc3QgbSA9IGYuY29kZSwgZyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKHppKSwgYiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKFxuICAgICAgICBFblxuICAgICAgKSwgVCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHk7XG4gICAgICBzd2l0Y2ggKHQgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGUgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCksIG0pIHtcbiAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICBmLnByZXZlbnREZWZhdWx0KCksIFQgfHwgZyA/ICh0aGlzLl9ob3VyLmZvY3VzKCksIGEoKSkgOiBiICYmIGwoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICAgIGYucHJldmVudERlZmF1bHQoKSwgVCB8fCBnID8gKHRoaXMuX2hvdXIuZm9jdXMoKSwgYygpKSA6IGIgJiYgZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDbG9zZSgpIHtcbiAgICB1Lm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgWyR7dm59XSwgWyR7Zm59XSwgWyR7QnJ9XWAsXG4gICAgICAoeyB0YXJnZXQ6IHQgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IGNsb3NlTW9kYWxPbkJhY2tkcm9wQ2xpY2s6IGUgfSA9IHRoaXMuX29wdGlvbnMsIGkgPSAoKSA9PiB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgcC5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgICAgfSksIHRoaXMuX2FuaW1hdGlvbnMgJiYgdGhpcy5fdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24oITApLCB0aGlzLl9yZW1vdmVNb2RhbCgpLCAobiA9IHRoaXMuX2ZvY3VzVHJhcCkgPT0gbnVsbCB8fCBuLmRpc2FibGUoKSwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5lbGVtZW50VG9nZ2xlID8gdGhpcy5lbGVtZW50VG9nZ2xlLmZvY3VzKCkgOiB0aGlzLmlucHV0ICYmIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHQuaGFzQXR0cmlidXRlKEJyKSkge1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZUFtUG0oXCJQTVwiKSwgdGhpcy5pbnB1dC52YWx1ZSA9IFwiXCIsIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKEIpO1xuICAgICAgICAgIGxldCBuO1xuICAgICAgICAgIFIodGhpcy5pbnB1dClbMF0gPT09IFwiXCIgPyBuID0gW1wiMTJcIiwgXCIwMFwiLCBcIlBNXCJdIDogbiA9IFIodGhpcy5pbnB1dCk7XG4gICAgICAgICAgY29uc3QgW28sIHIsIGFdID0gbjtcbiAgICAgICAgICB0aGlzLl9zZXRUaXBzQW5kVGltZXNEZXBlbmRPbklucHV0VmFsdWUoXCIxMlwiLCBcIjAwXCIpLCB0aGlzLl9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3BlbihvLCByLCBhKSwgdGhpcy5faG91ci5jbGljaygpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAodC5oYXNBdHRyaWJ1dGUoZm4pIHx8IHQuaGFzQXR0cmlidXRlKF9uKSB8fCB0Lmhhc0F0dHJpYnV0ZSh2bikgJiYgZSkgJiYgaSgpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgc2hvd1ZhbHVlSW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsdWU7XG4gIH1cbiAgX2hhbmRsZU9rQnV0dG9uKCkge1xuICAgIGVlLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgWyR7X259XWAsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGxldCB7IG1heFRpbWU6IHQsIG1pblRpbWU6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmb3JtYXQxMjogaSxcbiAgICAgICAgICBmb3JtYXQyNDogbixcbiAgICAgICAgICByZWFkT25seTogbyxcbiAgICAgICAgICBmb2N1c0lucHV0QWZ0ZXJBcHByb3ZlOiByLFxuICAgICAgICAgIGRpc2FibGVQYXN0OiBhLFxuICAgICAgICAgIGRpc2FibGVGdXR1cmU6IGxcbiAgICAgICAgfSA9IHRoaXMuX29wdGlvbnMsIGMgPSB0aGlzLl9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGAke1VpfVske0J9XWBcbiAgICAgICAgKSwgZCA9IGAke3RoaXMuX2hvdXIudGV4dENvbnRlbnR9OiR7dGhpcy5fbWludXRlcy50ZXh0Q29udGVudH1gLCBfID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBmID0gXyA9PT0gMTIgJiYgaSA/IDAgOiBfLCBtID0gTnVtYmVyKHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQpO1xuICAgICAgICBlID0ganQoZSwgYSwgaSksIHQgPSBLdCh0LCBsLCBpKTtcbiAgICAgICAgbGV0IFtnLCBiLCBUXSA9IFIoXG4gICAgICAgICAgdCxcbiAgICAgICAgICAhMVxuICAgICAgICApLCBbQywgdywgdl0gPSBSKFxuICAgICAgICAgIGUsXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgICAgQyA9IEMgPT09IFwiMTJcIiAmJiBpID8gXCIwMFwiIDogQywgZyA9IGcgPT09IFwiMTJcIiAmJiBpID8gXCIwMFwiIDogZztcbiAgICAgICAgY29uc3QgRSA9IGYgPCBOdW1iZXIoQyksIEEgPSBmID4gTnVtYmVyKGcpO1xuICAgICAgICBsZXQgeSA9ICEwO1xuICAgICAgICBjICYmICh5ID0gVCA9PT0gYy50ZXh0Q29udGVudCk7XG4gICAgICAgIGxldCBTID0gITA7XG4gICAgICAgIGMgJiYgKFMgPSB2ID09PSBjLnRleHRDb250ZW50KTtcbiAgICAgICAgY29uc3QgTyA9IG0gPiBiICYmIGYgPT09IE51bWJlcihnKSwgayA9IG0gPCB3ICYmIGYgPT09IE51bWJlcihDKTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKEIsIFwiXCIpLCBwLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgIH0pLCB0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgaWYgKHkgJiYgKEEgfHwgTykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKFQgPT09IFwiQU1cIiAmJiBjLnRleHRDb250ZW50ID09PSBcIlBNXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZSAhPT0gXCJcIiAmJiAoUyAmJiAoRSB8fCBrKSB8fCB2ID09PSBcIlBNXCIgJiYgYy50ZXh0Q29udGVudCA9PT0gXCJBTVwiKSB8fCBaZihcbiAgICAgICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgICAgIHRoaXMuaW5wdXQsXG4gICAgICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudFxuICAgICAgICApICE9PSB2b2lkIDAgJiYgKHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgJiYgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYm4pLCAhbyAmJiByICYmIHRoaXMuaW5wdXQuZm9jdXMoKSwgcC5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIlxuICAgICAgICB9KSwgbiA/IHRoaXMuaW5wdXQudmFsdWUgPSBkIDogYyA9PT0gbnVsbCA/IHRoaXMuaW5wdXQudmFsdWUgPSBgJHtkfSBQTWAgOiB0aGlzLmlucHV0LnZhbHVlID0gYCR7ZH0gJHtjLnRleHRDb250ZW50fWAsIHRoaXMuX2FuaW1hdGlvbnMgJiYgdGhpcy5fdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24oITApLCB0aGlzLl9yZW1vdmVNb2RhbCgpLCB1LnRyaWdnZXIodGhpcy5pbnB1dCwgXCJpbnB1dC50ZS50aW1lcGlja2VyXCIpLCB1LnRyaWdnZXIodGhpcy5pbnB1dCwgXCJpbnB1dFwiKSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlSG92ZXJJbmxpbmVCdG4oKSB7XG4gICAgZWUub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwibW91c2VvdmVyIG1vdXNlbGVhdmVcIixcbiAgICAgIGBbJHtjX31dYCxcbiAgICAgICh7IHR5cGU6IHQsIHRhcmdldDogZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSBoLmZpbmQoXG4gICAgICAgICAgYFske2FffV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIG4gPSBoLmZpbmQoXG4gICAgICAgICAgYFske2xffV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIG8gPSAobCwgYykgPT4gbC5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgIHAuYWRkQ2xhc3MoZCwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgZC5zZXRBdHRyaWJ1dGUoQiwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHAucmVtb3ZlQ2xhc3MoZCwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgZC5yZW1vdmVBdHRyaWJ1dGUoQik7XG4gICAgICAgIH0pLCBhID0gZS5oYXNBdHRyaWJ1dGUoemkpID8gaSA6IG47XG4gICAgICAgIG8oYSwgdCA9PT0gXCJtb3VzZW92ZXJcIik7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlRG9jdW1lbnRDbGlja0lubGluZSgpIHtcbiAgICB1Lm9uKGRvY3VtZW50LCBEciwgKHsgdGFyZ2V0OiB0IH0pID0+IHtcbiAgICAgIGlmICh0aGlzLl9tb2RhbCAmJiAhdGhpcy5fbW9kYWwuY29udGFpbnModCkgJiYgIXQuaGFzQXR0cmlidXRlKHJfKSkge1xuICAgICAgICBpZiAoY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksIHAuYWRkU3R5bGUodGhpcy5lbGVtZW50VG9nZ2xlLCB7XG4gICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgfSksIHRoaXMuX3JlbW92ZU1vZGFsKCksICF0aGlzLl9hbmltYXRpb25zKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24oITApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVTd2l0Y2hIb3VyTWludXRlKCkge1xuICAgIFFmKFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgS2ksXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdS5vbihcbiAgICAgIHRoaXMuX21vZGFsLFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgS2ksXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZm9ybWF0MjQ6IHQgfSA9IHRoaXMuX29wdGlvbnMsIGUgPSBoLmZpbmQoXG4gICAgICAgICAgS2ksXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgaSA9IGguZmluZChcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBuID0gaC5maW5kKFxuICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIG8gPSBoLmZpbmQoXG4gICAgICAgICAgYFske2F0fV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIHIgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGEgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCksIGwgPSAoYywgZCkgPT4ge1xuICAgICAgICAgIG4uZm9yRWFjaCgoZikgPT4gZi5yZW1vdmUoKSksIGkuZm9yRWFjaCgoZikgPT4gZi5yZW1vdmUoKSksIHAuYWRkQ2xhc3ModGhpcy5faGFuZCwgdGhpcy5fY2xhc3Nlcy50cmFuc2Zvcm0pLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHAucmVtb3ZlQ2xhc3ModGhpcy5faGFuZCwgdGhpcy5fY2xhc3Nlcy50cmFuc2Zvcm0pO1xuICAgICAgICAgIH0sIDQwMSksIHRoaXMuX2dldEFwcGVuZENsb2NrKGMsIGBbJHtsZX1dYCwgZCk7XG4gICAgICAgICAgY29uc3QgXyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBoLmZpbmQoXG4gICAgICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKSwgbSA9IGguZmluZChcbiAgICAgICAgICAgICAgYFske1h9XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChmLCByKSwgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChtLCBhKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICghdClcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBfKCk7XG4gICAgICAgICAgICB9LCA0MDEpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZiA9IGguZmluZChcbiAgICAgICAgICAgICAgYFske2F0fV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKGYsIHIpLCBfKCk7XG4gICAgICAgICAgICB9LCA0MDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgYy5oYXNBdHRyaWJ1dGUoQikgJiYgKGMuaGFzQXR0cmlidXRlKEVuKSA/IChwLmFkZENsYXNzKHRoaXMuX2hhbmQsIHRoaXMuX2NsYXNzZXMudHJhbnNmb3JtKSwgcC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7dGhpcy5fbWludXRlcy50ZXh0Q29udGVudCAqIDZ9ZGVnKWAsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiY2FsYyg0MCUgKyAxcHgpXCJcbiAgICAgICAgICB9KSwgdCAmJiBvLmxlbmd0aCA+IDAgJiYgby5mb3JFYWNoKChkKSA9PiBkLnJlbW92ZSgpKSwgbChcbiAgICAgICAgICAgIHRoaXMubWludXRlc0FycmF5LFxuICAgICAgICAgICAgWFxuICAgICAgICAgICksIHRoaXMuX2hvdXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiXCIsIHRoaXMuX21pbnV0ZXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiKSA6IGMuaGFzQXR0cmlidXRlKHppKSAmJiAocC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7dGhpcy5faG91ci50ZXh0Q29udGVudCAqIDMwfWRlZylgXG4gICAgICAgICAgfSksIE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSA+IDEyID8gKHAuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3RoaXMuX2hvdXIudGV4dENvbnRlbnQgKiAzMCAtIDM2MH1kZWcpYCxcbiAgICAgICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICAgICAgfSksIE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSA+IDEyICYmIHAuYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgaGVpZ2h0OiBcIjIxLjUlXCJcbiAgICAgICAgICB9KSkgOiBwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgICAgICAgIH0pLCB0ICYmIHRoaXMuX2dldEFwcGVuZENsb2NrKFxuICAgICAgICAgICAgdGhpcy5pbm5lckhvdXJzLFxuICAgICAgICAgICAgYFske0plfV1gLFxuICAgICAgICAgICAgYXRcbiAgICAgICAgICApLCBvLmxlbmd0aCA+IDAgJiYgby5mb3JFYWNoKChkKSA9PiBkLnJlbW92ZSgpKSwgbChcbiAgICAgICAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgICAgICAgIEtcbiAgICAgICAgICApLCBwLmFkZFN0eWxlKHRoaXMuX2hvdXIsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgICAgICAgfSksIHAuYWRkU3R5bGUodGhpcy5fbWludXRlcywge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJcIlxuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZURpc2FibGluZ1RpcHNNYXhUaW1lKHQsIGUsIGksIG4pIHtcbiAgICBpZiAoIXRoaXMuX29wdGlvbnMubWF4VGltZSAmJiAhdGhpcy5fb3B0aW9ucy5kaXNhYmxlRnV0dXJlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSBoLmZpbmQoXG4gICAgICBgWyR7S31dYFxuICAgICksIHIgPSBoLmZpbmQoXG4gICAgICBgWyR7YXR9XWBcbiAgICApLCBhID0gaC5maW5kKFxuICAgICAgYFske1h9XWBcbiAgICApO1xuICAgIGlmICghZSB8fCBlID09PSB0KSB7XG4gICAgICBPcihcbiAgICAgICAgcixcbiAgICAgICAgbixcbiAgICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICAgKSwgT3IoXG4gICAgICAgIG8sXG4gICAgICAgIG4sXG4gICAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICAgICksIEpmKFxuICAgICAgICBhLFxuICAgICAgICBpLFxuICAgICAgICBuLFxuICAgICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50LFxuICAgICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlID09PSBcIkFNXCIgJiYgdCA9PT0gXCJQTVwiICYmIChvLmZvckVhY2goKGwpID0+IHtcbiAgICAgIHAuYWRkQ2xhc3MobCwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBsLnNldEF0dHJpYnV0ZShCdCwgXCJcIik7XG4gICAgfSksIGEuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgcC5hZGRDbGFzcyhsLCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIGwuc2V0QXR0cmlidXRlKEJ0LCBcIlwiKTtcbiAgICB9KSk7XG4gIH1cbiAgX2hhbmRsZURpc2FibGluZ1RpcHNNaW5UaW1lKHQsIGUsIGksIG4pIHtcbiAgICBpZiAoIXRoaXMuX29wdGlvbnMubWluVGltZSAmJiAhdGhpcy5fb3B0aW9ucy5kaXNhYmxlUGFzdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gaC5maW5kKFxuICAgICAgYFske0t9XWBcbiAgICApLCByID0gaC5maW5kKFxuICAgICAgYFske2F0fV1gXG4gICAgKSwgYSA9IGguZmluZChcbiAgICAgIGBbJHtYfV1gXG4gICAgKTtcbiAgICAhZSB8fCBlID09PSB0ID8gKHhyKFxuICAgICAgbyxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICksIHhyKFxuICAgICAgcixcbiAgICAgIG4sXG4gICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICksIHRfKFxuICAgICAgYSxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCxcbiAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgKSkgOiBlID09PSBcIlBNXCIgJiYgdCA9PT0gXCJBTVwiICYmIChvLmZvckVhY2goKGwpID0+IHtcbiAgICAgIHAuYWRkQ2xhc3MobCwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBsLnNldEF0dHJpYnV0ZShCdCwgXCJcIik7XG4gICAgfSksIGEuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgcC5hZGRDbGFzcyhsLCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIGwuc2V0QXR0cmlidXRlKEJ0LCBcIlwiKTtcbiAgICB9KSk7XG4gIH1cbiAgX2hhbmRsZVN3aXRjaFRpbWVNb2RlKCkge1xuICAgIHUub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIFVpLFxuICAgICAgKHsgdGFyZ2V0OiB0IH0pID0+IHtcbiAgICAgICAgbGV0IHsgbWF4VGltZTogZSwgbWluVGltZTogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBkaXNhYmxlUGFzdDogbiwgZGlzYWJsZUZ1dHVyZTogbywgZm9ybWF0MTI6IHIgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGkgPSBqdChpLCBuLCByKSwgZSA9IEt0KGUsIG8sIHIpO1xuICAgICAgICBjb25zdCBbYSwgbCwgY10gPSBSKFxuICAgICAgICAgIGUsXG4gICAgICAgICAgITFcbiAgICAgICAgKSwgW2QsIF8sIGZdID0gUihcbiAgICAgICAgICBpLFxuICAgICAgICAgICExXG4gICAgICAgICksIG0gPSBoLmZpbmQoXG4gICAgICAgICAgYFske0t9XWBcbiAgICAgICAgKSwgZyA9IGguZmluZChcbiAgICAgICAgICBgWyR7WH1dYFxuICAgICAgICApO1xuICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgIG0uZm9yRWFjaCgoVCkgPT4ge1xuICAgICAgICAgICAgcC5yZW1vdmVDbGFzcyhULCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIFQucmVtb3ZlQXR0cmlidXRlKEJ0KTtcbiAgICAgICAgICB9KSwgZy5mb3JFYWNoKChUKSA9PiB7XG4gICAgICAgICAgICBwLnJlbW92ZUNsYXNzKFQsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgVC5yZW1vdmVBdHRyaWJ1dGUoQnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpLCB0aGlzLl9oYW5kbGVEaXNhYmxpbmdUaXBzTWluVGltZShcbiAgICAgICAgICB0LnRleHRDb250ZW50LFxuICAgICAgICAgIGYsXG4gICAgICAgICAgXyxcbiAgICAgICAgICBkXG4gICAgICAgICksIHRoaXMuX2hhbmRsZURpc2FibGluZ1RpcHNNYXhUaW1lKFxuICAgICAgICAgIHQudGV4dENvbnRlbnQsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBsLFxuICAgICAgICAgIGFcbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQW1QbSh0LnRleHRDb250ZW50KSwgdC5oYXNBdHRyaWJ1dGUoQikgfHwgKGguZmluZChcbiAgICAgICAgICBVaVxuICAgICAgICApLmZvckVhY2goKEMpID0+IHtcbiAgICAgICAgICBDLmhhc0F0dHJpYnV0ZShCKSAmJiAocC5yZW1vdmVDbGFzcyhDLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCBDLnJlbW92ZUF0dHJpYnV0ZShCKSk7XG4gICAgICAgIH0pLCBwLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHQuc2V0QXR0cmlidXRlKEIsIFwiXCIpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVDbG9ja0NsaWNrKCkge1xuICAgIGxldCB7IG1heFRpbWU6IHQsIG1pblRpbWU6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgeyBkaXNhYmxlUGFzdDogaSwgZGlzYWJsZUZ1dHVyZTogbiwgZm9ybWF0MTI6IG8gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgZSA9IGp0KGUsIGksIG8pLCB0ID0gS3QodCwgbiwgbyk7XG4gICAgY29uc3QgciA9IFIodCwgITEpWzJdLCBhID0gUihlLCAhMSlbMl0sIGwgPSBSKHQsICExKVswXSwgYyA9IFIoZSwgITEpWzBdLCBkID0gaC5maW5kT25lKFxuICAgICAgYFske0ZyfV1gXG4gICAgKTtcbiAgICBlZS5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgYCR7SXJ9ICR7JHJ9ICR7THJ9ICR7TXJ9ICR7TnJ9ICR7SHJ9ICR7UnJ9ICR7UHJ9YCxcbiAgICAgIFwiXCIsXG4gICAgICAoXykgPT4ge1xuICAgICAgICBZaSgpIHx8IF8ucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgeyB0eXBlOiBmLCB0YXJnZXQ6IG0gfSA9IF8sIHsgY2xvc2VNb2RhbE9uTWludXRlc0NsaWNrOiBnLCBzd2l0Y2hIb3Vyc1RvTWludXRlc09uQ2xpY2s6IGIgfSA9IHRoaXMuX29wdGlvbnMsIFQgPSBoLmZpbmRPbmUoXG4gICAgICAgICAgYFske1h9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSAhPT0gbnVsbCwgQyA9IGguZmluZE9uZShcbiAgICAgICAgICBgWyR7S31dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApICE9PSBudWxsLCB3ID0gaC5maW5kT25lKFxuICAgICAgICAgIGBbJHthdH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApICE9PSBudWxsLCB2ID0gaC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIEUgPSBrcihfLCBkKSwgQSA9IGQub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICBsZXQgeSA9IE1hdGguYXRhbjIoRS55IC0gQSwgRS54IC0gQSk7XG4gICAgICAgIGlmIChZaSgpKSB7XG4gICAgICAgICAgY29uc3QgRCA9IGtyKF8sIGQsICEwKTtcbiAgICAgICAgICB5ID0gTWF0aC5hdGFuMihELnkgLSBBLCBELnggLSBBKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgUyA9IG51bGwsIE8gPSBudWxsLCBrID0gbnVsbDtcbiAgICAgICAgaWYgKGYgPT09IFwibW91c2Vkb3duXCIgfHwgZiA9PT0gXCJtb3VzZW1vdmVcIiB8fCBmID09PSBcInRvdWNobW92ZVwiIHx8IGYgPT09IFwidG91Y2hzdGFydFwiKVxuICAgICAgICAgIChmID09PSBcIm1vdXNlZG93blwiIHx8IGYgPT09IFwidG91Y2hzdGFydFwiIHx8IGYgPT09IFwidG91Y2htb3ZlXCIpICYmICh0aGlzLl9oYXNUYXJnZXRJbm5lckNsYXNzKG0pIHx8IG0uaGFzQXR0cmlidXRlKEZyKSB8fCBtLmhhc0F0dHJpYnV0ZShsZSkgfHwgbS5oYXNBdHRyaWJ1dGUoWCkgfHwgbS5oYXNBdHRyaWJ1dGUoSykgfHwgbS5oYXNBdHRyaWJ1dGUoQ24pIHx8IG0uaGFzQXR0cmlidXRlKFRuKSB8fCBtLmhhc0F0dHJpYnV0ZShZcikgfHwgbS5oYXNBdHRyaWJ1dGUoWGkpKSAmJiAodGhpcy5faXNNb3VzZU1vdmUgPSAhMCwgWWkoKSAmJiBfLnRvdWNoZXMgJiYgKFMgPSBfLnRvdWNoZXNbMF0uY2xpZW50WCwgTyA9IF8udG91Y2hlc1swXS5jbGllbnRZLCBrID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChTLCBPKSkpO1xuICAgICAgICBlbHNlIGlmIChmID09PSBcIm1vdXNldXBcIiB8fCBmID09PSBcInRvdWNoZW5kXCIpIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNNb3VzZU1vdmUgPSAhMSwgdGhpcy5faGFzVGFyZ2V0SW5uZXJDbGFzcyhtKSB8fCBtLmhhc0F0dHJpYnV0ZShsZSkgfHwgbS5oYXNBdHRyaWJ1dGUoSykgfHwgbS5oYXNBdHRyaWJ1dGUoQ24pIHx8IG0uaGFzQXR0cmlidXRlKFRuKSB8fCBtLmhhc0F0dHJpYnV0ZShZcikgfHwgbS5oYXNBdHRyaWJ1dGUoWGkpKSB7XG4gICAgICAgICAgICBpZiAoKEMgfHwgdykgJiYgYikge1xuICAgICAgICAgICAgICBjb25zdCBEID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpID4gbCB8fCBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPCBjO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5mb3JtYXQyNCAmJiBsICE9PSBcIlwiICYmIGMgIT09IFwiXCIgJiYgRClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0ICYmIGMgIT09IFwiXCIgJiYgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpIDwgYylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1LnRyaWdnZXIodGhpcy5fbWludXRlcywgXCJjbGlja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFQgJiYgZykge1xuICAgICAgICAgICAgY29uc3QgRCA9IGguZmluZE9uZShcbiAgICAgICAgICAgICAgYFske19ufV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHUudHJpZ2dlcihELCBcImNsaWNrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoVCkge1xuICAgICAgICAgIGxldCBEO1xuICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnRydW5jKHkgKiAxODAgLyBNYXRoLlBJKSArIDkwLCB7IGRlZ3JlZXM6ICQsIG1pbnV0ZTogUCB9ID0gdGhpcy5fbWFrZU1pbnV0ZXNEZWdyZWVzKHgsIEQpO1xuICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyTWF4TWluTWludXRlc09wdGlvbnMoJCwgUCkgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCB7IGRlZ3JlZXM6IHR0LCBtaW51dGU6IGV0IH0gPSB0aGlzLl9oYW5kbGVyTWF4TWluTWludXRlc09wdGlvbnMoJCwgUCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAocC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0dH1kZWcpYFxuICAgICAgICAgICAgfSksIGV0ID09PSB2b2lkIDApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHogPSAoKSA9PiBldCA+PSAxMCB8fCBldCA9PT0gXCIwMFwiID8gZXQgOiBgMCR7ZXR9YDtcbiAgICAgICAgICAgIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSB6KCksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICAgICAgdGhpcy5fbWludXRlcyxcbiAgICAgICAgICAgICAgdlxuICAgICAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQmFja2dyb3VuZENvbG9yQ2lyY2xlKFxuICAgICAgICAgICAgICBgWyR7WH1dYFxuICAgICAgICAgICAgKSwgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZS5kZWdyZWVzTWludXRlcyA9IHR0LCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLm1pbnV0ZXMgPSBldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEMgfHwgdykge1xuICAgICAgICAgIGxldCBELCB4ID0gTWF0aC50cnVuYyh5ICogMTgwIC8gTWF0aC5QSSkgKyA5MDtcbiAgICAgICAgICBpZiAoeCA9IE1hdGgucm91bmQoeCAvIDMwKSAqIDMwLCBwLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMxOTc2ZDJcIlxuICAgICAgICAgIH0pLCB0aGlzLl9tYWtlSG91ckRlZ3JlZXMobSwgeCwgRCkgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCAkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKFlpKCkgJiYgeCAmJiBrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgZGVncmVlczogUCwgaG91cjogdHQgfSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyhrLCB4LCBEKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZU1vdmVIYW5kKFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgdHQsXG4gICAgICAgICAgICAgICAgUFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkZWdyZWVzOiBQLCBob3VyOiB0dCB9ID0gdGhpcy5fbWFrZUhvdXJEZWdyZWVzKG0sIHgsIEQpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlTW92ZUhhbmQobSwgdHQsIFApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZS5kZWdyZWVzSG91cnMgPSB4LCB0aGlzLl9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBfXG4gICAgICAgICAgKSAmJiAkKCk7XG4gICAgICAgIH1cbiAgICAgICAgXy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYXNUYXJnZXRJbm5lckNsYXNzKHQpIHtcbiAgICByZXR1cm4gdC5oYXNBdHRyaWJ1dGUoSmUpIHx8IHQuaGFzQXR0cmlidXRlKGF0KSB8fCB0Lmhhc0F0dHJpYnV0ZShHaSk7XG4gIH1cbiAgX2hhbmRsZU1vdmVIYW5kKHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gaC5maW5kKFxuICAgICAgYFske0t9XWAsXG4gICAgICB0aGlzLl9tb2RhbFxuICAgICksIG8gPSBoLmZpbmQoXG4gICAgICBgWyR7YXR9XWAsXG4gICAgICB0aGlzLl9tb2RhbFxuICAgICk7XG4gICAgdGhpcy5faXNNb3VzZU1vdmUgJiYgKHRoaXMuX2hhc1RhcmdldElubmVyQ2xhc3ModCkgPyBwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgfSkgOiBwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgIH0pLCBwLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHtpfWRlZylgXG4gICAgfSksIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSBlID49IDEwIHx8IGUgPT09IFwiMDBcIiA/IGUgOiBgMCR7ZX1gLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIG4pLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIG8pLCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLmhvdXIgPSBlID49IDEwIHx8IGUgPT09IFwiMDBcIiA/IGUgOiBgMCR7ZX1gKTtcbiAgfVxuICBfaGFuZGxlck1heE1pbk1pbnV0ZXNPcHRpb25zKHQsIGUpIHtcbiAgICBsZXQgeyBtYXhUaW1lOiBpLCBtaW5UaW1lOiBuIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IHsgZm9ybWF0MTI6IG8sIGluY3JlbWVudDogciwgZGlzYWJsZVBhc3Q6IGEsIGRpc2FibGVGdXR1cmU6IGwgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgbiA9IGp0KG4sIGEsIG8pLCBpID0gS3QoaSwgbCwgbyk7XG4gICAgY29uc3QgYyA9IFIoaSwgITEpWzFdLCBkID0gUihuLCAhMSlbMV0sIF8gPSBSKGksICExKVswXSwgZiA9IFIobiwgITEpWzBdLCBtID0gZiA9PT0gXCIxMlwiICYmIG8gPyBcIjBcIiA6IGYsIGcgPSBfID09PSBcIjEyXCIgJiYgbyA/IFwiMFwiIDogXywgYiA9IFIoaSwgITEpWzJdLCBUID0gUihuLCAhMSlbMl0sIEMgPSBjICE9PSBcIlwiID8gYyAqIDYgOiBcIlwiLCB3ID0gZCAhPT0gXCJcIiA/IGQgKiA2IDogXCJcIiwgdiA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgRSA9IHYgPT09IDEyICYmIG8gPyAwIDogdjtcbiAgICBpZiAoIWIgJiYgIVQpIHtcbiAgICAgIGlmIChpICE9PSBcIlwiICYmIG4gIT09IFwiXCIpIHtcbiAgICAgICAgaWYgKE51bWJlcihnKSA9PT0gRSAmJiB0ID4gQyB8fCBOdW1iZXIobSkgPT09IEUgJiYgdCA8IHcpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9IGVsc2UgaWYgKG4gIT09IFwiXCIgJiYgRSA8PSBOdW1iZXIobSkpIHtcbiAgICAgICAgaWYgKHQgPD0gdyAtIDYpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9IGVsc2UgaWYgKGkgIT09IFwiXCIgJiYgRSA+PSBOdW1iZXIoZykgJiYgdCA+PSBDICsgNilcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuICE9PSBcIlwiKSB7XG4gICAgICAgIGlmIChUID09PSBcIlBNXCIgJiYgdGhpcy5faXNBbUVuYWJsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoVCA9PT0gXCJQTVwiICYmIHRoaXMuX2lzUG1FbmFibGVkKSB7XG4gICAgICAgICAgaWYgKEUgPCBOdW1iZXIobSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKEUgPD0gTnVtYmVyKG0pICYmIHQgPD0gdyAtIDYpXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSBlbHNlIGlmIChUID09PSBcIkFNXCIgJiYgdGhpcy5faXNBbUVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoRSA8IE51bWJlcihtKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAoRSA8PSBOdW1iZXIobSkgJiYgdCA8PSB3IC0gNilcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSAhPT0gXCJcIikge1xuICAgICAgICBpZiAoYiA9PT0gXCJBTVwiICYmIHRoaXMuX2lzUG1FbmFibGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGIgPT09IFwiUE1cIiAmJiB0aGlzLl9pc1BtRW5hYmxlZCkge1xuICAgICAgICAgIGlmIChFID49IE51bWJlcihnKSAmJiB0ID49IEMgKyA2KVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gXCJBTVwiICYmIHRoaXMuX2lzQW1FbmFibGVkICYmIEUgPj0gTnVtYmVyKGcpICYmIHQgPj0gQyArIDYpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByICYmICh0ID0gTWF0aC5yb3VuZCh0IC8gMzApICogMzApLCB0IDwgMCA/IHQgPSAzNjAgKyB0IDogdCA+PSAzNjAgJiYgKHQgPSAwKSwge1xuICAgICAgZGVncmVlczogdCxcbiAgICAgIG1pbnV0ZTogZVxuICAgIH07XG4gIH1cbiAgX3JlbW92ZU1vZGFsKCkge1xuICAgIHRoaXMuX2FuaW1hdGlvbnMgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZU1vZGFsRWxlbWVudHMoKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgfSwgMzAwKSA6ICh0aGlzLl9yZW1vdmVNb2RhbEVsZW1lbnRzKCksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpKSwgZWUub2ZmKFxuICAgICAgdGhpcy5fZG9jdW1lbnQsXG4gICAgICBgJHtEcn0gJHtqaX0gJHtJcn0gJHskcn0gJHtMcn0gJHtNcn0gJHtOcn0gJHtIcn0gJHtScn0gJHtQcn1gXG4gICAgKSwgdS5vZmYod2luZG93LCBqaSk7XG4gIH1cbiAgX3JlbW92ZU1vZGFsRWxlbWVudHMoKSB7XG4gICAgdGhpcy5fbW9kYWwgJiYgdGhpcy5fbW9kYWwucmVtb3ZlKCk7XG4gIH1cbiAgX3RvZ2dsZUJhY2tkcm9wQW5pbWF0aW9uKHQgPSAhMSkge1xuICAgIHQgPyB0aGlzLl93cmFwcGVyLmNsYXNzTGlzdC5hZGQoXCJhbmltYXRlLVtmYWRlLW91dF8zNTBtc19lYXNlLWluLW91dF1cIikgOiAodGhpcy5fd3JhcHBlci5jbGFzc0xpc3QuYWRkKFwiYW5pbWF0ZS1bZmFkZS1pbl8zNTBtc19lYXNlLWluLW91dF1cIiksIHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHAuYWRkQ2xhc3ModGhpcy5fY2xvY2ssIHRoaXMuX2NsYXNzZXMuY2xvY2tBbmltYXRpb24pKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl93cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgIFwiYW5pbWF0ZS1bZmFkZS1vdXRfMzUwbXNfZWFzZS1pbi1vdXRdXCIsXG4gICAgICAgIFwiYW5pbWF0ZS1bZmFkZS1pbl8zNTBtc19lYXNlLWluLW91dF1cIlxuICAgICAgKTtcbiAgICB9LCAzNTEpO1xuICB9XG4gIF9hZGRBY3RpdmVDbGFzc1RvVGlwKHQsIGUpIHtcbiAgICB0LmZvckVhY2goKGkpID0+IHtcbiAgICAgIE51bWJlcihpLnRleHRDb250ZW50KSA9PT0gTnVtYmVyKGUpICYmIChwLmFkZENsYXNzKGksIHRoaXMuX2NsYXNzZXMudGlwc0FjdGl2ZSksIGkuc2V0QXR0cmlidXRlKEIsIFwiXCIpKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0SG91ck9yTWludXRlKHQpIHtcbiAgICByZXR1cm4gdCA8IDEwID8gYDAke3R9YCA6IHQ7XG4gIH1cbiAgX2FwcGVuZFRpbWVzKCkge1xuICAgIGNvbnN0IHsgZm9ybWF0MjQ6IHQgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgaWYgKHQpIHtcbiAgICAgIHRoaXMuX2dldEFwcGVuZENsb2NrKFxuICAgICAgICB0aGlzLmhvdXJzQXJyYXksXG4gICAgICAgIGBbJHtsZX1dYCxcbiAgICAgICAgS1xuICAgICAgKSwgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICAgIHRoaXMuaW5uZXJIb3VycyxcbiAgICAgICAgYFske0plfV1gLFxuICAgICAgICBhdFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICB0aGlzLmhvdXJzQXJyYXksXG4gICAgICBgWyR7bGV9XWAsXG4gICAgICBLXG4gICAgKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnBfLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKGhpLCB0LCBmXyksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5fXyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTihoaSwgdCwgbV8pLCB0O1xuICB9XG4gIF9nZXRDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZSh0aGlzLl9vcHRpb25zLmNvbnRhaW5lcik7XG4gIH1cbiAgX2dldFZhbGlkYXRlKHQpIHtcbiAgICBjb25zdCB7IGludmFsaWRMYWJlbDogZSwgZm9ybWF0MjQ6IGksIGZvcm1hdDEyOiBuLCBhcHBlbmRWYWxpZGF0aW9uSW5mbzogbyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBsZXQgcjtcbiAgICBvICYmIChyID0gTShcImRpdlwiKSwgci5zZXRBdHRyaWJ1dGUoV3IsIFwiXCIpLCByLmlubmVySFRNTCA9IGUpLCBlZS5vbih0aGlzLmlucHV0LCB0LCAoeyB0YXJnZXQ6IGEgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMgPT09IG51bGwgfHwgdGhpcy5pbnB1dC52YWx1ZSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbCA9IC9eKDA/WzEtOV18MVswMTJdKSg6WzAtNV1cXGQpIFtBUGFwXVttTV0kLywgYyA9IC9eKFswMV1cXGR8MlswLTNdKSg6WzAtNV1cXGQpJC8sIGQgPSBsLnRlc3QoYS52YWx1ZSk7XG4gICAgICBpZiAoYy50ZXN0KGEudmFsdWUpICE9PSAhMCAmJiBpIHx8IGQgIT09ICEwICYmIG4pIHtcbiAgICAgICAgbyAmJiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoYm4sIFwiXCIpLCB0aGlzLmlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgIHIsXG4gICAgICAgICAgdGhpcy5pbnB1dC5uZXh0U2libGluZ1xuICAgICAgICApKSwgcC5hZGRTdHlsZShhLCB7IG1hcmdpbkJvdHRvbTogMCB9KSwgcC5hZGRTdHlsZShyLCB7IGJvdHRvbTogXCItMjNweFwiIH0pLCB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gITA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKGJuKSwgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICExO1xuICAgICAgY29uc3QgZiA9IGguZmluZE9uZShcbiAgICAgICAgYFske1dyfV1gXG4gICAgICApO1xuICAgICAgZiAhPT0gbnVsbCAmJiBmLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgX3MpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbi8qIVxuICogcGVyZmVjdC1zY3JvbGxiYXIgdjEuNS4zXG4gKiBDb3B5cmlnaHQgMjAyMSBIeXVuamUgSnVuLCBNREJvb3RzdHJhcCBhbmQgQ29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqL1xuZnVuY3Rpb24geHQocykge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShzKTtcbn1cbmZ1bmN0aW9uIG90KHMsIHQpIHtcbiAgZm9yICh2YXIgZSBpbiB0KSB7XG4gICAgdmFyIGkgPSB0W2VdO1xuICAgIHR5cGVvZiBpID09IFwibnVtYmVyXCIgJiYgKGkgPSBpICsgXCJweFwiKSwgcy5zdHlsZVtlXSA9IGk7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBxaShzKSB7XG4gIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcmV0dXJuIHQuY2xhc3NOYW1lID0gcywgdDtcbn1cbnZhciBLciA9IHR5cGVvZiBFbGVtZW50IDwgXCJ1XCIgJiYgKEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3Rvcik7XG5mdW5jdGlvbiB6dChzLCB0KSB7XG4gIGlmICghS3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBtYXRjaGluZyBtZXRob2Qgc3VwcG9ydGVkXCIpO1xuICByZXR1cm4gS3IuY2FsbChzLCB0KTtcbn1cbmZ1bmN0aW9uIFNlKHMpIHtcbiAgcy5yZW1vdmUgPyBzLnJlbW92ZSgpIDogcy5wYXJlbnROb2RlICYmIHMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzKTtcbn1cbmZ1bmN0aW9uIFVyKHMsIHQpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChcbiAgICBzLmNoaWxkcmVuLFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiB6dChlLCB0KTtcbiAgICB9XG4gICk7XG59XG52YXIgaiA9IHtcbiAgbWFpbjogXCJwc1wiLFxuICBydGw6IFwicHNfX3J0bFwiLFxuICBlbGVtZW50OiB7XG4gICAgdGh1bWI6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBcInBzX190aHVtYi1cIiArIHM7XG4gICAgfSxcbiAgICByYWlsOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gXCJwc19fcmFpbC1cIiArIHM7XG4gICAgfSxcbiAgICBjb25zdW1pbmc6IFwicHNfX2NoaWxkLS1jb25zdW1lXCJcbiAgfSxcbiAgc3RhdGU6IHtcbiAgICBmb2N1czogXCJwcy0tZm9jdXNcIixcbiAgICBjbGlja2luZzogXCJwcy0tY2xpY2tpbmdcIixcbiAgICBhY3RpdmU6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBcInBzLS1hY3RpdmUtXCIgKyBzO1xuICAgIH0sXG4gICAgc2Nyb2xsaW5nOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gXCJwcy0tc2Nyb2xsaW5nLVwiICsgcztcbiAgICB9XG4gIH1cbn0sIHlsID0geyB4OiBudWxsLCB5OiBudWxsIH07XG5mdW5jdGlvbiB3bChzLCB0KSB7XG4gIHZhciBlID0gcy5lbGVtZW50LmNsYXNzTGlzdCwgaSA9IGouc3RhdGUuc2Nyb2xsaW5nKHQpO1xuICBlLmNvbnRhaW5zKGkpID8gY2xlYXJUaW1lb3V0KHlsW3RdKSA6IGUuYWRkKGkpO1xufVxuZnVuY3Rpb24ga2wocywgdCkge1xuICB5bFt0XSA9IHNldFRpbWVvdXQoXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcy5pc0FsaXZlICYmIHMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuc2Nyb2xsaW5nKHQpKTtcbiAgICB9LFxuICAgIHMuc2V0dGluZ3Muc2Nyb2xsaW5nVGhyZXNob2xkXG4gICk7XG59XG5mdW5jdGlvbiBnXyhzLCB0KSB7XG4gIHdsKHMsIHQpLCBrbChzLCB0KTtcbn1cbnZhciBFaSA9IGZ1bmN0aW9uKHQpIHtcbiAgdGhpcy5lbGVtZW50ID0gdCwgdGhpcy5oYW5kbGVycyA9IHt9O1xufSwgT2wgPSB7IGlzRW1wdHk6IHsgY29uZmlndXJhYmxlOiAhMCB9IH07XG5FaS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdHlwZW9mIHRoaXMuaGFuZGxlcnNbdF0gPiBcInVcIiAmJiAodGhpcy5oYW5kbGVyc1t0XSA9IFtdKSwgdGhpcy5oYW5kbGVyc1t0XS5wdXNoKGUpLCB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0LCBlLCAhMSk7XG59O1xuRWkucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIGkgPSB0aGlzO1xuICB0aGlzLmhhbmRsZXJzW3RdID0gdGhpcy5oYW5kbGVyc1t0XS5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgIHJldHVybiBlICYmIG4gIT09IGUgPyAhMCA6IChpLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBuLCAhMSksICExKTtcbiAgfSk7XG59O1xuRWkucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciB0IGluIHRoaXMuaGFuZGxlcnMpXG4gICAgdGhpcy51bmJpbmQodCk7XG59O1xuT2wuaXNFbXB0eS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHMgPSB0aGlzO1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5oYW5kbGVycykuZXZlcnkoXG4gICAgZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHMuaGFuZGxlcnNbdF0ubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFaS5wcm90b3R5cGUsIE9sKTtcbnZhciBVZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbn07XG5VZS5wcm90b3R5cGUuZXZlbnRFbGVtZW50ID0gZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHRoaXMuZXZlbnRFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBpLmVsZW1lbnQgPT09IHQ7XG4gIH0pWzBdO1xuICByZXR1cm4gZSB8fCAoZSA9IG5ldyBFaSh0KSwgdGhpcy5ldmVudEVsZW1lbnRzLnB1c2goZSkpLCBlO1xufTtcblVlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICB0aGlzLmV2ZW50RWxlbWVudCh0KS5iaW5kKGUsIGkpO1xufTtcblVlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gIHZhciBuID0gdGhpcy5ldmVudEVsZW1lbnQodCk7XG4gIG4udW5iaW5kKGUsIGkpLCBuLmlzRW1wdHkgJiYgdGhpcy5ldmVudEVsZW1lbnRzLnNwbGljZSh0aGlzLmV2ZW50RWxlbWVudHMuaW5kZXhPZihuKSwgMSk7XG59O1xuVWUucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmV2ZW50RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQudW5iaW5kQWxsKCk7XG4gIH0pLCB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbn07XG5VZS5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgdmFyIG4gPSB0aGlzLmV2ZW50RWxlbWVudCh0KSwgbyA9IGZ1bmN0aW9uKHIpIHtcbiAgICBuLnVuYmluZChlLCBvKSwgaShyKTtcbiAgfTtcbiAgbi5iaW5kKGUsIG8pO1xufTtcbmZ1bmN0aW9uIFFpKHMpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQocyk7XG4gIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgcmV0dXJuIHQuaW5pdEN1c3RvbUV2ZW50KHMsICExLCAhMSwgdm9pZCAwKSwgdDtcbn1cbmZ1bmN0aW9uIHlzKHMsIHQsIGUsIGksIG4pIHtcbiAgaSA9PT0gdm9pZCAwICYmIChpID0gITApLCBuID09PSB2b2lkIDAgJiYgKG4gPSAhMSk7XG4gIHZhciBvO1xuICBpZiAodCA9PT0gXCJ0b3BcIilcbiAgICBvID0gW1xuICAgICAgXCJjb250ZW50SGVpZ2h0XCIsXG4gICAgICBcImNvbnRhaW5lckhlaWdodFwiLFxuICAgICAgXCJzY3JvbGxUb3BcIixcbiAgICAgIFwieVwiLFxuICAgICAgXCJ1cFwiLFxuICAgICAgXCJkb3duXCJcbiAgICBdO1xuICBlbHNlIGlmICh0ID09PSBcImxlZnRcIilcbiAgICBvID0gW1xuICAgICAgXCJjb250ZW50V2lkdGhcIixcbiAgICAgIFwiY29udGFpbmVyV2lkdGhcIixcbiAgICAgIFwic2Nyb2xsTGVmdFwiLFxuICAgICAgXCJ4XCIsXG4gICAgICBcImxlZnRcIixcbiAgICAgIFwicmlnaHRcIlxuICAgIF07XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHByb3BlciBheGlzIHNob3VsZCBiZSBwcm92aWRlZFwiKTtcbiAgYl8ocywgZSwgbywgaSwgbik7XG59XG5mdW5jdGlvbiBiXyhzLCB0LCBlLCBpLCBuKSB7XG4gIHZhciBvID0gZVswXSwgciA9IGVbMV0sIGEgPSBlWzJdLCBsID0gZVszXSwgYyA9IGVbNF0sIGQgPSBlWzVdO1xuICBpID09PSB2b2lkIDAgJiYgKGkgPSAhMCksIG4gPT09IHZvaWQgMCAmJiAobiA9ICExKTtcbiAgdmFyIF8gPSBzLmVsZW1lbnQ7XG4gIHMucmVhY2hbbF0gPSBudWxsLCBfW2FdIDwgMSAmJiAocy5yZWFjaFtsXSA9IFwic3RhcnRcIiksIF9bYV0gPiBzW29dIC0gc1tyXSAtIDEgJiYgKHMucmVhY2hbbF0gPSBcImVuZFwiKSwgdCAmJiAoXy5kaXNwYXRjaEV2ZW50KFFpKFwicHMtc2Nyb2xsLVwiICsgbCkpLCB0IDwgMCA/IF8uZGlzcGF0Y2hFdmVudChRaShcInBzLXNjcm9sbC1cIiArIGMpKSA6IHQgPiAwICYmIF8uZGlzcGF0Y2hFdmVudChRaShcInBzLXNjcm9sbC1cIiArIGQpKSwgaSAmJiBnXyhzLCBsKSksIHMucmVhY2hbbF0gJiYgKHQgfHwgbikgJiYgXy5kaXNwYXRjaEV2ZW50KFFpKFwicHMtXCIgKyBsICsgXCItcmVhY2gtXCIgKyBzLnJlYWNoW2xdKSk7XG59XG5mdW5jdGlvbiBXKHMpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHMsIDEwKSB8fCAwO1xufVxuZnVuY3Rpb24gdl8ocykge1xuICByZXR1cm4genQocywgXCJpbnB1dCxbY29udGVudGVkaXRhYmxlXVwiKSB8fCB6dChzLCBcInNlbGVjdCxbY29udGVudGVkaXRhYmxlXVwiKSB8fCB6dChzLCBcInRleHRhcmVhLFtjb250ZW50ZWRpdGFibGVdXCIpIHx8IHp0KHMsIFwiYnV0dG9uLFtjb250ZW50ZWRpdGFibGVdXCIpO1xufVxuZnVuY3Rpb24gRV8ocykge1xuICB2YXIgdCA9IHh0KHMpO1xuICByZXR1cm4gVyh0LndpZHRoKSArIFcodC5wYWRkaW5nTGVmdCkgKyBXKHQucGFkZGluZ1JpZ2h0KSArIFcodC5ib3JkZXJMZWZ0V2lkdGgpICsgVyh0LmJvcmRlclJpZ2h0V2lkdGgpO1xufVxudmFyIGtlID0ge1xuICBpc1dlYktpdDogdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgJiYgXCJXZWJraXRBcHBlYXJhbmNlXCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICBzdXBwb3J0c1RvdWNoOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93IHx8IFwibWF4VG91Y2hQb2ludHNcIiBpbiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpLFxuICBzdXBwb3J0c0llUG9pbnRlcjogdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzLFxuICBpc0Nocm9tZTogdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIC9DaHJvbWUvaS50ZXN0KG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50KVxufTtcbmZ1bmN0aW9uIE10KHMpIHtcbiAgdmFyIHQgPSBzLmVsZW1lbnQsIGUgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKSwgaSA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHMuY29udGFpbmVyV2lkdGggPSBNYXRoLnJvdW5kKGkud2lkdGgpLCBzLmNvbnRhaW5lckhlaWdodCA9IE1hdGgucm91bmQoaS5oZWlnaHQpLCBzLmNvbnRlbnRXaWR0aCA9IHQuc2Nyb2xsV2lkdGgsIHMuY29udGVudEhlaWdodCA9IHQuc2Nyb2xsSGVpZ2h0LCB0LmNvbnRhaW5zKHMuc2Nyb2xsYmFyWFJhaWwpIHx8IChVcih0LCBqLmVsZW1lbnQucmFpbChcInhcIikpLmZvckVhY2goXG4gICAgZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIFNlKG4pO1xuICAgIH1cbiAgKSwgdC5hcHBlbmRDaGlsZChzLnNjcm9sbGJhclhSYWlsKSksIHQuY29udGFpbnMocy5zY3JvbGxiYXJZUmFpbCkgfHwgKFVyKHQsIGouZWxlbWVudC5yYWlsKFwieVwiKSkuZm9yRWFjaChcbiAgICBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gU2Uobik7XG4gICAgfVxuICApLCB0LmFwcGVuZENoaWxkKHMuc2Nyb2xsYmFyWVJhaWwpKSwgIXMuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmIHMuY29udGFpbmVyV2lkdGggKyBzLnNldHRpbmdzLnNjcm9sbFhNYXJnaW5PZmZzZXQgPCBzLmNvbnRlbnRXaWR0aCA/IChzLnNjcm9sbGJhclhBY3RpdmUgPSAhMCwgcy5yYWlsWFdpZHRoID0gcy5jb250YWluZXJXaWR0aCAtIHMucmFpbFhNYXJnaW5XaWR0aCwgcy5yYWlsWFJhdGlvID0gcy5jb250YWluZXJXaWR0aCAvIHMucmFpbFhXaWR0aCwgcy5zY3JvbGxiYXJYV2lkdGggPSB6cihcbiAgICBzLFxuICAgIFcocy5yYWlsWFdpZHRoICogcy5jb250YWluZXJXaWR0aCAvIHMuY29udGVudFdpZHRoKVxuICApLCBzLnNjcm9sbGJhclhMZWZ0ID0gVyhcbiAgICAocy5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyB0LnNjcm9sbExlZnQpICogKHMucmFpbFhXaWR0aCAtIHMuc2Nyb2xsYmFyWFdpZHRoKSAvIChzLmNvbnRlbnRXaWR0aCAtIHMuY29udGFpbmVyV2lkdGgpXG4gICkpIDogcy5zY3JvbGxiYXJYQWN0aXZlID0gITEsICFzLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWSAmJiBzLmNvbnRhaW5lckhlaWdodCArIHMuc2V0dGluZ3Muc2Nyb2xsWU1hcmdpbk9mZnNldCA8IHMuY29udGVudEhlaWdodCA/IChzLnNjcm9sbGJhcllBY3RpdmUgPSAhMCwgcy5yYWlsWUhlaWdodCA9IHMuY29udGFpbmVySGVpZ2h0IC0gcy5yYWlsWU1hcmdpbkhlaWdodCwgcy5yYWlsWVJhdGlvID0gcy5jb250YWluZXJIZWlnaHQgLyBzLnJhaWxZSGVpZ2h0LCBzLnNjcm9sbGJhcllIZWlnaHQgPSB6cihcbiAgICBzLFxuICAgIFcocy5yYWlsWUhlaWdodCAqIHMuY29udGFpbmVySGVpZ2h0IC8gcy5jb250ZW50SGVpZ2h0KVxuICApLCBzLnNjcm9sbGJhcllUb3AgPSBXKFxuICAgIGUgKiAocy5yYWlsWUhlaWdodCAtIHMuc2Nyb2xsYmFyWUhlaWdodCkgLyAocy5jb250ZW50SGVpZ2h0IC0gcy5jb250YWluZXJIZWlnaHQpXG4gICkpIDogcy5zY3JvbGxiYXJZQWN0aXZlID0gITEsIHMuc2Nyb2xsYmFyWExlZnQgPj0gcy5yYWlsWFdpZHRoIC0gcy5zY3JvbGxiYXJYV2lkdGggJiYgKHMuc2Nyb2xsYmFyWExlZnQgPSBzLnJhaWxYV2lkdGggLSBzLnNjcm9sbGJhclhXaWR0aCksIHMuc2Nyb2xsYmFyWVRvcCA+PSBzLnJhaWxZSGVpZ2h0IC0gcy5zY3JvbGxiYXJZSGVpZ2h0ICYmIChzLnNjcm9sbGJhcllUb3AgPSBzLnJhaWxZSGVpZ2h0IC0gcy5zY3JvbGxiYXJZSGVpZ2h0KSwgVF8odCwgcyksIHMuc2Nyb2xsYmFyWEFjdGl2ZSA/IHQuY2xhc3NMaXN0LmFkZChqLnN0YXRlLmFjdGl2ZShcInhcIikpIDogKHQuY2xhc3NMaXN0LnJlbW92ZShqLnN0YXRlLmFjdGl2ZShcInhcIikpLCBzLnNjcm9sbGJhclhXaWR0aCA9IDAsIHMuc2Nyb2xsYmFyWExlZnQgPSAwLCB0LnNjcm9sbExlZnQgPSBzLmlzUnRsID09PSAhMCA/IHMuY29udGVudFdpZHRoIDogMCksIHMuc2Nyb2xsYmFyWUFjdGl2ZSA/IHQuY2xhc3NMaXN0LmFkZChqLnN0YXRlLmFjdGl2ZShcInlcIikpIDogKHQuY2xhc3NMaXN0LnJlbW92ZShqLnN0YXRlLmFjdGl2ZShcInlcIikpLCBzLnNjcm9sbGJhcllIZWlnaHQgPSAwLCBzLnNjcm9sbGJhcllUb3AgPSAwLCB0LnNjcm9sbFRvcCA9IDApO1xufVxuZnVuY3Rpb24genIocywgdCkge1xuICByZXR1cm4gcy5zZXR0aW5ncy5taW5TY3JvbGxiYXJMZW5ndGggJiYgKHQgPSBNYXRoLm1heCh0LCBzLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCkpLCBzLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCAmJiAodCA9IE1hdGgubWluKHQsIHMuc2V0dGluZ3MubWF4U2Nyb2xsYmFyTGVuZ3RoKSksIHQ7XG59XG5mdW5jdGlvbiBUXyhzLCB0KSB7XG4gIHZhciBlID0geyB3aWR0aDogdC5yYWlsWFdpZHRoIH0sIGkgPSBNYXRoLmZsb29yKHMuc2Nyb2xsVG9wKTtcbiAgdC5pc1J0bCA/IGUubGVmdCA9IHQubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgcy5zY3JvbGxMZWZ0ICsgdC5jb250YWluZXJXaWR0aCAtIHQuY29udGVudFdpZHRoIDogZS5sZWZ0ID0gcy5zY3JvbGxMZWZ0LCB0LmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tID8gZS5ib3R0b20gPSB0LnNjcm9sbGJhclhCb3R0b20gLSBpIDogZS50b3AgPSB0LnNjcm9sbGJhclhUb3AgKyBpLCBvdCh0LnNjcm9sbGJhclhSYWlsLCBlKTtcbiAgdmFyIG4gPSB7IHRvcDogaSwgaGVpZ2h0OiB0LnJhaWxZSGVpZ2h0IH07XG4gIHQuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA/IHQuaXNSdGwgPyBuLnJpZ2h0ID0gdC5jb250ZW50V2lkdGggLSAodC5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBzLnNjcm9sbExlZnQpIC0gdC5zY3JvbGxiYXJZUmlnaHQgLSB0LnNjcm9sbGJhcllPdXRlcldpZHRoIC0gOSA6IG4ucmlnaHQgPSB0LnNjcm9sbGJhcllSaWdodCAtIHMuc2Nyb2xsTGVmdCA6IHQuaXNSdGwgPyBuLmxlZnQgPSB0Lm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIHMuc2Nyb2xsTGVmdCArIHQuY29udGFpbmVyV2lkdGggKiAyIC0gdC5jb250ZW50V2lkdGggLSB0LnNjcm9sbGJhcllMZWZ0IC0gdC5zY3JvbGxiYXJZT3V0ZXJXaWR0aCA6IG4ubGVmdCA9IHQuc2Nyb2xsYmFyWUxlZnQgKyBzLnNjcm9sbExlZnQsIG90KHQuc2Nyb2xsYmFyWVJhaWwsIG4pLCBvdCh0LnNjcm9sbGJhclgsIHtcbiAgICBsZWZ0OiB0LnNjcm9sbGJhclhMZWZ0LFxuICAgIHdpZHRoOiB0LnNjcm9sbGJhclhXaWR0aCAtIHQucmFpbEJvcmRlclhXaWR0aFxuICB9KSwgb3QodC5zY3JvbGxiYXJZLCB7XG4gICAgdG9wOiB0LnNjcm9sbGJhcllUb3AsXG4gICAgaGVpZ2h0OiB0LnNjcm9sbGJhcllIZWlnaHQgLSB0LnJhaWxCb3JkZXJZV2lkdGhcbiAgfSk7XG59XG5mdW5jdGlvbiBDXyhzKSB7XG4gIHMuZWxlbWVudCwgcy5ldmVudC5iaW5kKHMuc2Nyb2xsYmFyWSwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KSwgcy5ldmVudC5iaW5kKHMuc2Nyb2xsYmFyWVJhaWwsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQgLSBzLnNjcm9sbGJhcllSYWlsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCwgaSA9IGUgPiBzLnNjcm9sbGJhcllUb3AgPyAxIDogLTE7XG4gICAgcy5lbGVtZW50LnNjcm9sbFRvcCArPSBpICogcy5jb250YWluZXJIZWlnaHQsIE10KHMpLCB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KSwgcy5ldmVudC5iaW5kKHMuc2Nyb2xsYmFyWCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KSwgcy5ldmVudC5iaW5kKHMuc2Nyb2xsYmFyWFJhaWwsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQgLSBzLnNjcm9sbGJhclhSYWlsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQsIGkgPSBlID4gcy5zY3JvbGxiYXJYTGVmdCA/IDEgOiAtMTtcbiAgICBzLmVsZW1lbnQuc2Nyb2xsTGVmdCArPSBpICogcy5jb250YWluZXJXaWR0aCwgTXQocyksIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gQV8ocykge1xuICBYcihzLCBbXG4gICAgXCJjb250YWluZXJXaWR0aFwiLFxuICAgIFwiY29udGVudFdpZHRoXCIsXG4gICAgXCJwYWdlWFwiLFxuICAgIFwicmFpbFhXaWR0aFwiLFxuICAgIFwic2Nyb2xsYmFyWFwiLFxuICAgIFwic2Nyb2xsYmFyWFdpZHRoXCIsXG4gICAgXCJzY3JvbGxMZWZ0XCIsXG4gICAgXCJ4XCIsXG4gICAgXCJzY3JvbGxiYXJYUmFpbFwiXG4gIF0pLCBYcihzLCBbXG4gICAgXCJjb250YWluZXJIZWlnaHRcIixcbiAgICBcImNvbnRlbnRIZWlnaHRcIixcbiAgICBcInBhZ2VZXCIsXG4gICAgXCJyYWlsWUhlaWdodFwiLFxuICAgIFwic2Nyb2xsYmFyWVwiLFxuICAgIFwic2Nyb2xsYmFyWUhlaWdodFwiLFxuICAgIFwic2Nyb2xsVG9wXCIsXG4gICAgXCJ5XCIsXG4gICAgXCJzY3JvbGxiYXJZUmFpbFwiXG4gIF0pO1xufVxuZnVuY3Rpb24gWHIocywgdCkge1xuICB2YXIgZSA9IHRbMF0sIGkgPSB0WzFdLCBuID0gdFsyXSwgbyA9IHRbM10sIHIgPSB0WzRdLCBhID0gdFs1XSwgbCA9IHRbNl0sIGMgPSB0WzddLCBkID0gdFs4XSwgXyA9IHMuZWxlbWVudCwgZiA9IG51bGwsIG0gPSBudWxsLCBnID0gbnVsbDtcbiAgZnVuY3Rpb24gYih3KSB7XG4gICAgdy50b3VjaGVzICYmIHcudG91Y2hlc1swXSAmJiAod1tuXSA9IHcudG91Y2hlc1swXS5wYWdlWSksIF9bbF0gPSBmICsgZyAqICh3W25dIC0gbSksIHdsKHMsIGMpLCBNdChzKSwgdy5zdG9wUHJvcGFnYXRpb24oKSwgdy50eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKSAmJiB3LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDEgJiYgdy5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIFQoKSB7XG4gICAga2wocywgYyksIHNbZF0uY2xhc3NMaXN0LnJlbW92ZShqLnN0YXRlLmNsaWNraW5nKSwgcy5ldmVudC51bmJpbmQocy5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBDKHcsIHYpIHtcbiAgICBmID0gX1tsXSwgdiAmJiB3LnRvdWNoZXMgJiYgKHdbbl0gPSB3LnRvdWNoZXNbMF0ucGFnZVkpLCBtID0gd1tuXSwgZyA9IChzW2ldIC0gc1tlXSkgLyAoc1tvXSAtIHNbYV0pLCB2ID8gcy5ldmVudC5iaW5kKHMub3duZXJEb2N1bWVudCwgXCJ0b3VjaG1vdmVcIiwgYikgOiAocy5ldmVudC5iaW5kKHMub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgYiksIHMuZXZlbnQub25jZShzLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCBUKSwgdy5wcmV2ZW50RGVmYXVsdCgpKSwgc1tkXS5jbGFzc0xpc3QuYWRkKGouc3RhdGUuY2xpY2tpbmcpLCB3LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gIHMuZXZlbnQuYmluZChzW3JdLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih3KSB7XG4gICAgQyh3KTtcbiAgfSksIHMuZXZlbnQuYmluZChzW3JdLCBcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24odykge1xuICAgIEModywgITApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHlfKHMpIHtcbiAgdmFyIHQgPSBzLmVsZW1lbnQsIGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4genQodCwgXCI6aG92ZXJcIik7XG4gIH0sIGkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4genQocy5zY3JvbGxiYXJYLCBcIjpmb2N1c1wiKSB8fCB6dChzLnNjcm9sbGJhclksIFwiOmZvY3VzXCIpO1xuICB9O1xuICBmdW5jdGlvbiBuKG8sIHIpIHtcbiAgICB2YXIgYSA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApO1xuICAgIGlmIChvID09PSAwKSB7XG4gICAgICBpZiAoIXMuc2Nyb2xsYmFyWUFjdGl2ZSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKGEgPT09IDAgJiYgciA+IDAgfHwgYSA+PSBzLmNvbnRlbnRIZWlnaHQgLSBzLmNvbnRhaW5lckhlaWdodCAmJiByIDwgMClcbiAgICAgICAgcmV0dXJuICFzLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgfVxuICAgIHZhciBsID0gdC5zY3JvbGxMZWZ0O1xuICAgIGlmIChyID09PSAwKSB7XG4gICAgICBpZiAoIXMuc2Nyb2xsYmFyWEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKGwgPT09IDAgJiYgbyA8IDAgfHwgbCA+PSBzLmNvbnRlbnRXaWR0aCAtIHMuY29udGFpbmVyV2lkdGggJiYgbyA+IDApXG4gICAgICAgIHJldHVybiAhcy5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbiAgcy5ldmVudC5iaW5kKHMub3duZXJEb2N1bWVudCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoIShvLmlzRGVmYXVsdFByZXZlbnRlZCAmJiBvLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IG8uZGVmYXVsdFByZXZlbnRlZCkgJiYgISghZSgpICYmICFpKCkpKSB7XG4gICAgICB2YXIgciA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogcy5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBpZiAocikge1xuICAgICAgICBpZiAoci50YWdOYW1lID09PSBcIklGUkFNRVwiKVxuICAgICAgICAgIHIgPSByLmNvbnRlbnREb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICg7IHIuc2hhZG93Um9vdDsgKVxuICAgICAgICAgICAgciA9IHIuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpZiAodl8ocikpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGEgPSAwLCBsID0gMDtcbiAgICAgIHN3aXRjaCAoby53aGljaCkge1xuICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgIG8ubWV0YUtleSA/IGEgPSAtcy5jb250ZW50V2lkdGggOiBvLmFsdEtleSA/IGEgPSAtcy5jb250YWluZXJXaWR0aCA6IGEgPSAtMzA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgby5tZXRhS2V5ID8gbCA9IHMuY29udGVudEhlaWdodCA6IG8uYWx0S2V5ID8gbCA9IHMuY29udGFpbmVySGVpZ2h0IDogbCA9IDMwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgIG8ubWV0YUtleSA/IGEgPSBzLmNvbnRlbnRXaWR0aCA6IG8uYWx0S2V5ID8gYSA9IHMuY29udGFpbmVyV2lkdGggOiBhID0gMzA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgby5tZXRhS2V5ID8gbCA9IC1zLmNvbnRlbnRIZWlnaHQgOiBvLmFsdEtleSA/IGwgPSAtcy5jb250YWluZXJIZWlnaHQgOiBsID0gLTMwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIG8uc2hpZnRLZXkgPyBsID0gcy5jb250YWluZXJIZWlnaHQgOiBsID0gLXMuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgIGwgPSBzLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICBsID0gLXMuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgIGwgPSBzLmNvbnRlbnRIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgbCA9IC1zLmNvbnRlbnRIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcy5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFggJiYgYSAhPT0gMCB8fCBzLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWSAmJiBsICE9PSAwIHx8ICh0LnNjcm9sbFRvcCAtPSBsLCB0LnNjcm9sbExlZnQgKz0gYSwgTXQocyksIG4oYSwgbCkgJiYgby5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gd18ocykge1xuICB2YXIgdCA9IHMuZWxlbWVudDtcbiAgZnVuY3Rpb24gZShyLCBhKSB7XG4gICAgdmFyIGwgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKSwgYyA9IHQuc2Nyb2xsVG9wID09PSAwLCBkID0gbCArIHQub2Zmc2V0SGVpZ2h0ID09PSB0LnNjcm9sbEhlaWdodCwgXyA9IHQuc2Nyb2xsTGVmdCA9PT0gMCwgZiA9IHQuc2Nyb2xsTGVmdCArIHQub2Zmc2V0V2lkdGggPT09IHQuc2Nyb2xsV2lkdGgsIG07XG4gICAgcmV0dXJuIE1hdGguYWJzKGEpID4gTWF0aC5hYnMocikgPyBtID0gYyB8fCBkIDogbSA9IF8gfHwgZiwgbSA/ICFzLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb24gOiAhMDtcbiAgfVxuICBmdW5jdGlvbiBpKHIpIHtcbiAgICB2YXIgYSA9IHIuZGVsdGFYLCBsID0gLTEgKiByLmRlbHRhWTtcbiAgICByZXR1cm4gKHR5cGVvZiBhID4gXCJ1XCIgfHwgdHlwZW9mIGwgPiBcInVcIikgJiYgKGEgPSAtMSAqIHIud2hlZWxEZWx0YVggLyA2LCBsID0gci53aGVlbERlbHRhWSAvIDYpLCByLmRlbHRhTW9kZSAmJiByLmRlbHRhTW9kZSA9PT0gMSAmJiAoYSAqPSAxMCwgbCAqPSAxMCksIGEgIT09IGEgJiYgbCAhPT0gbCAmJiAoYSA9IDAsIGwgPSByLndoZWVsRGVsdGEpLCByLnNoaWZ0S2V5ID8gWy1sLCAtYV0gOiBbYSwgbF07XG4gIH1cbiAgZnVuY3Rpb24gbihyLCBhLCBsKSB7XG4gICAgaWYgKCFrZS5pc1dlYktpdCAmJiB0LnF1ZXJ5U2VsZWN0b3IoXCJzZWxlY3Q6Zm9jdXNcIikpXG4gICAgICByZXR1cm4gITA7XG4gICAgaWYgKCF0LmNvbnRhaW5zKHIpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAodmFyIGMgPSByOyBjICYmIGMgIT09IHQ7ICkge1xuICAgICAgaWYgKGMuY2xhc3NMaXN0LmNvbnRhaW5zKGouZWxlbWVudC5jb25zdW1pbmcpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB2YXIgZCA9IHh0KGMpO1xuICAgICAgaWYgKGwgJiYgZC5vdmVyZmxvd1kubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgXyA9IGMuc2Nyb2xsSGVpZ2h0IC0gYy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGlmIChfID4gMCAmJiAoYy5zY3JvbGxUb3AgPiAwICYmIGwgPCAwIHx8IGMuc2Nyb2xsVG9wIDwgXyAmJiBsID4gMCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgaWYgKGEgJiYgZC5vdmVyZmxvd1gubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgZiA9IGMuc2Nyb2xsV2lkdGggLSBjLmNsaWVudFdpZHRoO1xuICAgICAgICBpZiAoZiA+IDAgJiYgKGMuc2Nyb2xsTGVmdCA+IDAgJiYgYSA8IDAgfHwgYy5zY3JvbGxMZWZ0IDwgZiAmJiBhID4gMCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgYyA9IGMucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIG8ocikge1xuICAgIHZhciBhID0gaShyKSwgbCA9IGFbMF0sIGMgPSBhWzFdO1xuICAgIGlmICghbihyLnRhcmdldCwgbCwgYykpIHtcbiAgICAgIHZhciBkID0gITE7XG4gICAgICBzLnNldHRpbmdzLnVzZUJvdGhXaGVlbEF4ZXMgPyBzLnNjcm9sbGJhcllBY3RpdmUgJiYgIXMuc2Nyb2xsYmFyWEFjdGl2ZSA/IChjID8gdC5zY3JvbGxUb3AgLT0gYyAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCA6IHQuc2Nyb2xsVG9wICs9IGwgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQsIGQgPSAhMCkgOiBzLnNjcm9sbGJhclhBY3RpdmUgJiYgIXMuc2Nyb2xsYmFyWUFjdGl2ZSAmJiAobCA/IHQuc2Nyb2xsTGVmdCArPSBsICogcy5zZXR0aW5ncy53aGVlbFNwZWVkIDogdC5zY3JvbGxMZWZ0IC09IGMgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQsIGQgPSAhMCkgOiAodC5zY3JvbGxUb3AgLT0gYyAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCwgdC5zY3JvbGxMZWZ0ICs9IGwgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQpLCBNdChzKSwgZCA9IGQgfHwgZShsLCBjKSwgZCAmJiAhci5jdHJsS2V5ICYmIChyLnN0b3BQcm9wYWdhdGlvbigpLCByLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH1cbiAgfVxuICB0eXBlb2Ygd2luZG93Lm9ud2hlZWwgPCBcInVcIiA/IHMuZXZlbnQuYmluZCh0LCBcIndoZWVsXCIsIG8pIDogdHlwZW9mIHdpbmRvdy5vbm1vdXNld2hlZWwgPCBcInVcIiAmJiBzLmV2ZW50LmJpbmQodCwgXCJtb3VzZXdoZWVsXCIsIG8pO1xufVxuZnVuY3Rpb24ga18ocykge1xuICBpZiAoIWtlLnN1cHBvcnRzVG91Y2ggJiYgIWtlLnN1cHBvcnRzSWVQb2ludGVyKVxuICAgIHJldHVybjtcbiAgdmFyIHQgPSBzLmVsZW1lbnQ7XG4gIGZ1bmN0aW9uIGUoZywgYikge1xuICAgIHZhciBUID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCksIEMgPSB0LnNjcm9sbExlZnQsIHcgPSBNYXRoLmFicyhnKSwgdiA9IE1hdGguYWJzKGIpO1xuICAgIGlmICh2ID4gdykge1xuICAgICAgaWYgKGIgPCAwICYmIFQgPT09IHMuY29udGVudEhlaWdodCAtIHMuY29udGFpbmVySGVpZ2h0IHx8IGIgPiAwICYmIFQgPT09IDApXG4gICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsWSA9PT0gMCAmJiBiID4gMCAmJiBrZS5pc0Nocm9tZTtcbiAgICB9IGVsc2UgaWYgKHcgPiB2ICYmIChnIDwgMCAmJiBDID09PSBzLmNvbnRlbnRXaWR0aCAtIHMuY29udGFpbmVyV2lkdGggfHwgZyA+IDAgJiYgQyA9PT0gMCkpXG4gICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGZ1bmN0aW9uIGkoZywgYikge1xuICAgIHQuc2Nyb2xsVG9wIC09IGIsIHQuc2Nyb2xsTGVmdCAtPSBnLCBNdChzKTtcbiAgfVxuICB2YXIgbiA9IHt9LCBvID0gMCwgciA9IHt9LCBhID0gbnVsbDtcbiAgZnVuY3Rpb24gbChnKSB7XG4gICAgcmV0dXJuIGcudGFyZ2V0VG91Y2hlcyA/IGcudGFyZ2V0VG91Y2hlc1swXSA6IGc7XG4gIH1cbiAgZnVuY3Rpb24gYyhnKSB7XG4gICAgcmV0dXJuIGcucG9pbnRlclR5cGUgJiYgZy5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIiAmJiBnLmJ1dHRvbnMgPT09IDAgPyAhMSA6ICEhKGcudGFyZ2V0VG91Y2hlcyAmJiBnLnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxIHx8IGcucG9pbnRlclR5cGUgJiYgZy5wb2ludGVyVHlwZSAhPT0gXCJtb3VzZVwiICYmIGcucG9pbnRlclR5cGUgIT09IGcuTVNQT0lOVEVSX1RZUEVfTU9VU0UpO1xuICB9XG4gIGZ1bmN0aW9uIGQoZykge1xuICAgIGlmIChjKGcpKSB7XG4gICAgICB2YXIgYiA9IGwoZyk7XG4gICAgICBuLnBhZ2VYID0gYi5wYWdlWCwgbi5wYWdlWSA9IGIucGFnZVksIG8gPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSwgYSAhPT0gbnVsbCAmJiBjbGVhckludGVydmFsKGEpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfKGcsIGIsIFQpIHtcbiAgICBpZiAoIXQuY29udGFpbnMoZykpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yICh2YXIgQyA9IGc7IEMgJiYgQyAhPT0gdDsgKSB7XG4gICAgICBpZiAoQy5jbGFzc0xpc3QuY29udGFpbnMoai5lbGVtZW50LmNvbnN1bWluZykpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHZhciB3ID0geHQoQyk7XG4gICAgICBpZiAoVCAmJiB3Lm92ZXJmbG93WS5tYXRjaCgvKHNjcm9sbHxhdXRvKS8pKSB7XG4gICAgICAgIHZhciB2ID0gQy5zY3JvbGxIZWlnaHQgLSBDLmNsaWVudEhlaWdodDtcbiAgICAgICAgaWYgKHYgPiAwICYmIChDLnNjcm9sbFRvcCA+IDAgJiYgVCA8IDAgfHwgQy5zY3JvbGxUb3AgPCB2ICYmIFQgPiAwKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBpZiAoYiAmJiB3Lm92ZXJmbG93WC5tYXRjaCgvKHNjcm9sbHxhdXRvKS8pKSB7XG4gICAgICAgIHZhciBFID0gQy5zY3JvbGxXaWR0aCAtIEMuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmIChFID4gMCAmJiAoQy5zY3JvbGxMZWZ0ID4gMCAmJiBiIDwgMCB8fCBDLnNjcm9sbExlZnQgPCBFICYmIGIgPiAwKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBDID0gQy5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gZihnKSB7XG4gICAgaWYgKGMoZykpIHtcbiAgICAgIHZhciBiID0gbChnKSwgVCA9IHsgcGFnZVg6IGIucGFnZVgsIHBhZ2VZOiBiLnBhZ2VZIH0sIEMgPSBULnBhZ2VYIC0gbi5wYWdlWCwgdyA9IFQucGFnZVkgLSBuLnBhZ2VZO1xuICAgICAgaWYgKF8oZy50YXJnZXQsIEMsIHcpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpKEMsIHcpLCBuID0gVDtcbiAgICAgIHZhciB2ID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCksIEUgPSB2IC0gbztcbiAgICAgIEUgPiAwICYmIChyLnggPSBDIC8gRSwgci55ID0gdyAvIEUsIG8gPSB2KSwgZShDLCB3KSAmJiBnLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG0oKSB7XG4gICAgcy5zZXR0aW5ncy5zd2lwZUVhc2luZyAmJiAoY2xlYXJJbnRlcnZhbChhKSwgYSA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICBjbGVhckludGVydmFsKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXIueCAmJiAhci55KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhyLngpIDwgMC4wMSAmJiBNYXRoLmFicyhyLnkpIDwgMC4wMSkge1xuICAgICAgICBjbGVhckludGVydmFsKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXMuZWxlbWVudCkge1xuICAgICAgICBjbGVhckludGVydmFsKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpKHIueCAqIDMwLCByLnkgKiAzMCksIHIueCAqPSAwLjgsIHIueSAqPSAwLjg7XG4gICAgfSwgMTApKTtcbiAgfVxuICBrZS5zdXBwb3J0c1RvdWNoID8gKHMuZXZlbnQuYmluZCh0LCBcInRvdWNoc3RhcnRcIiwgZCksIHMuZXZlbnQuYmluZCh0LCBcInRvdWNobW92ZVwiLCBmKSwgcy5ldmVudC5iaW5kKHQsIFwidG91Y2hlbmRcIiwgbSkpIDoga2Uuc3VwcG9ydHNJZVBvaW50ZXIgJiYgKHdpbmRvdy5Qb2ludGVyRXZlbnQgPyAocy5ldmVudC5iaW5kKHQsIFwicG9pbnRlcmRvd25cIiwgZCksIHMuZXZlbnQuYmluZCh0LCBcInBvaW50ZXJtb3ZlXCIsIGYpLCBzLmV2ZW50LmJpbmQodCwgXCJwb2ludGVydXBcIiwgbSkpIDogd2luZG93Lk1TUG9pbnRlckV2ZW50ICYmIChzLmV2ZW50LmJpbmQodCwgXCJNU1BvaW50ZXJEb3duXCIsIGQpLCBzLmV2ZW50LmJpbmQodCwgXCJNU1BvaW50ZXJNb3ZlXCIsIGYpLCBzLmV2ZW50LmJpbmQodCwgXCJNU1BvaW50ZXJVcFwiLCBtKSkpO1xufVxudmFyIE9fID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgaGFuZGxlcnM6IFtcImNsaWNrLXJhaWxcIiwgXCJkcmFnLXRodW1iXCIsIFwia2V5Ym9hcmRcIiwgXCJ3aGVlbFwiLCBcInRvdWNoXCJdLFxuICAgIG1heFNjcm9sbGJhckxlbmd0aDogbnVsbCxcbiAgICBtaW5TY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gICAgc2Nyb2xsaW5nVGhyZXNob2xkOiAxZTMsXG4gICAgc2Nyb2xsWE1hcmdpbk9mZnNldDogMCxcbiAgICBzY3JvbGxZTWFyZ2luT2Zmc2V0OiAwLFxuICAgIHN1cHByZXNzU2Nyb2xsWDogITEsXG4gICAgc3VwcHJlc3NTY3JvbGxZOiAhMSxcbiAgICBzd2lwZUVhc2luZzogITAsXG4gICAgdXNlQm90aFdoZWVsQXhlczogITEsXG4gICAgd2hlZWxQcm9wYWdhdGlvbjogITAsXG4gICAgd2hlZWxTcGVlZDogMVxuICB9O1xufSwgeF8gPSB7XG4gIFwiY2xpY2stcmFpbFwiOiBDXyxcbiAgXCJkcmFnLXRodW1iXCI6IEFfLFxuICBrZXlib2FyZDogeV8sXG4gIHdoZWVsOiB3XyxcbiAgdG91Y2g6IGtfXG59LCBUaSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIGkgPSB0aGlzO1xuICBpZiAoZSA9PT0gdm9pZCAwICYmIChlID0ge30pLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmICh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KSksICF0IHx8ICF0Lm5vZGVOYW1lKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGVsZW1lbnQgaXMgc3BlY2lmaWVkIHRvIGluaXRpYWxpemUgUGVyZmVjdFNjcm9sbGJhclwiKTtcbiAgdGhpcy5lbGVtZW50ID0gdCwgdC5jbGFzc0xpc3QuYWRkKGoubWFpbiksIHRoaXMuc2V0dGluZ3MgPSBPXygpO1xuICBmb3IgKHZhciBuIGluIGUpXG4gICAgdGhpcy5zZXR0aW5nc1tuXSA9IGVbbl07XG4gIHRoaXMuY29udGFpbmVyV2lkdGggPSBudWxsLCB0aGlzLmNvbnRhaW5lckhlaWdodCA9IG51bGwsIHRoaXMuY29udGVudFdpZHRoID0gbnVsbCwgdGhpcy5jb250ZW50SGVpZ2h0ID0gbnVsbDtcbiAgdmFyIG8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5jbGFzc0xpc3QuYWRkKGouc3RhdGUuZm9jdXMpO1xuICB9LCByID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuY2xhc3NMaXN0LnJlbW92ZShqLnN0YXRlLmZvY3VzKTtcbiAgfTtcbiAgdGhpcy5pc1J0bCA9IHh0KHQpLmRpcmVjdGlvbiA9PT0gXCJydGxcIiwgdGhpcy5pc1J0bCA9PT0gITAgJiYgdC5jbGFzc0xpc3QuYWRkKGoucnRsKSwgdGhpcy5pc05lZ2F0aXZlU2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGMgPSB0LnNjcm9sbExlZnQsIGQgPSBudWxsO1xuICAgIHJldHVybiB0LnNjcm9sbExlZnQgPSAtMSwgZCA9IHQuc2Nyb2xsTGVmdCA8IDAsIHQuc2Nyb2xsTGVmdCA9IGMsIGQ7XG4gIH0oKSwgdGhpcy5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgPSB0aGlzLmlzTmVnYXRpdmVTY3JvbGwgPyB0LnNjcm9sbFdpZHRoIC0gdC5jbGllbnRXaWR0aCA6IDAsIHRoaXMuZXZlbnQgPSBuZXcgVWUoKSwgdGhpcy5vd25lckRvY3VtZW50ID0gdC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50LCB0aGlzLnNjcm9sbGJhclhSYWlsID0gcWkoai5lbGVtZW50LnJhaWwoXCJ4XCIpKSwgdC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclhSYWlsKSwgdGhpcy5zY3JvbGxiYXJYID0gcWkoai5lbGVtZW50LnRodW1iKFwieFwiKSksIHRoaXMuc2Nyb2xsYmFyWFJhaWwuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJYKSwgdGhpcy5zY3JvbGxiYXJYLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIDApLCB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJYLCBcImZvY3VzXCIsIG8pLCB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJYLCBcImJsdXJcIiwgciksIHRoaXMuc2Nyb2xsYmFyWEFjdGl2ZSA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWFdpZHRoID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJYTGVmdCA9IG51bGw7XG4gIHZhciBhID0geHQodGhpcy5zY3JvbGxiYXJYUmFpbCk7XG4gIHRoaXMuc2Nyb2xsYmFyWEJvdHRvbSA9IHBhcnNlSW50KGEuYm90dG9tLCAxMCksIGlzTmFOKHRoaXMuc2Nyb2xsYmFyWEJvdHRvbSkgPyAodGhpcy5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA9ICExLCB0aGlzLnNjcm9sbGJhclhUb3AgPSBXKGEudG9wKSkgOiB0aGlzLmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tID0gITAsIHRoaXMucmFpbEJvcmRlclhXaWR0aCA9IFcoYS5ib3JkZXJMZWZ0V2lkdGgpICsgVyhhLmJvcmRlclJpZ2h0V2lkdGgpLCBvdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgdGhpcy5yYWlsWE1hcmdpbldpZHRoID0gVyhhLm1hcmdpbkxlZnQpICsgVyhhLm1hcmdpblJpZ2h0KSwgb3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcIlwiIH0pLCB0aGlzLnJhaWxYV2lkdGggPSBudWxsLCB0aGlzLnJhaWxYUmF0aW8gPSBudWxsLCB0aGlzLnNjcm9sbGJhcllSYWlsID0gcWkoai5lbGVtZW50LnJhaWwoXCJ5XCIpKSwgdC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhcllSYWlsKSwgdGhpcy5zY3JvbGxiYXJZID0gcWkoai5lbGVtZW50LnRodW1iKFwieVwiKSksIHRoaXMuc2Nyb2xsYmFyWVJhaWwuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJZKSwgdGhpcy5zY3JvbGxiYXJZLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIDApLCB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJZLCBcImZvY3VzXCIsIG8pLCB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJZLCBcImJsdXJcIiwgciksIHRoaXMuc2Nyb2xsYmFyWUFjdGl2ZSA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWUhlaWdodCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWVRvcCA9IG51bGw7XG4gIHZhciBsID0geHQodGhpcy5zY3JvbGxiYXJZUmFpbCk7XG4gIHRoaXMuc2Nyb2xsYmFyWVJpZ2h0ID0gcGFyc2VJbnQobC5yaWdodCwgMTApLCBpc05hTih0aGlzLnNjcm9sbGJhcllSaWdodCkgPyAodGhpcy5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID0gITEsIHRoaXMuc2Nyb2xsYmFyWUxlZnQgPSBXKGwubGVmdCkpIDogdGhpcy5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID0gITAsIHRoaXMuc2Nyb2xsYmFyWU91dGVyV2lkdGggPSB0aGlzLmlzUnRsID8gRV8odGhpcy5zY3JvbGxiYXJZKSA6IG51bGwsIHRoaXMucmFpbEJvcmRlcllXaWR0aCA9IFcobC5ib3JkZXJUb3BXaWR0aCkgKyBXKGwuYm9yZGVyQm90dG9tV2lkdGgpLCBvdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgdGhpcy5yYWlsWU1hcmdpbkhlaWdodCA9IFcobC5tYXJnaW5Ub3ApICsgVyhsLm1hcmdpbkJvdHRvbSksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJcIiB9KSwgdGhpcy5yYWlsWUhlaWdodCA9IG51bGwsIHRoaXMucmFpbFlSYXRpbyA9IG51bGwsIHRoaXMucmVhY2ggPSB7XG4gICAgeDogdC5zY3JvbGxMZWZ0IDw9IDAgPyBcInN0YXJ0XCIgOiB0LnNjcm9sbExlZnQgPj0gdGhpcy5jb250ZW50V2lkdGggLSB0aGlzLmNvbnRhaW5lcldpZHRoID8gXCJlbmRcIiA6IG51bGwsXG4gICAgeTogdC5zY3JvbGxUb3AgPD0gMCA/IFwic3RhcnRcIiA6IHQuc2Nyb2xsVG9wID49IHRoaXMuY29udGVudEhlaWdodCAtIHRoaXMuY29udGFpbmVySGVpZ2h0ID8gXCJlbmRcIiA6IG51bGxcbiAgfSwgdGhpcy5pc0FsaXZlID0gITAsIHRoaXMuc2V0dGluZ3MuaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIHhfW2NdKGkpO1xuICB9KSwgdGhpcy5sYXN0U2Nyb2xsVG9wID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCksIHRoaXMubGFzdFNjcm9sbExlZnQgPSB0LnNjcm9sbExlZnQsIHRoaXMuZXZlbnQuYmluZCh0aGlzLmVsZW1lbnQsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gaS5vblNjcm9sbChjKTtcbiAgfSksIE10KHRoaXMpO1xufTtcblRpLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pc0FsaXZlICYmICh0aGlzLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCA9IHRoaXMuaXNOZWdhdGl2ZVNjcm9sbCA/IHRoaXMuZWxlbWVudC5zY3JvbGxXaWR0aCAtIHRoaXMuZWxlbWVudC5jbGllbnRXaWR0aCA6IDAsIG90KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCBvdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgdGhpcy5yYWlsWE1hcmdpbldpZHRoID0gVyh4dCh0aGlzLnNjcm9sbGJhclhSYWlsKS5tYXJnaW5MZWZ0KSArIFcoeHQodGhpcy5zY3JvbGxiYXJYUmFpbCkubWFyZ2luUmlnaHQpLCB0aGlzLnJhaWxZTWFyZ2luSGVpZ2h0ID0gVyh4dCh0aGlzLnNjcm9sbGJhcllSYWlsKS5tYXJnaW5Ub3ApICsgVyh4dCh0aGlzLnNjcm9sbGJhcllSYWlsKS5tYXJnaW5Cb3R0b20pLCBvdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pLCBvdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pLCBNdCh0aGlzKSwgeXModGhpcywgXCJ0b3BcIiwgMCwgITEsICEwKSwgeXModGhpcywgXCJsZWZ0XCIsIDAsICExLCAhMCksIG90KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJcIiB9KSwgb3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcIlwiIH0pKTtcbn07XG5UaS5wcm90b3R5cGUub25TY3JvbGwgPSBmdW5jdGlvbih0KSB7XG4gIHRoaXMuaXNBbGl2ZSAmJiAoTXQodGhpcyksIHlzKHRoaXMsIFwidG9wXCIsIHRoaXMuZWxlbWVudC5zY3JvbGxUb3AgLSB0aGlzLmxhc3RTY3JvbGxUb3ApLCB5cyhcbiAgICB0aGlzLFxuICAgIFwibGVmdFwiLFxuICAgIHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0IC0gdGhpcy5sYXN0U2Nyb2xsTGVmdFxuICApLCB0aGlzLmxhc3RTY3JvbGxUb3AgPSBNYXRoLmZsb29yKHRoaXMuZWxlbWVudC5zY3JvbGxUb3ApLCB0aGlzLmxhc3RTY3JvbGxMZWZ0ID0gdGhpcy5lbGVtZW50LnNjcm9sbExlZnQpO1xufTtcblRpLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaXNBbGl2ZSAmJiAodGhpcy5ldmVudC51bmJpbmRBbGwoKSwgU2UodGhpcy5zY3JvbGxiYXJYKSwgU2UodGhpcy5zY3JvbGxiYXJZKSwgU2UodGhpcy5zY3JvbGxiYXJYUmFpbCksIFNlKHRoaXMuc2Nyb2xsYmFyWVJhaWwpLCB0aGlzLnJlbW92ZVBzQ2xhc3NlcygpLCB0aGlzLmVsZW1lbnQgPSBudWxsLCB0aGlzLnNjcm9sbGJhclggPSBudWxsLCB0aGlzLnNjcm9sbGJhclkgPSBudWxsLCB0aGlzLnNjcm9sbGJhclhSYWlsID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZUmFpbCA9IG51bGwsIHRoaXMuaXNBbGl2ZSA9ICExKTtcbn07XG5UaS5wcm90b3R5cGUucmVtb3ZlUHNDbGFzc2VzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAhdC5tYXRjaCgvXnBzKFstX10uK3wpJC8pO1xuICB9KS5qb2luKFwiIFwiKTtcbn07XG5jb25zdCBTXyA9IHtcbiAgdGhyZXNob2xkOiAxMCxcbiAgZGlyZWN0aW9uOiBcImFsbFwiXG59O1xuY2xhc3MgRF8ge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsLCB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgLi4uU18sXG4gICAgICAuLi5lXG4gICAgfTtcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCk7XG4gIH1cbiAgaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICBpZiAoIXRoaXMuX3N0YXJ0UG9zaXRpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpLCBpID0ge1xuICAgICAgeDogZS54IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi54LFxuICAgICAgeTogZS55IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi55XG4gICAgfSwgbiA9IHRoaXMuX2dldERpcmVjdGlvbihpKTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwiYWxsXCIpIHtcbiAgICAgIGlmIChuLnkudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiBuLngudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IG4ueS52YWx1ZSA+IG4ueC52YWx1ZSA/IG4ueS5kaXJlY3Rpb24gOiBuLnguZGlyZWN0aW9uO1xuICAgICAgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7cn1gKSwgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwic3dpcGVcIiwgeyBkaXJlY3Rpb246IHIgfSksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvID0gdGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwibGVmdFwiIHx8IHRoaXMuX29wdGlvbnMgPT09IFwicmlnaHRcIiA/IFwieFwiIDogXCJ5XCI7XG4gICAgbltvXS5kaXJlY3Rpb24gPT09IHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uICYmIG5bb10udmFsdWUgPiB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiAodS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7bltvXS5kaXJlY3Rpb259YCksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsKTtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgfVxuICBfZ2V0Q29vcmRpbmF0ZXModCkge1xuICAgIGNvbnN0IFtlXSA9IHQudG91Y2hlcztcbiAgICByZXR1cm4ge1xuICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgeTogZS5jbGllbnRZXG4gICAgfTtcbiAgfVxuICBfZ2V0RGlyZWN0aW9uKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDoge1xuICAgICAgICBkaXJlY3Rpb246IHQueCA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKHQueClcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIGRpcmVjdGlvbjogdC55IDwgMCA/IFwidXBcIiA6IFwiZG93blwiLFxuICAgICAgICB2YWx1ZTogTWF0aC5hYnModC55KVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmNsYXNzIElfIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IFwic3dpcGVcIiwgaSA9IHt9KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2V2ZW50ID0gZSwgdGhpcy5zd2lwZSA9IG5ldyBEXyh0LCBpKSwgdGhpcy5fdG91Y2hTdGFydEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0LmJpbmQodGhpcyksIHRoaXMuX3RvdWNoTW92ZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVUb3VjaE1vdmUuYmluZCh0aGlzKSwgdGhpcy5fdG91Y2hFbmRIYW5kbGVyID0gdGhpcy5faGFuZGxlVG91Y2hFbmQuYmluZCh0aGlzKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fdG91Y2hTdGFydEhhbmRsZXIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fdG91Y2hFbmRIYW5kbGVyKTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQodClcbiAgICApLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVRvdWNoTW92ZSh0KVxuICAgICksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgKHQpID0+IHRoaXMuX2hhbmRsZVRvdWNoRW5kKHQpKTtcbiAgfVxuICBfaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgdGhpc1t0aGlzLl9ldmVudF0uaGFuZGxlVG91Y2hTdGFydCh0KTtcbiAgfVxuICBfaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaE1vdmUodCk7XG4gIH1cbiAgX2hhbmRsZVRvdWNoRW5kKHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaEVuZCh0KTtcbiAgfVxufVxuY29uc3QgJF8gPSBcImdyb3VwL3BzIG92ZXJmbG93LWhpZGRlbiBbb3ZlcmZsb3ctYW5jaG9yOm5vbmVdIFtvdmVyZmxvdy1zdHlsZTpub25lXSB0b3VjaC1ub25lXCIsIExfID0gXCJncm91cC94IGFic29sdXRlIGJvdHRvbS0wICF0b3AtYXV0byBoLVsxNXB4XSBoaWRkZW4gb3BhY2l0eS0wIFt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3JfLjJzX2xpbmVhcixfb3BhY2l0eV8uMnNfbGluZWFyXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBncm91cC1bJi5wcy0tYWN0aXZlLXhdL3BzOmJsb2NrIGdyb3VwLVsmLnBzLS1hY3RpdmUteF0vcHM6YmctdHJhbnNwYXJlbnQgZ3JvdXAtaG92ZXIvcHM6b3BhY2l0eS02MCBncm91cC1mb2N1cy9wczpvcGFjaXR5LTYwIGdyb3VwLVsmLnBzLS1zY3JvbGxpbmcteF0vcHM6b3BhY2l0eS02MCBob3Zlcjohb3BhY2l0eS05MCBob3ZlcjpiZy1bI2VlZV0gZm9jdXM6IW9wYWNpdHktOTAgZm9jdXM6YmctWyNlZWVdIFsmLnBzLS1jbGlja2luZ106IW9wYWNpdHktOTAgWyYucHMtLWNsaWNraW5nXTpiZy1bI2VlZV0gb3V0bGluZS1ub25lXCIsIE1fID0gXCJhYnNvbHV0ZSBib3R0b20tWzJweF0gcm91bmRlZC1tZCBoLTEuNSBvcGFjaXR5LTAgZ3JvdXAtaG92ZXIvcHM6b3BhY2l0eS0xMDAgZ3JvdXAtZm9jdXMvcHM6b3BhY2l0eS0xMDAgZ3JvdXAtYWN0aXZlL3BzOm9wYWNpdHktMTAwIGJnLVsjYWFhXSBbdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yXy4yc19saW5lYXIsX2hlaWdodF8uMnNfZWFzZS1pbi1vdXRdIGdyb3VwLWhvdmVyL3g6YmctWyM5OTldIGdyb3VwLWhvdmVyL3g6aC1bMTFweF0gZ3JvdXAtZm9jdXMveDpiZy1bIzk5OV0gZ3JvdXAtZm9jdXMveDpoLVsxMXB4XSBncm91cC1bJi5wcy0tY2xpY2tpbmddL3g6YmctWyM5OTldIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veDpoLVsxMXB4XSBvdXRsaW5lLW5vbmVcIiwgTl8gPSBcImdyb3VwL3kgYWJzb2x1dGUgcmlnaHQtMCAhbGVmdC1hdXRvIHctWzE1cHhdIGhpZGRlbiBvcGFjaXR5LTAgW3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvcl8uMnNfbGluZWFyLF9vcGFjaXR5Xy4yc19saW5lYXJdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGdyb3VwLVsmLnBzLS1hY3RpdmUteV0vcHM6YmxvY2sgZ3JvdXAtWyYucHMtLWFjdGl2ZS15XS9wczpiZy10cmFuc3BhcmVudCBncm91cC1ob3Zlci9wczpvcGFjaXR5LTYwIGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktNjAgZ3JvdXAtWyYucHMtLXNjcm9sbGluZy15XS9wczpvcGFjaXR5LTYwIGhvdmVyOiFvcGFjaXR5LTkwIGhvdmVyOmJnLVsjZWVlXSBmb2N1czohb3BhY2l0eS05MCBmb2N1czpiZy1bI2VlZV0gWyYucHMtLWNsaWNraW5nXTohb3BhY2l0eS05MCBbJi5wcy0tY2xpY2tpbmddOmJnLVsjZWVlXSBvdXRsaW5lLW5vbmVcIiwgUl8gPSBcImFic29sdXRlIHJpZ2h0LVsycHhdIHJvdW5kZWQtbWQgdy0xLjUgb3BhY2l0eS0wIGdyb3VwLWhvdmVyL3BzOm9wYWNpdHktMTAwIGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktMTAwIGdyb3VwLWFjdGl2ZS9wczpvcGFjaXR5LTEwMCBiZy1bI2FhYV0gW3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvcl8uMnNfbGluZWFyLF93aWR0aF8uMnNfZWFzZS1pbi1vdXRdIGdyb3VwLWhvdmVyL3k6YmctWyM5OTldIGdyb3VwLWhvdmVyL3k6dy1bMTFweF0gZ3JvdXAtZm9jdXMveTpiZy1bIzk5OV0gZ3JvdXAtZm9jdXMveTp3LVsxMXB4XSBncm91cC1bJi5wcy0tY2xpY2tpbmddL3k6YmctWyM5OTldIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veTp3LVsxMXB4XSBvdXRsaW5lLW5vbmVcIiwgUF8gPSAocyA9IGRvY3VtZW50KSA9PiB7XG4gIFtcbiAgICB7IHBzOiBcInBzX19yYWlsLXhcIiwgdGU6IExfIH0sXG4gICAgeyBwczogXCJwc19fcmFpbC15XCIsIHRlOiBOXyB9LFxuICAgIHsgcHM6IFwicHNfX3RodW1iLXhcIiwgdGU6IE1fIH0sXG4gICAgeyBwczogXCJwc19fdGh1bWIteVwiLCB0ZTogUl8gfVxuICBdLmZvckVhY2goKGUpID0+IHtcbiAgICBwLmFkZENsYXNzKFxuICAgICAgaC5maW5kT25lKGAuJHtlLnBzfWAsIHMpLFxuICAgICAgZS50ZVxuICAgICksIHAucmVtb3ZlQ2xhc3MoXG4gICAgICBoLmZpbmRPbmUoYC4ke2UucHN9YCwgcyksXG4gICAgICBlLnBzXG4gICAgKTtcbiAgfSksIHAuYWRkQ2xhc3MocywgJF8pLCBwLnJlbW92ZUNsYXNzKHMsIFwicHNcIik7XG59LCBHciA9IFwic2lkZW5hdlwiLCBaaSA9IFwidGUuc2lkZW5hdlwiLCBIXyA9IFwiZGF0YS10ZS1zaWRlbmF2LXJvdGF0ZS1pY29uLXJlZlwiLCBBbiA9IFwiW2RhdGEtdGUtc2lkZW5hdi10b2dnbGUtcmVmXVwiLCBCXyA9IFwiW2RhdGEtdGUtY29sbGFwc2UtaW5pdF1cIiwgVl8gPSAnW2RhdGEtdGUtc2lkZW5hdi1zbGltPVwidHJ1ZVwiXScsIFdfID0gJ1tkYXRhLXRlLXNpZGVuYXYtc2xpbT1cImZhbHNlXCJdJywgRl8gPSBcIltkYXRhLXRlLXNpZGVuYXYtbWVudS1yZWZdXCIsIENlID0gXCJbZGF0YS10ZS1zaWRlbmF2LWNvbGxhcHNlLXJlZl1cIiwgdGkgPSBcIltkYXRhLXRlLXNpZGVuYXYtbGluay1yZWZdXCIsIFlfID0gRigpID8gMTAwIDogLTEwMCwgal8gPSBGKCkgPyAtMTAwIDogMTAwLCBLXyA9IHtcbiAgc2lkZW5hdkFjY29yZGlvbjogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkJhY2tkcm9wOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2QmFja2Ryb3BDbGFzczogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHNpZGVuYXZDbG9zZU9uRXNjOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2Q29sb3I6IFwiKHN0cmluZylcIixcbiAgc2lkZW5hdkNvbnRlbnQ6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBzaWRlbmF2RXhwYW5kYWJsZTogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkV4cGFuZE9uSG92ZXI6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZGb2N1c1RyYXA6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZIaWRkZW46IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZNb2RlOiBcIihzdHJpbmcpXCIsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXI6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZTogXCIobnVsbHxzdHJpbmd8bnVtYmVyKVwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoOiBcIihudWxsfHN0cmluZ3xudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50U206IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnRNZDogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludExnOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50WGw6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnQyeGw6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdlNjcm9sbENvbnRhaW5lcjogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHNpZGVuYXZTbGltOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2U2xpbUNvbGxhcHNlZDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdlNsaW1XaWR0aDogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2UG9zaXRpb246IFwiKHN0cmluZylcIixcbiAgc2lkZW5hdlJpZ2h0OiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZXaWR0aDogXCIobnVtYmVyKVwiXG59LCBVXyA9IHtcbiAgc2lkZW5hdkFjY29yZGlvbjogITEsXG4gIHNpZGVuYXZCYWNrZHJvcDogITAsXG4gIHNpZGVuYXZCYWNrZHJvcENsYXNzOiBudWxsLFxuICBzaWRlbmF2Q2xvc2VPbkVzYzogITAsXG4gIHNpZGVuYXZDb2xvcjogXCJwcmltYXJ5XCIsXG4gIHNpZGVuYXZDb250ZW50OiBudWxsLFxuICBzaWRlbmF2RXhwYW5kYWJsZTogITAsXG4gIHNpZGVuYXZFeHBhbmRPbkhvdmVyOiAhMSxcbiAgc2lkZW5hdkZvY3VzVHJhcDogITAsXG4gIHNpZGVuYXZIaWRkZW46ICEwLFxuICBzaWRlbmF2TW9kZTogXCJvdmVyXCIsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXI6IG51bGwsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGU6IG51bGwsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2g6IG51bGwsXG4gIHNpZGVuYXZCcmVha3BvaW50U206IDY0MCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRNZDogNzY4LFxuICBzaWRlbmF2QnJlYWtwb2ludExnOiAxMDI0LFxuICBzaWRlbmF2QnJlYWtwb2ludFhsOiAxMjgwLFxuICBzaWRlbmF2QnJlYWtwb2ludDJ4bDogMTUzNixcbiAgc2lkZW5hdlNjcm9sbENvbnRhaW5lcjogbnVsbCxcbiAgc2lkZW5hdlNsaW06ICExLFxuICBzaWRlbmF2U2xpbUNvbGxhcHNlZDogITEsXG4gIHNpZGVuYXZTbGltV2lkdGg6IDc3LFxuICBzaWRlbmF2UG9zaXRpb246IFwiZml4ZWRcIixcbiAgc2lkZW5hdlJpZ2h0OiAhMSxcbiAgc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbjogMzAwLFxuICBzaWRlbmF2V2lkdGg6IDI0MFxufTtcbmNsYXNzIG5pIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9KSB7XG4gICAgVHQodGhpcywgXCJfYWRkQmFja2Ryb3BPbkluaXRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fb3B0aW9ucy5zaWRlbmF2SGlkZGVuIHx8ICh0aGlzLl9iYWNrZHJvcC5zaG93KCksIHUub2ZmKHRoaXMuX2VsZW1lbnQsIFwidHJhbnNpdGlvbmVuZFwiLCB0aGlzLl9hZGRCYWNrZHJvcE9uSW5pdCkpO1xuICAgIH0pO1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gZSwgdGhpcy5fSUQgPSBPdChcIlwiKSwgdGhpcy5fY29udGVudCA9IG51bGwsIHRoaXMuX2luaXRpYWxDb250ZW50U3R5bGUgPSBudWxsLCB0aGlzLl9zbGltQ29sbGFwc2VkID0gITEsIHRoaXMuX2FjdGl2ZU5vZGUgPSBudWxsLCB0aGlzLl90ZW1wU2xpbSA9ICExLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsLCB0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyID0gbnVsbCwgdGhpcy5fdG91Y2ggPSBudWxsLCB0aGlzLl9zZXRNb2RlRnJvbUJyZWFrcG9pbnRzKCksIHRoaXMuZXNjSGFuZGxlciA9IChpKSA9PiB7XG4gICAgICBpLmtleUNvZGUgPT09IElzICYmIHRoaXMudG9nZ2xlciAmJiBTdCh0aGlzLnRvZ2dsZXIpICYmICh0aGlzLl91cGRhdGUoITEpLCB1Lm9mZih3aW5kb3csIFwia2V5ZG93blwiLCB0aGlzLmVzY0hhbmRsZXIpKTtcbiAgICB9LCB0aGlzLmhhc2hIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc2V0QWN0aXZlRWxlbWVudHMoKTtcbiAgICB9LCB0ICYmIChJLnNldERhdGEodCwgWmksIHRoaXMpLCB0aGlzLl9zZXR1cCgpKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiAhdGhpcy5vcHRpb25zLnNpZGVuYXZIaWRkZW4gJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB1Lm9uKHRoaXMuX2VsZW1lbnQsIFwidHJhbnNpdGlvbmVuZFwiLCB0aGlzLl9hZGRCYWNrZHJvcE9uSW5pdCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBHcjtcbiAgfVxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uID09PSBcImZpeGVkXCIpXG4gICAgICByZXR1cm4gaC5maW5kT25lKFwiYm9keVwiKTtcbiAgICBjb25zdCB0ID0gKGUpID0+ICFlLnBhcmVudE5vZGUgfHwgZS5wYXJlbnROb2RlID09PSBkb2N1bWVudCA/IGUgOiBlLnBhcmVudE5vZGUuc3R5bGUucG9zaXRpb24gPT09IFwicmVsYXRpdmVcIiB8fCBlLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwicmVsYXRpdmVcIikgPyBlLnBhcmVudE5vZGUgOiB0KGUucGFyZW50Tm9kZSk7XG4gICAgcmV0dXJuIHQodGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICBsZXQgdCA9IDAsIGUgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbiAhPT0gXCJmaXhlZFwiKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0ID0gbi54LCBlID0gbi54ICsgbi53aWR0aDtcbiAgICB9XG4gICAgY29uc3QgeyB4OiBpIH0gPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0ID8gTWF0aC5hYnMoaSAtIGUpID4gMTAgOiBNYXRoLmFicyhpIC0gdCkgPCAxMDtcbiAgfVxuICBnZXQgbGlua3MoKSB7XG4gICAgcmV0dXJuIGguZmluZCh0aSwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IG5hdmlnYXRpb24oKSB7XG4gICAgcmV0dXJuIGguZmluZChGXywgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLlVfLFxuICAgICAgLi4ucC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRoaXMuX29wdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBOKEdyLCB0LCBLXyksIHQ7XG4gIH1cbiAgZ2V0IHNpZGVuYXZTdHlsZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGAke3RoaXMud2lkdGh9cHhgLFxuICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBcIjEwMHZoXCIgOiBcIjEwMCVcIixcbiAgICAgIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uLFxuICAgICAgdHJhbnNpdGlvbjogYGFsbCAke3RoaXMudHJhbnNpdGlvbkR1cmF0aW9ufSBsaW5lYXJgXG4gICAgfTtcbiAgfVxuICBnZXQgdG9nZ2xlcigpIHtcbiAgICByZXR1cm4gaC5maW5kKEFuKS5maW5kKFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgY29uc3QgaSA9IHAuZ2V0RGF0YUF0dHJpYnV0ZShlLCBcInRhcmdldFwiKTtcbiAgICAgICAgcmV0dXJuIGguZmluZE9uZShpKSA9PT0gdGhpcy5fZWxlbWVudDtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldCB0cmFuc2l0aW9uRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5zaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uIC8gMWUzfXNgO1xuICB9XG4gIGdldCB0cmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodCA/IGpfIDogWV87XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9zbGltQ29sbGFwc2VkID8gdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltV2lkdGggOiB0aGlzLm9wdGlvbnMuc2lkZW5hdldpZHRoO1xuICB9XG4gIGdldCBpc0JhY2tkcm9wVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9iYWNrZHJvcC5fZWxlbWVudDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgY2hhbmdlTW9kZSh0KSB7XG4gICAgdGhpcy5fc2V0TW9kZSh0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHUub2ZmKHdpbmRvdywgXCJrZXlkb3duXCIsIHRoaXMuZXNjSGFuZGxlciksIHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCB1Lm9mZih3aW5kb3csIFwiaGFzaGNoYW5nZVwiLCB0aGlzLmhhc2hIYW5kbGVyKSwgdGhpcy5fdG91Y2guZGlzcG9zZSgpLCBJLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgWmkpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoITEpLCB0aGlzLl91cGRhdGUoITEpLCB0aGlzLl9vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLmlzQmFja2Ryb3BWaXNpYmxlICYmIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgfVxuICBzaG93KCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoITApLCB0aGlzLl91cGRhdGUoITApLCB0aGlzLl9vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLl9vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9iYWNrZHJvcC5zaG93KCk7XG4gIH1cbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoIXRoaXMuaXNWaXNpYmxlKSwgdGhpcy5fdXBkYXRlKCF0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgdG9nZ2xlU2xpbSgpIHtcbiAgICB0aGlzLl9zZXRTbGltKCF0aGlzLl9zbGltQ29sbGFwc2VkKTtcbiAgfVxuICB1cGRhdGUodCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB0LCB0aGlzLl9zZXR1cCgpO1xuICB9XG4gIGdldEJyZWFrcG9pbnQodCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1CcmVha3BvaW50VmFsdWVzVG9PYmplY3QoKVt0XTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKHUub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIEFuLFxuICAgICAgbmkudG9nZ2xlU2lkZW5hdigpXG4gICAgKSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfdHJhbnNmb3JtQnJlYWtwb2ludFZhbHVlc1RvT2JqZWN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBzbTogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50U20sXG4gICAgICBtZDogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50TWQsXG4gICAgICBsZzogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50TGcsXG4gICAgICB4bDogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50WGwsXG4gICAgICBcIjJ4bFwiOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnQyeGxcbiAgICB9O1xuICB9XG4gIF9zZXRNb2RlRnJvbUJyZWFrcG9pbnRzKCkge1xuICAgIGNvbnN0IHQgPSB3aW5kb3cuaW5uZXJXaWR0aCwgZSA9IHRoaXMuX3RyYW5zZm9ybUJyZWFrcG9pbnRWYWx1ZXNUb09iamVjdCgpO1xuICAgIGlmICh0ID09PSB2b2lkIDAgfHwgIWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50T3ZlciA9PSBcIm51bWJlclwiID8gdCAtIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyIDogdCAtIGVbdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXJdLCBuID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlID09IFwibnVtYmVyXCIgPyB0IC0gdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGUgOiB0IC0gZVt0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZV0sIG8gPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2ggPT0gXCJudW1iZXJcIiA/IHQgLSB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaCA6IHQgLSBlW3RoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoXSwgciA9IChsLCBjKSA9PiBsIC0gYyA8IDAgPyAtMSA6IGMgLSBsIDwgMCA/IDEgOiAwLCBhID0gW2ksIG4sIG9dLmZpbHRlcigobCkgPT4gbCAhPSBudWxsICYmIGwgPj0gMCkuc29ydChyKVswXTtcbiAgICBpID4gMCAmJiBpID09PSBhID8gKHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcIm92ZXJcIiwgdGhpcy5fb3B0aW9ucy5zaWRlbmF2SGlkZGVuID0gITApIDogbiA+IDAgJiYgbiA9PT0gYSA/IHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcInNpZGVcIiA6IG8gPiAwICYmIG8gPT09IGEgJiYgKHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcInB1c2hcIik7XG4gIH1cbiAgX2NvbGxhcHNlSXRlbXMoKSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGguZmluZChDZSwgdCkuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBVdC5nZXRJbnN0YW5jZShpKS5oaWRlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfZ2V0T2Zmc2V0VmFsdWUodCwgeyBpbmRleDogZSwgcHJvcGVydHk6IGksIG9mZnNldHM6IG4gfSkge1xuICAgIGNvbnN0IG8gPSB0aGlzLl9nZXRQeFZhbHVlKFxuICAgICAgdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZVtlXVtuW2ldLnByb3BlcnR5XVxuICAgICksIHIgPSB0ID8gbltpXS52YWx1ZSA6IDA7XG4gICAgcmV0dXJuIG8gKyByO1xuICB9XG4gIF9nZXRQcm9wZXJ0eSguLi50KSB7XG4gICAgcmV0dXJuIHQubWFwKChlLCBpKSA9PiBpID09PSAwID8gZSA6IGVbMF0udG9VcHBlckNhc2UoKS5jb25jYXQoZS5zbGljZSgxKSkpLmpvaW4oXCJcIik7XG4gIH1cbiAgX2dldFB4VmFsdWUodCkge1xuICAgIHJldHVybiB0ID8gcGFyc2VGbG9hdCh0KSA6IDA7XG4gIH1cbiAgX2hhbmRsZVN3aXBlKHQsIGUpIHtcbiAgICBlICYmIHRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kYWJsZSA/IHRoaXMudG9nZ2xlU2xpbSgpIDogZSB8fCAodGhpcy5fc2xpbUNvbGxhcHNlZCB8fCAhdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltIHx8ICF0aGlzLm9wdGlvbnMuc2lkZW5hdkV4cGFuZGFibGUgPyB0aGlzLnRvZ2dsZXIgJiYgU3QodGhpcy50b2dnbGVyKSAmJiB0aGlzLnRvZ2dsZSgpIDogdGhpcy50b2dnbGVTbGltKCkpO1xuICB9XG4gIF9pc0FjdGl2ZSh0LCBlKSB7XG4gICAgcmV0dXJuIGUgPyBlID09PSB0IDogdC5hdHRyaWJ1dGVzLmhyZWYgPyBuZXcgVVJMKHQsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5ocmVmID09PSB3aW5kb3cubG9jYXRpb24uaHJlZiA6ICExO1xuICB9XG4gIF9pc0FsbFRvQmVDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIGguZmluZChcbiAgICAgIEJfLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkuZmlsdGVyKFxuICAgICAgKGkpID0+IGkuZ2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKSA9PT0gXCJ0cnVlXCJcbiAgICApLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBfaXNBbGxDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIGguZmluZChDZSwgdGhpcy5fZWxlbWVudCkuZmlsdGVyKFxuICAgICAgKHQpID0+IFN0KHQpXG4gICAgKS5sZW5ndGggPT09IDA7XG4gIH1cbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3ApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3BDbGFzcyA/IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3BDbGFzcy5zcGxpdChcIiBcIikgOiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uID8gW1xuICAgICAgXCJvcGFjaXR5LTUwXCIsXG4gICAgICBcInRyYW5zaXRpb24tYWxsXCIsXG4gICAgICBcImR1cmF0aW9uLTMwMFwiLFxuICAgICAgXCJlYXNlLWluLW91dFwiLFxuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbixcbiAgICAgIFwidG9wLTBcIixcbiAgICAgIFwibGVmdC0wXCIsXG4gICAgICBcInotNTBcIixcbiAgICAgIFwiYmctYmxhY2svMTBcIixcbiAgICAgIFwiZGFyazpiZy1ibGFjay02MFwiLFxuICAgICAgXCJ3LWZ1bGxcIixcbiAgICAgIFwiaC1mdWxsXCIsXG4gICAgICB0aGlzLl9lbGVtZW50LmlkXG4gICAgXSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBsbyh7XG4gICAgICBpc1Zpc2libGU6IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AsXG4gICAgICBpc0FuaW1hdGVkOiAhMCxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICBiYWNrZHJvcENsYXNzZXM6IHQsXG4gICAgICBjbGlja0NhbGxiYWNrOiAoKSA9PiB0aGlzLmhpZGUoKVxuICAgIH0pO1xuICB9XG4gIF91cGRhdGVCYWNrZHJvcCh0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIpIHtcbiAgICAgIHQgPyB0aGlzLl9iYWNrZHJvcC5zaG93KCkgOiB0aGlzLmlzQmFja2Ryb3BWaXNpYmxlICYmIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc0JhY2tkcm9wVmlzaWJsZSAmJiB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gIH1cbiAgX3NldHVwKCkge1xuICAgIHRoaXMuX3NldHVwVG91Y2goKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZGb2N1c1RyYXAgJiYgdGhpcy5fc2V0dXBGb2N1c1RyYXAoKSwgdGhpcy5fc2V0dXBDb2xsYXBzZSgpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW0gJiYgdGhpcy5fc2V0dXBTbGltKCksIHRoaXMuX3NldHVwSW5pdGlhbFN0eWxpbmcoKSwgdGhpcy5fc2V0dXBTY3JvbGxpbmcoKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZDb250ZW50ICYmIHRoaXMuX3NldHVwQ29udGVudCgpLCB0aGlzLl9zZXR1cEFjdGl2ZVN0YXRlKCksIHRoaXMuX3NldHVwUmlwcGxlRWZmZWN0KCksIHRoaXMub3B0aW9ucy5zaWRlbmF2SGlkZGVuIHx8IHRoaXMuX3VwZGF0ZU9mZnNldHMoITAsICEwKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9zZXRUYWJpbmRleCghMCk7XG4gIH1cbiAgX3NldHVwQWN0aXZlU3RhdGUoKSB7XG4gICAgdGhpcy5fc2V0QWN0aXZlRWxlbWVudHMoKSwgdGhpcy5saW5rcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB1Lm9uKHQsIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5fc2V0QWN0aXZlRWxlbWVudHModCkpLCB1Lm9uKHQsIFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgICBlLmtleUNvZGUgPT09IGx0ICYmIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKHQpO1xuICAgICAgfSk7XG4gICAgfSksIHUub24od2luZG93LCBcImhhc2hjaGFuZ2VcIiwgdGhpcy5oYXNoSGFuZGxlcik7XG4gIH1cbiAgX3NldHVwQ29sbGFwc2UoKSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICAgIGguZmluZChDZSwgdCkuZm9yRWFjaChcbiAgICAgICAgKG4sIG8pID0+IHRoaXMuX3NldHVwQ29sbGFwc2VMaXN0KHsgbGlzdDogbiwgaW5kZXg6IG8sIG1lbnU6IHQsIG1lbnVJbmRleDogZSB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBfZ2VuZXJhdGVDb2xscGFzZUlEKHQsIGUpIHtcbiAgICByZXR1cm4gYHNpZGVuYXYtY29sbGFwc2UtJHt0aGlzLl9JRH0tJHtlfS0ke3R9YDtcbiAgfVxuICBfc2V0dXBDb2xsYXBzZUxpc3QoeyBsaXN0OiB0LCBpbmRleDogZSwgbWVudTogaSwgbWVudUluZGV4OiBuIH0pIHtcbiAgICBjb25zdCBvID0gdGhpcy5fZ2VuZXJhdGVDb2xscGFzZUlEKGUsIG4pO1xuICAgIHQuc2V0QXR0cmlidXRlKFwiaWRcIiwgbyksIHQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1jb2xsYXBzZS1pdGVtXCIsIFwiXCIpO1xuICAgIGNvbnN0IFtyXSA9IGgucHJldih0LCB0aSk7XG4gICAgcC5zZXREYXRhQXR0cmlidXRlKHIsIFwiY29sbGFwc2UtaW5pdFwiLCBcIlwiKSwgci5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtvfWApLCByLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJidXR0b25cIik7XG4gICAgY29uc3QgYSA9IFV0LmdldEluc3RhbmNlKHQpIHx8IG5ldyBVdCh0LCB7XG4gICAgICB0b2dnbGU6ICExLFxuICAgICAgcGFyZW50OiB0aGlzLm9wdGlvbnMuc2lkZW5hdkFjY29yZGlvbiA/IGkgOiB0XG4gICAgfSk7XG4gICAgKHQuZGF0YXNldC50ZVNpZGVuYXZTdGF0ZVNob3cgPT09IFwiXCIgfHwgdC5kYXRhc2V0LnRlQ29sbGFwc2VTaG93ID09PSBcIlwiKSAmJiB0aGlzLl9yb3RhdGVBcnJvdyhyLCAhMSksIHUub24ociwgXCJjbGlja1wiLCAobCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlQ2F0ZWdvcnkobCwgYSwgdCksIHRoaXMuX3RlbXBTbGltICYmIHRoaXMuX2lzQWxsVG9CZUNvbGxhcHNlZCgpICYmICh0aGlzLl9zZXRTbGltKCEwKSwgdGhpcy5fdGVtcFNsaW0gPSAhMSksIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcC51cGRhdGUoKTtcbiAgICB9KSwgdS5vbihcbiAgICAgIHQsXG4gICAgICBcInNob3cudGUuY29sbGFwc2VcIixcbiAgICAgICgpID0+IHRoaXMuX3JvdGF0ZUFycm93KHIsICExKVxuICAgICksIHUub24oXG4gICAgICB0LFxuICAgICAgXCJoaWRlLnRlLmNvbGxhcHNlXCIsXG4gICAgICAoKSA9PiB0aGlzLl9yb3RhdGVBcnJvdyhyLCAhMClcbiAgICApLCB1Lm9uKHQsIFwic2hvd24udGUuY29sbGFwc2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwLnVwZGF0ZSgpO1xuICAgIH0pLCB1Lm9uKHQsIFwiaGlkZGVuLnRlLmNvbGxhcHNlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3RlbXBTbGltICYmIHRoaXMuX2lzQWxsQ29sbGFwc2VkKCkgJiYgKHRoaXMuX3NldFNsaW0oITApLCB0aGlzLl90ZW1wU2xpbSA9ICExKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwLnVwZGF0ZSgpO1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cENvbnRlbnQoKSB7XG4gICAgdGhpcy5fY29udGVudCA9IGguZmluZCh0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbnRlbnQpLCB0aGlzLl9jb250ZW50LmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBbXG4gICAgICAgIFwiIXBcIixcbiAgICAgICAgXCIhbVwiLFxuICAgICAgICBcIiFweFwiLFxuICAgICAgICBcIiFwbFwiLFxuICAgICAgICBcIiFwclwiLFxuICAgICAgICBcIiFteFwiLFxuICAgICAgICBcIiFtbFwiLFxuICAgICAgICBcIiFtclwiLFxuICAgICAgICBcIiEtcFwiLFxuICAgICAgICBcIiEtbVwiLFxuICAgICAgICBcIiEtcHhcIixcbiAgICAgICAgXCIhLXBsXCIsXG4gICAgICAgIFwiIS1wclwiLFxuICAgICAgICBcIiEtbXhcIixcbiAgICAgICAgXCIhLW1sXCIsXG4gICAgICAgIFwiIS1tclwiXG4gICAgICBdO1xuICAgICAgWy4uLnQuY2xhc3NMaXN0XS5maWx0ZXIoXG4gICAgICAgIChuKSA9PiBlLmZpbmRJbmRleCgobykgPT4gbi5pbmNsdWRlcyhvKSkgPj0gMFxuICAgICAgKS5mb3JFYWNoKChuKSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUobikpO1xuICAgIH0pLCB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlID0gdGhpcy5fY29udGVudC5tYXAoKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFkZGluZ0xlZnQ6IGUsIHBhZGRpbmdSaWdodDogaSwgbWFyZ2luTGVmdDogbiwgbWFyZ2luUmlnaHQ6IG8sIHRyYW5zaXRpb246IHIgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpO1xuICAgICAgcmV0dXJuIHsgcGFkZGluZ0xlZnQ6IGUsIHBhZGRpbmdSaWdodDogaSwgbWFyZ2luTGVmdDogbiwgbWFyZ2luUmlnaHQ6IG8sIHRyYW5zaXRpb246IHIgfTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwID0gbmV3IGJpKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHtcbiAgICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgICBjb25kaXRpb246ICh0KSA9PiB0LmtleUNvZGUgPT09IGZpLFxuICAgICAgICBvbmx5VmlzaWJsZTogITBcbiAgICAgIH0sXG4gICAgICB0aGlzLnRvZ2dsZXJcbiAgICApO1xuICB9XG4gIF9zZXR1cEluaXRpYWxTdHlsaW5nKCkge1xuICAgIHRoaXMuX3NldENvbG9yKCksIHAuc3R5bGUodGhpcy5fZWxlbWVudCwgdGhpcy5zaWRlbmF2U3R5bGUpO1xuICB9XG4gIF9zZXR1cFNjcm9sbGluZygpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2U2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICB0ID0gaC5maW5kT25lKFxuICAgICAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdlNjcm9sbENvbnRhaW5lcixcbiAgICAgICAgdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGkgPSB0Yyh0LnBhcmVudE5vZGUuY2hpbGRyZW4pLmZpbHRlcihcbiAgICAgICAgKG4pID0+IG4gIT09IHRcbiAgICAgICkucmVkdWNlKChuLCBvKSA9PiBuICsgby5jbGllbnRIZWlnaHQsIDApO1xuICAgICAgcC5zdHlsZSh0LCB7XG4gICAgICAgIG1heEhlaWdodDogYGNhbGMoMTAwJSAtICR7aX1weClgLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG5ldyBUaSh0LCB7XG4gICAgICBzdXBwcmVzc1Njcm9sbFg6ICEwLFxuICAgICAgaGFuZGxlcnM6IFtcImNsaWNrLXJhaWxcIiwgXCJkcmFnLXRodW1iXCIsIFwid2hlZWxcIiwgXCJ0b3VjaFwiXVxuICAgIH0pLCBQXyh0KTtcbiAgfVxuICBfc2V0dXBTbGltKCkge1xuICAgIHRoaXMuX3NsaW1Db2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW1Db2xsYXBzZWQsIHRoaXMuX3RvZ2dsZVNsaW1EaXNwbGF5KHRoaXMuX3NsaW1Db2xsYXBzZWQpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkV4cGFuZE9uSG92ZXIgJiYgKHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2xpbUNvbGxhcHNlZCAmJiB0aGlzLl9zZXRTbGltKCExKTtcbiAgICB9KSwgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zbGltQ29sbGFwc2VkIHx8IHRoaXMuX3NldFNsaW0oITApO1xuICAgIH0pKTtcbiAgfVxuICBfc2V0dXBSaXBwbGVFZmZlY3QoKSB7XG4gICAgdGhpcy5saW5rcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBsZXQgZSA9IENzLmdldEluc3RhbmNlKHQpLCBpID0gdGhpcy5vcHRpb25zLnNpZGVuYXZDb2xvcjtcbiAgICAgIGlmIChlICYmIGUuX29wdGlvbnMuc2lkZW5hdkNvbG9yICE9PSB0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbG9yKVxuICAgICAgICBlLmRpc3Bvc2UoKTtcbiAgICAgIGVsc2UgaWYgKGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIChsb2NhbFN0b3JhZ2UudGhlbWUgPT09IFwiZGFya1wiIHx8ICEoXCJ0aGVtZVwiIGluIGxvY2FsU3RvcmFnZSkgJiYgd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIpLm1hdGNoZXMpICYmIChpID0gXCJ3aGl0ZVwiKSwgZSA9IG5ldyBDcyh0LCB7IHJpcHBsZUNvbG9yOiBpIH0pO1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cFRvdWNoKCkge1xuICAgIHRoaXMuX3RvdWNoID0gbmV3IElfKHRoaXMuX2VsZW1lbnQsIFwic3dpcGVcIiwgeyB0aHJlc2hvbGQ6IDIwIH0pLCB0aGlzLl90b3VjaC5pbml0KCksIHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJzd2lwZWxlZnRcIixcbiAgICAgICh0KSA9PiB0aGlzLl9oYW5kbGVTd2lwZSh0LCB0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0KVxuICAgICksIHUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJzd2lwZXJpZ2h0XCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlU3dpcGUodCwgIXRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQpXG4gICAgKTtcbiAgfVxuICBfc2V0QWN0aXZlKHQsIGUpIHtcbiAgICB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZWJhci1zdGF0ZS1hY3RpdmVcIiwgXCJcIiksIHRoaXMuX2FjdGl2ZU5vZGUgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLXNpZGViYXItc3RhdGUtYWN0aXZlXCIpLCB0aGlzLl9hY3RpdmVOb2RlID0gdDtcbiAgICBjb25zdCBbaV0gPSBoLnBhcmVudHMoXG4gICAgICB0aGlzLl9hY3RpdmVOb2RlLFxuICAgICAgQ2VcbiAgICApO1xuICAgIGlmICghaSkge1xuICAgICAgdGhpcy5fc2V0QWN0aXZlQ2F0ZWdvcnkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW25dID0gaC5wcmV2KGksIHRpKTtcbiAgICB0aGlzLl9zZXRBY3RpdmVDYXRlZ29yeShuKSwgIWUgJiYgIXRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgVXQuZ2V0SW5zdGFuY2UoaSkuc2hvdygpO1xuICB9XG4gIF9zZXRBY3RpdmVDYXRlZ29yeSh0KSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGguZmluZChDZSwgZSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBjb25zdCBbb10gPSBoLnByZXYobiwgdGkpO1xuICAgICAgICBvICE9PSB0ID8gby5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLXNpZGVuYXYtc3RhdGUtYWN0aXZlXCIpIDogby5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNpZGVuYXYtc3RhdGUtYWN0aXZlXCIsIFwiXCIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldEFjdGl2ZUVsZW1lbnRzKHQpIHtcbiAgICB0aGlzLm5hdmlnYXRpb24uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaC5maW5kKHRpLCBlKS5maWx0ZXIoKG4pID0+IGgubmV4dChuLCBDZSkubGVuZ3RoID09PSAwKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzQWN0aXZlKG4sIHQpICYmIG4gIT09IHRoaXMuX2FjdGl2ZU5vZGUgJiYgdGhpcy5fc2V0QWN0aXZlKG4sIHQpO1xuICAgICAgfSk7XG4gICAgfSksIHQgJiYgdGhpcy5fdXBkYXRlRm9jdXModGhpcy5pc1Zpc2libGUpO1xuICB9XG4gIF9zZXRDb2xvcigpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgXCJwcmltYXJ5XCIsXG4gICAgICBcInNlY29uZGFyeVwiLFxuICAgICAgXCJzdWNjZXNzXCIsXG4gICAgICBcImluZm9cIixcbiAgICAgIFwid2FybmluZ1wiLFxuICAgICAgXCJkYW5nZXJcIixcbiAgICAgIFwibGlnaHRcIixcbiAgICAgIFwiZGFya1wiXG4gICAgXSwgeyBzaWRlbmF2Q29sb3I6IGUgfSA9IHRoaXMub3B0aW9ucywgaSA9IHQuaW5jbHVkZXMoZSkgPyBlIDogXCJwcmltYXJ5XCI7XG4gICAgdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoYHNpZGVuYXYtJHtufWApO1xuICAgIH0pLCBwLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIGBzaWRlbmF2LSR7aX1gKTtcbiAgfVxuICBfc2V0Q29udGVudE9mZnNldHModCwgZSwgaSkge1xuICAgIHRoaXMuX2NvbnRlbnQuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgY29uc3QgciA9IHRoaXMuX2dldE9mZnNldFZhbHVlKHQsIHtcbiAgICAgICAgaW5kZXg6IG8sXG4gICAgICAgIHByb3BlcnR5OiBcInBhZGRpbmdcIixcbiAgICAgICAgb2Zmc2V0czogZVxuICAgICAgfSksIGEgPSB0aGlzLl9nZXRPZmZzZXRWYWx1ZSh0LCB7XG4gICAgICAgIGluZGV4OiBvLFxuICAgICAgICBwcm9wZXJ0eTogXCJtYXJnaW5cIixcbiAgICAgICAgb2Zmc2V0czogZVxuICAgICAgfSksIGwgPSB7fTtcbiAgICAgIGlmIChpIHx8IChsLnRyYW5zaXRpb24gPSBgYWxsICR7dGhpcy50cmFuc2l0aW9uRHVyYXRpb259IGxpbmVhcmApLCBsW2UucGFkZGluZy5wcm9wZXJ0eV0gPSBgJHtyfXB4YCwgbFtlLm1hcmdpbi5wcm9wZXJ0eV0gPSBgJHthfXB4YCwgcC5zdHlsZShuLCBsKSwgISF0KSB7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgcC5zdHlsZShuLCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlW29dLnRyYW5zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdS5vbihuLCBcInRyYW5zaXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgICAgIHAuc3R5bGUobiwge1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZVtvXS50cmFuc2l0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9zZXRNb2RlKHQpIHtcbiAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgIT09IHQgJiYgKHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSB0LCB0aGlzLl91cGRhdGUodGhpcy5pc1Zpc2libGUpKTtcbiAgfVxuICBfc2V0U2xpbSh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyBbXCJjb2xsYXBzZVwiLCBcImNvbGxhcHNlZFwiXSA6IFtcImV4cGFuZFwiLCBcImV4cGFuZGVkXCJdO1xuICAgIHRoaXMuX3RyaWdnZXJFdmVudHMoLi4uZSksIHQgJiYgdGhpcy5fY29sbGFwc2VJdGVtcygpLCB0aGlzLl9zbGltQ29sbGFwc2VkID0gdCwgdGhpcy5fdG9nZ2xlU2xpbURpc3BsYXkodCksIHAuc3R5bGUodGhpcy5fZWxlbWVudCwgeyB3aWR0aDogYCR7dGhpcy53aWR0aH1weGAgfSksIHRoaXMuX3VwZGF0ZU9mZnNldHModGhpcy5pc1Zpc2libGUpO1xuICB9XG4gIF9zZXRUYWJpbmRleCh0KSB7XG4gICAgdGhpcy5saW5rcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBlLnRhYkluZGV4ID0gdCA/IDAgOiAtMTtcbiAgICB9KTtcbiAgfVxuICBfZW1pdEV2ZW50cyh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyBbXCJzaG93XCIsIFwic2hvd25cIl0gOiBbXCJoaWRlXCIsIFwiaGlkZGVuXCJdO1xuICAgIHRoaXMuX3RyaWdnZXJFdmVudHMoLi4uZSk7XG4gIH1cbiAgX3JvdGF0ZUFycm93KHQsIGUpIHtcbiAgICBjb25zdCBbaV0gPSBoLmNoaWxkcmVuKHQsIGBbJHtIX31dYCk7XG4gICAgaSAmJiAoZSA/IHAucmVtb3ZlQ2xhc3MoaSwgXCJyb3RhdGUtMTgwXCIpIDogcC5hZGRDbGFzcyhpLCBcInJvdGF0ZS0xODBcIikpO1xuICB9XG4gIF90b2dnbGVDYXRlZ29yeSh0LCBlKSB7XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpLCBlLnRvZ2dsZSgpLCB0aGlzLl9zbGltQ29sbGFwc2VkICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kYWJsZSAmJiAodGhpcy5fdGVtcFNsaW0gPSAhMCwgdGhpcy5fc2V0U2xpbSghMSkpO1xuICB9XG4gIF90b2dnbGVTbGltRGlzcGxheSh0KSB7XG4gICAgY29uc3QgZSA9IGguZmluZChcbiAgICAgIFZfLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGkgPSBoLmZpbmQoXG4gICAgICBXXyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBuID0gKCkgPT4ge1xuICAgICAgZS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIHAuc3R5bGUobywge1xuICAgICAgICAgIGRpc3BsYXk6IHRoaXMuX3NsaW1Db2xsYXBzZWQgPyBcInVuc2V0XCIgOiBcIm5vbmVcIlxuICAgICAgICB9KTtcbiAgICAgIH0pLCBpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgcC5zdHlsZShvLCB7XG4gICAgICAgICAgZGlzcGxheTogdGhpcy5fc2xpbUNvbGxhcHNlZCA/IFwibm9uZVwiIDogXCJ1bnNldFwiXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0ID8gc2V0VGltZW91dChcbiAgICAgICgpID0+IG4oKSxcbiAgICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uXG4gICAgKSA6IG4oKTtcbiAgfVxuICBhc3luYyBfdHJpZ2dlckV2ZW50cyh0LCBlKSB7XG4gICAgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke3R9LnRlLnNpZGVuYXZgKSwgZSAmJiBhd2FpdCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHtlfS50ZS5zaWRlbmF2YCk7XG4gICAgfSwgdGhpcy5vcHRpb25zLnNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb24gKyA1KTtcbiAgfVxuICBfdXBkYXRlKHQpIHtcbiAgICB0aGlzLnRvZ2dsZXIgJiYgdGhpcy5fdXBkYXRlVG9nZ2xlckFyaWEodCksIHRoaXMuX3VwZGF0ZURpc3BsYXkodCksIHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgdGhpcy5fdXBkYXRlQmFja2Ryb3AodCksIHRoaXMuX3VwZGF0ZU9mZnNldHModCksIHQgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZDbG9zZU9uRXNjICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSAhPT0gXCJzaWRlXCIgJiYgdS5vbih3aW5kb3csIFwia2V5ZG93blwiLCB0aGlzLmVzY0hhbmRsZXIpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkZvY3VzVHJhcCAmJiB0aGlzLl91cGRhdGVGb2N1cyh0KTtcbiAgfVxuICBfdXBkYXRlRGlzcGxheSh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyAwIDogdGhpcy50cmFuc2xhdGlvbjtcbiAgICBwLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtlfSUpYFxuICAgIH0pO1xuICB9XG4gIF91cGRhdGVGb2N1cyh0KSB7XG4gICAgaWYgKHRoaXMuX3NldFRhYmluZGV4KHQpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2Rm9jdXNUcmFwKSB7XG4gICAgICBpZiAodCkge1xuICAgICAgICB0aGlzLl9mb2N1c1RyYXAudHJhcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9mb2N1c1RyYXAuZGlzYWJsZSgpO1xuICAgIH1cbiAgICB0aGlzLl9mb2N1c1RyYXAuZGlzYWJsZSgpO1xuICB9XG4gIF91cGRhdGVPZmZzZXRzKHQsIGUgPSAhMSkge1xuICAgIGNvbnN0IFtpLCBuXSA9IHRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQgPyBbXCJyaWdodFwiLCBcImxlZnRcIl0gOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sIG8gPSB7XG4gICAgICBwcm9wZXJ0eTogdGhpcy5fZ2V0UHJvcGVydHkoXCJwYWRkaW5nXCIsIGkpLFxuICAgICAgdmFsdWU6IHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgPyAwIDogdGhpcy53aWR0aFxuICAgIH0sIHIgPSB7XG4gICAgICBwcm9wZXJ0eTogdGhpcy5fZ2V0UHJvcGVydHkoXCJtYXJnaW5cIiwgbiksXG4gICAgICB2YWx1ZTogdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcInB1c2hcIiA/IC0xICogdGhpcy53aWR0aCA6IDBcbiAgICB9O1xuICAgIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcInVwZGF0ZS50ZS5zaWRlbmF2XCIsIHtcbiAgICAgIG1hcmdpbjogcixcbiAgICAgIHBhZGRpbmc6IG9cbiAgICB9KSwgdGhpcy5fY29udGVudCAmJiAodGhpcy5fY29udGVudC5jbGFzc05hbWUgPSBcIlwiLCB0aGlzLl9zZXRDb250ZW50T2Zmc2V0cyh0LCB7IHBhZGRpbmc6IG8sIG1hcmdpbjogciB9LCBlKSk7XG4gIH1cbiAgX3VwZGF0ZVRvZ2dsZXJBcmlhKHQpIHtcbiAgICB0aGlzLnRvZ2dsZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCB0KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIHRvZ2dsZVNpZGVuYXYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBoLmNsb3Nlc3QodC50YXJnZXQsIEFuKSwgaSA9IHAuZ2V0RGF0YUF0dHJpYnV0ZXMoZSkudGFyZ2V0O1xuICAgICAgaC5maW5kKGkpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgKG5pLmdldEluc3RhbmNlKG4pIHx8IG5ldyBuaShuKSkudG9nZ2xlKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaSA9IEkuZ2V0RGF0YSh0aGlzLCBaaSk7XG4gICAgICBjb25zdCBuID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWkgJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3IG5pKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIFppKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBZbiA9IFwic3RlcHBlclwiLCBtcyA9IFwidGUuc3RlcHBlclwiLCBNcyA9IGAuJHttc31gLCBDaSA9IGBkYXRhLXRlLSR7WW59YCwgb2kgPSBcImhvcml6b250YWxcIiwgeXQgPSBcInZlcnRpY2FsXCIsIHpfID0ge1xuICBzdGVwcGVyVHlwZTogXCJzdHJpbmdcIixcbiAgc3RlcHBlckxpbmVhcjogXCJib29sZWFuXCIsXG4gIHN0ZXBwZXJOb0VkaXRhYmxlOiBcImJvb2xlYW5cIixcbiAgc3RlcHBlckFjdGl2ZTogXCJzdHJpbmdcIixcbiAgc3RlcHBlckNvbXBsZXRlZDogXCJzdHJpbmdcIixcbiAgc3RlcHBlckludmFsaWQ6IFwic3RyaW5nXCIsXG4gIHN0ZXBwZXJEaXNhYmxlZDogXCJzdHJpbmdcIixcbiAgc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludDogXCJudW1iZXJcIixcbiAgc3RlcHBlck1vYmlsZUJyZWFrcG9pbnQ6IFwibnVtYmVyXCIsXG4gIHN0ZXBwZXJNb2JpbGVCYXJCcmVha3BvaW50OiBcIm51bWJlclwiXG59LCBYXyA9IHtcbiAgc3RlcHBlclR5cGU6IG9pLFxuICBzdGVwcGVyTGluZWFyOiAhMSxcbiAgc3RlcHBlck5vRWRpdGFibGU6ICExLFxuICBzdGVwcGVyQWN0aXZlOiBcIlwiLFxuICBzdGVwcGVyQ29tcGxldGVkOiBcIlwiLFxuICBzdGVwcGVySW52YWxpZDogXCJcIixcbiAgc3RlcHBlckRpc2FibGVkOiBcIlwiLFxuICBzdGVwcGVyVmVydGljYWxCcmVha3BvaW50OiAwLFxuICBzdGVwcGVyTW9iaWxlQnJlYWtwb2ludDogMCxcbiAgc3RlcHBlck1vYmlsZUJhckJyZWFrcG9pbnQ6IDRcbn0sIHFyID0gYG1vdXNlZG93biR7TXN9YCwgUXIgPSBga2V5ZG93biR7TXN9YCwgR18gPSBga2V5dXAke01zfWAsIFpyID0gYHJlc2l6ZSR7TXN9YCwgVnQgPSBgWyR7Q2l9LXN0ZXAtcmVmXWAsIEcgPSBgWyR7Q2l9LWhlYWQtcmVmXWAsIEpyID0gYFske0NpfS1oZWFkLXRleHQtcmVmXWAsIEppID0gYFske0NpfS1oZWFkLWljb24tcmVmXWAsIHN0ID0gYFske0NpfS1jb250ZW50LXJlZl1gO1xuY2xhc3MgUWcge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2VsZW1lbnRIZWlnaHQgPSAwLCB0aGlzLl9zdGVwcyA9IGguZmluZChgJHtWdH1gLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fY3VycmVudFZpZXcgPSBcIlwiLCB0aGlzLl9hY3RpdmVTdGVwSW5kZXggPSAwLCB0aGlzLl92ZXJ0aWNhbFN0ZXBwZXJTdHlsZXMgPSBbXSwgdGhpcy5fZWxlbWVudCAmJiAoSS5zZXREYXRhKHQsIG1zLCB0aGlzKSwgdGhpcy5faW5pdCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gWW47XG4gIH1cbiAgZ2V0IGFjdGl2ZVN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXBzW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF07XG4gIH1cbiAgZ2V0IGFjdGl2ZVN0ZXBJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlU3RlcEluZGV4O1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHUub2ZmKHQsIHFyKSwgdS5vZmYodCwgUXIpO1xuICAgIH0pLCB1Lm9mZih3aW5kb3csIFpyKSwgSS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIG1zKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgY2hhbmdlU3RlcCh0KSB7XG4gICAgdGhpcy5fdG9nZ2xlU3RlcCh0KTtcbiAgfVxuICBuZXh0U3RlcCgpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwKHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCArIDEpO1xuICB9XG4gIHByZXZpb3VzU3RlcCgpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwKHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAtIDEpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgY29uc3QgdCA9IGguZmluZChgJHtWdH1gLCB0aGlzLl9lbGVtZW50KVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLnNldEF0dHJpYnV0ZShcImRhdGEtdGVcIiwgXCJhY3RpdmUtc3RlcFwiKSwgZSA9IGguZmluZChcbiAgICAgIGAke0pyfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaSA9IGguZmluZChcbiAgICAgIGAke0ppfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBzd2l0Y2ggKHQgPyAodGhpcy5fYWN0aXZlU3RlcEluZGV4ID0gdGhpcy5fc3RlcHMuaW5kZXhPZih0KSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKFxuICAgICAgdGhpcy5fYWN0aXZlU3RlcEluZGV4LFxuICAgICAgXCJhZGRcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3RlcHBlckFjdGl2ZVxuICAgICksIGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiZm9udC1tZWRpdW1cIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiF0ZXh0LXByaW1hcnktNzAwXCIpKSA6IChlW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcImZvbnQtbWVkaXVtXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiFiZy1wcmltYXJ5LTEwMFwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCIhdGV4dC1wcmltYXJ5LTcwMFwiKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKFxuICAgICAgdGhpcy5fYWN0aXZlU3RlcEluZGV4LFxuICAgICAgXCJhZGRcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3RlcHBlckFjdGl2ZVxuICAgICkpLCB0aGlzLl9iaW5kTW91c2VEb3duKCksIHRoaXMuX2JpbmRLZXlzTmF2aWdhdGlvbigpLCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJUeXBlKSB7XG4gICAgICBjYXNlIHl0OlxuICAgICAgICB0aGlzLl90b2dnbGVWZXJ0aWNhbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuX3RvZ2dsZUhvcml6b250YWwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICh0aGlzLl9vcHRpb25zLnN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQgfHwgdGhpcy5fb3B0aW9ucy5zdGVwcGVyTW9iaWxlQnJlYWtwb2ludCkgJiYgdGhpcy5fdG9nZ2xlU3RlcHBlclZpZXcoKSwgdGhpcy5fYmluZFJlc2l6ZSgpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uWF8sXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4oWW4sIHQsIHpfKSwgdDtcbiAgfVxuICBfYmluZE1vdXNlRG93bigpIHtcbiAgICB0aGlzLl9zdGVwcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5maW5kT25lKGAke0d9YCwgdCk7XG4gICAgICB1Lm9uKGUsIHFyLCAoaSkgPT4ge1xuICAgICAgICBjb25zdCBuID0gaC5wYXJlbnRzKGkudGFyZ2V0LCBgJHtWdH1gKVswXSwgbyA9IHRoaXMuX3N0ZXBzLmluZGV4T2Yobik7XG4gICAgICAgIGkucHJldmVudERlZmF1bHQoKSwgdGhpcy5fdG9nZ2xlU3RlcChvKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kUmVzaXplKCkge1xuICAgIHUub24od2luZG93LCBaciwgKCkgPT4ge1xuICAgICAgdGhpcy5fY3VycmVudFZpZXcgPT09IHl0ICYmIHRoaXMuX3NldFNpbmdsZVN0ZXBIZWlnaHQodGhpcy5hY3RpdmVTdGVwKSwgdGhpcy5fY3VycmVudFZpZXcgPT09IG9pICYmIHRoaXMuX3NldEhlaWdodCh0aGlzLmFjdGl2ZVN0ZXApLCAodGhpcy5fb3B0aW9ucy5zdGVwcGVyVmVydGljYWxCcmVha3BvaW50IHx8IHRoaXMuX29wdGlvbnMuc3RlcHBlck1vYmlsZUJyZWFrcG9pbnQpICYmIHRoaXMuX3RvZ2dsZVN0ZXBwZXJWaWV3KCk7XG4gICAgfSk7XG4gIH1cbiAgX3RvZ2dsZVN0ZXBwZXJWaWV3KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9vcHRpb25zLnN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQgPCB3aW5kb3cuaW5uZXJXaWR0aCwgZSA9IHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCA+IHdpbmRvdy5pbm5lcldpZHRoLCBpID0gdGhpcy5fb3B0aW9ucy5zdGVwcGVyTW9iaWxlQnJlYWtwb2ludCA+IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHQgJiYgdGhpcy5fY3VycmVudFZpZXcgIT09IG9pICYmIHRoaXMuX3RvZ2dsZUhvcml6b250YWwoKSwgZSAmJiAhaSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0geXQgJiYgKHRoaXMuX3N0ZXBzLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSBoLmZpbmRPbmUoYCR7c3R9YCwgbik7XG4gICAgICB0aGlzLl9yZXNldFN0ZXBwZXJIZWlnaHQoKSwgdGhpcy5fc2hvd0VsZW1lbnQobyk7XG4gICAgfSksIHRoaXMuX3RvZ2dsZVZlcnRpY2FsKCkpO1xuICB9XG4gIF90b2dnbGVTdGVwKHQpIHtcbiAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXggIT09IHQgJiYgKHRoaXMuX29wdGlvbnMuc3RlcHBlck5vRWRpdGFibGUgJiYgdGhpcy5fdG9nZ2xlRGlzYWJsZWQoKSwgdGhpcy5fc2hvd0VsZW1lbnQoXG4gICAgICBoLmZpbmRPbmUoYCR7c3R9YCwgdGhpcy5fc3RlcHNbdF0pXG4gICAgKSwgdGhpcy5fdG9nZ2xlQWN0aXZlKHQpLCB0ID4gdGhpcy5fYWN0aXZlU3RlcEluZGV4ICYmIHRoaXMuX3RvZ2dsZUNvbXBsZXRlZCh0aGlzLl9hY3RpdmVTdGVwSW5kZXgpLCB0aGlzLl9jdXJyZW50VmlldyA9PT0gb2kgPyB0aGlzLl9hbmltYXRlSG9yaXpvbnRhbFN0ZXAodCkgOiAodGhpcy5fYW5pbWF0ZVZlcnRpY2FsU3RlcCh0KSwgdGhpcy5fc2V0U2luZ2xlU3RlcEhlaWdodCh0aGlzLl9zdGVwc1t0XSkpLCB0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoXG4gICAgICBoLmZpbmRPbmUoYCR7R31gLCB0aGlzLmFjdGl2ZVN0ZXApLFxuICAgICAgaC5maW5kT25lKGAke0d9YCwgdGhpcy5fc3RlcHNbdF0pXG4gICAgKSwgdGhpcy5fYWN0aXZlU3RlcEluZGV4ID0gdCwgdGhpcy5fc3RlcHNbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlXCIsIFwiYWN0aXZlLXN0ZXBcIiksIHRoaXMuX3N0ZXBzLmZvckVhY2goKGUsIGkpID0+IHtcbiAgICAgIGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XSAhPT0gaSAmJiBlLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGVcIik7XG4gICAgfSkpO1xuICB9XG4gIF9yZXNldFN0ZXBwZXJIZWlnaHQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICB9XG4gIF9zZXRTdGVwc0hlaWdodCgpIHtcbiAgICB0aGlzLl9zdGVwcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5maW5kT25lKGAke3N0fWAsIHQpLCBpID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSk7XG4gICAgICB0aGlzLl92ZXJ0aWNhbFN0ZXBwZXJTdHlsZXMucHVzaCh7XG4gICAgICAgIHBhZGRpbmdUb3A6IHBhcnNlRmxvYXQoaS5wYWRkaW5nVG9wKSxcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogcGFyc2VGbG9hdChpLnBhZGRpbmdCb3R0b20pXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG4gPSBlLnNjcm9sbEhlaWdodDtcbiAgICAgIGUuc3R5bGUuaGVpZ2h0ID0gYCR7bn1weGA7XG4gICAgfSk7XG4gIH1cbiAgX3NldFNpbmdsZVN0ZXBIZWlnaHQodCkge1xuICAgIGNvbnN0IGUgPSBoLmZpbmRPbmUoYCR7c3R9YCwgdCksIGkgPSB0aGlzLmFjdGl2ZVN0ZXAgPT09IHQsIG4gPSB0aGlzLl9zdGVwcy5pbmRleE9mKHQpO1xuICAgIGxldCBvO1xuICAgIGkgPyAoZS5zdHlsZS5oZWlnaHQgPSBcIlwiLCBvID0gZS5zY3JvbGxIZWlnaHQpIDogbyA9IGUuc2Nyb2xsSGVpZ2h0ICsgdGhpcy5fdmVydGljYWxTdGVwcGVyU3R5bGVzW25dLnBhZGRpbmdUb3AgKyB0aGlzLl92ZXJ0aWNhbFN0ZXBwZXJTdHlsZXNbbl0ucGFkZGluZ0JvdHRvbSwgZS5zdHlsZS5oZWlnaHQgPSBgJHtvfXB4YDtcbiAgfVxuICBfdG9nZ2xlVmVydGljYWwoKSB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSB5dCwgdGhpcy5fc2V0U3RlcHNIZWlnaHQoKSwgdGhpcy5faGlkZUluYWN0aXZlU3RlcHMoKTtcbiAgfVxuICBfdG9nZ2xlSG9yaXpvbnRhbCgpIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IG9pLCB0aGlzLl9zZXRIZWlnaHQodGhpcy5hY3RpdmVTdGVwKSwgdGhpcy5faGlkZUluYWN0aXZlU3RlcHMoKTtcbiAgfVxuICBfdG9nZ2xlU3RlcHBlckNsYXNzKCkge1xuICAgIGguZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtc3RlcHBlci10eXBlXVwiLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkgIT09IG51bGwgJiYgdGhpcy5fc3RlcHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaC5maW5kT25lKGAke3N0fWAsIGUpLmNsYXNzTGlzdC5yZW1vdmUoXCIhbXktMFwiKSwgaC5maW5kT25lKGAke3N0fWAsIGUpLmNsYXNzTGlzdC5yZW1vdmUoXCIhcHktMFwiKSwgaC5maW5kT25lKGAke3N0fWAsIGUpLmNsYXNzTGlzdC5yZW1vdmUoXCIhaC0wXCIpO1xuICAgIH0pO1xuICB9XG4gIF90b2dnbGVTdGVwQ2xhc3ModCwgZSwgaSkge1xuICAgIGkgJiYgdGhpcy5fc3RlcHNbdF0uY2xhc3NMaXN0W2VdKGkpO1xuICB9XG4gIF9iaW5kS2V5c05hdmlnYXRpb24oKSB7XG4gICAgdGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KFxuICAgICAgITEsXG4gICAgICBoLmZpbmRPbmUoYCR7R31gLCB0aGlzLmFjdGl2ZVN0ZXApXG4gICAgKSwgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGguZmluZE9uZShgJHtHfWAsIHQpO1xuICAgICAgdS5vbihlLCBRciwgKGkpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IGgucGFyZW50cyhcbiAgICAgICAgICBpLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgYCR7VnR9YFxuICAgICAgICApWzBdLCBvID0gaC5uZXh0KG4sIGAke1Z0fWApWzBdLCByID0gaC5wcmV2KG4sIGAke1Z0fWApWzBdLCBhID0gaC5maW5kT25lKFxuICAgICAgICAgIGAke0d9YCxcbiAgICAgICAgICBuXG4gICAgICAgICksIGwgPSBoLmZpbmRPbmUoXG4gICAgICAgICAgYCR7R31gLFxuICAgICAgICAgIHRoaXMuYWN0aXZlU3RlcFxuICAgICAgICApO1xuICAgICAgICBsZXQgYyA9IG51bGwsIGQgPSBudWxsO1xuICAgICAgICBpZiAobyAmJiAoYyA9IGguZmluZE9uZShgJHtHfWAsIG8pKSwgciAmJiAoZCA9IGguZmluZE9uZShgJHtHfWAsIHIpKSwgaS5rZXlDb2RlID09PSBJZSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0geXQgJiYgKGQgPyAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGQpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIGQpLCBkLmZvY3VzKCkpIDogYyAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGMpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIGMpLCBjLmZvY3VzKCkpKSwgaS5rZXlDb2RlID09PSAkZSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0geXQgJiYgKGMgPyAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGMpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIGMpLCBjLmZvY3VzKCkpIDogZCAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGQpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIGQpLCBkLmZvY3VzKCkpKSwgaS5rZXlDb2RlID09PSBVICYmIHRoaXMuX2N1cnJlbnRWaWV3ID09PSB5dCAmJiAoaS5wcmV2ZW50RGVmYXVsdCgpLCBjICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgYyksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgYyksIGMuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09IHJ0ICYmIHRoaXMuX2N1cnJlbnRWaWV3ID09PSB5dCAmJiAoaS5wcmV2ZW50RGVmYXVsdCgpLCBkICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgZCksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgZCksIGQuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09IExlKSB7XG4gICAgICAgICAgY29uc3QgXyA9IGguZmluZE9uZShcbiAgICAgICAgICAgIGAke0d9YCxcbiAgICAgICAgICAgIHRoaXMuX3N0ZXBzWzBdXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgXyksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgXyksIF8uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaS5rZXlDb2RlID09PSBNZSkge1xuICAgICAgICAgIGNvbnN0IF8gPSB0aGlzLl9zdGVwc1t0aGlzLl9zdGVwcy5sZW5ndGggLSAxXSwgZiA9IGguZmluZE9uZShgJHtHfWAsIF8pO1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBmKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBmKSwgZi5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIChpLmtleUNvZGUgPT09IGx0IHx8IGkua2V5Q29kZSA9PT0gcHMpICYmIChpLnByZXZlbnREZWZhdWx0KCksIHRoaXMuY2hhbmdlU3RlcCh0aGlzLl9zdGVwcy5pbmRleE9mKG4pKSksIGkua2V5Q29kZSA9PT0gZmkgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBsKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCAhMSksIGwuZm9jdXMoKSk7XG4gICAgICB9KSwgdS5vbihlLCBHXywgKGkpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IGgucGFyZW50cyhcbiAgICAgICAgICBpLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgYCR7VnR9YFxuICAgICAgICApWzBdLCBvID0gaC5maW5kT25lKFxuICAgICAgICAgIGAke0d9YCxcbiAgICAgICAgICBuXG4gICAgICAgICksIHIgPSBoLmZpbmRPbmUoXG4gICAgICAgICAgYCR7R31gLFxuICAgICAgICAgIHRoaXMuYWN0aXZlU3RlcFxuICAgICAgICApO1xuICAgICAgICBpLmtleUNvZGUgPT09IGZpICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgobywgciksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoITEsIHIpLCByLmZvY3VzKCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3RvZ2dsZVN0ZXBUYWJJbmRleCh0LCBlKSB7XG4gICAgdCAmJiB0LnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIC0xKSwgZSAmJiBlLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIDApO1xuICB9XG4gIF90b2dnbGVPdXRsaW5lU3R5bGVzKHQsIGUpIHtcbiAgICB0ICYmICh0LnN0eWxlLm91dGxpbmUgPSBcIlwiKSwgZSAmJiAoZS5zdHlsZS5vdXRsaW5lID0gXCJyZXZlcnRcIik7XG4gIH1cbiAgX3RvZ2dsZURpc2FibGVkKCkge1xuICAgIGNvbnN0IHQgPSBoLmZpbmQoYCR7R31gLCB0aGlzLl9lbGVtZW50KSwgZSA9IGguZmluZChcbiAgICAgIGAke0ppfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICB0W3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcImNvbG9yLVsjODU4NTg1XVwiKSwgdFt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCJjdXJzb3ItZGVmYXVsdFwiKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCIhYmctWyM4NTg1ODVdXCIpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyRGlzYWJsZWRcbiAgICApO1xuICB9XG4gIF90b2dnbGVBY3RpdmUodCkge1xuICAgIGNvbnN0IGUgPSBoLmZpbmQoXG4gICAgICBgJHtKcn1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGkgPSBoLmZpbmQoXG4gICAgICBgJHtKaX1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgZVt0XS5jbGFzc0xpc3QuYWRkKFwiZm9udC1tZWRpdW1cIiksIGlbdF0uY2xhc3NMaXN0LmFkZChcIiFiZy1wcmltYXJ5LTEwMFwiKSwgaVt0XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtcHJpbWFyeS03MDBcIiksIGlbdF0uY2xhc3NMaXN0LnJlbW92ZShcIiFiZy1zdWNjZXNzLTEwMFwiKSwgaVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIXRleHQtc3VjY2Vzcy03MDBcIiksIGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKFwiZm9udC1tZWRpdW1cIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgIFwiIXRleHQtcHJpbWFyeS03MDBcIlxuICAgICksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyh0LCBcImFkZFwiLCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJBY3RpdmUpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcInJlbW92ZVwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKTtcbiAgfVxuICBfdG9nZ2xlQ29tcGxldGVkKHQpIHtcbiAgICBjb25zdCBlID0gaC5maW5kKFxuICAgICAgYCR7Sml9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIGVbdF0uY2xhc3NMaXN0LmFkZChcIiFiZy1zdWNjZXNzLTEwMFwiKSwgZVt0XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtc3VjY2Vzcy03MDBcIiksIGVbdF0uY2xhc3NMaXN0LnJlbW92ZShcIiFiZy1kYW5nZXItMTAwXCIpLCBlW3RdLmNsYXNzTGlzdC5yZW1vdmUoXCIhdGV4dC1kYW5nZXItNzAwXCIpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3ModCwgXCJhZGRcIiwgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQ29tcGxldGVkKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKHQsIFwicmVtb3ZlXCIsIHRoaXMuX29wdGlvbnMuc3RlcHBlckludmFsaWQpO1xuICB9XG4gIF9oaWRlSW5hY3RpdmVTdGVwcygpIHtcbiAgICB0aGlzLl9zdGVwcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LmdldEF0dHJpYnV0ZShcImRhdGEtdGVcIikgfHwgdGhpcy5faGlkZUVsZW1lbnQoaC5maW5kT25lKGAke3N0fWAsIHQpKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0SGVpZ2h0KHQpIHtcbiAgICBjb25zdCBlID0gaC5maW5kT25lKGAke3N0fWAsIHQpLCBpID0gZ2V0Q29tcHV0ZWRTdHlsZShlKSwgbiA9IGguZmluZE9uZShgJHtHfWAsIHQpLCBvID0gZ2V0Q29tcHV0ZWRTdHlsZShuKSwgciA9IGUub2Zmc2V0SGVpZ2h0ICsgcGFyc2VGbG9hdChpLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KGkubWFyZ2luQm90dG9tKSwgYSA9IG4ub2Zmc2V0SGVpZ2h0ICsgcGFyc2VGbG9hdChvLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KG8ubWFyZ2luQm90dG9tKTtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke2EgKyByfXB4YDtcbiAgfVxuICBfaGlkZUVsZW1lbnQodCkge1xuICAgICFoLnBhcmVudHMoXG4gICAgICB0LFxuICAgICAgYCR7VnR9YFxuICAgIClbMF0uZ2V0QXR0cmlidXRlKFwiZGF0YS10ZVwiKSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0geXQgfHwgKHQuY2xhc3NMaXN0LmFkZChcIiFteS0wXCIpLCB0LmNsYXNzTGlzdC5hZGQoXCIhcHktMFwiKSwgdC5jbGFzc0xpc3QuYWRkKFwiIWgtMFwiKSk7XG4gIH1cbiAgX3Nob3dFbGVtZW50KHQpIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9PT0geXQgPyAodC5jbGFzc0xpc3QucmVtb3ZlKFwiIW15LTBcIiksIHQuY2xhc3NMaXN0LnJlbW92ZShcIiFweS0wXCIpLCB0LmNsYXNzTGlzdC5yZW1vdmUoXCIhaC0wXCIpKSA6IHQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgfVxuICBfYW5pbWF0ZUhvcml6b250YWxTdGVwKHQpIHtcbiAgICBjb25zdCBlID0gdCA+IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCwgaSA9IGguZmluZE9uZShcbiAgICAgIGAke3N0fWAsXG4gICAgICB0aGlzLl9zdGVwc1t0XVxuICAgICksIG4gPSBoLmZpbmRPbmUoXG4gICAgICBgJHtzdH1gLFxuICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgKTtcbiAgICBsZXQgbywgcjtcbiAgICB0aGlzLl9zdGVwcy5mb3JFYWNoKChkLCBfKSA9PiB7XG4gICAgICBjb25zdCBmID0gaC5maW5kT25lKGAke3N0fWAsIGQpO1xuICAgICAgXyAhPT0gdCAmJiBfICE9PSB0aGlzLl9hY3RpdmVTdGVwSW5kZXggJiYgdGhpcy5faGlkZUVsZW1lbnQoZik7XG4gICAgfSk7XG4gICAgY29uc3QgYSA9IFwidHJhbnNsYXRlLXgtWzE1MCVdXCIsIGwgPSBcIi10cmFuc2xhdGUteC1bMTUwJV1cIiwgYyA9IFwidHJhbnNsYXRlLTBcIjtcbiAgICBlID8gKHIgPSBsLCBvID0gYywgaS5jbGFzc0xpc3QucmVtb3ZlKFwidHJhbnNsYXRlLXgtWzE1MCVdXCIpLCBpLmNsYXNzTGlzdC5yZW1vdmUoXCItdHJhbnNsYXRlLXgtWzE1MCVdXCIpKSA6IChyID0gYSwgbyA9IGMsIGkuY2xhc3NMaXN0LnJlbW92ZShcIi10cmFuc2xhdGUteC1bMTUwJV1cIiksIGkuY2xhc3NMaXN0LnJlbW92ZShcInRyYW5zbGF0ZS14LVsxNTAlXVwiKSksIG4uY2xhc3NMaXN0LmFkZChyKSwgaS5jbGFzc0xpc3QuYWRkKG8pLCB0aGlzLl9zZXRIZWlnaHQodGhpcy5fc3RlcHNbdF0pO1xuICB9XG4gIF9hbmltYXRlVmVydGljYWxTdGVwKHQpIHtcbiAgICBjb25zdCBlID0gaC5maW5kT25lKFxuICAgICAgYCR7c3R9YCxcbiAgICAgIHRoaXMuX3N0ZXBzW3RdXG4gICAgKSwgaSA9IGguZmluZE9uZShcbiAgICAgIGAke3N0fWAsXG4gICAgICB0aGlzLmFjdGl2ZVN0ZXBcbiAgICApO1xuICAgIHRoaXMuX2hpZGVFbGVtZW50KGkpLCB0aGlzLl9zaG93RWxlbWVudChlKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgbXMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IHRhID0gXCJkYXRhLXRlLWlucHV0LXN0YXRlLWFjdGl2ZVwiLCB0cyA9IFwiZGF0YS10ZS1pbnB1dC1zZWxlY3RlZFwiLCBlYSA9IFwiZGF0YS10ZS1pbnB1dC1tdWx0aXBsZS1hY3RpdmVcIiwgaWEgPSBcIltkYXRhLXRlLWZvcm0tY2hlY2staW5wdXRdXCI7XG5jbGFzcyBzYSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIGMsIGQsIF8pIHtcbiAgICB0aGlzLmlkID0gdCwgdGhpcy5uYXRpdmVPcHRpb24gPSBlLCB0aGlzLm11bHRpcGxlID0gaSwgdGhpcy52YWx1ZSA9IG4sIHRoaXMubGFiZWwgPSBvLCB0aGlzLnNlbGVjdGVkID0gciwgdGhpcy5kaXNhYmxlZCA9IGEsIHRoaXMuaGlkZGVuID0gbCwgdGhpcy5zZWNvbmRhcnlUZXh0ID0gYywgdGhpcy5ncm91cElkID0gZCwgdGhpcy5pY29uID0gXywgdGhpcy5ub2RlID0gbnVsbCwgdGhpcy5hY3RpdmUgPSAhMTtcbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdE11bHRpcGxlKCkgOiB0aGlzLl9zZWxlY3RTaW5nbGUoKTtcbiAgfVxuICBfc2VsZWN0U2luZ2xlKCkge1xuICAgIHRoaXMuc2VsZWN0ZWQgfHwgKHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUodHMsIFwiXCIpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMCksIHRoaXMuc2VsZWN0ZWQgPSAhMCwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITApKTtcbiAgfVxuICBfc2VsZWN0TXVsdGlwbGUoKSB7XG4gICAgaWYgKCF0aGlzLnNlbGVjdGVkKSB7XG4gICAgICBjb25zdCB0ID0gaC5maW5kT25lKFxuICAgICAgICBpYSxcbiAgICAgICAgdGhpcy5ub2RlXG4gICAgICApO1xuICAgICAgdC5jaGVja2VkID0gITAsIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUodHMsIFwiXCIpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMCksIHRoaXMuc2VsZWN0ZWQgPSAhMCwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITApO1xuICAgIH1cbiAgfVxuICBkZXNlbGVjdCgpIHtcbiAgICB0aGlzLm11bHRpcGxlID8gdGhpcy5fZGVzZWxlY3RNdWx0aXBsZSgpIDogdGhpcy5fZGVzZWxlY3RTaW5nbGUoKTtcbiAgfVxuICBfZGVzZWxlY3RTaW5nbGUoKSB7XG4gICAgdGhpcy5zZWxlY3RlZCAmJiAodGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSh0cyksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKSwgdGhpcy5zZWxlY3RlZCA9ICExLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMSkpO1xuICB9XG4gIF9kZXNlbGVjdE11bHRpcGxlKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICBjb25zdCB0ID0gaC5maW5kT25lKFxuICAgICAgICBpYSxcbiAgICAgICAgdGhpcy5ub2RlXG4gICAgICApO1xuICAgICAgdC5jaGVja2VkID0gITEsIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUodHMpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMSksIHRoaXMuc2VsZWN0ZWQgPSAhMSwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITEpO1xuICAgIH1cbiAgfVxuICBzZXROb2RlKHQpIHtcbiAgICB0aGlzLm5vZGUgPSB0O1xuICB9XG4gIHNldEFjdGl2ZVN0eWxlcygpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKGVhLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmUgPSAhMCwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSh0YSwgXCJcIik7XG4gICAgfVxuICB9XG4gIHJlbW92ZUFjdGl2ZVN0eWxlcygpIHtcbiAgICB0aGlzLmFjdGl2ZSAmJiAodGhpcy5hY3RpdmUgPSAhMSwgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSh0YSkpLCB0aGlzLm11bHRpcGxlICYmIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoZWEpO1xuICB9XG59XG5jbGFzcyBxXyB7XG4gIGNvbnN0cnVjdG9yKHQgPSAhMSkge1xuICAgIHRoaXMuX211bHRpcGxlID0gdCwgdGhpcy5fc2VsZWN0aW9ucyA9IFtdO1xuICB9XG4gIHNlbGVjdCh0KSB7XG4gICAgdGhpcy5fbXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25zLnB1c2godCkgOiB0aGlzLl9zZWxlY3Rpb25zID0gW3RdO1xuICB9XG4gIGRlc2VsZWN0KHQpIHtcbiAgICBpZiAodGhpcy5fbXVsdGlwbGUpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9zZWxlY3Rpb25zLmZpbmRJbmRleChcbiAgICAgICAgKGkpID0+IHQgPT09IGlcbiAgICAgICk7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25zLnNwbGljZShlLCAxKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuX3NlbGVjdGlvbnMgPSBbXTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9zZWxlY3Rpb25zID0gW107XG4gIH1cbiAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uc1swXTtcbiAgfVxuICBnZXQgc2VsZWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9ucztcbiAgfVxuICBnZXQgbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnNbMF0gJiYgdGhpcy5zZWxlY3Rpb24ubGFiZWw7XG4gIH1cbiAgZ2V0IGxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9ucy5tYXAoKHQpID0+IHQubGFiZWwpLmpvaW4oXCIsIFwiKTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uc1swXSAmJiB0aGlzLnNlbGVjdGlvbi52YWx1ZTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zLm1hcCgodCkgPT4gdC52YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGpuKHMpIHtcbiAgcmV0dXJuIHMuZmlsdGVyKCh0KSA9PiAhdC5kaXNhYmxlZCkuZXZlcnkoKHQpID0+IHQuc2VsZWN0ZWQpO1xufVxuY29uc3QgUV8gPSBcImRhdGEtdGUtc2VsZWN0LWZvcm0tb3V0bGluZS1yZWZcIiwgWl8gPSBcImRhdGEtdGUtc2VsZWN0LXdyYXBwZXItcmVmXCIsIEpfID0gXCJkYXRhLXRlLXNlbGVjdC1pbnB1dC1yZWZcIiwgdG0gPSBcImRhdGEtdGUtc2VsZWN0LWNsZWFyLWJ0bi1yZWZcIiwgZW0gPSBcImRhdGEtdGUtc2VsZWN0LWRyb3Bkb3duLWNvbnRhaW5lci1yZWZcIiwgaW0gPSBcImRhdGEtdGUtc2VsZWN0LWRyb3Bkb3duLXJlZlwiLCBzbSA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy13cmFwcGVyLXJlZlwiLCBubSA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy1saXN0LXJlZlwiLCBvbSA9IFwiZGF0YS10ZS1zZWxlY3QtaW5wdXQtZmlsdGVyLXJlZlwiLCB4bCA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLXJlZlwiLCBybSA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWFsbC1yZWZcIiwgYW0gPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi10ZXh0LXJlZlwiLCBsbSA9IFwiZGF0YS10ZS1mb3JtLWNoZWNrLWlucHV0XCIsIGNtID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZ3JvdXAtcmVmXCIsIGRtID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZ3JvdXAtbGFiZWwtcmVmXCIsIFNsID0gXCJkYXRhLXRlLXNlbGVjdC1zZWxlY3RlZFwiLCBobSA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbjwvc3ZnPlxuYCwgdW0gPSAocykgPT4ge1xuICBzLmNvZGUgPT09IFwiVGFiXCIgfHwgcy5jb2RlID09PSBcIkVzY1wiIHx8IHMucHJldmVudERlZmF1bHQoKTtcbn07XG5mdW5jdGlvbiBlcyhzLCB0LCBlLCBpLCBuKSB7XG4gIHQuc2VsZWN0U2l6ZSA9PT0gXCJkZWZhdWx0XCIgJiYgcC5hZGRDbGFzcyhzLCBlKSwgdC5zZWxlY3RTaXplID09PSBcInNtXCIgJiYgcC5hZGRDbGFzcyhzLCBpKSwgdC5zZWxlY3RTaXplID09PSBcImxnXCIgJiYgcC5hZGRDbGFzcyhzLCBuKTtcbn1cbmZ1bmN0aW9uIHBtKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG4uc2V0QXR0cmlidXRlKFwiaWRcIiwgcyksIG4uc2V0QXR0cmlidXRlKFpfLCBcIlwiKTtcbiAgY29uc3QgbyA9IE0oXCJkaXZcIik7XG4gIG8uc2V0QXR0cmlidXRlKFFfLCBcIlwiKSwgcC5hZGRDbGFzcyhvLCBpLmZvcm1PdXRsaW5lKTtcbiAgY29uc3QgciA9IE0oXCJpbnB1dFwiKSwgYSA9IHQuc2VsZWN0RmlsdGVyID8gXCJjb21ib2JveFwiIDogXCJsaXN0Ym94XCIsIGwgPSB0Lm11bHRpcGxlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsIGMgPSB0LmRpc2FibGVkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gIHIuc2V0QXR0cmlidXRlKEpfLCBcIlwiKSwgcC5hZGRDbGFzcyhyLCBpLnNlbGVjdElucHV0KSwgZXMoXG4gICAgcixcbiAgICB0LFxuICAgIGkuc2VsZWN0SW5wdXRTaXplRGVmYXVsdCxcbiAgICBpLnNlbGVjdElucHV0U2l6ZVNtLFxuICAgIGkuc2VsZWN0SW5wdXRTaXplTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgcC5hZGRDbGFzcyhyLCBpLnNlbGVjdElucHV0V2hpdGUpLCByLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0XCIpLCByLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgYSksIHIuc2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIiwgbCksIHIuc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLCBjKSwgci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsIFwidHJ1ZVwiKSwgci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICExKSwgdC50YWJJbmRleCAmJiByLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIHQudGFiSW5kZXgpLCB0LmRpc2FibGVkICYmIHIuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIiksIHQuc2VsZWN0UGxhY2Vob2xkZXIgIT09IFwiXCIgJiYgci5zZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiLCB0LnNlbGVjdFBsYWNlaG9sZGVyKSwgdC5zZWxlY3RWYWxpZGF0aW9uID8gKHAuYWRkU3R5bGUociwge1xuICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCIsXG4gICAgXCJjYXJldC1jb2xvclwiOiBcInRyYW5zcGFyZW50XCJcbiAgfSksIHAuYWRkU3R5bGUobywgeyBjdXJzb3I6IFwicG9pbnRlclwiIH0pKSA6IHIuc2V0QXR0cmlidXRlKFwicmVhZG9ubHlcIiwgXCJ0cnVlXCIpLCB0LnNlbGVjdFZhbGlkYXRpb24gJiYgKHIuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgXCJ0cnVlXCIpLCByLnNldEF0dHJpYnV0ZShcImFyaWEtcmVxdWlyZWRcIiwgXCJ0cnVlXCIpLCByLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHVtKSk7XG4gIGNvbnN0IGQgPSBNKFwiZGl2XCIpO1xuICBwLmFkZENsYXNzKGQsIGkuc2VsZWN0VmFsaWRhdGlvblZhbGlkKTtcbiAgY29uc3QgXyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgIGAke3Quc2VsZWN0VmFsaWRGZWVkYmFja31gXG4gICk7XG4gIGQuYXBwZW5kQ2hpbGQoXyk7XG4gIGNvbnN0IGYgPSBNKFwiZGl2XCIpO1xuICBwLmFkZENsYXNzKGYsIGkuc2VsZWN0VmFsaWRhdGlvbkludmFsaWQpO1xuICBjb25zdCBtID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgYCR7dC5zZWxlY3RJbnZhbGlkRmVlZGJhY2t9YFxuICApO1xuICBmLmFwcGVuZENoaWxkKG0pO1xuICBjb25zdCBnID0gTShcInNwYW5cIik7XG4gIGcuc2V0QXR0cmlidXRlKHRtLCBcIlwiKSwgcC5hZGRDbGFzcyhnLCBpLnNlbGVjdENsZWFyQnRuKSwgZXMoXG4gICAgZyxcbiAgICB0LFxuICAgIGkuc2VsZWN0Q2xlYXJCdG5EZWZhdWx0LFxuICAgIGkuc2VsZWN0Q2xlYXJCdG5TbSxcbiAgICBpLnNlbGVjdENsZWFyQnRuTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgcC5hZGRDbGFzcyhnLCBpLnNlbGVjdENsZWFyQnRuV2hpdGUpO1xuICBjb25zdCBiID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCLinJVcIik7XG4gIGcuYXBwZW5kQ2hpbGQoYiksIGcuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICBjb25zdCBUID0gTShcInNwYW5cIik7XG4gIHJldHVybiBwLmFkZENsYXNzKFQsIGkuc2VsZWN0QXJyb3cpLCBlcyhcbiAgICBULFxuICAgIHQsXG4gICAgaS5zZWxlY3RBcnJvd0RlZmF1bHQsXG4gICAgaS5zZWxlY3RBcnJvd1NtLFxuICAgIGkuc2VsZWN0QXJyb3dMZ1xuICApLCB0LnNlbGVjdEZvcm1XaGl0ZSAmJiBwLmFkZENsYXNzKFQsIGkuc2VsZWN0QXJyb3dXaGl0ZSksIFQuaW5uZXJIVE1MID0gaG0sIG8uYXBwZW5kQ2hpbGQociksIGUgJiYgKHAuYWRkQ2xhc3MoZSwgaS5zZWxlY3RMYWJlbCksIGVzKFxuICAgIGUsXG4gICAgdCxcbiAgICBpLnNlbGVjdExhYmVsU2l6ZURlZmF1bHQsXG4gICAgaS5zZWxlY3RMYWJlbFNpemVTbSxcbiAgICBpLnNlbGVjdExhYmVsU2l6ZUxnXG4gICksIHQuc2VsZWN0Rm9ybVdoaXRlICYmIHAuYWRkQ2xhc3MoZSwgaS5zZWxlY3RMYWJlbFdoaXRlKSwgby5hcHBlbmRDaGlsZChlKSksIHQuc2VsZWN0VmFsaWRhdGlvbiAmJiAoby5hcHBlbmRDaGlsZChkKSwgby5hcHBlbmRDaGlsZChmKSksIHQuc2VsZWN0Q2xlYXJCdXR0b24gJiYgby5hcHBlbmRDaGlsZChnKSwgby5hcHBlbmRDaGlsZChUKSwgbi5hcHBlbmRDaGlsZChvKSwgbjtcbn1cbmZ1bmN0aW9uIG5hKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEpIHtcbiAgY29uc3QgbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGwuc2V0QXR0cmlidXRlKGVtLCBcIlwiKSwgcC5hZGRDbGFzcyhsLCBhLnNlbGVjdERyb3Bkb3duQ29udGFpbmVyKSwgbC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtzfWApLCBsLnN0eWxlLndpZHRoID0gYCR7ZX1weGA7XG4gIGNvbnN0IGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIDApLCBjLnNldEF0dHJpYnV0ZShpbSwgXCJcIiksIHAuYWRkQ2xhc3MoYywgYS5kcm9wZG93bik7XG4gIGNvbnN0IGQgPSBNKFwiZGl2XCIpO1xuICBkLnNldEF0dHJpYnV0ZShzbSwgXCJcIiksIHAuYWRkQ2xhc3MoZCwgYS5vcHRpb25zV3JhcHBlciksIHAuYWRkQ2xhc3MoZCwgYS5vcHRpb25zV3JhcHBlclNjcm9sbGJhciksIGQuc3R5bGUubWF4SGVpZ2h0ID0gYCR7aX1weGA7XG4gIGNvbnN0IF8gPSBEbChcbiAgICBvLFxuICAgIG4sXG4gICAgdCxcbiAgICBhXG4gICk7XG4gIHJldHVybiBkLmFwcGVuZENoaWxkKF8pLCB0LnNlbGVjdEZpbHRlciAmJiBjLmFwcGVuZENoaWxkKFxuICAgIGZtKHQuc2VsZWN0U2VhcmNoUGxhY2Vob2xkZXIsIGEpXG4gICksIGMuYXBwZW5kQ2hpbGQoZCksIHIgJiYgYy5hcHBlbmRDaGlsZChyKSwgbC5hcHBlbmRDaGlsZChjKSwgbDtcbn1cbmZ1bmN0aW9uIERsKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IE0oXCJkaXZcIik7XG4gIG4uc2V0QXR0cmlidXRlKG5tLCBcIlwiKSwgcC5hZGRDbGFzcyhuLCBpLm9wdGlvbnNMaXN0KTtcbiAgbGV0IG87XG4gIHJldHVybiBlLm11bHRpcGxlID8gbyA9IG1tKFxuICAgIHMsXG4gICAgdCxcbiAgICBlLFxuICAgIGlcbiAgKSA6IG8gPSBfbShzLCBlLCBpKSwgby5mb3JFYWNoKChyKSA9PiB7XG4gICAgbi5hcHBlbmRDaGlsZChyKTtcbiAgfSksIG47XG59XG5mdW5jdGlvbiBmbShzLCB0KSB7XG4gIGNvbnN0IGUgPSBNKFwiZGl2XCIpO1xuICBwLmFkZENsYXNzKGUsIHQuaW5wdXRHcm91cCk7XG4gIGNvbnN0IGkgPSBNKFwiaW5wdXRcIik7XG4gIHJldHVybiBpLnNldEF0dHJpYnV0ZShvbSwgXCJcIiksIHAuYWRkQ2xhc3MoaSwgdC5zZWxlY3RGaWx0ZXJJbnB1dCksIGkucGxhY2Vob2xkZXIgPSBzLCBpLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzZWFyY2hib3hcIiksIGkuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHRcIiksIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG59XG5mdW5jdGlvbiBfbShzLCB0LCBlKSB7XG4gIHJldHVybiBJbChzLCB0LCBlKTtcbn1cbmZ1bmN0aW9uIG1tKHMsIHQsIGUsIGkpIHtcbiAgbGV0IG4gPSBudWxsO1xuICBlLnNlbGVjdEFsbCAmJiAobiA9IGdtKFxuICAgIHQsXG4gICAgcyxcbiAgICBlLFxuICAgIGlcbiAgKSk7XG4gIGNvbnN0IG8gPSBJbChzLCBlLCBpKTtcbiAgcmV0dXJuIG4gPyBbbiwgLi4ub10gOiBvO1xufVxuZnVuY3Rpb24gSWwocywgdCwgZSkge1xuICBjb25zdCBpID0gW107XG4gIHJldHVybiBzLmZvckVhY2goKG4pID0+IHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgbixcbiAgICAgIFwib3B0aW9uc1wiXG4gICAgKSkge1xuICAgICAgY29uc3QgciA9IFRtKG4sIHQsIGUpO1xuICAgICAgaS5wdXNoKHIpO1xuICAgIH0gZWxzZVxuICAgICAgaS5wdXNoKCRsKG4sIHQsIGUpKTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiBnbShzLCB0LCBlLCBpKSB7XG4gIGNvbnN0IG4gPSBqbih0KSwgbyA9IE0oXCJkaXZcIik7XG4gIHJldHVybiBvLnNldEF0dHJpYnV0ZSh4bCwgXCJcIiksIHAuYWRkQ2xhc3MobywgaS5zZWxlY3RPcHRpb24pLCBvLnNldEF0dHJpYnV0ZShybSwgXCJcIiksIHAuYWRkU3R5bGUobywge1xuICAgIGhlaWdodDogYCR7ZS5zZWxlY3RPcHRpb25IZWlnaHR9cHhgXG4gIH0pLCBvLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIiksIG8uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBuKSwgbiAmJiBvLnNldEF0dHJpYnV0ZShTbCwgXCJcIiksIG8uYXBwZW5kQ2hpbGQoTGwocywgZSwgaSkpLCBzLnNldE5vZGUobyksIG87XG59XG5mdW5jdGlvbiAkbChzLCB0LCBlKSB7XG4gIGlmIChzLm5vZGUpXG4gICAgcmV0dXJuIHMubm9kZTtcbiAgY29uc3QgaSA9IE0oXCJkaXZcIik7XG4gIHJldHVybiBpLnNldEF0dHJpYnV0ZSh4bCwgXCJcIiksIHAuYWRkQ2xhc3MoaSwgZS5zZWxlY3RPcHRpb24pLCBwLmFkZFN0eWxlKGksIHtcbiAgICBoZWlnaHQ6IGAke3Quc2VsZWN0T3B0aW9uSGVpZ2h0fXB4YFxuICB9KSwgcC5zZXREYXRhQXR0cmlidXRlKGksIFwiaWRcIiwgcy5pZCksIGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIHMuc2VsZWN0ZWQpLCBpLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgcy5kaXNhYmxlZCksIHMuc2VsZWN0ZWQgJiYgaS5zZXRBdHRyaWJ1dGUoU2wsIFwiXCIpLCBzLmRpc2FibGVkICYmIGkuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXCIsICEwKSwgcy5oaWRkZW4gJiYgcC5hZGRDbGFzcyhpLCBcImhpZGRlblwiKSwgaS5hcHBlbmRDaGlsZChMbChzLCB0LCBlKSksIHMuaWNvbiAmJiBpLmFwcGVuZENoaWxkKEVtKHMsIGUpKSwgcy5zZXROb2RlKGkpLCBpO1xufVxuZnVuY3Rpb24gTGwocywgdCwgZSkge1xuICBjb25zdCBpID0gTShcInNwYW5cIik7XG4gIGkuc2V0QXR0cmlidXRlKGFtLCBcIlwiKSwgcC5hZGRDbGFzcyhpLCBlLnNlbGVjdE9wdGlvblRleHQpO1xuICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocy5sYWJlbCk7XG4gIHJldHVybiB0Lm11bHRpcGxlICYmIGkuYXBwZW5kQ2hpbGQodm0ocywgZSkpLCBpLmFwcGVuZENoaWxkKG4pLCAocy5zZWNvbmRhcnlUZXh0IHx8IHR5cGVvZiBzLnNlY29uZGFyeVRleHQgPT0gXCJudW1iZXJcIikgJiYgaS5hcHBlbmRDaGlsZChcbiAgICBibShzLnNlY29uZGFyeVRleHQsIGUpXG4gICksIGk7XG59XG5mdW5jdGlvbiBibShzLCB0KSB7XG4gIGNvbnN0IGUgPSBNKFwic3BhblwiKTtcbiAgcC5hZGRDbGFzcyhlLCB0LnNlbGVjdE9wdGlvblNlY29uZGFyeVRleHQpO1xuICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocyk7XG4gIHJldHVybiBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gdm0ocywgdCkge1xuICBjb25zdCBlID0gTShcImlucHV0XCIpO1xuICBlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJjaGVja2JveFwiKSwgcC5hZGRDbGFzcyhlLCB0LmZvcm1DaGVja0lucHV0KSwgZS5zZXRBdHRyaWJ1dGUobG0sIFwiXCIpO1xuICBjb25zdCBpID0gTShcImxhYmVsXCIpO1xuICByZXR1cm4gcy5zZWxlY3RlZCAmJiBlLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgITApLCBzLmRpc2FibGVkICYmIGUuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgITApLCBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gRW0ocywgdCkge1xuICBjb25zdCBlID0gTShcInNwYW5cIiksIGkgPSBNKFwiaW1nXCIpO1xuICByZXR1cm4gcC5hZGRDbGFzcyhpLCB0LnNlbGVjdE9wdGlvbkljb24pLCBpLnNyYyA9IHMuaWNvbiwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbn1cbmZ1bmN0aW9uIFRtKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IE0oXCJkaXZcIik7XG4gIGkuc2V0QXR0cmlidXRlKGNtLCBcIlwiKSwgcC5hZGRDbGFzcyhpLCBlLnNlbGVjdE9wdGlvbkdyb3VwKSwgaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZ3JvdXBcIiksIGkuc2V0QXR0cmlidXRlKFwiaWRcIiwgcy5pZCksIHMuaGlkZGVuICYmIHAuYWRkQ2xhc3MoaSwgXCJoaWRkZW5cIik7XG4gIGNvbnN0IG4gPSBNKFwibGFiZWxcIik7XG4gIHJldHVybiBuLnNldEF0dHJpYnV0ZShkbSwgXCJcIiksIHAuYWRkQ2xhc3MobiwgZS5zZWxlY3RPcHRpb25Hcm91cExhYmVsKSwgcC5hZGRTdHlsZShuLCB7IGhlaWdodDogYCR7dC5zZWxlY3RPcHRpb25IZWlnaHR9cHhgIH0pLCBuLnNldEF0dHJpYnV0ZShcImZvclwiLCBzLmlkKSwgbi50ZXh0Q29udGVudCA9IHMubGFiZWwsIGkuYXBwZW5kQ2hpbGQobiksIHMub3B0aW9ucy5mb3JFYWNoKChvKSA9PiB7XG4gICAgaS5hcHBlbmRDaGlsZCgkbChvLCB0LCBlKSk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gQ20ocywgdCkge1xuICBjb25zdCBlID0gTShcImRpdlwiKTtcbiAgcmV0dXJuIGUuaW5uZXJIVE1MID0gcywgcC5hZGRDbGFzcyhlLCB0LnNlbGVjdExhYmVsKSwgcC5hZGRDbGFzcyhlLCB0LnNlbGVjdEZha2VWYWx1ZSksIGU7XG59XG5jb25zdCB5biA9IFwic2VsZWN0XCIsIHJpID0gXCJ0ZS5zZWxlY3RcIiwgQWkgPSBgLiR7cml9YCwgQW0gPSBgY2xvc2Uke0FpfWAsIHltID0gYG9wZW4ke0FpfWAsIG9hID0gYG9wdGlvblNlbGVjdCR7QWl9YCwgcmEgPSBgb3B0aW9uRGVzZWxlY3Qke0FpfWAsIHdtID0gYHZhbHVlQ2hhbmdlJHtBaX1gLCBrbSA9IFwiY2hhbmdlXCIsIGFhID0gXCJkYXRhLXRlLXNlbGVjdC1pbml0XCIsIE1sID0gXCJkYXRhLXRlLXNlbGVjdC1uby1yZXN1bHRzLXJlZlwiLCBsYSA9IFwiZGF0YS10ZS1zZWxlY3Qtb3BlblwiLCBxID0gXCJkYXRhLXRlLWlucHV0LXN0YXRlLWFjdGl2ZVwiLCBXdCA9IFwiZGF0YS10ZS1pbnB1dC1mb2N1c2VkXCIsIHduID0gXCJkYXRhLXRlLWlucHV0LWRpc2FibGVkXCIsIE9tID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZ3JvdXAtbGFiZWwtcmVmXCIsIHhtID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tYWxsLXJlZlwiLCBlaSA9IFwiZGF0YS10ZS1zZWxlY3Qtc2VsZWN0ZWRcIiwgU20gPSBcIltkYXRhLXRlLXNlbGVjdC1sYWJlbC1yZWZdXCIsIGNhID0gXCJbZGF0YS10ZS1zZWxlY3QtaW5wdXQtcmVmXVwiLCBEbSA9IFwiW2RhdGEtdGUtc2VsZWN0LWlucHV0LWZpbHRlci1yZWZdXCIsIEltID0gXCJbZGF0YS10ZS1zZWxlY3QtZHJvcGRvd24tcmVmXVwiLCAkbSA9IFwiW2RhdGEtdGUtc2VsZWN0LW9wdGlvbnMtd3JhcHBlci1yZWZdXCIsIGRhID0gXCJbZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy1saXN0LXJlZl1cIiwgTG0gPSBcIltkYXRhLXRlLXNlbGVjdC1vcHRpb24tcmVmXVwiLCBNbSA9IFwiW2RhdGEtdGUtc2VsZWN0LWNsZWFyLWJ0bi1yZWZdXCIsIE5tID0gXCJbZGF0YS10ZS1zZWxlY3QtY3VzdG9tLWNvbnRlbnQtcmVmXVwiLCBSbSA9IGBbJHtNbH1dYCwgaGEgPSBcIltkYXRhLXRlLXNlbGVjdC1mb3JtLW91dGxpbmUtcmVmXVwiLCBQbSA9IFwiW2RhdGEtdGUtc2VsZWN0LXRvZ2dsZV1cIiwga24gPSBcIltkYXRhLXRlLWlucHV0LW5vdGNoLXJlZl1cIiwgSG0gPSAyMDAsIEJtID0ge1xuICBzZWxlY3RBdXRvU2VsZWN0OiAhMSxcbiAgc2VsZWN0Q29udGFpbmVyOiBcImJvZHlcIixcbiAgc2VsZWN0Q2xlYXJCdXR0b246ICExLFxuICBkaXNhYmxlZDogITEsXG4gIHNlbGVjdERpc3BsYXllZExhYmVsczogNSxcbiAgc2VsZWN0Rm9ybVdoaXRlOiAhMSxcbiAgbXVsdGlwbGU6ICExLFxuICBzZWxlY3RPcHRpb25zU2VsZWN0ZWRMYWJlbDogXCJvcHRpb25zIHNlbGVjdGVkXCIsXG4gIHNlbGVjdE9wdGlvbkhlaWdodDogMzgsXG4gIHNlbGVjdEFsbDogITAsXG4gIHNlbGVjdEFsbExhYmVsOiBcIlNlbGVjdCBhbGxcIixcbiAgc2VsZWN0U2VhcmNoUGxhY2Vob2xkZXI6IFwiU2VhcmNoLi4uXCIsXG4gIHNlbGVjdFNpemU6IFwiZGVmYXVsdFwiLFxuICBzZWxlY3RWaXNpYmxlT3B0aW9uczogNSxcbiAgc2VsZWN0RmlsdGVyOiAhMSxcbiAgc2VsZWN0RmlsdGVyRGVib3VuY2U6IDMwMCxcbiAgc2VsZWN0Tm9SZXN1bHRUZXh0OiBcIk5vIHJlc3VsdHNcIixcbiAgc2VsZWN0VmFsaWRhdGlvbjogITEsXG4gIHNlbGVjdFZhbGlkRmVlZGJhY2s6IFwiVmFsaWRcIixcbiAgc2VsZWN0SW52YWxpZEZlZWRiYWNrOiBcIkludmFsaWRcIixcbiAgc2VsZWN0UGxhY2Vob2xkZXI6IFwiXCJcbn0sIFZtID0ge1xuICBzZWxlY3RBdXRvU2VsZWN0OiBcImJvb2xlYW5cIixcbiAgc2VsZWN0Q29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBzZWxlY3RDbGVhckJ1dHRvbjogXCJib29sZWFuXCIsXG4gIGRpc2FibGVkOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0RGlzcGxheWVkTGFiZWxzOiBcIm51bWJlclwiLFxuICBzZWxlY3RGb3JtV2hpdGU6IFwiYm9vbGVhblwiLFxuICBtdWx0aXBsZTogXCJib29sZWFuXCIsXG4gIHNlbGVjdE9wdGlvbnNTZWxlY3RlZExhYmVsOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25IZWlnaHQ6IFwibnVtYmVyXCIsXG4gIHNlbGVjdEFsbDogXCJib29sZWFuXCIsXG4gIHNlbGVjdEFsbExhYmVsOiBcInN0cmluZ1wiLFxuICBzZWxlY3RTZWFyY2hQbGFjZWhvbGRlcjogXCJzdHJpbmdcIixcbiAgc2VsZWN0U2l6ZTogXCJzdHJpbmdcIixcbiAgc2VsZWN0VmlzaWJsZU9wdGlvbnM6IFwibnVtYmVyXCIsXG4gIHNlbGVjdEZpbHRlcjogXCJib29sZWFuXCIsXG4gIHNlbGVjdEZpbHRlckRlYm91bmNlOiBcIm51bWJlclwiLFxuICBzZWxlY3ROb1Jlc3VsdFRleHQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFZhbGlkYXRpb246IFwiYm9vbGVhblwiLFxuICBzZWxlY3RWYWxpZEZlZWRiYWNrOiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnZhbGlkRmVlZGJhY2s6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFBsYWNlaG9sZGVyOiBcInN0cmluZ1wiXG59LCBXbSA9IHtcbiAgZHJvcGRvd246IFwicmVsYXRpdmUgb3V0bGluZS1ub25lIG1pbi13LVsxMDBweF0gbS0wIHNjYWxlLVswLjhdIG9wYWNpdHktMCBiZy13aGl0ZSBzaGFkb3ctWzBfMnB4XzVweF8wX3JnYmEoMCwwLDAsMC4xNiksXzBfMnB4XzEwcHhfMF9yZ2JhKDAsMCwwLDAuMTIpXSB0cmFuc2l0aW9uIGR1cmF0aW9uLTIwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXRhLVt0ZS1zZWxlY3Qtb3Blbl06c2NhbGUtMTAwIGRhdGEtW3RlLXNlbGVjdC1vcGVuXTpvcGFjaXR5LTEwMCBkYXJrOmJnLXppbmMtNzAwXCIsXG4gIGZvcm1DaGVja0lucHV0OiBcInJlbGF0aXZlIGZsb2F0LWxlZnQgbXQtWzAuMTVyZW1dIG1yLVs4cHhdIGgtWzEuMTI1cmVtXSB3LVsxLjEyNXJlbV0gYXBwZWFyYW5jZS1ub25lIHJvdW5kZWQtWzAuMjVyZW1dIGJvcmRlci1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgb3V0bGluZS1ub25lIGJlZm9yZTpwb2ludGVyLWV2ZW50cy1ub25lIGJlZm9yZTphYnNvbHV0ZSBiZWZvcmU6aC1bMC44NzVyZW1dIGJlZm9yZTp3LVswLjg3NXJlbV0gYmVmb3JlOnNjYWxlLTAgYmVmb3JlOnJvdW5kZWQtZnVsbCBiZWZvcmU6YmctdHJhbnNwYXJlbnQgYmVmb3JlOm9wYWNpdHktMCBiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3RyYW5zcGFyZW50XSBiZWZvcmU6Y29udGVudC1bJyddIGNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgZGFyazpjaGVja2VkOmJvcmRlci1wcmltYXJ5IGNoZWNrZWQ6YmctcHJpbWFyeSBkYXJrOmNoZWNrZWQ6YmctcHJpbWFyeSBjaGVja2VkOmJlZm9yZTpvcGFjaXR5LVswLjE2XSBjaGVja2VkOmFmdGVyOmFic29sdXRlIGNoZWNrZWQ6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6YWZ0ZXI6YmxvY2sgY2hlY2tlZDphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmFmdGVyOmJnLXRyYW5zcGFyZW50IGNoZWNrZWQ6YWZ0ZXI6Y29udGVudC1bJyddIGhvdmVyOmN1cnNvci1wb2ludGVyIGhvdmVyOmJlZm9yZTpvcGFjaXR5LVswLjA0XSBob3ZlcjpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZm9jdXM6c2hhZG93LW5vbmUgZm9jdXM6dHJhbnNpdGlvbi1bYm9yZGVyLWNvbG9yXzAuMnNdIGZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgZm9jdXM6YmVmb3JlOm9wYWNpdHktWzAuMTJdIGZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBkYXJrOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgyNTUsMjU1LDI1NSwwLjQpXSBmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBmb2N1czphZnRlcjphYnNvbHV0ZSBmb2N1czphZnRlcjp6LVsxXSBmb2N1czphZnRlcjpibG9jayBmb2N1czphZnRlcjpoLVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6dy1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnJvdW5kZWQtWzAuMTI1cmVtXSBmb2N1czphZnRlcjpjb250ZW50LVsnJ10gY2hlY2tlZDpmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBkYXJrOmNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBjaGVja2VkOmZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdW5kZWQtbm9uZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDpmb2N1czphZnRlcjpiZy10cmFuc3BhcmVudFwiLFxuICBmb3JtT3V0bGluZTogXCJyZWxhdGl2ZVwiLFxuICBpbml0aWFsaXplZDogXCJoaWRkZW5cIixcbiAgaW5wdXRHcm91cDogXCJmbGV4IGl0ZW1zLWNlbnRlciB3aGl0ZXNwYWNlLW5vd3JhcCBwLTIuNSB0ZXh0LWNlbnRlciB0ZXh0LWJhc2UgZm9udC1ub3JtYWwgbGVhZGluZy1bMS42XSB0ZXh0LWdyYXktNzAwIGRhcms6YmctemluYy04MDAgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGxhY2Vob2xkZXI6dGV4dC1ncmF5LTIwMFwiLFxuICBub1Jlc3VsdDogXCJmbGV4IGl0ZW1zLWNlbnRlciBweC00XCIsXG4gIG9wdGlvbnNMaXN0OiBcImxpc3Qtbm9uZSBtLTAgcC0wXCIsXG4gIG9wdGlvbnNXcmFwcGVyOiBcIm92ZXJmbG93LXktYXV0b1wiLFxuICBvcHRpb25zV3JhcHBlclNjcm9sbGJhcjogXCJbJjo6LXdlYmtpdC1zY3JvbGxiYXJdOnctMSBbJjo6LXdlYmtpdC1zY3JvbGxiYXJdOmgtMSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXTpibG9jayBbJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXTpoLTAgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbl06YmctdHJhbnNwYXJlbnQgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTpiZy10cmFuc3BhcmVudCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOnJvdW5kZWQtbm9uZSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOiBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOnJvdW5kZWQtbCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJdOmgtWzUwcHhdIFsmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYl06YmctWyM5OTldIFsmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYl06cm91bmRlZFwiLFxuICBzZWxlY3RBcnJvdzogXCJhYnNvbHV0ZSByaWdodC0zIHRleHQtWzAuOHJlbV0gY3Vyc29yLXBvaW50ZXIgcGVlci1mb2N1czp0ZXh0LXByaW1hcnkgcGVlci1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTp0ZXh0LXByaW1hcnkgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLXZhbGlkOnRleHQtZ3JlZW4tNjAwIGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246cGVlci1pbnZhbGlkOnRleHQtW3JnYigyMjAsNzYsMTAwKV0gdy01IGgtNVwiLFxuICBzZWxlY3RBcnJvd1doaXRlOiBcInRleHQtZ3JheS01MCBwZWVyLWZvY3VzOiF0ZXh0LXdoaXRlIHBlZXItZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06IXRleHQtd2hpdGVcIixcbiAgc2VsZWN0QXJyb3dEZWZhdWx0OiBcInRvcC0yXCIsXG4gIHNlbGVjdEFycm93TGc6IFwidG9wLVsxM3B4XVwiLFxuICBzZWxlY3RBcnJvd1NtOiBcInRvcC0xXCIsXG4gIHNlbGVjdENsZWFyQnRuOiBcImFic29sdXRlIHRvcC0yIHJpZ2h0LTkgdGV4dC1ibGFjayBjdXJzb3ItcG9pbnRlciBmb2N1czp0ZXh0LXByaW1hcnkgb3V0bGluZS1ub25lIGRhcms6dGV4dC1ncmF5LTIwMFwiLFxuICBzZWxlY3RDbGVhckJ0bldoaXRlOiBcIiF0ZXh0LWdyYXktNTBcIixcbiAgc2VsZWN0Q2xlYXJCdG5EZWZhdWx0OiBcInRvcC0yIHRleHQtYmFzZVwiLFxuICBzZWxlY3RDbGVhckJ0bkxnOiBcInRvcC1bMTFweF0gdGV4dC1iYXNlXCIsXG4gIHNlbGVjdENsZWFyQnRuU206IFwidG9wLTEgdGV4dC1bMC44cmVtXVwiLFxuICBzZWxlY3REcm9wZG93bkNvbnRhaW5lcjogXCJ6LVsxMDcwXVwiLFxuICBzZWxlY3RGYWtlVmFsdWU6IFwidHJhbnNmb3JtLW5vbmUgaGlkZGVuIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06YmxvY2tcIixcbiAgc2VsZWN0RmlsdGVySW5wdXQ6IFwicmVsYXRpdmUgbS0wIGJsb2NrIHctZnVsbCBtaW4tdy0wIGZsZXgtYXV0byByb3VuZGVkIGJvcmRlciBib3JkZXItc29saWQgYm9yZGVyLWdyYXktMzAwIGJnLXRyYW5zcGFyZW50IGJnLWNsaXAtcGFkZGluZyBweC0zIHB5LTEuNSB0ZXh0LWJhc2UgZm9udC1ub3JtYWwgdGV4dC1ncmF5LTcwMCB0cmFuc2l0aW9uIGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBmb2N1czpib3JkZXItcHJpbWFyeSBmb2N1czp0ZXh0LWdyYXktNzAwIGZvY3VzOnNoYWRvdy10ZS1wcmltYXJ5IGZvY3VzOm91dGxpbmUtbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwXCIsXG4gIHNlbGVjdElucHV0OiBcInBlZXIgYmxvY2sgbWluLWgtW2F1dG9dIHctZnVsbCByb3VuZGVkIGJvcmRlci0wIGJnLXRyYW5zcGFyZW50IG91dGxpbmUtbm9uZSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgZm9jdXM6cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwIFsmOm5vdChbZGF0YS10ZS1pbnB1dC1wbGFjZWhvbGRlci1hY3RpdmVdKV06cGxhY2Vob2xkZXI6b3BhY2l0eS0wIGN1cnNvci1wb2ludGVyIGRhdGEtW3RlLWlucHV0LWRpc2FibGVkXTpiZy1bI2U5ZWNlZl0gZGF0YS1bdGUtaW5wdXQtZGlzYWJsZWRdOmN1cnNvci1kZWZhdWx0IGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246bWItNCBkYXJrOmRhdGEtW3RlLWlucHV0LWRpc2FibGVkXTpiZy16aW5jLTYwMFwiLFxuICBzZWxlY3RJbnB1dFdoaXRlOiBcIiF0ZXh0LWdyYXktNTBcIixcbiAgc2VsZWN0SW5wdXRTaXplRGVmYXVsdDogXCJweS1bMC4zMnJlbV0gcHgtMyBsZWFkaW5nLVsxLjZdXCIsXG4gIHNlbGVjdElucHV0U2l6ZUxnOiBcInB5LVswLjMycmVtXSBweC0zIGxlYWRpbmctWzIuMTVdXCIsXG4gIHNlbGVjdElucHV0U2l6ZVNtOiBcInB5LVswLjMzcmVtXSBweC0zIHRleHQteHMgbGVhZGluZy1bMS41XVwiLFxuICBzZWxlY3RMYWJlbDogXCJwb2ludGVyLWV2ZW50cy1ub25lIGFic29sdXRlIHRvcC0wIGxlZnQtMyBtYi0wIG1heC13LVs5MCVdIG9yaWdpbi1bMF8wXSB0cnVuY2F0ZSB0ZXh0LWdyYXktNTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLW91dCBwZWVyLWZvY3VzOnNjYWxlLVswLjhdIHBlZXItZm9jdXM6dGV4dC1wcmltYXJ5IHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwZWVyLWZvY3VzOnRleHQtZ3JheS0yMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBkYXJrOnBlZXItZm9jdXM6dGV4dC1wcmltYXJ5XCIsXG4gIHNlbGVjdExhYmVsV2hpdGU6IFwiIXRleHQtZ3JheS01MFwiLFxuICBzZWxlY3RMYWJlbFNpemVEZWZhdWx0OiBcInB0LVswLjM3cmVtXSBsZWFkaW5nLVsxLjZdIHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVswLjlyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuOXJlbV0gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuOXJlbV1cIixcbiAgc2VsZWN0TGFiZWxTaXplTGc6IFwicHQtWzAuMzdyZW1dIGxlYWRpbmctWzIuMTVdIHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVsxLjE1cmVtXSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVsxLjE1cmVtXSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMS4xNXJlbV1cIixcbiAgc2VsZWN0TGFiZWxTaXplU206IFwicHQtWzAuMzdyZW1dIHRleHQteHMgbGVhZGluZy1bMS41XSBwZWVyLWZvY3VzOi10cmFuc2xhdGUteS1bMC43NXJlbV0gcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC43NXJlbV0gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuNzVyZW1dXCIsXG4gIHNlbGVjdE9wdGlvbjogXCJmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gdy1mdWxsIHB4LTQgdHJ1bmNhdGUgdGV4dC1ncmF5LTcwMCBiZy10cmFuc3BhcmVudCBzZWxlY3Qtbm9uZSBjdXJzb3ItcG9pbnRlciBkYXRhLVt0ZS1pbnB1dC1tdWx0aXBsZS1hY3RpdmVdOmJnLWJsYWNrLzUgaG92ZXI6WyY6bm90KFtkYXRhLXRlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdKV06YmctYmxhY2svNSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJnLWJsYWNrLzUgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1zZWxlY3RlZF06ZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy1ibGFjay81IGRhdGEtW3RlLXNlbGVjdC1zZWxlY3RlZF06ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZGF0YS1bdGUtc2VsZWN0LXNlbGVjdGVkXTpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTp0ZXh0LWdyYXktNDAwIGRhdGEtW3RlLXNlbGVjdC1zZWxlY3RlZF06ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06YmctdHJhbnNwYXJlbnQgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1zZWxlY3RlZF06YmctYmxhY2svWzAuMDJdIGRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOnRleHQtZ3JheS00MDAgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZ3JvdXAtZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1yZWZdL29wdDpwbC03IGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOmhvdmVyOlsmOm5vdChbZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXSldOmJnLXdoaXRlLzMwIGRhcms6ZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy13aGl0ZS8zMCBkYXJrOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tc2VsZWN0ZWRdOmRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ymctd2hpdGUvMzAgZGFyazpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTp0ZXh0LWdyYXktNDAwIGRhcms6ZGF0YS1bdGUtaW5wdXQtbXVsdGlwbGUtYWN0aXZlXTpiZy13aGl0ZS8zMFwiLFxuICBzZWxlY3RPcHRpb25Hcm91cDogXCJncm91cC9vcHRcIixcbiAgc2VsZWN0T3B0aW9uR3JvdXBMYWJlbDogXCJmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciB3LWZ1bGwgcHgtNCB0cnVuY2F0ZSBiZy10cmFuc3BhcmVudCB0ZXh0LWJsYWNrLzUwIHNlbGVjdC1ub25lIGRhcms6dGV4dC1ncmF5LTMwMFwiLFxuICBzZWxlY3RPcHRpb25JY29uOiBcInctNyBoLTcgcm91bmRlZC1mdWxsXCIsXG4gIHNlbGVjdE9wdGlvblNlY29uZGFyeVRleHQ6IFwiYmxvY2sgdGV4dC1bMC44cmVtXSB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC1ncmF5LTMwMFwiLFxuICBzZWxlY3RPcHRpb25UZXh0OiBcImdyb3VwXCIsXG4gIHNlbGVjdFZhbGlkYXRpb25WYWxpZDogXCJoaWRkZW4gYWJzb2x1dGUgLW10LTMgdy1hdXRvIHRleHQtc20gdGV4dC1ncmVlbi02MDAgY3Vyc29yLXBvaW50ZXIgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLXZhbGlkOmJsb2NrXCIsXG4gIHNlbGVjdFZhbGlkYXRpb25JbnZhbGlkOiBcImhpZGRlbiBhYnNvbHV0ZSAtbXQtMyB3LWF1dG8gdGV4dC1zbSB0ZXh0LVtyZ2IoMjIwLDc2LDEwMCldIGN1cnNvci1wb2ludGVyIGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246cGVlci1pbnZhbGlkOmJsb2NrXCJcbn0sIEZtID0ge1xuICBkcm9wZG93bjogXCJzdHJpbmdcIixcbiAgZm9ybUNoZWNrSW5wdXQ6IFwic3RyaW5nXCIsXG4gIGZvcm1PdXRsaW5lOiBcInN0cmluZ1wiLFxuICBpbml0aWFsaXplZDogXCJzdHJpbmdcIixcbiAgaW5wdXRHcm91cDogXCJzdHJpbmdcIixcbiAgbm9SZXN1bHQ6IFwic3RyaW5nXCIsXG4gIG9wdGlvbnNMaXN0OiBcInN0cmluZ1wiLFxuICBvcHRpb25zV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgb3B0aW9uc1dyYXBwZXJTY3JvbGxiYXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEFycm93OiBcInN0cmluZ1wiLFxuICBzZWxlY3RBcnJvd0RlZmF1bHQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEFycm93TGc6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEFycm93U206IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnRuOiBcInN0cmluZ1wiLFxuICBzZWxlY3RDbGVhckJ0bkRlZmF1bHQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnRuTGc6IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnRuU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdERyb3Bkb3duQ29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBzZWxlY3RGYWtlVmFsdWU6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEZpbHRlcklucHV0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dDogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW5wdXRTaXplRGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW5wdXRTaXplTGc6IFwic3RyaW5nXCIsXG4gIHNlbGVjdElucHV0U2l6ZVNtOiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbDogXCJzdHJpbmdcIixcbiAgc2VsZWN0TGFiZWxTaXplRGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0TGFiZWxTaXplTGc6IFwic3RyaW5nXCIsXG4gIHNlbGVjdExhYmVsU2l6ZVNtOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb246IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbkdyb3VwOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25Hcm91cExhYmVsOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25JY29uOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25TZWNvbmRhcnlUZXh0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25UZXh0OiBcInN0cmluZ1wiXG59O1xuY2xhc3MgTmwge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX29wdGlvbnNUb1JlbmRlciA9IHRoaXMuX2dldE9wdGlvbnNUb1JlbmRlcih0KSwgdGhpcy5fcGxhaW5PcHRpb25zID0gdGhpcy5fZ2V0UGxhaW5PcHRpb25zKHRoaXMuX29wdGlvbnNUb1JlbmRlciksIHRoaXMuX2ZpbHRlcmVkT3B0aW9uc0xpc3QgPSBudWxsLCB0aGlzLl9zZWxlY3Rpb25Nb2RlbCA9IG5ldyBxXyh0aGlzLm11bHRpcGxlKSwgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPSAtMSwgdGhpcy5fYWN0aXZlT3B0aW9uID0gbnVsbCwgdGhpcy5fd3JhcHBlcklkID0gT3QoXCJzZWxlY3Qtd3JhcHBlci1cIiksIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVySWQgPSBPdChcInNlbGVjdC1kcm9wZG93bi1jb250YWluZXItXCIpLCB0aGlzLl9zZWxlY3RBbGxJZCA9IE90KFwic2VsZWN0LWFsbC1cIiksIHRoaXMuX2RlYm91bmNlVGltZW91dElkID0gbnVsbCwgdGhpcy5fZHJvcGRvd25IZWlnaHQgPSB0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uSGVpZ2h0ICogdGhpcy5fY29uZmlnLnNlbGVjdFZpc2libGVPcHRpb25zLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9pbnB1dCA9IG51bGwsIHRoaXMuX2xhYmVsID0gaC5uZXh0KHRoaXMuX2VsZW1lbnQsIFNtKVswXSwgdGhpcy5fbm90Y2ggPSBudWxsLCB0aGlzLl9mYWtlVmFsdWUgPSBudWxsLCB0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA9ICExLCB0aGlzLl9jdXN0b21Db250ZW50ID0gaC5uZXh0KFxuICAgICAgdCxcbiAgICAgIE5tXG4gICAgKVswXSwgdGhpcy5fdG9nZ2xlQnV0dG9uID0gbnVsbCwgdGhpcy5fZWxlbWVudFRvZ2dsZSA9IG51bGwsIHRoaXMuX3dyYXBwZXIgPSBudWxsLCB0aGlzLl9pbnB1dEVsID0gbnVsbCwgdGhpcy5fZHJvcGRvd25Db250YWluZXIgPSBudWxsLCB0aGlzLl9jb250YWluZXIgPSBudWxsLCB0aGlzLl9zZWxlY3RBbGxPcHRpb24gPSBudWxsLCB0aGlzLl9pbml0KCksIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBudWxsLCB0aGlzLl9pc09wZW4gPSAhMSwgdGhpcy5fYWRkTXV0YXRpb25PYnNlcnZlcigpLCB0aGlzLl9lbGVtZW50ICYmIEkuc2V0RGF0YSh0LCByaSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiB5bjtcbiAgfVxuICBnZXQgZmlsdGVySW5wdXQoKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShcbiAgICAgIERtLFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJcbiAgICApO1xuICB9XG4gIGdldCBkcm9wZG93bigpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKEltLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IG9wdGlvbnNMaXN0KCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUoXG4gICAgICBkYSxcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyXG4gICAgKTtcbiAgfVxuICBnZXQgb3B0aW9uc1dyYXBwZXIoKSB7XG4gICAgcmV0dXJuIGguZmluZE9uZShcbiAgICAgICRtLFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJcbiAgICApO1xuICB9XG4gIGdldCBjbGVhckJ1dHRvbigpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKE1tLCB0aGlzLl93cmFwcGVyKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA/IHRoaXMuX2ZpbHRlcmVkT3B0aW9uc0xpc3QgOiB0aGlzLl9wbGFpbk9wdGlvbnM7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0aW9uTW9kZWwudmFsdWVzIDogdGhpcy5fc2VsZWN0aW9uTW9kZWwudmFsdWU7XG4gIH1cbiAgZ2V0IG11bHRpcGxlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcubXVsdGlwbGU7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdEFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSAmJiB0aGlzLl9jb25maWcuc2VsZWN0QWxsO1xuICB9XG4gIGdldCBoYXNTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbiB8fCB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zLmxlbmd0aCA+IDA7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5CbSxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAmJiAodC5tdWx0aXBsZSA9ICEwKSwgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSAmJiAodC5kaXNhYmxlZCA9ICEwKSwgdGhpcy5fZWxlbWVudC50YWJJbmRleCAmJiAodC50YWJJbmRleCA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIikpLCBOKHluLCB0LCBWbSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBwLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5XbSxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgTih5biwgdCwgRm0pLCB0O1xuICB9XG4gIF9nZXRPcHRpb25zVG9SZW5kZXIodCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICByZXR1cm4gdC5jaGlsZE5vZGVzLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGlmIChuLm5vZGVOYW1lID09PSBcIk9QVEdST1VQXCIpIHtcbiAgICAgICAgY29uc3QgbyA9IHtcbiAgICAgICAgICBpZDogT3QoXCJncm91cC1cIiksXG4gICAgICAgICAgbGFiZWw6IG4ubGFiZWwsXG4gICAgICAgICAgZGlzYWJsZWQ6IG4uaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksXG4gICAgICAgICAgaGlkZGVuOiBuLmhhc0F0dHJpYnV0ZShcImhpZGRlblwiKSxcbiAgICAgICAgICBvcHRpb25zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBuLmNoaWxkTm9kZXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICAgIGEubm9kZU5hbWUgPT09IFwiT1BUSU9OXCIgJiYgby5vcHRpb25zLnB1c2goXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVPcHRpb25PYmplY3QoYSwgbylcbiAgICAgICAgICApO1xuICAgICAgICB9KSwgZS5wdXNoKG8pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG4ubm9kZU5hbWUgPT09IFwiT1BUSU9OXCIgJiYgZS5wdXNoKHRoaXMuX2NyZWF0ZU9wdGlvbk9iamVjdChuKSk7XG4gICAgfSksIGU7XG4gIH1cbiAgX2dldFBsYWluT3B0aW9ucyh0KSB7XG4gICAgaWYgKCFoLmZpbmRPbmUoXCJvcHRncm91cFwiLCB0aGlzLl9lbGVtZW50KSlcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IGkgPSBbXTtcbiAgICByZXR1cm4gdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICAgIG4sXG4gICAgICAgIFwib3B0aW9uc1wiXG4gICAgICApID8gbi5vcHRpb25zLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgaS5wdXNoKHIpO1xuICAgICAgfSkgOiBpLnB1c2gobik7XG4gICAgfSksIGk7XG4gIH1cbiAgX2NyZWF0ZU9wdGlvbk9iamVjdCh0LCBlID0ge30pIHtcbiAgICBjb25zdCBpID0gT3QoXCJvcHRpb24tXCIpLCBuID0gZS5pZCA/IGUuaWQgOiBudWxsLCBvID0gZS5kaXNhYmxlZCA/IGUuZGlzYWJsZWQgOiAhMSwgciA9IHQuc2VsZWN0ZWQgfHwgdC5oYXNBdHRyaWJ1dGUoZWkpLCBhID0gdC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSB8fCBvLCBsID0gdC5oYXNBdHRyaWJ1dGUoXCJoaWRkZW5cIikgfHwgZSAmJiBlLmhpZGRlbiwgYyA9IHRoaXMubXVsdGlwbGUsIGQgPSB0LnZhbHVlLCBfID0gdC5sYWJlbCwgZiA9IHAuZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgIHQsXG4gICAgICBcInNlbGVjdFNlY29uZGFyeVRleHRcIlxuICAgICksIG0gPSBwLmdldERhdGFBdHRyaWJ1dGUodCwgXCJzZWxlY3QtaWNvblwiKTtcbiAgICByZXR1cm4gbmV3IHNhKFxuICAgICAgaSxcbiAgICAgIHQsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIF8sXG4gICAgICByLFxuICAgICAgYSxcbiAgICAgIGwsXG4gICAgICBmLFxuICAgICAgbixcbiAgICAgIG1cbiAgICApO1xuICB9XG4gIF9nZXROYXZpZ2F0aW9uT3B0aW9ucygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLmZpbHRlcigoZSkgPT4gIWUuaGlkZGVuKTtcbiAgICByZXR1cm4gdGhpcy5oYXNTZWxlY3RBbGwgPyBbdGhpcy5fc2VsZWN0QWxsT3B0aW9uLCAuLi50XSA6IHQ7XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fcmVuZGVyTWF0ZXJpYWxXcmFwcGVyKCksIHRoaXMuX3dyYXBwZXIgPSBoLmZpbmRPbmUoYCMke3RoaXMuX3dyYXBwZXJJZH1gKSwgdGhpcy5faW5wdXQgPSBoLmZpbmRPbmUoY2EsIHRoaXMuX3dyYXBwZXIpLCB0aGlzLl9jb25maWcuZGlzYWJsZWQgJiYgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKHduLCBcIlwiKTtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29uZmlnLnNlbGVjdENvbnRhaW5lcjtcbiAgICB0ID09PSBcImJvZHlcIiA/IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmJvZHkgOiB0aGlzLl9jb250YWluZXIgPSBoLmZpbmRPbmUodCksIHRoaXMuX2luaXRPdXRsaW5lSW5wdXQoKSwgdGhpcy5fc2V0RGVmYXVsdFNlbGVjdGlvbnMoKSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl9hcHBlbmRGYWtlVmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fYmluZENvbXBvbmVudEV2ZW50cygpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiAodGhpcy5fc2VsZWN0QWxsT3B0aW9uID0gdGhpcy5fY3JlYXRlU2VsZWN0QWxsT3B0aW9uKCkpLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciA9IG5hKFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJJZCxcbiAgICAgIHRoaXMuX2NvbmZpZyxcbiAgICAgIHRoaXMuX2lucHV0Lm9mZnNldFdpZHRoLFxuICAgICAgdGhpcy5fZHJvcGRvd25IZWlnaHQsXG4gICAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24sXG4gICAgICB0aGlzLl9vcHRpb25zVG9SZW5kZXIsXG4gICAgICB0aGlzLl9jdXN0b21Db250ZW50LFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCksIHRoaXMuX2xpc3RlblRvRm9jdXNDaGFuZ2UoKTtcbiAgfVxuICBfcmVuZGVyTWF0ZXJpYWxXcmFwcGVyKCkge1xuICAgIGNvbnN0IHQgPSBwbShcbiAgICAgIHRoaXMuX3dyYXBwZXJJZCxcbiAgICAgIHRoaXMuX2NvbmZpZyxcbiAgICAgIHRoaXMuX2xhYmVsLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LCB0aGlzLl9lbGVtZW50KSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmluaXRpYWxpemVkKSwgdC5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfaW5pdE91dGxpbmVJbnB1dCgpIHtcbiAgICBjb25zdCB0ID0gaC5maW5kT25lKFxuICAgICAgaGEsXG4gICAgICB0aGlzLl93cmFwcGVyXG4gICAgKTtcbiAgICBuZXcgVih0LCB7XG4gICAgICBpbnB1dEZvcm1XaGl0ZTogdGhpcy5fY29uZmlnLnNlbGVjdEZvcm1XaGl0ZVxuICAgIH0pLmluaXQoKSwgdGhpcy5fbm90Y2ggPSBoLmZpbmRPbmUoa24sIHRoaXMuX3dyYXBwZXIpO1xuICB9XG4gIF9iaW5kQ29tcG9uZW50RXZlbnRzKCkge1xuICAgIHRoaXMuX2xpc3RlblRvQ29tcG9uZW50S2V5ZG93bigpLCB0aGlzLl9saXN0ZW5Ub1dyYXBwZXJDbGljaygpLCB0aGlzLl9saXN0ZW5Ub0NsZWFyQnRuQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9DbGVhckJ0bktleWRvd24oKTtcbiAgfVxuICBfc2V0RGVmYXVsdFNlbGVjdGlvbnMoKSB7XG4gICAgdGhpcy5vcHRpb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuc2VsZWN0ZWQgJiYgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHQpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0NvbXBvbmVudEtleWRvd24oKSB7XG4gICAgdS5vbih0aGlzLl93cmFwcGVyLCBcImtleWRvd25cIiwgdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKTtcbiAgfVxuICBfaGFuZGxlS2V5ZG93bih0KSB7XG4gICAgdGhpcy5faXNPcGVuICYmICF0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyID8gdGhpcy5faGFuZGxlT3BlbktleWRvd24odCkgOiB0aGlzLl9oYW5kbGVDbG9zZWRLZXlkb3duKHQpO1xuICB9XG4gIF9oYW5kbGVPcGVuS2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHQua2V5Q29kZSwgaSA9IGUgPT09IElzIHx8IGUgPT09IHJ0ICYmIHQuYWx0S2V5IHx8IGUgPT09IGZpO1xuICAgIGlmIChlID09PSBmaSAmJiB0aGlzLl9jb25maWcuc2VsZWN0QXV0b1NlbGVjdCAmJiAhdGhpcy5tdWx0aXBsZSAmJiB0aGlzLl9oYW5kbGVBdXRvU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbiksIGkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKSwgdGhpcy5faW5wdXQuZm9jdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIFU6XG4gICAgICAgIHRoaXMuX3NldE5leHRPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHJ0OlxuICAgICAgICB0aGlzLl9zZXRQcmV2aW91c09wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGU6XG4gICAgICAgIHRoaXMuX3NldEZpcnN0T3B0aW9uQWN0aXZlKCksIHRoaXMuX3Njcm9sbFRvT3B0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNZTpcbiAgICAgICAgdGhpcy5fc2V0TGFzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbHQ6XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fYWN0aXZlT3B0aW9uICYmICh0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCA9PT0gMCA/IHRoaXMuX2hhbmRsZVNlbGVjdEFsbCgpIDogdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbikpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfaGFuZGxlQ2xvc2VkS2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHQua2V5Q29kZTtcbiAgICBpZiAoZSA9PT0gbHQgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCAoZSA9PT0gbHQgfHwgZSA9PT0gVSAmJiB0LmFsdEtleSB8fCBlID09PSBVICYmIHRoaXMubXVsdGlwbGUpICYmIHRoaXMub3BlbigpLCB0aGlzLm11bHRpcGxlKVxuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgVTpcbiAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBydDpcbiAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgVTpcbiAgICAgICAgICB0aGlzLl9zZXROZXh0T3B0aW9uQWN0aXZlKCksIHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHJ0OlxuICAgICAgICAgIHRoaXMuX3NldFByZXZpb3VzT3B0aW9uQWN0aXZlKCksIHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExlOlxuICAgICAgICAgIHRoaXMuX3NldEZpcnN0T3B0aW9uQWN0aXZlKCksIHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1lOlxuICAgICAgICAgIHRoaXMuX3NldExhc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfc2Nyb2xsVG9PcHRpb24odCkge1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZTtcbiAgICBjb25zdCBpID0gdGhpcy5vcHRpb25zLmZpbHRlcigoZCkgPT4gIWQuaGlkZGVuKTtcbiAgICB0aGlzLmhhc1NlbGVjdEFsbCA/IGUgPSBpLmluZGV4T2YodCkgKyAxIDogZSA9IGkuaW5kZXhPZih0KTtcbiAgICBjb25zdCBuID0gdGhpcy5fZ2V0TnVtYmVyT2ZHcm91cHNCZWZvcmVPcHRpb24oZSksIG8gPSBlICsgbiwgciA9IHRoaXMub3B0aW9uc1dyYXBwZXIsIGEgPSByLm9mZnNldEhlaWdodCwgbCA9IHRoaXMuX2NvbmZpZy5zZWxlY3RPcHRpb25IZWlnaHQsIGMgPSByLnNjcm9sbFRvcDtcbiAgICBpZiAoZSA+IC0xKSB7XG4gICAgICBjb25zdCBkID0gbyAqIGwsIF8gPSBkICsgbCA+IGMgKyBhO1xuICAgICAgZCA8IGMgPyByLnNjcm9sbFRvcCA9IGQgOiBfID8gci5zY3JvbGxUb3AgPSBkIC0gYSArIGwgOiByLnNjcm9sbFRvcCA9IGM7XG4gICAgfVxuICB9XG4gIF9nZXROdW1iZXJPZkdyb3Vwc0JlZm9yZU9wdGlvbih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucy5maWx0ZXIoKHIpID0+ICFyLmhpZGRlbiksIGkgPSB0aGlzLl9vcHRpb25zVG9SZW5kZXIuZmlsdGVyKChyKSA9PiAhci5oaWRkZW4pLCBuID0gdGhpcy5oYXNTZWxlY3RBbGwgPyB0IC0gMSA6IHQ7XG4gICAgbGV0IG8gPSAwO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDw9IG47IHIrKylcbiAgICAgIGVbcl0uZ3JvdXBJZCAmJiBpW29dICYmIGlbb10uaWQgJiYgZVtyXS5ncm91cElkID09PSBpW29dLmlkICYmIG8rKztcbiAgICByZXR1cm4gbztcbiAgfVxuICBfc2V0TmV4dE9wdGlvbkFjdGl2ZSgpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ICsgMTtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKTtcbiAgICBpZiAoZVt0XSkge1xuICAgICAgZm9yICg7IGVbdF0uZGlzYWJsZWQ7IClcbiAgICAgICAgaWYgKHQgKz0gMSwgIWVbdF0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKGVbdF0sIHQpO1xuICAgIH1cbiAgfVxuICBfc2V0UHJldmlvdXNPcHRpb25BY3RpdmUoKSB7XG4gICAgbGV0IHQgPSB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCAtIDE7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCk7XG4gICAgaWYgKGVbdF0pIHtcbiAgICAgIGZvciAoOyBlW3RdLmRpc2FibGVkOyApXG4gICAgICAgIGlmICh0IC09IDEsICFlW3RdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZU9wdGlvbihlW3RdLCB0KTtcbiAgICB9XG4gIH1cbiAgX3NldEZpcnN0T3B0aW9uQWN0aXZlKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpO1xuICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZU9wdGlvbihlWzBdLCAwKTtcbiAgfVxuICBfc2V0TGFzdE9wdGlvbkFjdGl2ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKSwgZSA9IHQubGVuZ3RoIC0gMTtcbiAgICB0aGlzLl91cGRhdGVBY3RpdmVPcHRpb24odFtlXSwgZSk7XG4gIH1cbiAgX3VwZGF0ZUFjdGl2ZU9wdGlvbih0LCBlKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2FjdGl2ZU9wdGlvbjtcbiAgICBpICYmIGkucmVtb3ZlQWN0aXZlU3R5bGVzKCksIHQuc2V0QWN0aXZlU3R5bGVzKCksIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gZSwgdGhpcy5fYWN0aXZlT3B0aW9uID0gdDtcbiAgfVxuICBfbGlzdGVuVG9XcmFwcGVyQ2xpY2soKSB7XG4gICAgdS5vbih0aGlzLl93cmFwcGVyLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvQ2xlYXJCdG5DbGljaygpIHtcbiAgICB1Lm9uKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdC5zdG9wUHJvcGFnYXRpb24oKSwgdGhpcy5faGFuZGxlQ2xlYXIoKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9DbGVhckJ0bktleWRvd24oKSB7XG4gICAgdS5vbih0aGlzLmNsZWFyQnV0dG9uLCBcImtleWRvd25cIiwgKHQpID0+IHtcbiAgICAgIHQua2V5Q29kZSA9PT0gbHQgJiYgKHRoaXMuX2hhbmRsZUNsZWFyKCksIHQucHJldmVudERlZmF1bHQoKSwgdC5zdG9wUHJvcGFnYXRpb24oKSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNsZWFyKCkge1xuICAgIGlmICh0aGlzLm11bHRpcGxlKVxuICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKSwgdGhpcy5fZGVzZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuaGFzU2VsZWN0QWxsICYmIHRoaXMuX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uO1xuICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKSwgdC5kZXNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KG51bGwpLCB0aGlzLl9lbWl0TmF0aXZlQ2hhbmdlRXZlbnQoKTtcbiAgfVxuICBfbGlzdGVuVG9PcHRpb25zQ2xpY2soKSB7XG4gICAgdS5vbih0aGlzLm9wdGlvbnNXcmFwcGVyLCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICBpZiAodC50YXJnZXQuaGFzQXR0cmlidXRlKFxuICAgICAgICBPbVxuICAgICAgKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaSA9IHQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkRJVlwiID8gdC50YXJnZXQgOiBoLmNsb3Nlc3QodC50YXJnZXQsIExtKTtcbiAgICAgIGlmIChpLmhhc0F0dHJpYnV0ZSh4bSkpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlU2VsZWN0QWxsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG8gPSBpLmRhdGFzZXQudGVJZCwgciA9IHRoaXMub3B0aW9ucy5maW5kKChhKSA9PiBhLmlkID09PSBvKTtcbiAgICAgIHIgJiYgIXIuZGlzYWJsZWQgJiYgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHIpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVTZWxlY3RBbGwoKSB7XG4gICAgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLnNlbGVjdGVkID8gKHRoaXMuX2Rlc2VsZWN0QWxsT3B0aW9ucyh0aGlzLm9wdGlvbnMpLCB0aGlzLl9zZWxlY3RBbGxPcHRpb24uZGVzZWxlY3QoKSkgOiAodGhpcy5fc2VsZWN0QWxsT3B0aW9ucyh0aGlzLm9wdGlvbnMpLCB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0KCkpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHRoaXMudmFsdWUpLCB0aGlzLl9lbWl0TmF0aXZlQ2hhbmdlRXZlbnQoKTtcbiAgfVxuICBfc2VsZWN0QWxsT3B0aW9ucyh0KSB7XG4gICAgdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAhZS5zZWxlY3RlZCAmJiAhZS5kaXNhYmxlZCAmJiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KGUpLCBlLnNlbGVjdCgpKTtcbiAgICB9KTtcbiAgfVxuICBfZGVzZWxlY3RBbGxPcHRpb25zKHQpIHtcbiAgICB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUuc2VsZWN0ZWQgJiYgIWUuZGlzYWJsZWQgJiYgKHRoaXMuX3NlbGVjdGlvbk1vZGVsLmRlc2VsZWN0KGUpLCBlLmRlc2VsZWN0KCkpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVTZWxlY3Rpb24odCkge1xuICAgIHRoaXMubXVsdGlwbGUgPyAodGhpcy5faGFuZGxlTXVsdGlTZWxlY3Rpb24odCksIHRoaXMuaGFzU2VsZWN0QWxsICYmIHRoaXMuX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCkpIDogdGhpcy5faGFuZGxlU2luZ2xlU2VsZWN0aW9uKHQpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCk7XG4gIH1cbiAgX2hhbmRsZUF1dG9TZWxlY3Rpb24odCkge1xuICAgIHRoaXMuX3NpbmdsZU9wdGlvblNlbGVjdCh0KSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpO1xuICB9XG4gIF9oYW5kbGVTaW5nbGVTZWxlY3Rpb24odCkge1xuICAgIHRoaXMuX3NpbmdsZU9wdGlvblNlbGVjdCh0KSwgdGhpcy5jbG9zZSgpLCB0aGlzLl9pbnB1dC5mb2N1cygpO1xuICB9XG4gIF9zaW5nbGVPcHRpb25TZWxlY3QodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zWzBdO1xuICAgIGUgJiYgZSAhPT0gdCAmJiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoZSksIGUuZGVzZWxlY3QoKSwgZS5ub2RlLnNldEF0dHJpYnV0ZShlaSwgITEpLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgcmEsIHtcbiAgICAgIHZhbHVlOiBlLnZhbHVlXG4gICAgfSkpLCAoIWUgfHwgZSAmJiB0ICE9PSBlKSAmJiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHQpLCB0LnNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKGVpLCAhMCksIHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBvYSwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQodGhpcy52YWx1ZSksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpKTtcbiAgfVxuICBfaGFuZGxlTXVsdGlTZWxlY3Rpb24odCkge1xuICAgIHQuc2VsZWN0ZWQgPyAodGhpcy5fc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QodCksIHQuZGVzZWxlY3QoKSwgdC5ub2RlLnNldEF0dHJpYnV0ZShlaSwgITEpLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgcmEsIHtcbiAgICAgIHZhbHVlOiB0LnZhbHVlXG4gICAgfSkpIDogKHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdCh0KSwgdC5zZWxlY3QoKSwgdC5ub2RlLnNldEF0dHJpYnV0ZShlaSwgITApLCB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgb2EsIHtcbiAgICAgIHZhbHVlOiB0LnZhbHVlXG4gICAgfSkpLCB0aGlzLl9lbWl0VmFsdWVDaGFuZ2VFdmVudCh0aGlzLnZhbHVlKSwgdGhpcy5fZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCk7XG4gIH1cbiAgX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHQpIHtcbiAgICB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgd20sIHsgdmFsdWU6IHQgfSk7XG4gIH1cbiAgX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpIHtcbiAgICB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwga20pO1xuICB9XG4gIF91cGRhdGVJbnB1dFZhbHVlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0aW9uTW9kZWwubGFiZWxzIDogdGhpcy5fc2VsZWN0aW9uTW9kZWwubGFiZWw7XG4gICAgbGV0IGU7XG4gICAgdGhpcy5tdWx0aXBsZSAmJiB0aGlzLl9jb25maWcuc2VsZWN0RGlzcGxheWVkTGFiZWxzICE9PSAtMSAmJiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zLmxlbmd0aCA+IHRoaXMuX2NvbmZpZy5zZWxlY3REaXNwbGF5ZWRMYWJlbHMgPyBlID0gYCR7dGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9ucy5sZW5ndGh9ICR7dGhpcy5fY29uZmlnLnNlbGVjdE9wdGlvbnNTZWxlY3RlZExhYmVsfWAgOiBlID0gdCwgIXRoaXMubXVsdGlwbGUgJiYgIXRoaXMuX2lzU2VsZWN0aW9uVmFsaWQodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uKSA/IHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiA6IHRoaXMuX2lzTGFiZWxFbXB0eSh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24pID8gdGhpcy5faW5wdXQudmFsdWUgPSBcIiBcIiA6IGUgPyB0aGlzLl9pbnB1dC52YWx1ZSA9IGUgOiB0aGlzLm11bHRpcGxlIHx8ICF0aGlzLl9vcHRpb25zVG9SZW5kZXJbMF0gPyB0aGlzLl9pbnB1dC52YWx1ZSA9IFwiXCIgOiB0aGlzLl9pbnB1dC52YWx1ZSA9IHRoaXMuX29wdGlvbnNUb1JlbmRlclswXS5sYWJlbDtcbiAgfVxuICBfaXNTZWxlY3Rpb25WYWxpZCh0KSB7XG4gICAgcmV0dXJuICEodCAmJiAodC5kaXNhYmxlZCB8fCB0LnZhbHVlID09PSBcIlwiKSk7XG4gIH1cbiAgX2lzTGFiZWxFbXB0eSh0KSB7XG4gICAgcmV0dXJuICEhKHQgJiYgdC5sYWJlbCA9PT0gXCJcIik7XG4gIH1cbiAgX2FwcGVuZEZha2VWYWx1ZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbiB8fCB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5fbXVsdGlwbGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbi5sYWJlbDtcbiAgICB0aGlzLl9mYWtlVmFsdWUgPSBDbSh0LCB0aGlzLl9jbGFzc2VzKSwgaC5maW5kT25lKFxuICAgICAgaGEsXG4gICAgICB0aGlzLl93cmFwcGVyXG4gICAgKS5hcHBlbmRDaGlsZCh0aGlzLl9mYWtlVmFsdWUpO1xuICB9XG4gIF91cGRhdGVMYWJlbFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShhYSksIGUgPSB0aGlzLl9pbnB1dC52YWx1ZSAhPT0gXCJcIjtcbiAgICB0aGlzLl9sYWJlbCAmJiAodCAmJiAoZSB8fCB0aGlzLl9pc09wZW4gfHwgdGhpcy5faXNGYWtlVmFsdWVBY3RpdmUpID8gKHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZShxLCBcIlwiKSwgdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKHEsIFwiXCIpKSA6ICh0aGlzLl9sYWJlbC5yZW1vdmVBdHRyaWJ1dGUocSksIHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShxLCBcIlwiKSkpO1xuICB9XG4gIF91cGRhdGVMYWJlbFBvc2l0aW9uV2hpbGVDbG9zaW5nKCkge1xuICAgIHRoaXMuX2xhYmVsICYmICh0aGlzLl9pbnB1dC52YWx1ZSAhPT0gXCJcIiB8fCB0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA/ICh0aGlzLl9sYWJlbC5zZXRBdHRyaWJ1dGUocSwgXCJcIiksIHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZShxLCBcIlwiKSkgOiAodGhpcy5fbGFiZWwucmVtb3ZlQXR0cmlidXRlKHEpLCB0aGlzLl9ub3RjaC5yZW1vdmVBdHRyaWJ1dGUocSkpKTtcbiAgfVxuICBfdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSB7XG4gICAgdGhpcy5fZmFrZVZhbHVlICYmICh0aGlzLl9pbnB1dC52YWx1ZSA9PT0gXCJcIiAmJiB0aGlzLl9mYWtlVmFsdWUuaW5uZXJIVE1MICE9PSBcIlwiID8gKHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID0gITAsIHRoaXMuX2Zha2VWYWx1ZS5zZXRBdHRyaWJ1dGUocSwgXCJcIikpIDogKHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID0gITEsIHRoaXMuX2Zha2VWYWx1ZS5yZW1vdmVBdHRyaWJ1dGUocSkpKTtcbiAgfVxuICBfdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCkge1xuICAgIGlmICghdGhpcy5jbGVhckJ1dHRvbilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24gfHwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9ucy5sZW5ndGggPiAwID8gcC5hZGRTdHlsZSh0aGlzLmNsZWFyQnV0dG9uLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSA6IHAuYWRkU3R5bGUodGhpcy5jbGVhckJ1dHRvbiwgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KTtcbiAgfVxuICBfdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5zZWxlY3RlZCwgZSA9IGpuKHRoaXMub3B0aW9ucyk7XG4gICAgIWUgJiYgdCA/IHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5kZXNlbGVjdCgpIDogZSAmJiAhdCAmJiB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0KCk7XG4gIH1cbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2lzT3BlbiA/IHRoaXMuY2xvc2UoKSA6IHRoaXMub3BlbigpO1xuICB9XG4gIG9wZW4oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZy5kaXNhYmxlZCwgZSA9IHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB5bSk7XG4gICAgdGhpcy5faXNPcGVuIHx8IHQgfHwgZS5kZWZhdWx0UHJldmVudGVkIHx8ICh0aGlzLl9vcGVuRHJvcGRvd24oKSwgdGhpcy5fdXBkYXRlRHJvcGRvd25XaWR0aCgpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pLCB0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyICYmIChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZmlsdGVySW5wdXQuZm9jdXMoKTtcbiAgICB9LCAwKSwgdGhpcy5fbGlzdGVuVG9TZWxlY3RTZWFyY2goKSwgdGhpcy5fbGlzdGVuVG9Ecm9wZG93bktleWRvd24oKSksIHRoaXMuX2xpc3RlblRvT3B0aW9uc0NsaWNrKCksIHRoaXMuX2xpc3RlblRvT3V0c2lkZUNsaWNrKCksIHRoaXMuX2xpc3RlblRvV2luZG93UmVzaXplKCksIHRoaXMuX2lzT3BlbiA9ICEwLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3NldElucHV0QWN0aXZlU3R5bGVzKCkpO1xuICB9XG4gIF9vcGVuRHJvcGRvd24oKSB7XG4gICAgdGhpcy5fcG9wcGVyID0gamUodGhpcy5faW5wdXQsIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLCB7XG4gICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tLXN0YXJ0XCIsXG4gICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwib2Zmc2V0XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KSwgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRyb3Bkb3duLnNldEF0dHJpYnV0ZShsYSwgXCJcIik7XG4gICAgfSwgMCk7XG4gIH1cbiAgX3VwZGF0ZURyb3Bkb3duV2lkdGgoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2lucHV0Lm9mZnNldFdpZHRoO1xuICAgIHAuYWRkU3R5bGUodGhpcy5fZHJvcGRvd25Db250YWluZXIsIHsgd2lkdGg6IGAke3R9cHhgIH0pO1xuICB9XG4gIF9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKSwgZSA9IHRoaXMuX2FjdGl2ZU9wdGlvbjtcbiAgICBlICYmIGUucmVtb3ZlQWN0aXZlU3R5bGVzKCk7XG4gICAgY29uc3QgaSA9IHRoaXMubXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zWzBdIDogdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uO1xuICAgIGkgPyAodGhpcy5fYWN0aXZlT3B0aW9uID0gaSwgaS5zZXRBY3RpdmVTdHlsZXMoKSwgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPSB0LmZpbmRJbmRleChcbiAgICAgIChuKSA9PiBuID09PSBpXG4gICAgKSkgOiAodGhpcy5fYWN0aXZlT3B0aW9uID0gbnVsbCwgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPSAtMSk7XG4gIH1cbiAgX3NldElucHV0QWN0aXZlU3R5bGVzKCkge1xuICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShXdCwgXCJcIiksIGguZmluZE9uZShrbiwgdGhpcy5fd3JhcHBlcikuc2V0QXR0cmlidXRlKFxuICAgICAgV3QsXG4gICAgICBcIlwiXG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9XaW5kb3dSZXNpemUoKSB7XG4gICAgdS5vbih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgfVxuICBfaGFuZGxlV2luZG93UmVzaXplKCkge1xuICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyICYmIHRoaXMuX3VwZGF0ZURyb3Bkb3duV2lkdGgoKTtcbiAgfVxuICBfbGlzdGVuVG9TZWxlY3RTZWFyY2goKSB7XG4gICAgdGhpcy5maWx0ZXJJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnRhcmdldC52YWx1ZSwgaSA9IHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXJEZWJvdW5jZTtcbiAgICAgIHRoaXMuX2RlYm91bmNlRmlsdGVyKGUsIGkpO1xuICAgIH0pO1xuICB9XG4gIF9kZWJvdW5jZUZpbHRlcih0LCBlKSB7XG4gICAgdGhpcy5fZGVib3VuY2VUaW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuX2RlYm91bmNlVGltZW91dElkKSwgdGhpcy5fZGVib3VuY2VUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2ZpbHRlck9wdGlvbnModCk7XG4gICAgfSwgZSk7XG4gIH1cbiAgX2ZpbHRlck9wdGlvbnModCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICB0aGlzLl9vcHRpb25zVG9SZW5kZXIuZm9yRWFjaCgobykgPT4ge1xuICAgICAgY29uc3QgciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgICAgbyxcbiAgICAgICAgXCJvcHRpb25zXCJcbiAgICAgICksIGEgPSAhciAmJiBvLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModC50b0xvd2VyQ2FzZSgpKSwgbCA9IHt9O1xuICAgICAgciAmJiAobC5sYWJlbCA9IG8ubGFiZWwsIGwub3B0aW9ucyA9IHRoaXMuX2ZpbHRlcih0LCBvLm9wdGlvbnMpLCBsLm9wdGlvbnMubGVuZ3RoID4gMCAmJiBlLnB1c2gobCkpLCBhICYmIGUucHVzaChvKTtcbiAgICB9KTtcbiAgICBjb25zdCBpID0gdGhpcy5fY29uZmlnLnNlbGVjdE5vUmVzdWx0VGV4dCAhPT0gXCJcIiwgbiA9IGUubGVuZ3RoICE9PSAwO1xuICAgIGlmIChuKVxuICAgICAgdGhpcy5fdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZShlKSwgdGhpcy5fcG9wcGVyLmZvcmNlVXBkYXRlKCksIHRoaXMuX2ZpbHRlcmVkT3B0aW9uc0xpc3QgPSB0aGlzLl9nZXRQbGFpbk9wdGlvbnMoZSksIHRoaXMuaGFzU2VsZWN0QWxsICYmIHRoaXMuX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCk7XG4gICAgZWxzZSBpZiAoIW4gJiYgaSkge1xuICAgICAgY29uc3QgbyA9IHRoaXMuX2dldE5vUmVzdWx0VGVtcGxhdGUoKTtcbiAgICAgIHRoaXMub3B0aW9uc1dyYXBwZXIuaW5uZXJIVE1MID0gbztcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZU9wdGlvbnNMaXN0VGVtcGxhdGUodCkge1xuICAgIGNvbnN0IGUgPSBoLmZpbmRPbmUoZGEsIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKSB8fCBoLmZpbmRPbmUoUm0sIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKSwgaSA9IERsKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX3NlbGVjdEFsbE9wdGlvbixcbiAgICAgIHRoaXMuX2NvbmZpZyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMub3B0aW9uc1dyYXBwZXIucmVtb3ZlQ2hpbGQoZSksIHRoaXMub3B0aW9uc1dyYXBwZXIuYXBwZW5kQ2hpbGQoaSk7XG4gIH1cbiAgX2dldE5vUmVzdWx0VGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLm5vUmVzdWx0fVwiICR7TWx9IHN0eWxlPVwiaGVpZ2h0OiAke3RoaXMuX2NvbmZpZy5zZWxlY3RPcHRpb25IZWlnaHR9cHhcIj4ke3RoaXMuX2NvbmZpZy5zZWxlY3ROb1Jlc3VsdFRleHR9PC9kaXY+YDtcbiAgfVxuICBfZmlsdGVyKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBlLmZpbHRlcihcbiAgICAgIChuKSA9PiBuLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaSlcbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub0Ryb3Bkb3duS2V5ZG93bigpIHtcbiAgICB1Lm9uKFxuICAgICAgdGhpcy5kcm9wZG93bixcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5faGFuZGxlT3BlbktleWRvd24uYmluZCh0aGlzKVxuICAgICk7XG4gIH1cbiAgX2xpc3RlblRvT3V0c2lkZUNsaWNrKCkge1xuICAgIHRoaXMuX291dHNpZGVDbGljayA9IHRoaXMuX2hhbmRsZU91dFNpZGVDbGljay5iaW5kKHRoaXMpLCB1Lm9uKGRvY3VtZW50LCBcImNsaWNrXCIsIHRoaXMuX291dHNpZGVDbGljayk7XG4gIH1cbiAgX2xpc3RlblRvRm9jdXNDaGFuZ2UodCA9ICEwKSB7XG4gICAgaWYgKHQgPT09ICExKSB7XG4gICAgICB1LnJlbW92ZShcbiAgICAgICAgdGhpcy5faW5wdXQsXG4gICAgICAgIFwiZm9jdXNcIixcbiAgICAgICAgKCkgPT4gdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKFd0LCBcIlwiKVxuICAgICAgKSwgdS5yZW1vdmUoXG4gICAgICAgIHRoaXMuX2lucHV0LFxuICAgICAgICBcImJsdXJcIixcbiAgICAgICAgKCkgPT4gdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKFd0KVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdS5vbihcbiAgICAgIHRoaXMuX2lucHV0LFxuICAgICAgXCJmb2N1c1wiLFxuICAgICAgKCkgPT4gdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKFd0LCBcIlwiKVxuICAgICksIHUub24oXG4gICAgICB0aGlzLl9pbnB1dCxcbiAgICAgIFwiYmx1clwiLFxuICAgICAgKCkgPT4gdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKFd0KVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZU91dFNpZGVDbGljayh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3dyYXBwZXIgJiYgdGhpcy5fd3JhcHBlci5jb250YWlucyh0LnRhcmdldCksIGkgPSB0LnRhcmdldCA9PT0gdGhpcy5fZHJvcGRvd25Db250YWluZXIsIG4gPSB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciAmJiB0aGlzLl9kcm9wZG93bkNvbnRhaW5lci5jb250YWlucyh0LnRhcmdldCk7XG4gICAgbGV0IG87XG4gICAgdGhpcy5fdG9nZ2xlQnV0dG9uIHx8ICh0aGlzLl9lbGVtZW50VG9nZ2xlID0gaC5maW5kKFBtKSksIHRoaXMuX2VsZW1lbnRUb2dnbGUgJiYgdGhpcy5fZWxlbWVudFRvZ2dsZS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBjb25zdCBhID0gcC5nZXREYXRhQXR0cmlidXRlKFxuICAgICAgICByLFxuICAgICAgICBcInNlbGVjdC10b2dnbGVcIlxuICAgICAgKTtcbiAgICAgIChhID09PSB0aGlzLl9lbGVtZW50LmlkIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGEpKSAmJiAodGhpcy5fdG9nZ2xlQnV0dG9uID0gciwgbyA9IHRoaXMuX3RvZ2dsZUJ1dHRvbi5jb250YWlucyh0LnRhcmdldCkpO1xuICAgIH0pLCAhZSAmJiAhaSAmJiAhbiAmJiAhbyAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgY29uc3QgdCA9IHUudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBBbSk7XG4gICAgIXRoaXMuX2lzT3BlbiB8fCB0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgJiYgdGhpcy5oYXNTZWxlY3RBbGwgJiYgKHRoaXMuX3Jlc2V0RmlsdGVyU3RhdGUoKSwgdGhpcy5fdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZSh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9jb25maWcubXVsdGlwbGUgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSksIHRoaXMuX3JlbW92ZURyb3Bkb3duRXZlbnRzKCksIHRoaXMuZHJvcGRvd24ucmVtb3ZlQXR0cmlidXRlKGxhKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoV3QpLCB0aGlzLl9pbnB1dC5ibHVyKCksIGguZmluZE9uZShrbiwgdGhpcy5fd3JhcHBlcikucmVtb3ZlQXR0cmlidXRlKFxuICAgICAgICBXdFxuICAgICAgKSwgdGhpcy5fbGFiZWwgJiYgIXRoaXMuaGFzU2VsZWN0aW9uICYmICh0aGlzLl9sYWJlbC5yZW1vdmVBdHRyaWJ1dGUocSksIHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZShxLCBcIlwiKSwgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKHEpLCB0aGlzLl9ub3RjaC5yZW1vdmVBdHRyaWJ1dGUocSkpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uV2hpbGVDbG9zaW5nKCk7XG4gICAgfSwgMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY29udGFpbmVyICYmIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZHJvcGRvd25Db250YWluZXIpLCB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9pc09wZW4gPSAhMSwgdS5vZmYodGhpcy5kcm9wZG93biwgXCJ0cmFuc2l0aW9uZW5kXCIpO1xuICAgIH0sIEhtKSk7XG4gIH1cbiAgX3Jlc2V0RmlsdGVyU3RhdGUoKSB7XG4gICAgdGhpcy5maWx0ZXJJbnB1dC52YWx1ZSA9IFwiXCIsIHRoaXMuX2ZpbHRlcmVkT3B0aW9uc0xpc3QgPSBudWxsO1xuICB9XG4gIF9yZW1vdmVEcm9wZG93bkV2ZW50cygpIHtcbiAgICB1Lm9mZihkb2N1bWVudCwgXCJjbGlja1wiLCB0aGlzLl9vdXRzaWRlQ2xpY2spLCB0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyICYmIHUub2ZmKHRoaXMuZHJvcGRvd24sIFwia2V5ZG93blwiKSwgdS5vZmYodGhpcy5vcHRpb25zV3JhcHBlciwgXCJjbGlja1wiKTtcbiAgfVxuICBfYWRkTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgdGhpcy5fd3JhcHBlciAmJiAodGhpcy5fdXBkYXRlU2VsZWN0aW9ucygpLCB0aGlzLl91cGRhdGVEaXNhYmxlZFN0YXRlKCkpO1xuICAgIH0pLCB0aGlzLl9vYnNlcnZlTXV0YXRpb25PYnNlcnZlcigpO1xuICB9XG4gIF91cGRhdGVTZWxlY3Rpb25zKCkge1xuICAgIHRoaXMuX29wdGlvbnNUb1JlbmRlciA9IHRoaXMuX2dldE9wdGlvbnNUb1JlbmRlcih0aGlzLl9lbGVtZW50KSwgdGhpcy5fcGxhaW5PcHRpb25zID0gdGhpcy5fZ2V0UGxhaW5PcHRpb25zKHRoaXMuX29wdGlvbnNUb1JlbmRlciksIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCksIHRoaXMuX3NldERlZmF1bHRTZWxlY3Rpb25zKCksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29uZmlnLmZpbHRlciAmJiB0aGlzLmZpbHRlcklucHV0ICYmIHRoaXMuZmlsdGVySW5wdXQudmFsdWU7XG4gICAgdGhpcy5faXNPcGVuICYmICF0ID8gKHRoaXMuX3VwZGF0ZU9wdGlvbnNMaXN0VGVtcGxhdGUodGhpcy5fb3B0aW9uc1RvUmVuZGVyKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSkgOiB0aGlzLl9pc09wZW4gJiYgdCA/ICh0aGlzLl9maWx0ZXJPcHRpb25zKHRoaXMuZmlsdGVySW5wdXQudmFsdWUpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpKSA6IHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyID0gbmEoXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkLFxuICAgICAgdGhpcy5fY29uZmlnLFxuICAgICAgdGhpcy5faW5wdXQub2Zmc2V0V2lkdGgsXG4gICAgICB0aGlzLl9kcm9wZG93bkhlaWdodCxcbiAgICAgIHRoaXMuX3NlbGVjdEFsbE9wdGlvbixcbiAgICAgIHRoaXMuX29wdGlvbnNUb1JlbmRlcixcbiAgICAgIHRoaXMuX2N1c3RvbUNvbnRlbnQsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgfVxuICBfdXBkYXRlRGlzYWJsZWRTdGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gaC5maW5kT25lKGNhLCB0aGlzLl93cmFwcGVyKTtcbiAgICB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpID8gKHRoaXMuX2NvbmZpZy5kaXNhYmxlZCA9ICEwLCB0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0LnNldEF0dHJpYnV0ZSh3biwgXCJcIikpIDogKHRoaXMuX2NvbmZpZy5kaXNhYmxlZCA9ICExLCB0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpLCB0LnJlbW92ZUF0dHJpYnV0ZSh3bikpO1xuICB9XG4gIF9vYnNlcnZlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyICYmIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICBhdHRyaWJ1dGVzOiAhMCxcbiAgICAgIGNoaWxkTGlzdDogITAsXG4gICAgICBjaGFyYWN0ZXJEYXRhOiAhMCxcbiAgICAgIHN1YnRyZWU6ICEwXG4gICAgfSk7XG4gIH1cbiAgX2Rpc2Nvbm5lY3RNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciAmJiAodGhpcy5fbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCksIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBudWxsKTtcbiAgfVxuICBfY3JlYXRlU2VsZWN0QWxsT3B0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zZWxlY3RBbGxJZCwgZSA9IG51bGwsIGkgPSAhMCwgbiA9IFwic2VsZWN0LWFsbFwiLCBvID0gdGhpcy5fY29uZmlnLnNlbGVjdEFsbExhYmVsLCByID0gam4odGhpcy5vcHRpb25zKSwgYSA9ICExLCBsID0gITEsIGMgPSBudWxsLCBkID0gbnVsbCwgXyA9IG51bGw7XG4gICAgcmV0dXJuIG5ldyBzYShcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBvLFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsLFxuICAgICAgYyxcbiAgICAgIGQsXG4gICAgICBfXG4gICAgKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3JlbW92ZUNvbXBvbmVudEV2ZW50cygpLCB0aGlzLl9kZXN0cm95TWF0ZXJpYWxTZWxlY3QoKSwgdGhpcy5fbGlzdGVuVG9Gb2N1c0NoYW5nZSghMSksIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCByaSk7XG4gIH1cbiAgX3JlbW92ZUNvbXBvbmVudEV2ZW50cygpIHtcbiAgICB1Lm9mZih0aGlzLmlucHV0LCBcImNsaWNrXCIpLCB1Lm9mZih0aGlzLndyYXBwZXIsIHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKSksIHUub2ZmKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiksIHUub2ZmKHRoaXMuY2xlYXJCdXR0b24sIFwia2V5ZG93blwiKSwgdS5vZmYod2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemUuYmluZCh0aGlzKSk7XG4gIH1cbiAgX2Rlc3Ryb3lNYXRlcmlhbFNlbGVjdCgpIHtcbiAgICB0aGlzLl9pc09wZW4gJiYgdGhpcy5jbG9zZSgpLCB0aGlzLl9kZXN0cm95TWF0ZXJpYWxUZW1wbGF0ZSgpO1xuICB9XG4gIF9kZXN0cm95TWF0ZXJpYWxUZW1wbGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fd3JhcHBlci5wYXJlbnROb2RlLCBlID0gaC5maW5kKFwibGFiZWxcIiwgdGhpcy5fd3JhcHBlcik7XG4gICAgdC5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KSwgZS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICB0LmFwcGVuZENoaWxkKGkpO1xuICAgIH0pLCBlLmZvckVhY2goKGkpID0+IHtcbiAgICAgIGkucmVtb3ZlQXR0cmlidXRlKHEpO1xuICAgIH0pLCBwLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaW5pdGlhbGl6ZWQpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUFjdGl2ZVN0eWxlcyhhYSksIHQucmVtb3ZlQ2hpbGQodGhpcy5fd3JhcHBlcik7XG4gIH1cbiAgc2V0VmFsdWUodCkge1xuICAgIHRoaXMub3B0aW9ucy5maWx0ZXIoKGkpID0+IGkuc2VsZWN0ZWQpLmZvckVhY2goKGkpID0+IGkubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITEpLCBBcnJheS5pc0FycmF5KHQpID8gdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICB0aGlzLl9zZWxlY3RCeVZhbHVlKGkpO1xuICAgIH0pIDogdGhpcy5fc2VsZWN0QnlWYWx1ZSh0KSwgdGhpcy5fdXBkYXRlU2VsZWN0aW9ucygpO1xuICB9XG4gIF9zZWxlY3RCeVZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLmZpbmQoXG4gICAgICAoaSkgPT4gaS52YWx1ZSA9PT0gdFxuICAgICk7XG4gICAgcmV0dXJuIGUgPyAoZS5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMCwgITApIDogITE7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gSS5nZXREYXRhKHRoaXMsIHJpKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgTmwodGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgcmkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IFltID0gKHMpID0+IHtcbiAgQWEoKCkgPT4ge1xuICAgIGNvbnN0IHQgPSBDYSgpO1xuICAgIGlmICh0KSB7XG4gICAgICBjb25zdCBlID0gcy5OQU1FLCBpID0gdC5mbltlXTtcbiAgICAgIHQuZm5bZV0gPSBzLmpRdWVyeUludGVyZmFjZSwgdC5mbltlXS5Db25zdHJ1Y3RvciA9IHMsIHQuZm5bZV0ubm9Db25mbGljdCA9ICgpID0+ICh0LmZuW2VdID0gaSwgcy5qUXVlcnlJbnRlcmZhY2UpO1xuICAgIH1cbiAgfSk7XG59LCBqbSA9IChzLCB0KSA9PiB7XG4gIHUub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCksIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS50b2dnbGUoKTtcbiAgICB9XG4gICk7XG59LCBLbSA9IChzLCB0KSA9PiB7XG4gIHUub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBlLnByZXZlbnREZWZhdWx0KCksIHVlKHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykuc2hvdygpO1xuICAgIH1cbiAgKTtcbn0sIFVtID0gKHMsIHQpID0+IHtcbiAgdS5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9LmRhdGEtYXBpYCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGNvbnN0IGkgPSBYdCh0aGlzKTtcbiAgICAgIGlmIChbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgdWUodGhpcykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHUub25lKGksIHMuRVZFTlRfSElEREVOLCAoKSA9PiB7XG4gICAgICAgIFN0KHRoaXMpICYmIHRoaXMuZm9jdXMoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbiA9IGguZmluZE9uZShzLk9QRU5fU0VMRUNUT1IpO1xuICAgICAgbiAmJiBuICE9PSBpICYmIHMuZ2V0SW5zdGFuY2UobikuaGlkZSgpLCBzLmdldE9yQ3JlYXRlSW5zdGFuY2UoaSkudG9nZ2xlKHRoaXMpO1xuICAgIH1cbiAgKTtcbn0sIHptID0gKHMsIHQpID0+IHtcbiAgdS5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9YCxcbiAgICB0LFxuICAgIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBpID0gZS50YXJnZXQuY2xvc2VzdCh0KTtcbiAgICAgIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKS50b2dnbGUoKTtcbiAgICB9XG4gICk7XG59LCBYbSA9IChzLCB0KSA9PiB7XG4gIHUub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBjb25zdCBpID0gWHQodGhpcyk7XG4gICAgICBbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgdS5vbmUoaSwgcy5FVkVOVF9TSE9XLCAocikgPT4ge1xuICAgICAgICByLmRlZmF1bHRQcmV2ZW50ZWQgfHwgdS5vbmUoaSwgcy5FVkVOVF9ISURERU4sICgpID0+IHtcbiAgICAgICAgICBTdCh0aGlzKSAmJiB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBuID0gaC5maW5kT25lKFxuICAgICAgICBgWyR7cy5PUEVOX1NFTEVDVE9SfT1cInRydWVcIl1gXG4gICAgICApO1xuICAgICAgbiAmJiBzLmdldEluc3RhbmNlKG4pLmhpZGUoKSwgcy5nZXRPckNyZWF0ZUluc3RhbmNlKGkpLnRvZ2dsZSh0aGlzKTtcbiAgICB9XG4gICk7XG59LCBHbSA9IChzLCB0KSA9PiB7XG4gIHUub25lKFxuICAgIGRvY3VtZW50LFxuICAgIFwibW91c2Vkb3duXCIsXG4gICAgdCxcbiAgICBzLmF1dG9Jbml0aWFsKG5ldyBzKCkpXG4gICk7XG59LCBxbSA9IChzLCB0KSA9PiB7XG4gIHUub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICAoZS50YXJnZXQudGFnTmFtZSA9PT0gXCJBXCIgfHwgZS5kZWxlZ2F0ZVRhcmdldCAmJiBlLmRlbGVnYXRlVGFyZ2V0LnRhZ05hbWUgPT09IFwiQVwiKSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBpID0gWG4odGhpcyk7XG4gICAgICBoLmZpbmQoaSkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UobywgeyB0b2dnbGU6ICExIH0pLnRvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xufSwgRnQgPSB7XG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBjb2xvcjogXCJyZ2IoMTAyLDEwMiwxMDIpXCJcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sIGdzID0ge1xuICBsaW5lOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uRnQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjApXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgICB0ZW5zaW9uOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICB0b29sdGlwczoge1xuICAgICAgICBpbnRlcnNlY3Q6ICExLFxuICAgICAgICBtb2RlOiBcImluZGV4XCJcbiAgICAgIH0sXG4gICAgICBkYXRhc2V0czoge1xuICAgICAgICBib3JkZXJDb2xvcjogXCJyZWRcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITEsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiYXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5GdCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfSxcbiAgICAgIHRvb2x0aXBzOiB7XG4gICAgICAgIGludGVyc2VjdDogITEsXG4gICAgICAgIG1vZGU6IFwiaW5kZXhcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwaWU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5GdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGFyYzogeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIiB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRvdWdobnV0OiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uRnQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBhcmM6IHsgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2xhckFyZWE6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5GdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGFyYzogeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIiB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJhZGFyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uRnQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMlxuICAgICAgICB9LFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2F0dGVyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uRnQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgICB0ZW5zaW9uOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICB0b29sdGlwczoge1xuICAgICAgICBpbnRlcnNlY3Q6ICExLFxuICAgICAgICBtb2RlOiBcImluZGV4XCJcbiAgICAgIH0sXG4gICAgICBkYXRhc2V0czoge1xuICAgICAgICBib3JkZXJDb2xvcjogXCJyZWRcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITEsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBidWJibGU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5GdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIGRyYXdCb3JkZXI6ICExLFxuICAgICAgICAgICAgemVyb0xpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogWzJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSwgUW0gPSAocywgdCkgPT4ge1xuICBjb25zdCBlID0gKG8pID0+IG9bMF0gPT09IFwie1wiICYmIG9bby5sZW5ndGggLSAxXSA9PT0gXCJ9XCIgfHwgb1swXSA9PT0gXCJbXCIgJiYgb1tvLmxlbmd0aCAtIDFdID09PSBcIl1cIiwgaSA9IChvKSA9PiB0eXBlb2YgbyAhPSBcInN0cmluZ1wiID8gbyA6IGUobykgPyBKU09OLnBhcnNlKG8ucmVwbGFjZSgvJy9nLCAnXCInKSkgOiBvLCBuID0gKG8pID0+IHtcbiAgICBjb25zdCByID0ge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGlmIChhLm1hdGNoKC9kYXRhc2V0LiovKSkge1xuICAgICAgICBjb25zdCBsID0gYS5zbGljZSg3LCA4KS50b0xvd2VyQ2FzZSgpLmNvbmNhdChhLnNsaWNlKDgpKTtcbiAgICAgICAgcltsXSA9IGkob1thXSk7XG4gICAgICB9XG4gICAgfSksIHI7XG4gIH07XG4gIGguZmluZCh0KS5mb3JFYWNoKChvKSA9PiB7XG4gICAgaWYgKHAuZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImNoYXJ0XCIpICE9PSBcImJ1YmJsZVwiICYmIHAuZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImNoYXJ0XCIpICE9PSBcInNjYXR0ZXJcIikge1xuICAgICAgY29uc3QgciA9IHAuZ2V0RGF0YUF0dHJpYnV0ZXMobyksIGEgPSB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkYXRhc2V0czogW24ocildXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gci5jaGFydCAmJiAoYS50eXBlID0gci5jaGFydCksIHIubGFiZWxzICYmIChhLmRhdGEubGFiZWxzID0gSlNPTi5wYXJzZShyLmxhYmVscy5yZXBsYWNlKC8nL2csICdcIicpKSksIG5ldyBzKG8sIHtcbiAgICAgICAgLi4uYSxcbiAgICAgICAgLi4uZ3NbYS50eXBlXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbn0sIGFpID0ge1xuICBhbGVydDoge1xuICAgIG5hbWU6IFwiQWxlcnRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1hbGVydC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgYW5pbWF0aW9uOiB7XG4gICAgbmFtZTogXCJBbmltYXRlXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtYW5pbWF0aW9uLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBjYXJvdXNlbDoge1xuICAgIG5hbWU6IFwiQ2Fyb3VzZWxcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jYXJvdXNlbC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgY2hpcHM6IHtcbiAgICBuYW1lOiBcIkNoaXBzSW5wdXRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jaGlwcy1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgY2hpcDoge1xuICAgIG5hbWU6IFwiQ2hpcFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNoaXAtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGRhdGVwaWNrZXI6IHtcbiAgICBuYW1lOiBcIkRhdGVwaWNrZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1kYXRlcGlja2VyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBpbnB1dDoge1xuICAgIG5hbWU6IFwiSW5wdXRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1pbnB1dC13cmFwcGVyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBzY3JvbGxzcHk6IHtcbiAgICBuYW1lOiBcIlNjcm9sbFNweVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXNweT0nc2Nyb2xsJ11cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHNlbGVjdDoge1xuICAgIG5hbWU6IFwiU2VsZWN0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtc2VsZWN0LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBzaWRlbmF2OiB7XG4gICAgbmFtZTogXCJTaWRlbmF2XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtc2lkZW5hdi1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc3RlcHBlcjoge1xuICAgIG5hbWU6IFwiU3RlcHBlclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXN0ZXBwZXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHRpbWVwaWNrZXI6IHtcbiAgICBuYW1lOiBcIlRpbWVwaWNrZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10aW1lcGlja2VyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICB0b2FzdDoge1xuICAgIG5hbWU6IFwiVG9hc3RcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2FzdC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgLy8gYWR2YW5jZWRJbml0c1xuICBjaGFydDoge1xuICAgIG5hbWU6IFwiQ2hhcnRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jaGFydF1cIixcbiAgICBpc1RvZ2dsZXI6ICExLFxuICAgIGFkdmFuY2VkOiBRbVxuICB9LFxuICAvLyB0b2dnbGVyc1xuICBidXR0b246IHtcbiAgICBuYW1lOiBcIkJ1dHRvblwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvZ2dsZT0nYnV0dG9uJ11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiB6bVxuICB9LFxuICBjb2xsYXBzZToge1xuICAgIG5hbWU6IFwiQ29sbGFwc2VcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jb2xsYXBzZS1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IHFtXG4gIH0sXG4gIGRyb3Bkb3duOiB7XG4gICAgbmFtZTogXCJEcm9wZG93blwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWRyb3Bkb3duLXRvZ2dsZS1yZWZdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogam1cbiAgfSxcbiAgbW9kYWw6IHtcbiAgICBuYW1lOiBcIk1vZGFsXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdtb2RhbCddXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogWG1cbiAgfSxcbiAgcmlwcGxlOiB7XG4gICAgbmFtZTogXCJSaXBwbGVcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1yaXBwbGUtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBHbVxuICB9LFxuICBvZmZjYW52YXM6IHtcbiAgICBuYW1lOiBcIk9mZmNhbnZhc1wiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLW9mZmNhbnZhcy10b2dnbGVdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogVW1cbiAgfSxcbiAgdGFiOiB7XG4gICAgbmFtZTogXCJUYWJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3RhYiddLCBbZGF0YS10ZS10b2dnbGU9J3BpbGwnXSwgW2RhdGEtdGUtdG9nZ2xlPSdsaXN0J11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBLbVxuICB9XG59LCBabSA9IChzKSA9PiBhaVtzLk5BTUVdIHx8IG51bGwsIEptID0gKHMpID0+IHtcbiAgaWYgKCFzIHx8IFtdLmluY2x1ZGVzKHMuTkFNRSkpXG4gICAgcmV0dXJuO1xuICBbXS5wdXNoKHMuTkFNRSk7XG4gIGNvbnN0IHQgPSBabShzKSwgZSA9ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmlzVG9nZ2xlcikgfHwgITE7XG4gIGlmIChZbShzKSwgdCAhPSBudWxsICYmIHQuYWR2YW5jZWQpIHtcbiAgICB0ID09IG51bGwgfHwgdC5hZHZhbmNlZChzLCB0ID09IG51bGwgPyB2b2lkIDAgOiB0LnNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGUpIHtcbiAgICB0ID09IG51bGwgfHwgdC5jYWxsYmFjayhzLCB0ID09IG51bGwgPyB2b2lkIDAgOiB0LnNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaC5maW5kKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuc2VsZWN0b3IpLmZvckVhY2goKGkpID0+IHtcbiAgICBsZXQgbiA9IHMuZ2V0SW5zdGFuY2UoaSk7XG4gICAgbiB8fCAobiA9IG5ldyBzKGkpKTtcbiAgfSk7XG59LCB0ZyA9IChzKSA9PiB7XG4gIHMuZm9yRWFjaCgodCkgPT4gSm0odCkpO1xufSwgZWcgPSAocywgdCA9ICExKSA9PiB7XG4gIGNvbnN0IGUgPSBPYmplY3Qua2V5cyhhaSkubWFwKChpKSA9PiB7XG4gICAgaWYgKCEhZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKGFpW2ldLnNlbGVjdG9yKSkge1xuICAgICAgY29uc3QgbyA9IHNbYWlbaV0ubmFtZV07XG4gICAgICByZXR1cm4gIW8gJiYgIVtdLmluY2x1ZGVzKGkpICYmIHQgJiYgY29uc29sZS53YXJuKFxuICAgICAgICBgUGxlYXNlIGltcG9ydCAke2FpW2ldLm5hbWV9IGZyb20gXCJ0dy1lbGVtZW50c1wiIHBhY2thZ2UgYW5kIGFkZCBpdCB0byBhIG9iamVjdCBwYXJhbWV0ZXIgaW5zaWRlIFwiaW5pdFRFXCIgZnVuY3Rpb25gXG4gICAgICApLCBvO1xuICAgIH1cbiAgfSk7XG4gIHRnKGUpO1xufSwgaWcgPSAoeyBpbnB1dElEOiBzLCBsYWJlbFRleHQ6IHQgfSwgZSkgPT4gKGVnKHsgSW5wdXQ6IFYgfSwgITEpLCBgPGRpdiBkYXRhLXRlLWNoaXBzLWlucHV0LXdyYXBwZXIgZGF0YS10ZS1pbnB1dC13cmFwcGVyLWluaXQgY2xhc3M9XCIke2UuY2hpcHNJbnB1dFdyYXBwZXJ9XCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgY2xhc3M9XCIke2UuY2hpcHNJbnB1dH1cIlxuICAgICAgICAgIGlkPVwiJHtzfVwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJFeGFtcGxlIGxhYmVsXCIgLz5cbiAgICAgICAgPGxhYmVsXG4gICAgICAgICAgZm9yPVwiJHtzfVwiXG4gICAgICAgICAgY2xhc3M9XCIke2UuY2hpcHNMYWJlbH1cIlxuICAgICAgICAgID4ke3R9XG4gICAgICAgIDwvbGFiZWw+XG5cbiAgICAgICAgPGRpdiBkYXRhLXRlLWlucHV0LW5vdGNoLXJlZiBjbGFzcz1cIiR7ZS5jaGlwc05vdGNoZXNXcmFwcGVyfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtlLmNoaXBzTm90Y2hlc0xlYWRpbmd9XCIgZGF0YS10ZS1pbnB1dC1ub3RjaC1sZWFkaW5nLXJlZiBzdHlsZT1cIndpZHRoOiA5cHg7XCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke2UuY2hpcHNOb3RjaGVzTWlkZGxlfVwiIGRhdGEtdGUtaW5wdXQtbm90Y2gtbWlkZGxlLXJlZiBzdHlsZT1cIndpZHRoOiA4Ny4ycHg7XCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke2UuY2hpcHNOb3RjaGVzVHJhaWxpbmd9XCIgZGF0YS10ZS1pbnB1dC1ub3RjaC10cmFpbGluZy1yZWY+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5gKSwgc2cgPSAoeyB0ZXh0OiBzLCBpY29uU1ZHOiB0IH0sIGUpID0+IGA8ZGl2IGRhdGEtdGUtY2hpcC1pbml0IGRhdGEtdGUtcmlwcGxlLWluaXQgY2xhc3M9XCIke2UuY2hpcEVsZW1lbnR9XCI+XG4gICAgPHNwYW4gZGF0YS10ZS1jaGlwLXRleHQ+JHtzfTwvc3Bhbj4gXG4gICAgICA8c3BhbiBkYXRhLXRlLWNoaXAtY2xvc2UgY2xhc3M9XCIke2UuY2hpcENsb3NlSWNvbn1cIj5cbiAgICAgICAgJHt0fVxuICAgICAgPC9zcGFuPlxuICA8L2Rpdj5gLCBicyA9IFwiY2hpcFwiLCBuZyA9IGB0ZS4ke2JzfWAsIFJsID0gXCJkYXRhLXRlLWNoaXAtY2xvc2VcIiwgT24gPSBgWyR7Umx9XWAsIG9nID0gXCJkZWxldGUudGUuY2hpcHNcIiwgcmcgPSBcInNlbGVjdC50ZS5jaGlwXCIsIGFnID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy0zIGgtM1wiPiA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTYgMThMMTggNk02IDZsMTIgMTJcIiAvPjwvc3ZnPicsIGxnID0ge1xuICB0ZXh0OiBcInN0cmluZ1wiLFxuICBjbG9zZUljb246IFwiYm9vbGVhblwiLFxuICBpbWc6IFwib2JqZWN0XCIsXG4gIGljb25TVkc6IFwic3RyaW5nXCJcbn0sIGNnID0ge1xuICB0ZXh0OiBcIlwiLFxuICBjbG9zZUljb246ICExLFxuICBpbWc6IHsgcGF0aDogXCJcIiwgYWx0OiBcIlwiIH0sXG4gIGljb25TVkc6IGFnXG59LCBkZyA9IHtcbiAgaWNvbjogXCJmbG9hdC1yaWdodCBwbC1bOHB4XSB0ZXh0LVsxNnB4XSBvcGFjaXR5LVsuNTNdIGN1cnNvci1wb2ludGVyIGZpbGwtWyNhZmFmYWZdIGhvdmVyOnRleHQtWyM4YjhiOGJdIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dFwiLFxuICBjaGlwRWxlbWVudDogXCJmbGV4IGp1c3RpZnktYmV0d2VlbiBpdGVtcy1jZW50ZXIgaC1bMzJweF0gbGVhZGluZy1sb29zZSBweS1bNXB4XSBweC1bMTJweF0gbXItNCBteS1bNXB4XSB0ZXh0LVsxM3B4XSBmb250LW5vcm1hbCB0ZXh0LVsjNGY0ZjRmXSBjdXJzb3ItcG9pbnRlciBiZy1bI2VjZWZmMV0gZGFyazp0ZXh0LXdoaXRlIGRhcms6YmctbmV1dHJhbC02MDAgcm91bmRlZC1bMTZweF0gdHJhbnNpdGlvbi1bb3BhY2l0eV0gZHVyYXRpb24tMzAwIGVhc2UtbGluZWFyIFt3b3JkLXdyYXA6IGJyZWFrLXdvcmRdIHNoYWRvdy1ub25lIG5vcm1hbC1jYXNlIGhvdmVyOiFzaGFkb3ctbm9uZSBhY3RpdmU6YmctWyNjYWNmZDFdIGlubGluZS1ibG9jayBmb250LW1lZGl1bSBsZWFkaW5nLW5vcm1hbCB0ZXh0LVsjNGY0ZjRmXSB0ZXh0LWNlbnRlciBuby11bmRlcmxpbmUgYWxpZ24tbWlkZGxlIGN1cnNvci1wb2ludGVyIHNlbGVjdC1ub25lIGJvcmRlci1bLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci10cmFuc3BhcmVudCBweS0xLjUgcHgtMyB0ZXh0LXhzIHJvdW5kZWRcIixcbiAgY2hpcENsb3NlSWNvbjogXCJ3LTQgZmxvYXQtcmlnaHQgcGwtWzhweF0gdGV4dC1bMTZweF0gb3BhY2l0eS1bLjUzXSBjdXJzb3ItcG9pbnRlciBmaWxsLVsjYWZhZmFmXSBob3ZlcjpmaWxsLVsjOGI4YjhiXSBkYXJrOmZpbGwtZ3JheS00MDAgZGFyazpob3ZlcjpmaWxsLWdyYXktMTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dFwiXG59LCBoZyA9IHtcbiAgaWNvbjogXCJzdHJpbmdcIixcbiAgY2hpcEVsZW1lbnQ6IFwic3RyaW5nXCIsXG4gIGNoaXBDbG9zZUljb246IFwic3RyaW5nXCJcbn07XG5jbGFzcyBpaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gYnM7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fYXBwZW5kQ2xvc2VJY29uKCksIHRoaXMuX2hhbmRsZURlbGV0ZSgpLCB0aGlzLl9oYW5kbGVUZXh0Q2hpcCgpLCB0aGlzLl9oYW5kbGVDbGlja09uQ2hpcCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsLCB1Lm9mZih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIpO1xuICB9XG4gIGFwcGVuZENoaXAoKSB7XG4gICAgY29uc3QgeyB0ZXh0OiB0LCBjbG9zZUljb246IGUsIGljb25TVkc6IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgcmV0dXJuIHNnKHsgdGV4dDogdCwgY2xvc2VJY29uOiBlLCBpY29uU1ZHOiBpIH0sIHRoaXMuX2NsYXNzZXMpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2FwcGVuZENsb3NlSWNvbih0ID0gdGhpcy5fZWxlbWVudCkge1xuICAgIGlmICghKGguZmluZChPbiwgdGhpcy5fZWxlbWVudCkubGVuZ3RoID4gMCkgJiYgdGhpcy5fb3B0aW9ucy5jbG9zZUljb24pIHtcbiAgICAgIGNvbnN0IGUgPSBNKFwic3BhblwiKTtcbiAgICAgIGUuY2xhc3NMaXN0ID0gdGhpcy5fY2xhc3Nlcy5pY29uLCBlLnNldEF0dHJpYnV0ZShSbCksIGUuaW5uZXJIVE1MID0gdGhpcy5fb3B0aW9ucy5pY29uU1ZHLCB0Lmluc2VydEFkamFjZW50RWxlbWVudChcImJlZm9yZWVuZFwiLCBlKTtcbiAgICB9XG4gIH1cbiAgX2hhbmRsZUNsaWNrT25DaGlwKCkge1xuICAgIHUub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgY29uc3QgeyB0ZXh0Q29udGVudDogZSB9ID0gdC50YXJnZXQsIGkgPSB7fTtcbiAgICAgIGkudGFnID0gZS50cmltKCksIHUudHJpZ2dlcihyZywgeyBldmVudDogdCwgb2JqOiBpIH0pO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVEZWxldGUoKSB7XG4gICAgaC5maW5kKFxuICAgICAgT24sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKS5sZW5ndGggIT09IDAgJiYgdS5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIE9uLCAoKSA9PiB7XG4gICAgICB1LnRyaWdnZXIodGhpcy5fZWxlbWVudCwgb2cpLCB0aGlzLl9lbGVtZW50LnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVUZXh0Q2hpcCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LmlubmVyVGV4dCA9PT0gXCJcIiAmJiAodGhpcy5fZWxlbWVudC5pbm5lclRleHQgPSB0aGlzLl9vcHRpb25zLnRleHQpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5jZyxcbiAgICAgIC4uLnAuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gTihicywgZSwgbGcpLCBlO1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gcC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZGcsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIE4oYnMsIHQsIGhnKSwgdDtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBJLmdldERhdGEodCwgbmcpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IHVpID0gXCJjaGlwc1wiLCB5aSA9IGBkYXRhLXRlLSR7dWl9YCwgdWEgPSBgdGUuJHt1aX1gLCB1ZyA9IGAke3lpfS1pbml0YCwgZnQgPSBgJHt5aX0tYWN0aXZlYCwgcGEgPSBgJHt5aX0taW5pdGlhbGAsIFBsID0gYCR7eWl9LXBsYWNlaG9sZGVyYCwgcGcgPSBgJHt5aX0taW5wdXQtd3JhcHBlcmAsIEtuID0gXCJkYXRhLXRlLWNoaXAtaW5pdFwiLCBIbCA9IFwiZGF0YS10ZS1jaGlwLWNsb3NlXCIsIEJsID0gXCJkYXRhLXRlLWNoaXAtdGV4dFwiLCBmZyA9IGBbJHtmdH1dYCwgVW4gPSBgWyR7S259XWAsIF9nID0gYCR7VW59JHtmZ31gLCB4biA9IGBbJHtIbH1dYCwgbWcgPSBgWyR7cGd9XWAsIGdnID0gYFske0JsfV1gLCBiZyA9IGBbJHtQbH1dYCwgdmcgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtbGVhZGluZy1yZWZcIiwgRWcgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtbWlkZGxlLXJlZlwiLCBUZyA9IGBbJHt2Z31dYCwgQ2cgPSBgWyR7RWd9XWAsIEFlID0gXCJkYXRhLXRlLWlucHV0LXN0YXRlLWFjdGl2ZVwiLCBTbiA9IFwiW2RhdGEtdGUtaW5wdXQtbm90Y2gtcmVmXVwiLCBBZyA9IFwiYWRkLnRlLmNoaXBzXCIsIHlnID0gXCJhcnJvd0Rvd24udGUuY2hpcHNcIiwgd2cgPSBcImFycm93TGVmdC50ZS5jaGlwc1wiLCBrZyA9IFwiYXJyb3dSaWdodC50ZS5jaGlwc1wiLCBPZyA9IFwiYXJyb3dVcC50ZS5jaGlwc1wiLCBmYSA9IFwiZGVsZXRlLnRlLmNoaXBzXCIsIF9hID0gXCJzZWxlY3QudGUuY2hpcHNcIiwgeGcgPSB7XG4gIGlucHV0SUQ6IFwic3RyaW5nXCIsXG4gIHBhcmVudFNlbGVjdG9yOiBcInN0cmluZ1wiLFxuICBpbml0aWFsVmFsdWVzOiBcImFycmF5XCIsXG4gIGVkaXRhYmxlOiBcImJvb2xlYW5cIixcbiAgbGFiZWxUZXh0OiBcInN0cmluZ1wiXG59LCBTZyA9IHtcbiAgaW5wdXRJRDogT3QoXCJjaGlwcy1pbnB1dC1cIiksXG4gIHBhcmVudFNlbGVjdG9yOiBcIlwiLFxuICBpbml0aWFsVmFsdWVzOiBbeyB0YWc6IFwiaW5pdDFcIiB9LCB7IHRhZzogXCJpbml0MlwiIH1dLFxuICBlZGl0YWJsZTogITEsXG4gIGxhYmVsVGV4dDogXCJFeGFtcGxlIGxhYmVsXCJcbn0sIERnID0ge1xuICBvcGFjaXR5OiBcIm9wYWNpdHktMFwiLFxuICBpbnB1dFdyYXBwZXJQYWRkaW5nOiBcInAtWzVweF1cIixcbiAgdHJhbnNpdGlvbjogXCJ0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMSldXCIsXG4gIGNvbnRlbnRFZGl0YWJsZTogXCJvdXRsaW5lLW5vbmUgIWJvcmRlci1bM3B4XSAhYm9yZGVyLXNvbGlkICFib3JkZXItWyNiMmIzYjRdXCIsXG4gIGNoaXBzSW5wdXRXcmFwcGVyOiBcInJlbGF0aXZlIGZsZXggaXRlbXMtY2VudGVyIGZsZXgtd3JhcCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMSldXCIsXG4gIGNoaXBzSW5wdXQ6IFwicGVlciBibG9jayBtaW4taC1bYXV0b10gdy1bMTUwcHhdIHJvdW5kZWQgYm9yZGVyLTAgYmctdHJhbnNwYXJlbnQgcHktWzAuMzJyZW1dIHB4LTMgbGVhZGluZy1bMS42XSBvdXRsaW5lLW5vbmUgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIGZvY3VzOnBsYWNlaG9sZGVyOm9wYWNpdHktMTAwIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGxhY2Vob2xkZXI6dGV4dC1ncmF5LTIwMCBbJjpub3QoW2RhdGEtdGUtaW5wdXQtcGxhY2Vob2xkZXItYWN0aXZlXSldOnBsYWNlaG9sZGVyOm9wYWNpdHktMFwiLFxuICBjaGlwc0xhYmVsOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG9wLTAgbGVmdC0zIG1iLTAgbWF4LXctWzkwJV0gb3JpZ2luLVswXzBdIHRydW5jYXRlIHB0LVswLjM3cmVtXSBsZWFkaW5nLVsxLjZdIHRleHQtZ3JheS01MDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2Utb3V0IHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVswLjlyZW1dIHBlZXItZm9jdXM6c2NhbGUtWzAuOF0gcGVlci1mb2N1czp0ZXh0LXByaW1hcnkgcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC45cmVtXSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06c2NhbGUtWzAuOF0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGVlci1mb2N1czp0ZXh0LWdyYXktMjAwXCIsXG4gIGNoaXBzTm90Y2hlc1dyYXBwZXI6IFwiZ3JvdXAgZmxleCBhYnNvbHV0ZSBsZWZ0LTAgdG9wLTAgdy1mdWxsIG1heC13LWZ1bGwgaC1mdWxsIHRleHQtbGVmdCBwb2ludGVyLWV2ZW50cy1ub25lXCIsXG4gIGNoaXBzTm90Y2hlc0xlYWRpbmc6IFwicG9pbnRlci1ldmVudHMtbm9uZSBib3JkZXIgYm9yZGVyLXNvbGlkIGJveC1ib3JkZXIgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGxlZnQtMCB0b3AtMCBoLWZ1bGwgdy0yIGJvcmRlci1yLTAgcm91bmRlZC1sLVswLjI1cmVtXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItci0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXItMCBib3JkZXItZ3JheS0zMDAgZGFyazpib3JkZXItZ3JheS02MDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVstMXB4XzBfMF8jM2I3MWNhLF8wXzFweF8wXzBfIzNiNzFjYSxfMF8tMXB4XzBfMF8jM2I3MWNhXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxuICBjaGlwc05vdGNoZXNNaWRkbGU6IFwicG9pbnRlci1ldmVudHMtbm9uZSBib3JkZXIgYm9yZGVyLXNvbGlkIGJveC1ib3JkZXIgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGdyb3ctMCBzaHJpbmstMCBiYXNpcy1hdXRvIHctYXV0byBtYXgtdy1bY2FsYygxMDAlLTFyZW0pXSBoLWZ1bGwgYm9yZGVyLXItMCBib3JkZXItbC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci14LTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXIteC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci10IGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXNvbGlkIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXNvbGlkIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci10LXRyYW5zcGFyZW50IGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXQtdHJhbnNwYXJlbnQgYm9yZGVyLWdyYXktMzAwIGRhcms6Ym9yZGVyLWdyYXktNjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMF8xcHhfMF8wXyMzYjcxY2FdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCIsXG4gIGNoaXBzTm90Y2hlc1RyYWlsaW5nOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBncm93IGgtZnVsbCBib3JkZXItbC0wIHJvdW5kZWQtci1bMC4yNXJlbV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLWwtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci1sLTAgYm9yZGVyLWdyYXktMzAwIGRhcms6Ym9yZGVyLWdyYXktNjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jM2I3MWNhLF8wXy0xcHhfMF8wXyMzYjcxY2EsXzBfMXB4XzBfMF8jM2I3MWNhXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiXG59LCBJZyA9IHtcbiAgb3BhY2l0eTogXCJzdHJpbmdcIixcbiAgaW5wdXRXcmFwcGVyUGFkZGluZzogXCJzdHJpbmdcIixcbiAgdHJhbnNpdGlvbjogXCJzdHJpbmdcIixcbiAgY29udGVudEVkaXRhYmxlOiBcInN0cmluZ1wiLFxuICBjaGlwc0lucHV0V3JhcHBlcjogXCJzdHJpbmdcIixcbiAgY2hpcHNJbnB1dDogXCJzdHJpbmdcIixcbiAgY2hpcHNMYWJlbDogXCJzdHJpbmdcIixcbiAgY2hpcHNOb3RjaGVzV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgY2hpcHNOb3RjaGVzTGVhZGluZzogXCJzdHJpbmdcIixcbiAgY2hpcHNOb3RjaGVzTWlkZGxlOiBcInN0cmluZ1wiLFxuICBjaGlwc05vdGNoZXNUcmFpbGluZzogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFpnIGV4dGVuZHMgaWkge1xuICBjb25zdHJ1Y3RvcihlLCBpID0ge30sIG4pIHtcbiAgICBzdXBlcihlLCBpKTtcbiAgICBUdCh0aGlzLCBcIl9oYW5kbGVCbHVySW5wdXRcIiwgKHsgdGFyZ2V0OiBlIH0pID0+IHtcbiAgICAgIGUudmFsdWUubGVuZ3RoID4gMCAmJiB0aGlzLl9oYW5kbGVDcmVhdGVDaGlwKGUsIGUudmFsdWUpLCB0aGlzLmFsbENoaXBzLmxlbmd0aCA+IDAgPyAoZS5zZXRBdHRyaWJ1dGUoZnQsIFwiXCIpLCB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShBZSwgXCJcIiksIGguZmluZE9uZShcbiAgICAgICAgU24sXG4gICAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZVxuICAgICAgKS5zZXRBdHRyaWJ1dGUoQWUsIFwiXCIpLCB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICAgICkpIDogKGUucmVtb3ZlQXR0cmlidXRlKGZ0KSwgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoQWUpLCBoLmZpbmRPbmUoXG4gICAgICAgIFNuLFxuICAgICAgICB0aGlzLmlucHV0LnBhcmVudE5vZGVcbiAgICAgICkucmVtb3ZlQXR0cmlidXRlKEFlKSwgdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgICApKSwgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChpKSA9PiBpLnJlbW92ZUF0dHJpYnV0ZShmdCkpO1xuICAgIH0pO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlLCB0aGlzLl9sYWJlbCA9IG51bGwsIHRoaXMuX2xhYmVsV2lkdGggPSAwLCB0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSAwLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBudWxsLCB0aGlzLl9ub3RjaE1pZGRsZSA9IG51bGwsIHRoaXMuX2VsZW1lbnQgJiYgSS5zZXREYXRhKGUsIHVhLCB0aGlzKSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhpKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMobiksIHRoaXMubnVtYmVyQ2xpY2tzID0gMCwgdGhpcy5pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHVpO1xuICB9XG4gIGdldCBhY3RpdmVDaGlwKCkge1xuICAgIHJldHVybiBoLmZpbmRPbmUoX2csIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBpbnB1dCgpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGFsbENoaXBzKCkge1xuICAgIHJldHVybiBoLmZpbmQoVW4sIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBjaGlwc0lucHV0V3JhcHBlcigpIHtcbiAgICByZXR1cm4gaC5maW5kT25lKG1nLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9zZXRDaGlwc0NsYXNzKCksIHRoaXMuX2FwcGVuZElucHV0VG9FbGVtZW50KFBsKSwgdGhpcy5faGFuZGxlSW5pdGlhbFZhbHVlKCksIHRoaXMuX2hhbmRsZUlucHV0VGV4dCgpLCB0aGlzLl9oYW5kbGVLZXlib2FyZCgpLCB0aGlzLl9oYW5kbGVDaGlwc09uU2VsZWN0KCksIHRoaXMuX2hhbmRsZUVkaXRhYmxlKCksIHRoaXMuX2hhbmRsZUNoaXBzRm9jdXMoKSwgdGhpcy5faGFuZGxlQ2xpY2tzT25DaGlwcygpLCB0aGlzLl9nZXRMYWJlbERhdGEoKSwgdGhpcy5fZ2V0TGFiZWxXaWR0aCgpLCB0aGlzLl9nZXROb3RjaERhdGEoKSwgdGhpcy5fYXBwbHlOb3RjaCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldE5vdGNoRGF0YSgpIHtcbiAgICB0aGlzLl9ub3RjaE1pZGRsZSA9IGguZmluZE9uZShcbiAgICAgIENnLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX25vdGNoTGVhZGluZyA9IGguZmluZE9uZShcbiAgICAgIFRnLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gIH1cbiAgX2dldExhYmVsRGF0YSgpIHtcbiAgICB0aGlzLl9sYWJlbCA9IGguZmluZE9uZShcImxhYmVsXCIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9nZXRMYWJlbFdpZHRoKCkge1xuICAgIHRoaXMuX2xhYmVsV2lkdGggPSB0aGlzLl9sYWJlbC5jbGllbnRXaWR0aCAqIDAuOCArIDg7XG4gIH1cbiAgX2FwcGx5Tm90Y2goKSB7XG4gICAgdGhpcy5fbm90Y2hNaWRkbGUuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9sYWJlbFdpZHRofXB4YCwgdGhpcy5fbm90Y2hMZWFkaW5nLnN0eWxlLndpZHRoID0gYCR7dGhpcy5fbGFiZWxNYXJnaW5MZWZ0ICsgOX1weGAsIHRoaXMuX2xhYmVsICE9PSBudWxsICYmICh0aGlzLl9sYWJlbC5zdHlsZS5tYXJnaW5MZWZ0ID0gYCR7dGhpcy5fbGFiZWxNYXJnaW5MZWZ0fXB4YCk7XG4gIH1cbiAgX3NldENoaXBzQ2xhc3MoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUodWcsIFwiXCIpO1xuICB9XG4gIF9oYW5kbGVEZWxldGVFdmVudHMoZSkge1xuICAgIGNvbnN0IFtpXSA9IHRoaXMuYWxsQ2hpcHMuc2xpY2UoLTEpO1xuICAgIGlmICh0aGlzLmFjdGl2ZUNoaXAgPT09IG51bGwpXG4gICAgICBpLnJlbW92ZSgpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgZmEpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbiA9IHRoaXMuYWxsQ2hpcHMuZmluZEluZGV4KChhKSA9PiBhID09PSB0aGlzLmFjdGl2ZUNoaXApLCBvID0gdGhpcy5faGFuZGxlQWN0aXZlQ2hpcEFmdGVyUmVtb3ZlKG4pLCByID0gW107XG4gICAgICBpZiAodGhpcy5hY3RpdmVDaGlwID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmFjdGl2ZUNoaXAucmVtb3ZlKCksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBmYSksIHRoaXMubnVtYmVyQ2xpY2tzID0gbiwgby5zZXRBdHRyaWJ1dGUoZnQsIFwiXCIpLCB0aGlzLmFsbENoaXBzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgYS5oYXNBdHRyaWJ1dGUoZnQpICYmIChyLnB1c2goYSksIHIubGVuZ3RoID4gMSAmJiB0aGlzLmFsbENoaXBzLmZvckVhY2goKGwpID0+IGwucmVtb3ZlKCkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlVXBFdmVudHMoZSkge1xuICAgIHRoaXMubnVtYmVyQ2xpY2tzICs9IDEsIHRoaXMubnVtYmVyQ2xpY2tzID09PSB0aGlzLmFsbENoaXBzLmxlbmd0aCArIDEgJiYgKHRoaXMubnVtYmVyQ2xpY2tzID0gMCksIHRoaXMuX2hhbmRsZVJpZ2h0S2V5Ym9hcmRBcnJvdyh0aGlzLm51bWJlckNsaWNrcyksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBrZyksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBPZyk7XG4gIH1cbiAgX2hhbmRsZURvd25FdmVudHMoZSkge1xuICAgIHRoaXMubnVtYmVyQ2xpY2tzIC09IDEsIHRoaXMubnVtYmVyQ2xpY2tzIDw9IDAgJiYgKHRoaXMubnVtYmVyQ2xpY2tzID0gdGhpcy5hbGxDaGlwcy5sZW5ndGgpLCB0aGlzLl9oYW5kbGVMZWZ0S2V5Ym9hcmRBcnJvdyh0aGlzLm51bWJlckNsaWNrcyksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCB3ZyksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCB5Zyk7XG4gIH1cbiAgX2tleWJvYXJkRXZlbnRzKGUpIHtcbiAgICBjb25zdCB7IHRhcmdldDogaSwga2V5Q29kZTogbiwgY3RybEtleTogbyB9ID0gZTtcbiAgICBpLnZhbHVlLmxlbmd0aCA+IDAgfHwgdGhpcy5hbGxDaGlwcy5sZW5ndGggPT09IDAgfHwgKG4gPT09IFhwIHx8IG4gPT09IEdwID8gdGhpcy5faGFuZGxlRGVsZXRlRXZlbnRzKGUpIDogbiA9PT0gJGUgfHwgbiA9PT0gcnQgPyB0aGlzLl9oYW5kbGVVcEV2ZW50cyhlKSA6IG4gPT09IEllIHx8IG4gPT09IFUgPyB0aGlzLl9oYW5kbGVEb3duRXZlbnRzKGUpIDogbiA9PT0gNjUgJiYgbyAmJiB0aGlzLl9oYW5kbGVBZGRBY3RpdmVDbGFzcygpKTtcbiAgfVxuICBfaGFuZGxlS2V5Ym9hcmQoKSB7XG4gICAgdS5vbihcbiAgICAgIHRoaXMuaW5wdXQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIChlKSA9PiB0aGlzLl9rZXlib2FyZEV2ZW50cyhlKVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUVkaXRhYmxlKCkge1xuICAgIGNvbnN0IHsgZWRpdGFibGU6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgZSAmJiB0aGlzLmFsbENoaXBzLmZvckVhY2goKGkpID0+IHtcbiAgICAgIHUub24oaSwgXCJkYmxjbGlja1wiLCAobikgPT4ge1xuICAgICAgICBjb25zdCBvID0gaC5maW5kT25lKHhuLCBpKTtcbiAgICAgICAgaS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuY29udGVudEVkaXRhYmxlLnNwbGl0KFwiIFwiKSksIGkuY29udGVudEVkaXRhYmxlID0gITAsIGkuZm9jdXMoKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcC5hZGRTdHlsZShvLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pO1xuICAgICAgICB9LCAyMDApLCBvLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSksIG4udGFyZ2V0LnRleHRDb250ZW50LCB1LnRyaWdnZXIoaSwgX2EsIHtcbiAgICAgICAgICBldmVudDogbixcbiAgICAgICAgICBhbGxDaGlwczogdGhpcy5hbGxDaGlwc1xuICAgICAgICB9KTtcbiAgICAgIH0pLCB1Lm9uKGRvY3VtZW50LCBcImNsaWNrXCIsICh7IHRhcmdldDogbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBoLmZpbmRPbmUoeG4sIGkpLCByID0gaC5maW5kT25lKGdnLCBpKSwgYSA9IG4gPT09IGksIGwgPSBpICYmIGkuY29udGFpbnMobik7XG4gICAgICAgICFhICYmICFsICYmIChpLmNvbnRlbnRFZGl0YWJsZSA9ICExLCBpLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5jb250ZW50RWRpdGFibGUuc3BsaXQoXCIgXCIpKSwgci50ZXh0Q29udGVudCAhPT0gXCJcIiAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBwLmFkZFN0eWxlKG8sIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCBvLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH0sIDE2MCkpLCByLnRleHRDb250ZW50ID09PSBcIlwiICYmIChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH0sIDIwMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGkucmVtb3ZlKCk7XG4gICAgICAgIH0sIDMwMCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCkge1xuICAgIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmVBdHRyaWJ1dGUoZnQpKTtcbiAgfVxuICBfaGFuZGxlQWRkQWN0aXZlQ2xhc3MoKSB7XG4gICAgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChlKSA9PiBlLnNldEF0dHJpYnV0ZShmdCwgXCJcIikpO1xuICB9XG4gIF9oYW5kbGVSaWdodEtleWJvYXJkQXJyb3coZSkge1xuICAgIHRoaXMuX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCksIGUgPT09IDAgJiYgKGUgPSAxKSwgdGhpcy5faGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpO1xuICB9XG4gIF9oYW5kbGVMZWZ0S2V5Ym9hcmRBcnJvdyhlKSB7XG4gICAgdGhpcy5faGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSwgdGhpcy5faGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpO1xuICB9XG4gIF9oYW5kbGVBY3RpdmVDaGlwQWZ0ZXJSZW1vdmUoZSkge1xuICAgIGNvbnN0IGkgPSBlID09PSAwID8gMSA6IGUgLSAxO1xuICAgIHJldHVybiB0aGlzLmFsbENoaXBzW2ldO1xuICB9XG4gIF9oYW5kbGVDbGlja3NPbkNoaXBzKCkge1xuICAgIHUub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmFsbENoaXBzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgICApLCB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShmdCkpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgcmV0dXJuIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoaSkgPT4gZS5wdXNoKHsgdGFnOiBpLnRleHRDb250ZW50LnRyaW0oKSB9KSksIGU7XG4gIH1cbiAgX2hhbmRsZUV2ZW50cyhlLCBpKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2hhbmRsZVRleHRDb250ZW50KCksIG8gPSB0aGlzLmFsbENoaXBzLmZpbHRlcihcbiAgICAgIChyKSA9PiByLmhhc0F0dHJpYnV0ZShmdCkgJiYgclxuICAgICk7XG4gICAgdS50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGksIHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgYWxsQ2hpcHM6IHRoaXMuYWxsQ2hpcHMsXG4gICAgICBhcnJPZk9iamVjdHM6IG4sXG4gICAgICBhY3RpdmU6IG8sXG4gICAgICBhY3RpdmVPYmo6IHtcbiAgICAgICAgdGFnOiBvLmxlbmd0aCA8PSAwID8gXCJcIiA6IG9bMF0udGV4dENvbnRlbnQudHJpbSgpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNoaXBzRm9jdXMoKSB7XG4gICAgdS5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsICh7IHRhcmdldDogeyBhdHRyaWJ1dGVzOiBlIH0gfSkgPT4ge1xuICAgICAgY29uc3QgaSA9IFsuLi5lXTtcbiAgICAgIGkuaW5jbHVkZXMoS24pIHx8IGkuaW5jbHVkZXMoSGwpIHx8IGkuaW5jbHVkZXMoQmwpIHx8IHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlSW5pdGlhbFZhbHVlKCkge1xuICAgIGlmICh0aGlzLl9hcHBlbmRJbnB1dFRvRWxlbWVudChwYSksIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKHBhKSkge1xuICAgICAgY29uc3QgeyBpbml0aWFsVmFsdWVzOiBlIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgZS5mb3JFYWNoKFxuICAgICAgICAoeyB0YWc6IGkgfSkgPT4gdGhpcy5faGFuZGxlQ3JlYXRlQ2hpcCh0aGlzLmlucHV0LCBpKVxuICAgICAgKSwgaC5maW5kT25lKFxuICAgICAgICBTbixcbiAgICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXG4gICAgICApLnNldEF0dHJpYnV0ZShBZSwgXCJcIiksIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKGZ0LCBcIlwiKSwgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoQWUsIFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLmFsbENoaXBzLmxlbmd0aCA+IDAgJiYgKHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICApLCB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLnRyYW5zaXRpb24uc3BsaXQoXCIgXCIpXG4gICAgKSk7XG4gIH1cbiAgX2hhbmRsZUtleXNJbnB1dFRvRWxlbWVudChlKSB7XG4gICAgY29uc3QgeyBrZXlDb2RlOiBpLCB0YXJnZXQ6IG4gfSA9IGU7XG4gICAgaWYgKG4uaGFzQXR0cmlidXRlKEtuKSkge1xuICAgICAgY29uc3QgbyA9IGguZmluZE9uZSh4biwgbik7XG4gICAgICBpID09PSBsdCAmJiAobi5jb250ZW50RWRpdGFibGUgPSAhMSwgbi5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuY29udGVudEVkaXRhYmxlLnNwbGl0KFwiIFwiKSksIG4udGV4dENvbnRlbnQgIT09IFwiXCIgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcC5hZGRTdHlsZShvLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgby5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMub3BhY2l0eS5zcGxpdChcIiBcIikpO1xuICAgICAgfSwgMTYwKSA6IG4udGV4dENvbnRlbnQgPT09IFwiXCIgJiYgKHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBuLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICB9LCAyMDApLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbi5yZW1vdmUoKTtcbiAgICAgIH0sIDMwMCkpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGkgPT09IGx0KSB7XG4gICAgICBpZiAobi52YWx1ZSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5faGFuZGxlQ3JlYXRlQ2hpcChuLCBuLnZhbHVlKSwgdGhpcy5faGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSwgdGhpcy5udW1iZXJDbGlja3MgPSB0aGlzLmFsbENoaXBzLmxlbmd0aCArIDEsIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBBZyk7XG4gICAgfVxuICAgIHRoaXMuYWxsQ2hpcHMubGVuZ3RoID4gMCA/ICh0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgKSwgdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy50cmFuc2l0aW9uLnNwbGl0KFwiIFwiKVxuICAgICkpIDogdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUlucHV0VGV4dCgpIHtcbiAgICBjb25zdCBlID0gaC5maW5kT25lKFxuICAgICAgYmcsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICB1Lm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwia2V5dXBcIixcbiAgICAgIGUsXG4gICAgICAoaSkgPT4gdGhpcy5faGFuZGxlS2V5c0lucHV0VG9FbGVtZW50KGkpXG4gICAgKSwgdS5vbih0aGlzLmlucHV0LCBcImJsdXJcIiwgKGkpID0+IHRoaXMuX2hhbmRsZUJsdXJJbnB1dChpKSk7XG4gIH1cbiAgX2FwcGVuZElucHV0VG9FbGVtZW50KGUpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBpZyh0aGlzLl9vcHRpb25zLCB0aGlzLl9jbGFzc2VzKTtcbiAgICB0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBpKTtcbiAgfVxuICBfaGFuZGxlQ3JlYXRlQ2hpcChlLCBpKSB7XG4gICAgY29uc3QgbiA9IE0oXCJkaXZcIiksIG8gPSBpaS5nZXRJbnN0YW5jZShuKSwgciA9IG5ldyBpaShvLCB7IHRleHQ6IGkgfSwgdGhpcy5fY2xhc3Nlcyk7XG4gICAgdGhpcy5fb3B0aW9ucy5wYXJlbnRTZWxlY3RvciAhPT0gXCJcIiA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fb3B0aW9ucy5wYXJlbnRTZWxlY3RvcikuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIHIuYXBwZW5kQ2hpcCgpKSA6IGUuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIiwgci5hcHBlbmRDaGlwKCkpLCBlLnZhbHVlID0gXCJcIiwgaC5maW5kKFVuKS5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBsZXQgbCA9IGlpLmdldEluc3RhbmNlKGEpO1xuICAgICAgcmV0dXJuIGwgfHwgKGwgPSBuZXcgaWkoYSwge30sIHRoaXMuX2NsYXNzZXMpKSwgbC5pbml0KCk7XG4gICAgfSksIHRoaXMuX2hhbmRsZUVkaXRhYmxlKCk7XG4gIH1cbiAgX2hhbmRsZUNoaXBzT25TZWxlY3QoKSB7XG4gICAgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICB1Lm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKGkpID0+IHtcbiAgICAgICAgdS50cmlnZ2VyKGUsIF9hLCB7XG4gICAgICAgICAgZXZlbnQ6IGksXG4gICAgICAgICAgYWxsQ2hpcHM6IHRoaXMuYWxsQ2hpcHNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpIHtcbiAgICBsZXQgaTtcbiAgICB0aGlzLmFsbENoaXBzW2UgLSAxXSA9PT0gdm9pZCAwID8gaSA9IHRoaXMuYWxsQ2hpcHNbZSAtIDJdIDogaSA9IHRoaXMuYWxsQ2hpcHNbZSAtIDFdLCBpLnNldEF0dHJpYnV0ZShmdCk7XG4gIH1cbiAgX2dldENvbmZpZyhlKSB7XG4gICAgY29uc3QgaSA9IHtcbiAgICAgIC4uLlNnLFxuICAgICAgLi4ucC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLmVcbiAgICB9O1xuICAgIHJldHVybiBOKHVpLCBpLCB4ZyksIGk7XG4gIH1cbiAgX2dldENsYXNzZXMoZSkge1xuICAgIGNvbnN0IGkgPSBwLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIGUgPSB7XG4gICAgICAuLi5EZyxcbiAgICAgIC4uLmksXG4gICAgICAuLi5lXG4gICAgfSwgTih1aSwgZSwgSWcpLCBlO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlKSB7XG4gICAgcmV0dXJuIEkuZ2V0RGF0YShlLCB1YSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UoZSwgaSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoZSkgfHwgbmV3IHRoaXMoZSwgdHlwZW9mIGkgPT0gXCJvYmplY3RcIiA/IGkgOiBudWxsKTtcbiAgfVxufVxudmFyICRnID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gTGcodCkgJiYgIU1nKHQpO1xufTtcbmZ1bmN0aW9uIExnKHMpIHtcbiAgcmV0dXJuICEhcyAmJiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gTWcocykge1xuICB2YXIgdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzKTtcbiAgcmV0dXJuIHQgPT09IFwiW29iamVjdCBSZWdFeHBdXCIgfHwgdCA9PT0gXCJbb2JqZWN0IERhdGVdXCIgfHwgUGcocyk7XG59XG52YXIgTmcgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yLCBSZyA9IE5nID8gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIikgOiA2MDEwMztcbmZ1bmN0aW9uIFBnKHMpIHtcbiAgcmV0dXJuIHMuJCR0eXBlb2YgPT09IFJnO1xufVxuZnVuY3Rpb24gSGcocykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzKSA/IFtdIDoge307XG59XG5mdW5jdGlvbiBfaShzLCB0KSB7XG4gIHJldHVybiB0LmNsb25lICE9PSAhMSAmJiB0LmlzTWVyZ2VhYmxlT2JqZWN0KHMpID8gV2UoSGcocyksIHMsIHQpIDogcztcbn1cbmZ1bmN0aW9uIEJnKHMsIHQsIGUpIHtcbiAgcmV0dXJuIHMuY29uY2F0KHQpLm1hcChmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIF9pKGksIGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFZnKHMsIHQpIHtcbiAgaWYgKCF0LmN1c3RvbU1lcmdlKVxuICAgIHJldHVybiBXZTtcbiAgdmFyIGUgPSB0LmN1c3RvbU1lcmdlKHMpO1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSA6IFdlO1xufVxuZnVuY3Rpb24gV2cocykge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocykuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgdCk7XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiBtYShzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzKS5jb25jYXQoV2cocykpO1xufVxuZnVuY3Rpb24gVmwocywgdCkge1xuICB0cnkge1xuICAgIHJldHVybiB0IGluIHM7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gRmcocywgdCkge1xuICByZXR1cm4gVmwocywgdCkgJiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChzLCB0KSAmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCB0KSk7XG59XG5mdW5jdGlvbiBZZyhzLCB0LCBlKSB7XG4gIHZhciBpID0ge307XG4gIHJldHVybiBlLmlzTWVyZ2VhYmxlT2JqZWN0KHMpICYmIG1hKHMpLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIGlbbl0gPSBfaShzW25dLCBlKTtcbiAgfSksIG1hKHQpLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIEZnKHMsIG4pIHx8IChWbChzLCBuKSAmJiBlLmlzTWVyZ2VhYmxlT2JqZWN0KHRbbl0pID8gaVtuXSA9IFZnKG4sIGUpKHNbbl0sIHRbbl0sIGUpIDogaVtuXSA9IF9pKHRbbl0sIGUpKTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiBXZShzLCB0LCBlKSB7XG4gIGUgPSBlIHx8IHt9LCBlLmFycmF5TWVyZ2UgPSBlLmFycmF5TWVyZ2UgfHwgQmcsIGUuaXNNZXJnZWFibGVPYmplY3QgPSBlLmlzTWVyZ2VhYmxlT2JqZWN0IHx8ICRnLCBlLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gX2k7XG4gIHZhciBpID0gQXJyYXkuaXNBcnJheSh0KSwgbiA9IEFycmF5LmlzQXJyYXkocyksIG8gPSBpID09PSBuO1xuICByZXR1cm4gbyA/IGkgPyBlLmFycmF5TWVyZ2UocywgdCwgZSkgOiBZZyhzLCB0LCBlKSA6IF9pKHQsIGUpO1xufVxuV2UuYWxsID0gZnVuY3Rpb24odCwgZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5XCIpO1xuICByZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24oaSwgbikge1xuICAgIHJldHVybiBXZShpLCBuLCBlKTtcbiAgfSwge30pO1xufTtcbnZhciBqZyA9IFdlLCB6biA9IGpnO1xuY29uc3QgZ2EgPSBcImNoYXJ0XCIsIGlzID0gXCJ0ZS5jaGFydFwiLCBLZyA9IFwiY2hhcnRcIiwgYmEgPSAocywgdCwgZSkgPT4ge1xuICBjb25zdCBpID0gKG4sIG8sIHIpID0+IHtcbiAgICBjb25zdCBhID0gbi5zbGljZSgpO1xuICAgIHJldHVybiBvLmZvckVhY2goKGwsIGMpID0+IHtcbiAgICAgIHR5cGVvZiBhW2NdID4gXCJ1XCIgPyBhW2NdID0gci5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChcbiAgICAgICAgbCxcbiAgICAgICAgclxuICAgICAgKSA6IHIuaXNNZXJnZWFibGVPYmplY3QobCkgPyBhW2NdID0gem4obltjXSwgbCwgcikgOiBuLmluZGV4T2YobCkgPT09IC0xICYmIGEucHVzaChsKTtcbiAgICB9KSwgYTtcbiAgfTtcbiAgcmV0dXJuIHpuKGVbdF0sIHMsIHtcbiAgICBhcnJheU1lcmdlOiBpXG4gIH0pO1xufSwgVWcgPSB7XG4gIGRhcmtUaWNrc0NvbG9yOiBcIiNmZmZcIixcbiAgZGFya0xhYmVsQ29sb3I6IFwiI2ZmZlwiLFxuICBkYXJrR3JpZExpbmVzQ29sb3I6IFwiIzU1NVwiLFxuICBkYXJrbW9kZU9mZjogXCJ1bmRlZmluZWRcIixcbiAgZGFya0JnQ29sb3I6IFwiIzI2MjYyNlwiLFxuICBvcHRpb25zOiBudWxsXG59LCB6ZyA9IHtcbiAgZGFya1RpY2tzQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmtMYWJlbENvbG9yOiBcInN0cmluZ1wiLFxuICBkYXJrR3JpZExpbmVzQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmttb2RlT2ZmOiBcIihzdHJpbmd8bnVsbClcIixcbiAgZGFya0JnQ29sb3I6IFwic3RyaW5nXCIsXG4gIG9wdGlvbnM6IFwiKG9iamVjdHxudWxsKVwiXG59O1xuY2xhc3MgV2wge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpID0ge30sIG4gPSB7fSkge1xuICAgIHRoaXMuX3dhaXRGb3JDaGFydHModCwgZSwgaSwgbik7XG4gIH1cbiAgYXN5bmMgX2dldENoYXJ0anMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgQ2hhcnQ6IHQsXG4gICAgICBBcmNFbGVtZW50OiBlLFxuICAgICAgTGluZUVsZW1lbnQ6IGksXG4gICAgICBCYXJFbGVtZW50OiBuLFxuICAgICAgUG9pbnRFbGVtZW50OiBvLFxuICAgICAgQmFyQ29udHJvbGxlcjogcixcbiAgICAgIEJ1YmJsZUNvbnRyb2xsZXI6IGEsXG4gICAgICBEb3VnaG51dENvbnRyb2xsZXI6IGwsXG4gICAgICBMaW5lQ29udHJvbGxlcjogYyxcbiAgICAgIFBpZUNvbnRyb2xsZXI6IGQsXG4gICAgICBQb2xhckFyZWFDb250cm9sbGVyOiBfLFxuICAgICAgUmFkYXJDb250cm9sbGVyOiBmLFxuICAgICAgU2NhdHRlckNvbnRyb2xsZXI6IG0sXG4gICAgICBDYXRlZ29yeVNjYWxlOiBnLFxuICAgICAgTGluZWFyU2NhbGU6IGIsXG4gICAgICBMb2dhcml0aG1pY1NjYWxlOiBULFxuICAgICAgUmFkaWFsTGluZWFyU2NhbGU6IEMsXG4gICAgICBUaW1lU2NhbGU6IHcsXG4gICAgICBUaW1lU2VyaWVzU2NhbGU6IHYsXG4gICAgICBEZWNpbWF0aW9uOiBFLFxuICAgICAgRmlsbGVyOiBBLFxuICAgICAgTGVnZW5kOiB5LFxuICAgICAgVGl0bGU6IFMsXG4gICAgICBUb29sdGlwOiBPLFxuICAgICAgU3ViVGl0bGU6IGtcbiAgICB9ID0gYXdhaXQgaW1wb3J0KFwiLi9jaGFydC5lcy5qc1wiKS50aGVuKChEKSA9PiBELmYpO1xuICAgIHJldHVybiB0LnJlZ2lzdGVyKFxuICAgICAgZSxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgbyxcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbCxcbiAgICAgIGMsXG4gICAgICBkLFxuICAgICAgXyxcbiAgICAgIGYsXG4gICAgICBtLFxuICAgICAgZyxcbiAgICAgIGIsXG4gICAgICBULFxuICAgICAgQyxcbiAgICAgIHcsXG4gICAgICB2LFxuICAgICAgRSxcbiAgICAgIEEsXG4gICAgICB5LFxuICAgICAgUyxcbiAgICAgIE8sXG4gICAgICBrXG4gICAgKSwgdDtcbiAgfVxuICBhc3luYyBfZ2V0Q2hhcnREYXRhTGFiZWxzKCkge1xuICAgIGNvbnN0IHsgQ2hhcnREYXRhTGFiZWxzOiB0IH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuZXMuanNcIik7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgYXN5bmMgX3dhaXRGb3JDaGFydHModCwgZSwgaSA9IHt9LCBuID0ge30pIHtcbiAgICB0aGlzLl9DaGFydGpzID0gYXdhaXQgdGhpcy5fZ2V0Q2hhcnRqcygpLCB0aGlzLl9DaGFydERhdGFMYWJlbHMgPSBhd2FpdCB0aGlzLl9nZXRDaGFydERhdGFMYWJlbHMoKSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2RhdGEgPSBlLCB0aGlzLl9vcHRpb25zID0gaSwgdGhpcy5fdHlwZSA9IGUudHlwZSwgdGhpcy5fY2FudmFzID0gbnVsbCwgdGhpcy5fY2hhcnQgPSBudWxsLCB0aGlzLl9kYXJrT3B0aW9ucyA9IHRoaXMuX2dldERhcmtDb25maWcobiksIHRoaXMuX2RhcmtNb2RlQ2xhc3NDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaHRtbFwiKSwgdGhpcy5fcHJldkNvbmZpZyA9IG51bGwsIHRoaXMuX29ic2VydmVyID0gbnVsbCwgdGhpcy5fZWxlbWVudCAmJiAoSS5zZXREYXRhKHQsIGlzLCB0aGlzKSwgcC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBLZyksIHRoaXMuX2NoYXJ0Q29uc3RydWN0b3IoKSksIHRoaXMuX2RhcmtPcHRpb25zLmRhcmttb2RlT2ZmICE9PSBudWxsICYmICh0aGlzLl9oYW5kbGVNb2RlKHRoaXMuc3lzdGVtQ29sb3JNb2RlKSwgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9vYnNlcnZlckNhbGxiYWNrLmJpbmQodGhpcykpLCB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RhcmtNb2RlQ2xhc3NDb250YWluZXIsIHtcbiAgICAgIGF0dHJpYnV0ZXM6ICEwXG4gICAgfSkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBnYTtcbiAgfVxuICBnZXQgc3lzdGVtQ29sb3JNb2RlKCkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UudGhlbWUgfHwgKHRoaXMuX2RhcmtNb2RlQ2xhc3NDb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGFya1wiKSA/IFwiZGFya1wiIDogXCJsaWdodFwiKTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCksIEkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBpcyksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIHVwZGF0ZSh0LCBlKSB7XG4gICAgdCAmJiAodGhpcy5fZGF0YSA9IHsgLi4udGhpcy5fZGF0YSwgLi4udCB9LCB0aGlzLl9jaGFydC5kYXRhID0gdGhpcy5fZGF0YSksIHRoaXMuX3ByZXZDb25maWcgPSB0aGlzLl9jaGFydC5vcHRpb25zLCB0aGlzLl9vcHRpb25zID0geyAuLi50aGlzLl9vcHRpb25zLCAuLi5lIH0sIHRoaXMuX2NoYXJ0Lm9wdGlvbnMgPSB6bih0aGlzLl9jaGFydC5vcHRpb25zLCB0aGlzLl9vcHRpb25zKSwgdGhpcy5fY2hhcnQudXBkYXRlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0RGFya0NvbmZpZyh0KSB7XG4gICAgbGV0IGUgPSB7fTtcbiAgICBjb25zdCBpID0gcC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKFxuICAgICAgKGMpID0+IGMuc3RhcnRzV2l0aChcImRhcmtcIikgJiYgKGVbY10gPSBpW2NdKVxuICAgICksIGUgPSB7XG4gICAgICAuLi5VZyxcbiAgICAgIC4uLmVcbiAgICB9O1xuICAgIGNvbnN0IG4gPSB7XG4gICAgICB5OiB7XG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya1RpY2tzQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtHcmlkTGluZXNDb2xvclxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeDoge1xuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtUaWNrc0NvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrR3JpZExpbmVzQ29sb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIG8gPSB7XG4gICAgICByOiB7XG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya1RpY2tzQ29sb3IsXG4gICAgICAgICAgYmFja2Ryb3BDb2xvcjogZS5kYXJrQmdDb2xvclxuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya0dyaWRMaW5lc0NvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya1RpY2tzQ29sb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGwgPSB7XG4gICAgICBzY2FsZXM6IFtcInBpZVwiLCBcImRvdWdobnV0XCIsIFwicG9sYXJBcmVhXCIsIFwicmFkYXJcIl0uaW5jbHVkZXModGhpcy5fdHlwZSkgPyBbXCJwb2xhckFyZWFcIiwgXCJyYWRhclwiXS5pbmNsdWRlcyh0aGlzLl90eXBlKSA/IG8gOiB7fSA6IG4sXG4gICAgICBwbHVnaW5zOiB7XG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgY29sb3I6IGUuZGFya0xhYmVsQ29sb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgLi4ubFxuICAgICAgfSxcbiAgICAgIC4uLnRcbiAgICB9LCBOKGdhLCB0LCB6ZyksIHQ7XG4gIH1cbiAgX2NoYXJ0Q29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZUNhbnZhcygpO1xuICAgICAgY29uc3QgdCA9IGJhKHRoaXMuX29wdGlvbnMsIHRoaXMuX3R5cGUsIGdzKSwgZSA9IFtdO1xuICAgICAgdC5kYXRhTGFiZWxzUGx1Z2luICYmIGUucHVzaCh0aGlzLl9DaGFydERhdGFMYWJlbHMpLCB0aGlzLl9jaGFydCA9IG5ldyB0aGlzLl9DaGFydGpzKHRoaXMuX2NhbnZhcywge1xuICAgICAgICAuLi50aGlzLl9kYXRhLFxuICAgICAgICAuLi50LFxuICAgICAgICBwbHVnaW5zOiBlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX2NyZWF0ZUNhbnZhcygpIHtcbiAgICB0aGlzLl9jYW52YXMgfHwgKHRoaXMuX2VsZW1lbnQubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIgPyB0aGlzLl9jYW52YXMgPSB0aGlzLl9lbGVtZW50IDogKHRoaXMuX2NhbnZhcyA9IE0oXCJjYW52YXNcIiksIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzKSkpO1xuICB9XG4gIF9oYW5kbGVNb2RlKHQpIHtcbiAgICB0ID09PSBcImRhcmtcIiA/ICh0aGlzLl9jaGFuZ2VEYXRhc2V0Qm9yZGVyQ29sb3IoKSwgdGhpcy51cGRhdGUobnVsbCwgdGhpcy5fZGFya09wdGlvbnMub3B0aW9ucykpIDogKHRoaXMuX2NoYW5nZURhdGFzZXRCb3JkZXJDb2xvcighMSksIHRoaXMuX3ByZXZDb25maWcgJiYgdGhpcy51cGRhdGUobnVsbCwgdGhpcy5fcHJldkNvbmZpZykpO1xuICB9XG4gIF9vYnNlcnZlckNhbGxiYWNrKHQpIHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdClcbiAgICAgIGUudHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIgJiYgdGhpcy5faGFuZGxlTW9kZSh0aGlzLnN5c3RlbUNvbG9yTW9kZSk7XG4gIH1cbiAgX2NoYW5nZURhdGFzZXRCb3JkZXJDb2xvcih0ID0gITApIHtcbiAgICBbLi4udGhpcy5fZGF0YS5kYXRhLmRhdGFzZXRzXS5mb3JFYWNoKFxuICAgICAgKGUpID0+IFtcInBpZVwiLCBcImRvdWdobnV0XCIsIFwicG9sYXJBcmVhXCJdLmluY2x1ZGVzKHRoaXMuX3R5cGUpICYmIChlLmJvcmRlckNvbG9yID0gdCA/IHRoaXMuX2RhcmtPcHRpb25zLmRhcmtCZ0NvbG9yIDogXCIjZmZmXCIpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUsIGkpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IG4gPSBJLmdldERhdGEodGhpcywgaXMpO1xuICAgICAgaWYgKCEoIW4gJiYgL2Rpc3Bvc2UvLnRlc3QodCkpKSB7XG4gICAgICAgIGlmICghbikge1xuICAgICAgICAgIGNvbnN0IG8gPSBlID8gYmEoZSwgaSwgZ3MpIDogZ3NbaV07XG4gICAgICAgICAgbiA9IG5ldyBXbCh0aGlzLCB7XG4gICAgICAgICAgICAuLi50LFxuICAgICAgICAgICAgLi4ub1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuW3RdID4gXCJ1XCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgICBuW3RdKGUsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gSS5nZXREYXRhKHQsIGlzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5leHBvcnQge1xuICBSbiBhcyBBbGVydCxcbiAgbWwgYXMgQW5pbWF0ZSxcbiAgJGEgYXMgQnV0dG9uLFxuICBZdCBhcyBDYXJvdXNlbCxcbiAgV2wgYXMgQ2hhcnQsXG4gIGlpIGFzIENoaXAsXG4gIFpnIGFzIENoaXBzSW5wdXQsXG4gIFV0IGFzIENvbGxhcHNlLFxuICBHZyBhcyBEYXRlcGlja2VyLFxuICB3dCBhcyBEcm9wZG93bixcbiAgViBhcyBJbnB1dCxcbiAgUG4gYXMgTW9kYWwsXG4gIHJzIGFzIE9mZmNhbnZhcyxcbiAgbGwgYXMgUG9wb3ZlcixcbiAgQ3MgYXMgUmlwcGxlLFxuICBCbiBhcyBTY3JvbGxTcHksXG4gIE5sIGFzIFNlbGVjdCxcbiAgbmkgYXMgU2lkZW5hdixcbiAgUWcgYXMgU3RlcHBlcixcbiAgaGwgYXMgVGFiLFxuICBxZyBhcyBUaW1lcGlja2VyLFxuICBWbiBhcyBUb2FzdCxcbiAgdmkgYXMgVG9vbHRpcCxcbiAgZWcgYXMgaW5pdFRFXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHctZWxlbWVudHMuZXMubWluLmpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmYgPSB7fTtcbi8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbi8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5lID0gKGNodW5rSWQpID0+IHtcblx0cmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uZikucmVkdWNlKChwcm9taXNlcywga2V5KSA9PiB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mW2tleV0oY2h1bmtJZCwgcHJvbWlzZXMpO1xuXHRcdHJldHVybiBwcm9taXNlcztcblx0fSwgW10pKTtcbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYXN5bmMgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnUgPSAoY2h1bmtJZCkgPT4ge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwianMvXCIgKyBjaHVua0lkICsgXCIuaW5ib3VuZF9vcmRlci5qc1wiO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCJ2YXIgaW5Qcm9ncmVzcyA9IHt9O1xudmFyIGRhdGFXZWJwYWNrUHJlZml4ID0gXCJzdGF0aWM6XCI7XG4vLyBsb2FkU2NyaXB0IGZ1bmN0aW9uIHRvIGxvYWQgYSBzY3JpcHQgdmlhIHNjcmlwdCB0YWdcbl9fd2VicGFja19yZXF1aXJlX18ubCA9ICh1cmwsIGRvbmUsIGtleSwgY2h1bmtJZCkgPT4ge1xuXHRpZihpblByb2dyZXNzW3VybF0pIHsgaW5Qcm9ncmVzc1t1cmxdLnB1c2goZG9uZSk7IHJldHVybjsgfVxuXHR2YXIgc2NyaXB0LCBuZWVkQXR0YWNoO1xuXHRpZihrZXkgIT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBzID0gc2NyaXB0c1tpXTtcblx0XHRcdGlmKHMuZ2V0QXR0cmlidXRlKFwic3JjXCIpID09IHVybCB8fCBzLmdldEF0dHJpYnV0ZShcImRhdGEtd2VicGFja1wiKSA9PSBkYXRhV2VicGFja1ByZWZpeCArIGtleSkgeyBzY3JpcHQgPSBzOyBicmVhazsgfVxuXHRcdH1cblx0fVxuXHRpZighc2NyaXB0KSB7XG5cdFx0bmVlZEF0dGFjaCA9IHRydWU7XG5cdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cblx0XHRzY3JpcHQuY2hhcnNldCA9ICd1dGYtOCc7XG5cdFx0c2NyaXB0LnRpbWVvdXQgPSAxMjA7XG5cdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubmMpIHtcblx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKTtcblx0XHR9XG5cdFx0c2NyaXB0LnNldEF0dHJpYnV0ZShcImRhdGEtd2VicGFja1wiLCBkYXRhV2VicGFja1ByZWZpeCArIGtleSk7XG5cdFx0c2NyaXB0LnNyYyA9IHVybDtcblx0fVxuXHRpblByb2dyZXNzW3VybF0gPSBbZG9uZV07XG5cdHZhciBvblNjcmlwdENvbXBsZXRlID0gKHByZXYsIGV2ZW50KSA9PiB7XG5cdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuXHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdHZhciBkb25lRm5zID0gaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdGRlbGV0ZSBpblByb2dyZXNzW3VybF07XG5cdFx0c2NyaXB0LnBhcmVudE5vZGUgJiYgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRkb25lRm5zICYmIGRvbmVGbnMuZm9yRWFjaCgoZm4pID0+IChmbihldmVudCkpKTtcblx0XHRpZihwcmV2KSByZXR1cm4gcHJldihldmVudCk7XG5cdH1cblx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCB1bmRlZmluZWQsIHsgdHlwZTogJ3RpbWVvdXQnLCB0YXJnZXQ6IHNjcmlwdCB9KSwgMTIwMDAwKTtcblx0c2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuXHRzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuXHRuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn07IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwidmFyIHNjcmlwdFVybDtcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmcuaW1wb3J0U2NyaXB0cykgc2NyaXB0VXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmxvY2F0aW9uICsgXCJcIjtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5kb2N1bWVudDtcbmlmICghc2NyaXB0VXJsICYmIGRvY3VtZW50KSB7XG5cdGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuXHRpZiAoIXNjcmlwdFVybCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0aWYoc2NyaXB0cy5sZW5ndGgpIHNjcmlwdFVybCA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5zcmNcblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmwgKyBcIi4uL1wiOyIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3Ncbi8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuLy8gW3Jlc29sdmUsIHJlamVjdCwgUHJvbWlzZV0gPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG52YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuXHRcIm1haW5cIjogMFxufTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5mLmogPSAoY2h1bmtJZCwgcHJvbWlzZXMpID0+IHtcblx0XHQvLyBKU09OUCBjaHVuayBsb2FkaW5nIGZvciBqYXZhc2NyaXB0XG5cdFx0dmFyIGluc3RhbGxlZENodW5rRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpID8gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdIDogdW5kZWZpbmVkO1xuXHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSAhPT0gMCkgeyAvLyAwIG1lYW5zIFwiYWxyZWFkeSBpbnN0YWxsZWRcIi5cblxuXHRcdFx0Ly8gYSBQcm9taXNlIG1lYW5zIFwiY3VycmVudGx5IGxvYWRpbmdcIi5cblx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuXHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0cnVlKSB7IC8vIGFsbCBjaHVua3MgaGF2ZSBKU1xuXHRcdFx0XHRcdC8vIHNldHVwIFByb21pc2UgaW4gY2h1bmsgY2FjaGVcblx0XHRcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IChpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSBbcmVzb2x2ZSwgcmVqZWN0XSkpO1xuXHRcdFx0XHRcdHByb21pc2VzLnB1c2goaW5zdGFsbGVkQ2h1bmtEYXRhWzJdID0gcHJvbWlzZSk7XG5cblx0XHRcdFx0XHQvLyBzdGFydCBjaHVuayBsb2FkaW5nXG5cdFx0XHRcdFx0dmFyIHVybCA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIF9fd2VicGFja19yZXF1aXJlX18udShjaHVua0lkKTtcblx0XHRcdFx0XHQvLyBjcmVhdGUgZXJyb3IgYmVmb3JlIHN0YWNrIHVud291bmQgdG8gZ2V0IHVzZWZ1bCBzdGFja3RyYWNlIGxhdGVyXG5cdFx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCk7XG5cdFx0XHRcdFx0dmFyIGxvYWRpbmdFbmRlZCA9IChldmVudCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkpIHtcblx0XHRcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuXHRcdFx0XHRcdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEgIT09IDApIGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGVycm9yVHlwZSA9IGV2ZW50ICYmIChldmVudC50eXBlID09PSAnbG9hZCcgPyAnbWlzc2luZycgOiBldmVudC50eXBlKTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmVhbFNyYyA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuc3JjO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLm1lc3NhZ2UgPSAnTG9hZGluZyBjaHVuayAnICsgY2h1bmtJZCArICcgZmFpbGVkLlxcbignICsgZXJyb3JUeXBlICsgJzogJyArIHJlYWxTcmMgKyAnKSc7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IubmFtZSA9ICdDaHVua0xvYWRFcnJvcic7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IudHlwZSA9IGVycm9yVHlwZTtcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5yZXF1ZXN0ID0gcmVhbFNyYztcblx0XHRcdFx0XHRcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGFbMV0oZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmwodXJsLCBsb2FkaW5nRW5kZWQsIFwiY2h1bmstXCIgKyBjaHVua0lkLCBjaHVua0lkKTtcblx0XHRcdFx0fSBlbHNlIGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDA7XG5cdFx0XHR9XG5cdFx0fVxufTtcblxuLy8gbm8gcHJlZmV0Y2hpbmdcblxuLy8gbm8gcHJlbG9hZGVkXG5cbi8vIG5vIEhNUlxuXG4vLyBubyBITVIgbWFuaWZlc3RcblxuLy8gbm8gb24gY2h1bmtzIGxvYWRlZFxuXG4vLyBpbnN0YWxsIGEgSlNPTlAgY2FsbGJhY2sgZm9yIGNodW5rIGxvYWRpbmdcbnZhciB3ZWJwYWNrSnNvbnBDYWxsYmFjayA9IChwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbiwgZGF0YSkgPT4ge1xuXHR2YXIgW2NodW5rSWRzLCBtb3JlTW9kdWxlcywgcnVudGltZV0gPSBkYXRhO1xuXHQvLyBhZGQgXCJtb3JlTW9kdWxlc1wiIHRvIHRoZSBtb2R1bGVzIG9iamVjdCxcblx0Ly8gdGhlbiBmbGFnIGFsbCBcImNodW5rSWRzXCIgYXMgbG9hZGVkIGFuZCBmaXJlIGNhbGxiYWNrXG5cdHZhciBtb2R1bGVJZCwgY2h1bmtJZCwgaSA9IDA7XG5cdGlmKGNodW5rSWRzLnNvbWUoKGlkKSA9PiAoaW5zdGFsbGVkQ2h1bmtzW2lkXSAhPT0gMCkpKSB7XG5cdFx0Zm9yKG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG5cdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8obW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm1bbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihydW50aW1lKSB2YXIgcmVzdWx0ID0gcnVudGltZShfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0fVxuXHRpZihwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbikgcGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24oZGF0YSk7XG5cdGZvcig7aSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2h1bmtJZCA9IGNodW5rSWRzW2ldO1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpICYmIGluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1xuXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKCk7XG5cdFx0fVxuXHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDA7XG5cdH1cblxufVxuXG52YXIgY2h1bmtMb2FkaW5nR2xvYmFsID0gc2VsZltcIndlYnBhY2tDaHVua3N0YXRpY1wiXSA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtzdGF0aWNcIl0gfHwgW107XG5jaHVua0xvYWRpbmdHbG9iYWwuZm9yRWFjaCh3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIDApKTtcbmNodW5rTG9hZGluZ0dsb2JhbC5wdXNoID0gd2VicGFja0pzb25wQ2FsbGJhY2suYmluZChudWxsLCBjaHVua0xvYWRpbmdHbG9iYWwucHVzaC5iaW5kKGNodW5rTG9hZGluZ0dsb2JhbCkpOyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luYm91bmRfb3JkZXIvaW5ib3VuZF9vcmRlci50c1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==